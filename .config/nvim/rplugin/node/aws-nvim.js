/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 8565:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  CreateTokenCommand: () => (/* reexport */ CreateTokenCommand),
  SSOOIDCClient: () => (/* reexport */ SSOOIDCClient)
});

// UNUSED EXPORTS: $Command, AccessDeniedException, AuthorizationPendingException, CreateTokenRequestFilterSensitiveLog, CreateTokenResponseFilterSensitiveLog, CreateTokenWithIAMCommand, CreateTokenWithIAMRequestFilterSensitiveLog, CreateTokenWithIAMResponseFilterSensitiveLog, ExpiredTokenException, InternalServerException, InvalidClientException, InvalidClientMetadataException, InvalidGrantException, InvalidRedirectUriException, InvalidRequestException, InvalidRequestRegionException, InvalidScopeException, RegisterClientCommand, RegisterClientResponseFilterSensitiveLog, SSOOIDC, SSOOIDCServiceException, SlowDownException, StartDeviceAuthorizationCommand, StartDeviceAuthorizationRequestFilterSensitiveLog, UnauthorizedClientException, UnsupportedGrantTypeException, __Client

// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-host-header/dist-es/index.js + 14 modules
var dist_es = __webpack_require__(9813);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-logger/dist-es/index.js + 1 modules
var middleware_logger_dist_es = __webpack_require__(9359);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js + 14 modules
var middleware_recursion_detection_dist_es = __webpack_require__(2163);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js + 17 modules
var middleware_user_agent_dist_es = __webpack_require__(4725);
// EXTERNAL MODULE: ./node_modules/@smithy/config-resolver/dist-es/index.js + 26 modules
var config_resolver_dist_es = __webpack_require__(7373);
// EXTERNAL MODULE: ./node_modules/@smithy/core/dist-es/index.js + 110 modules
var core_dist_es = __webpack_require__(2073);
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-content-length/dist-es/index.js + 14 modules
var middleware_content_length_dist_es = __webpack_require__(9587);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
const resolveParamsForS3 = async (endpointParams) => {
    const bucket = endpointParams?.Bucket || "";
    if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if (isArnBucketName(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
            throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
    }
    else if (!isDnsCompatibleBucketName(bucket) ||
        (bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:")) ||
        bucket.toLowerCase() !== bucket ||
        bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
    }
    return endpointParams;
};
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
const DOT_PATTERN = /\./;
const S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
const isArnBucketName = (bucketName) => {
    const [arn, partition, service, , , bucket] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = Boolean(isArn && partition && service && bucket);
    if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return isValidArn;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
    const configProvider = async () => {
        const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
            return configValue();
        }
        return configValue;
    };
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
        return async () => {
            const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
            const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
            return configValue;
        };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
            const endpoint = await configProvider();
            if (endpoint && typeof endpoint === "object") {
                if ("url" in endpoint) {
                    return endpoint.url.href;
                }
                if ("hostname" in endpoint) {
                    const { protocol, hostname, port, path } = endpoint;
                    return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
                }
            }
            return endpoint;
        };
    }
    return configProvider;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/property-provider/dist-es/fromStatic.js
const fromStatic = (staticValue) => () => Promise.resolve(staticValue);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/property-provider/dist-es/memoize.js
const memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-config-provider/dist-es/fromEnv.js

const fromEnv = (envVarSelector) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
};

// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${external_path_.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0,external_os_.homedir)();
    return homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = createHash("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile } = external_fs_.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/types/dist-es/http.js
var http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(http_FieldPosition || (http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/types/dist-es/middleware.js
const SMITHY_CONTEXT_KEY = "__smithy_context";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/types/dist-es/profile.js
var profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(profile_IniSectionType || (profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(profile_IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === profile_IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath_getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(profile_IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: slurpFile_readFile } = external_fs_.promises;
const filePromisesHash = {};
const slurpFile_slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = slurpFile_readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const swallowError = () => ({});
const loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles_loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath_getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile_slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile_slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js


const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = getProfileName(init);
    const { configFile, credentialsFile } = await loadSharedConfigFiles_loadSharedConfigFiles(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message ||
            `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-config-provider/dist-es/fromStatic.js

const isFunction = (func) => typeof func === "function";
const fromStatic_fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : fromStatic(defaultValue);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-config-provider/dist-es/configLoader.js




const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize(chain(fromEnv(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic_fromStatic(defaultValue)));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-config-provider/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointUrlConfig.js

const ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
const CONFIG_ENDPOINT_URL = "endpoint_url";
const getEndpointUrlConfig = (serviceId) => ({
    environmentVariableSelector: (env) => {
        const serviceSuffixParts = serviceId.split(" ").map((w) => w.toUpperCase());
        const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
        if (serviceEndpointUrl)
            return serviceEndpointUrl;
        const endpointUrl = env[ENV_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    configFileSelector: (profile, config) => {
        if (config && profile.services) {
            const servicesSection = config[["services", profile.services].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR)];
            if (servicesSection) {
                const servicePrefixParts = serviceId.split(" ").map((w) => w.toLowerCase());
                const endpointUrl = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR)];
                if (endpointUrl)
                    return endpointUrl;
            }
        }
        const endpointUrl = profile[CONFIG_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    default: undefined,
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.js


const getEndpointFromConfig = async (serviceId) => loadConfig(getEndpointUrlConfig(serviceId))();

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
        for (const pair of querystring.split("&")) {
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
                value = decodeURIComponent(value);
            }
            if (!(key in query)) {
                query[key] = value;
            }
            else if (Array.isArray(query[key])) {
                query[key].push(value);
            }
            else {
                query[key] = [query[key], value];
            }
        }
    }
    return query;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/url-parser/dist-es/index.js

const parseUrl = (url) => {
    if (typeof url === "string") {
        return parseUrl(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
        query = parseQueryString(search);
    }
    return {
        hostname,
        port: port ? parseInt(port) : undefined,
        protocol,
        path: pathname,
        query,
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js

const toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
        if ("url" in endpoint) {
            return parseUrl(endpoint.url);
        }
        return endpoint;
    }
    return parseUrl(endpoint);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js




const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.endpoint) {
        const endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId || "");
        if (endpointFromConfig) {
            clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
        }
    }
    const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
};
const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
            case "staticContextParams":
                endpointParams[name] = instruction.value;
                break;
            case "contextParams":
                endpointParams[name] = commandInput[instruction.name];
                break;
            case "clientContextParams":
            case "builtInParams":
                endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
                break;
            default:
                throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
    }
    if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await resolveParamsForS3(endpointParams);
    }
    return endpointParams;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js

const getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-middleware/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js


const endpointMiddleware = ({ config, instructions, }) => {
    return (next, context) => async (args) => {
        const endpoint = await getEndpointFromInstructions(args.input, {
            getEndpointParameterInstructions() {
                return instructions;
            },
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
            context["signing_region"] = authScheme.signingRegion;
            context["signing_service"] = authScheme.signingName;
            const smithyContext = getSmithyContext(context);
            const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
            if (httpAuthOption) {
                httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
                    signing_region: authScheme.signingRegion,
                    signingRegion: authScheme.signingRegion,
                    signing_service: authScheme.signingName,
                    signingName: authScheme.signingName,
                    signingRegionSet: authScheme.signingRegionSet,
                }, authScheme.properties);
            }
        }
        return next({
            ...args,
        });
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
const deserializerMiddleware = (options, deserializer) => (next) => async (args) => {
    const { response } = await next(args);
    try {
        const parsed = await deserializer(response, options);
        return {
            response,
            output: parsed,
        };
    }
    catch (error) {
        Object.defineProperty(error, "$response", {
            value: response,
        });
        if (!("$metadata" in error)) {
            const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
            error.message += "\n  " + hint;
            if (typeof error.$responseBodyText !== "undefined") {
                if (error.$response) {
                    error.$response.body = error.$responseBodyText;
                }
            }
        }
        throw error;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    const endpoint = context.endpointV2?.url && options.urlParser
        ? async () => options.urlParser(context.endpointV2.url)
        : options.endpoint;
    if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
        ...args,
        request,
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js


const deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true,
};
const serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true,
};
function getSerdePlugin(config, serializer, deserializer) {
    return {
        applyToStack: (commandStack) => {
            commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
            commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
        },
    };
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-serde/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js


const endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: serializerMiddlewareOption.name,
};
const getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(endpointMiddleware({
            config,
            instructions,
        }), endpointMiddlewareOptions);
    },
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js


const resolveEndpointConfig = (input) => {
    const tls = input.tls ?? true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    return {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
        useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-endpoint/dist-es/index.js






// EXTERNAL MODULE: ./node_modules/@smithy/middleware-retry/dist-es/index.js + 69 modules
var middleware_retry_dist_es = __webpack_require__(2467);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
class NoOpLogger {
    trace() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
const getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo(constructStack()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo(constructStack());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                const step = mw.step ??
                    mw.relation +
                        " " +
                        mw.toMiddleware;
                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/middleware-stack/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/client.js

class Client {
    constructor(config) {
        this.middlewareStack = constructStack();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/is-array-buffer/dist-es/index.js
const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// EXTERNAL MODULE: external "buffer"
var external_buffer_ = __webpack_require__(181);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-buffer-from/dist-es/index.js


const dist_es_fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return external_buffer_.Buffer.from(input, offset, length);
};
const fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? external_buffer_.Buffer.from(input, encoding) : external_buffer_.Buffer.from(input);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-base64/dist-es/fromBase64.js

const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64_fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = fromString(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js

const fromUtf8_fromUtf8 = (input) => {
    const buf = fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js

const toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-utf8/dist-es/toUtf8.js

const toUtf8_toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return dist_es_fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-utf8/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-base64/dist-es/toBase64.js


const toBase64_toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
        input = fromUtf8_fromUtf8(_input);
    }
    else {
        input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return dist_es_fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-base64/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-stream/dist-es/blob/transforms.js



function transforms_transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return toBase64(payload);
    }
    return toUtf8(payload);
}
function transforms_transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js

class Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter extends (/* unused pure expression or super */ null && (Uint8Array)) {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return transformFromString(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
    }
}

// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(2203);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.js

const getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
const getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
    let httpHandler = runtimeConfig.httpHandler;
    return {
        setHttpHandler(handler) {
            httpHandler = handler;
        },
        httpHandler() {
            return httpHandler;
        },
        updateHttpClientConfig(key, value) {
            httpHandler.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
            return httpHandler.httpHandlerConfigs();
        },
    };
};
const resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
    return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/protocol-http/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/protocol-http/dist-es/httpResponse.js
class httpResponse_HttpResponse {
    constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/protocol-http/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/querystring-builder/dist-es/index.js

function dist_es_buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = escapeUri(key);
        if (Array.isArray(value)) {
            for (let i = 0, iLen = value.length; i < iLen; i++) {
                parts.push(`${key}=${escapeUri(value[i])}`);
            }
        }
        else {
            let qsEntry = key;
            if (value || typeof value === "string") {
                qsEntry += `=${escapeUri(value)}`;
            }
            parts.push(qsEntry);
        }
    }
    return parts.join("&");
}

// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(8611);
// EXTERNAL MODULE: external "https"
var external_https_ = __webpack_require__(5692);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/constants.js
const NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/get-transformed-headers.js
const get_transformed_headers_getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
};


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/set-connection-timeout.js
const setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
        return;
    }
    const timeoutId = setTimeout(() => {
        request.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
            name: "TimeoutError",
        }));
    }, timeoutInMs);
    request.on("socket", (socket) => {
        if (socket.connecting) {
            socket.on("connect", () => {
                clearTimeout(timeoutId);
            });
        }
        else {
            clearTimeout(timeoutId);
        }
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/set-socket-keep-alive.js
const setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }) => {
    if (keepAlive !== true) {
        return;
    }
    request.on("socket", (socket) => {
        socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/set-socket-timeout.js
const setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    request.setTimeout(timeoutInMs, () => {
        request.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/write-request-body.js

const MIN_WAIT_TIME = 1000;
async function write_request_body_writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", () => {
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            }),
        ]);
    }
    if (!hasError) {
        writeBody(httpRequest, request.body);
    }
}
function writeBody(httpRequest, body) {
    if (body instanceof external_stream_.Readable) {
        body.pipe(httpRequest);
        return;
    }
    if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
            httpRequest.end(body);
            return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" &&
            uint8.buffer &&
            typeof uint8.byteOffset === "number" &&
            typeof uint8.byteLength === "number") {
            httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
            return;
        }
        httpRequest.end(Buffer.from(body));
        return;
    }
    httpRequest.end();
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js










const DEFAULT_REQUEST_TIMEOUT = 0;
class NodeHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
            return socketWarningTimestamp;
        }
        const interval = 15000;
        if (Date.now() - interval < socketWarningTimestamp) {
            return socketWarningTimestamp;
        }
        if (sockets && requests) {
            for (const origin in sockets) {
                const socketsInUse = sockets[origin]?.length ?? 0;
                const requestsEnqueued = requests[origin]?.length ?? 0;
                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
                    console.warn("@smithy/node-http-handler:WARN", `socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.`, "See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html", "or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.");
                    return Date.now();
                }
            }
        }
        return socketWarningTimestamp;
    }
    constructor(options) {
        this.socketWarningTimestamp = 0;
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout ?? socketTimeout,
            httpAgent: (() => {
                if (httpAgent instanceof external_http_.Agent || typeof httpAgent?.destroy === "function") {
                    return httpAgent;
                }
                return new external_http_.Agent({ keepAlive, maxSockets, ...httpAgent });
            })(),
            httpsAgent: (() => {
                if (httpsAgent instanceof external_https_.Agent || typeof httpsAgent?.destroy === "function") {
                    return httpsAgent;
                }
                return new external_https_.Agent({ keepAlive, maxSockets, ...httpsAgent });
            })(),
        };
    }
    destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        let socketCheckTimeoutId;
        return new Promise((_resolve, _reject) => {
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                clearTimeout(socketCheckTimeoutId);
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
            socketCheckTimeoutId = setTimeout(() => {
                this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp);
            }, this.config.socketAcquisitionWarningTimeout ??
                (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000));
            const queryString = dist_es_buildQueryString(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent,
                auth,
            };
            const requestFunc = isSSL ? external_https_.request : external_http_.request;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new httpResponse_HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: get_transformed_headers_getTransformedHeaders(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            setConnectionTimeout(req, reject, this.config.connectionTimeout);
            setSocketTimeout(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                setSocketKeepAlive(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                });
            }
            writeRequestBodyPromise = write_request_body_writeRequestBody(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

// EXTERNAL MODULE: external "http2"
var external_http2_ = __webpack_require__(5675);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
class node_http2_connection_pool_NodeHttp2ConnectionPool {
    constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions ?? [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-manager.js


class node_http2_connection_manager_NodeHttp2ConnectionManager {
    constructor(config) {
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/node-http2-handler.js






class NodeHttp2Handler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal?.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: this.config?.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = buildQueryString(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [constants.HTTP2_HEADER_PATH]: path,
                [constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: getTransformedHeaders(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js

class Collector extends external_stream_.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js

const stream_collector_streamCollector = (stream) => {
    if (isReadableStreamInstance(stream)) {
        return collectReadableStream(stream);
    }
    return new Promise((resolve, reject) => {
        const collector = new Collector();
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
            resolve(bytes);
        });
    });
};
const isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
async function collectReadableStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/node-http-handler/dist-es/index.js




// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(9023);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js



const keepAliveSupport = {
    supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
};
class FetchHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
        if (typeof options === "function") {
            this.configProvider = options().then((opts) => opts || {});
        }
        else {
            this.config = options ?? {};
            this.configProvider = Promise.resolve(this.config);
        }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        const requestTimeoutInMs = this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = buildQueryString(request.query || {});
        if (queryString) {
            path += `?${queryString}`;
        }
        if (request.fragment) {
            path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? undefined : request.body;
        const requestOptions = {
            body,
            headers: new Headers(request.headers),
            method: method,
        };
        if (body) {
            requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
            requestOptions.signal = abortSignal;
        }
        if (keepAliveSupport.supported) {
            requestOptions.keepalive = keepAlive;
        }
        const fetchRequest = new Request(url, requestOptions);
        const raceOfPromises = [
            fetch(fetchRequest).then((response) => {
                const fetchHeaders = response.headers;
                const transformedHeaders = {};
                for (const pair of fetchHeaders.entries()) {
                    transformedHeaders[pair[0]] = pair[1];
                }
                const hasReadableStream = response.body != undefined;
                if (!hasReadableStream) {
                    return response.blob().then((body) => ({
                        response: new HttpResponse({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body,
                        }),
                    }));
                }
                return {
                    response: new HttpResponse({
                        headers: transformedHeaders,
                        reason: response.statusText,
                        statusCode: response.status,
                        body: response.body,
                    }),
                };
            }),
            requestTimeout(requestTimeoutInMs),
        ];
        if (abortSignal) {
            raceOfPromises.push(new Promise((resolve, reject) => {
                abortSignal.onabort = () => {
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }));
        }
        return Promise.race(raceOfPromises);
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            config[key] = value;
            return config;
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js

const dist_es_stream_collector_streamCollector = (stream) => {
    if (typeof Blob === "function" && stream instanceof Blob) {
        return collectBlob(stream);
    }
    return collectStream(stream);
};
async function collectBlob(blob) {
    const base64 = await readToBase64(blob);
    const arrayBuffer = fromBase64(base64);
    return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}
function readToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (reader.readyState !== 2) {
                return reject(new Error("Reader aborted too early"));
            }
            const result = (reader.result ?? "");
            const commaIndex = result.indexOf(",");
            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
            resolve(result.substring(dataOffset));
        };
        reader.onabort = () => reject(new Error("Read aborted"));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
    });
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/fetch-http-handler/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-hex-encoding/dist-es/index.js
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function dist_es_toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js




const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    if (!isBlobInstance(stream) && !sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
            throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" +
                "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
    };
    return Object.assign(stream, {
        transformToByteArray: transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === "base64") {
                return toBase64(buf);
            }
            else if (encoding === "hex") {
                return toHex(buf);
            }
            else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
                return toUtf8(buf);
            }
            else if (typeof TextDecoder === "function") {
                return new TextDecoder(encoding).decode(buf);
            }
            else {
                throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            transformed = true;
            if (isBlobInstance(stream)) {
                return blobToWebStream(stream);
            }
            else if (sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
                return stream;
            }
            else {
                throw new Error(`Cannot transform payload to web stream, got ${stream}`);
            }
        },
    });
};
const isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
const sdk_stream_mixin_browser_isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js





const sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdk_stream_mixin_sdkStreamMixin = (stream) => {
    if (!(stream instanceof Readable)) {
        try {
            return sdkStreamMixinReadableStream(stream);
        }
        catch (e) {
            const name = stream?.__proto__?.constructor?.name || stream;
            throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return Readable.toWeb(stream);
        },
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/util-stream/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js

const collect_stream_body_collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/command.js


class Command {
    constructor() {
        this.middlewareStack = constructStack();
    }
    static classBuilder() {
        return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [SMITHY_CONTEXT_KEY]: {
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
class ClassBuilder {
    constructor() {
        this._init = () => { };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
    }
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends Command {
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(...[input]) {
                super();
                this.serialize = closure._serializer;
                this.deserialize = closure._deserializer;
                this.input = input ?? {};
                closure._init(this);
            }
            resolveMiddleware(stack, configuration, options) {
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/constants.js
const constants_SENSITIVE_STRING = "***SensitiveInformation***";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/parse-utils.js
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
const expectInt = (/* unused pure expression or super */ null && (expectLong));
const expectInt32 = (value) => expectSizedInt(value, 32);
const expectShort = (value) => expectSizedInt(value, 16);
const expectByte = (value) => expectSizedInt(value, 8);
const expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = expectObject(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
const parse_utils_strictParseDouble = (value) => {
    if (typeof value == "string") {
        return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
};
const strictParseFloat = (/* unused pure expression or super */ null && (parse_utils_strictParseDouble));
const parse_utils_strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
};
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectNumber(value);
};
const handleFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectFloat32(value);
};
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value) => {
    if (typeof value === "string") {
        return expectLong(parseNumber(value));
    }
    return expectLong(value);
};
const strictParseInt = (/* unused pure expression or super */ null && (strictParseLong));
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
};
const parse_utils_strictParseShort = (value) => {
    if (typeof value === "string") {
        return expectShort(parseNumber(value));
    }
    return expectShort(value);
};
const parse_utils_strictParseByte = (value) => {
    if (typeof value === "string") {
        return expectByte(parseNumber(value));
    }
    return expectByte(value);
};
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
const logger = {
    warn: console.warn,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/date-utils.js

const DAYS = (/* unused pure expression or super */ null && (["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]));
const MONTHS = (/* unused pure expression or super */ null && (["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]));
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
const RFC3339 = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/)));
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
const RFC3339_WITH_OFFSET = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/)));
const parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
const IMF_FIXDATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const RFC_850_DATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const ASC_TIME = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/)));
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = (/* unused pure expression or super */ null && (50 * 365 * 24 * 60 * 60 * 1000));
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = (/* unused pure expression or super */ null && ([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]));
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/exceptions.js
class ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
const decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/default-error-handler.js

const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw decorateServiceException(response, parsedBody);
};
const withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
const loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
        case "standard":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "in-region":
            return {
                retryMode: "standard",
                connectionTimeout: 1100,
            };
        case "cross-region":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "mobile":
            return {
                retryMode: "standard",
                connectionTimeout: 30000,
            };
        default:
            return {};
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
let warningEmitted = false;
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
        warningEmitted = true;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js


const extensions_checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in AlgorithmId) {
        const algorithmId = AlgorithmId[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const extensions_checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
const getRetryConfiguration = (runtimeConfig) => {
    let _retryStrategy = runtimeConfig.retryStrategy;
    return {
        setRetryStrategy(retryStrategy) {
            _retryStrategy = retryStrategy;
        },
        retryStrategy() {
            return _retryStrategy;
        },
    };
};
const resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js


const getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
        ...extensions_checksum_getChecksumConfiguration(runtimeConfig),
        ...getRetryConfiguration(runtimeConfig),
    };
};
const defaultExtensionConfiguration_getDefaultClientConfiguration = (/* unused pure expression or super */ null && (getDefaultExtensionConfiguration));
const defaultExtensionConfiguration_resolveDefaultRuntimeConfig = (config) => {
    return {
        ...extensions_checksum_resolveChecksumRuntimeConfig(config),
        ...resolveRetryRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/lazy-json.js
const StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(StringWrapper, String);
class LazyJsonString extends (/* unused pure expression or super */ null && (StringWrapper)) {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
        }
        return new LazyJsonString(JSON.stringify(object));
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/object-mapping.js
function object_mapping_map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
        target = {};
        instructions = arg0;
    }
    else {
        target = arg0;
        if (typeof arg1 === "function") {
            filter = arg1;
            instructions = arg2;
            return mapWithFilter(target, filter, instructions);
        }
        else {
            instructions = arg1;
        }
    }
    for (const key of Object.keys(instructions)) {
        if (!Array.isArray(instructions[key])) {
            target[key] = instructions[key];
            continue;
        }
        applyInstruction(target, null, instructions, key);
    }
    return target;
}
const convertMap = (target) => {
    const output = {};
    for (const [k, v] of Object.entries(target || {})) {
        output[k] = [, v];
    }
    return output;
};
const object_mapping_take = (source, instructions) => {
    const out = {};
    for (const key in instructions) {
        applyInstruction(out, source, instructions, key);
    }
    return out;
};
const mapWithFilter = (target, filter, instructions) => {
    return object_mapping_map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
            _instructions[key] = value;
        }
        else {
            if (typeof value === "function") {
                _instructions[key] = [filter, value()];
            }
            else {
                _instructions[key] = [filter, value];
            }
        }
        return _instructions;
    }, {}));
};
const applyInstruction = (target, source, instructions, targetKey) => {
    if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
            instruction = [, instruction];
        }
        const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if ((typeof filter === "function" && filter(source[sourceKey])) || (typeof filter !== "function" && !!filter)) {
            target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter === undefined && (_value = value()) != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed) {
            target[targetKey] = _value;
        }
        else if (customFilterPassed) {
            target[targetKey] = value();
        }
    }
    else {
        const defaultFilterPassed = filter === undefined && value != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed || customFilterPassed) {
            target[targetKey] = value;
        }
    }
};
const nonNullish = (_) => _ != null;
const pass = (_) => _;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/serde-json.js
const serde_json_json = (obj) => {
    if (obj == null) {
        return {};
    }
    if (Array.isArray(obj)) {
        return obj.filter((_) => _ != null).map(serde_json_json);
    }
    if (typeof obj === "object") {
        const target = {};
        for (const key of Object.keys(obj)) {
            if (obj[key] == null) {
                continue;
            }
            target[key] = serde_json_json(obj[key]);
        }
        return target;
    }
    return obj;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/node_modules/@smithy/smithy-client/dist-es/index.js























// EXTERNAL MODULE: ./node_modules/@aws-sdk/core/dist-cjs/index.js
var dist_cjs = __webpack_require__(5685);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/auth/httpAuthSchemeProvider.js


const defaultSSOOIDCHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
        operation: getSmithyContext(context).operation,
        region: (await normalizeProvider(config.region)()) ||
            (() => {
                throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
            })(),
    };
};
function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
            name: "sso-oauth",
            region: authParameters.region,
        },
        propertiesExtractor: (config, context) => ({
            signingProperties: {
                config,
                context,
            },
        }),
    };
}
function createSmithyApiNoAuthHttpAuthOption(authParameters) {
    return {
        schemeId: "smithy.api#noAuth",
    };
}
const defaultSSOOIDCHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
        case "CreateToken": {
            options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
            break;
        }
        case "RegisterClient": {
            options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
            break;
        }
        case "StartDeviceAuthorization": {
            options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
            break;
        }
        default: {
            options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
        }
    }
    return options;
};
const resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = (0,dist_cjs.resolveAwsSdkSigV4Config)(config);
    return {
        ...config_0,
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/EndpointParameters.js
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "sso-oauth",
    };
};
const commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/package.json
const package_namespaceObject = {"rE":"3.582.0"};
// EXTERNAL MODULE: ./node_modules/@aws-sdk/credential-provider-node/dist-es/index.js + 33 modules
var credential_provider_node_dist_es = __webpack_require__(2528);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js + 40 modules
var util_user_agent_node_dist_es = __webpack_require__(4733);
// EXTERNAL MODULE: ./node_modules/@smithy/hash-node/dist-es/index.js + 6 modules
var hash_node_dist_es = __webpack_require__(5914);
// EXTERNAL MODULE: ./node_modules/@smithy/util-body-length-node/dist-es/index.js + 1 modules
var util_body_length_node_dist_es = __webpack_require__(7809);
// EXTERNAL MODULE: ./node_modules/@smithy/util-retry/dist-es/index.js + 8 modules
var util_retry_dist_es = __webpack_require__(3323);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/index.js + 9 modules
var util_endpoints_dist_es = __webpack_require__(6652);
// EXTERNAL MODULE: ./node_modules/@smithy/util-endpoints/dist-es/index.js + 45 modules
var _smithy_util_endpoints_dist_es = __webpack_require__(6275);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/ruleset.js
const u = "required", v = "fn", w = "argv", x = "ref";
const a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = "getAttr", i = { [u]: false, "type": "String" }, j = { [u]: true, "default": false, "type": "Boolean" }, k = { [x]: "Endpoint" }, l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] }, m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] }, n = {}, o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] }, p = { [x]: g }, q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] }, r = [l], s = [m], t = [{ [x]: "Region" }];
const _data = { version: "1.0", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://oidc.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
const ruleSet = _data;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/endpointResolver.js



const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0,_smithy_util_endpoints_dist_es/* resolveEndpoint */.sO)(ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
_smithy_util_endpoints_dist_es/* customEndpointFunctions */.mw.aws = util_endpoints_dist_es/* awsEndpointFunctions */.UF;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.shared.js








const getRuntimeConfig = (config) => {
    return {
        apiVersion: "2019-06-10",
        base64Decoder: config?.base64Decoder ?? fromBase64_fromBase64,
        base64Encoder: config?.base64Encoder ?? toBase64_toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSSOOIDCHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                signer: new dist_cjs.AwsSdkSigV4Signer(),
            },
            {
                schemeId: "smithy.api#noAuth",
                identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
                signer: new core_dist_es.NoAuthSigner(),
            },
        ],
        logger: config?.logger ?? new NoOpLogger(),
        serviceId: config?.serviceId ?? "SSO OIDC",
        urlParser: config?.urlParser ?? parseUrl,
        utf8Decoder: config?.utf8Decoder ?? fromUtf8_fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? toUtf8_toUtf8,
    };
};

// EXTERNAL MODULE: ./node_modules/@smithy/util-defaults-mode-node/dist-es/index.js + 40 modules
var util_defaults_mode_node_dist_es = __webpack_require__(2);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.js















const runtimeConfig_getRuntimeConfig = (config) => {
    emitWarningIfUnsupportedVersion(process.version);
    const defaultsMode = (0,util_defaults_mode_node_dist_es/* resolveDefaultsModeConfig */.I)(config);
    const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
    const clientSharedValues = getRuntimeConfig(config);
    (0,dist_cjs.emitWarningIfUnsupportedVersion)(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_dist_es/* calculateBodyLength */.n,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? credential_provider_node_dist_es/* defaultProvider */.v6,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0,util_user_agent_node_dist_es/* defaultUserAgent */.mJ)({ serviceId: clientSharedValues.serviceId, clientVersion: package_namespaceObject.rE }),
        maxAttempts: config?.maxAttempts ?? loadConfig(middleware_retry_dist_es/* NODE_MAX_ATTEMPT_CONFIG_OPTIONS */.qs),
        region: config?.region ?? loadConfig(config_resolver_dist_es/* NODE_REGION_CONFIG_OPTIONS */.GG, config_resolver_dist_es/* NODE_REGION_CONFIG_FILE_OPTIONS */.zH),
        requestHandler: NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ??
            loadConfig({
                ...middleware_retry_dist_es/* NODE_RETRY_MODE_CONFIG_OPTIONS */.kN,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_dist_es/* DEFAULT_RETRY_MODE */.L0,
            }),
        sha256: config?.sha256 ?? hash_node_dist_es/* Hash */.V.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? stream_collector_streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(config_resolver_dist_es/* NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS */.e$),
        useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(config_resolver_dist_es/* NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS */.Ko),
    };
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/region-config-resolver/dist-es/index.js + 3 modules
var region_config_resolver_dist_es = __webpack_require__(4547);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/auth/httpAuthExtensionConfiguration.js
const getHttpAuthExtensionConfiguration = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
const resolveHttpAuthRuntimeConfig = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeExtensions.js




const asPartial = (t) => t;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial((0,region_config_resolver_dist_es/* getAwsRegionExtensionConfiguration */.Rq)(runtimeConfig)),
        ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
        ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig)),
        ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0,region_config_resolver_dist_es/* resolveAwsRegionExtensionConfiguration */.$3)(extensionConfiguration),
        ...defaultExtensionConfiguration_resolveDefaultRuntimeConfig(extensionConfiguration),
        ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
        ...resolveHttpAuthRuntimeConfig(extensionConfiguration),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/SSOOIDCClient.js















class SSOOIDCClient extends Client {
    constructor(...[configuration]) {
        const _config_0 = runtimeConfig_getRuntimeConfig(configuration || {});
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = (0,config_resolver_dist_es/* resolveRegionConfig */.TD)(_config_1);
        const _config_3 = resolveEndpointConfig(_config_2);
        const _config_4 = (0,middleware_retry_dist_es/* resolveRetryConfig */.$z)(_config_3);
        const _config_5 = (0,dist_es/* resolveHostHeaderConfig */.OV)(_config_4);
        const _config_6 = (0,middleware_user_agent_dist_es/* resolveUserAgentConfig */.Dc)(_config_5);
        const _config_7 = resolveHttpAuthSchemeConfig(_config_6);
        const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0,middleware_retry_dist_es/* getRetryPlugin */.ey)(this.config));
        this.middlewareStack.use((0,middleware_content_length_dist_es/* getContentLengthPlugin */.vK)(this.config));
        this.middlewareStack.use((0,dist_es/* getHostHeaderPlugin */.TC)(this.config));
        this.middlewareStack.use((0,middleware_logger_dist_es/* getLoggerPlugin */.Y7)(this.config));
        this.middlewareStack.use((0,middleware_recursion_detection_dist_es/* getRecursionDetectionPlugin */.n4)(this.config));
        this.middlewareStack.use((0,middleware_user_agent_dist_es/* getUserAgentPlugin */.sM)(this.config));
        this.middlewareStack.use((0,core_dist_es.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
            httpAuthSchemeParametersProvider: this.getDefaultHttpAuthSchemeParametersProvider(),
            identityProviderConfigProvider: this.getIdentityProviderConfigProvider(),
        }));
        this.middlewareStack.use((0,core_dist_es.getHttpSigningPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
    getDefaultHttpAuthSchemeParametersProvider() {
        return defaultSSOOIDCHttpAuthSchemeParametersProvider;
    }
    getIdentityProviderConfigProvider() {
        return async (config) => new core_dist_es.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials,
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/models/SSOOIDCServiceException.js


class SSOOIDCServiceException extends ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, SSOOIDCServiceException.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/models/models_0.js


class AccessDeniedException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        this.name = "AccessDeniedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AccessDeniedException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
class AuthorizationPendingException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "AuthorizationPendingException",
            $fault: "client",
            ...opts,
        });
        this.name = "AuthorizationPendingException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AuthorizationPendingException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
class ExpiredTokenException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "ExpiredTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "ExpiredTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ExpiredTokenException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
class InternalServerException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InternalServerException",
            $fault: "server",
            ...opts,
        });
        this.name = "InternalServerException";
        this.$fault = "server";
        Object.setPrototypeOf(this, InternalServerException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
class InvalidClientException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidClientException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
class InvalidGrantException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidGrantException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidGrantException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidGrantException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
class InvalidRequestException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequestException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
class InvalidScopeException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidScopeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidScopeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidScopeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
class SlowDownException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "SlowDownException",
            $fault: "client",
            ...opts,
        });
        this.name = "SlowDownException";
        this.$fault = "client";
        Object.setPrototypeOf(this, SlowDownException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
class UnauthorizedClientException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "UnauthorizedClientException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnauthorizedClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnauthorizedClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
class UnsupportedGrantTypeException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "UnsupportedGrantTypeException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnsupportedGrantTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnsupportedGrantTypeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
class InvalidRequestRegionException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidRequestRegionException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequestRegionException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequestRegionException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
        this.endpoint = opts.endpoint;
        this.region = opts.region;
    }
}
class InvalidClientMetadataException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidClientMetadataException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidClientMetadataException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidClientMetadataException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
class InvalidRedirectUriException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidRedirectUriException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRedirectUriException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRedirectUriException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
const CreateTokenRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.clientSecret && { clientSecret: constants_SENSITIVE_STRING }),
    ...(obj.refreshToken && { refreshToken: constants_SENSITIVE_STRING }),
    ...(obj.codeVerifier && { codeVerifier: constants_SENSITIVE_STRING }),
});
const CreateTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: constants_SENSITIVE_STRING }),
    ...(obj.refreshToken && { refreshToken: constants_SENSITIVE_STRING }),
    ...(obj.idToken && { idToken: constants_SENSITIVE_STRING }),
});
const CreateTokenWithIAMRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.refreshToken && { refreshToken: SENSITIVE_STRING }),
    ...(obj.assertion && { assertion: SENSITIVE_STRING }),
    ...(obj.subjectToken && { subjectToken: SENSITIVE_STRING }),
    ...(obj.codeVerifier && { codeVerifier: SENSITIVE_STRING }),
});
const CreateTokenWithIAMResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: SENSITIVE_STRING }),
    ...(obj.refreshToken && { refreshToken: SENSITIVE_STRING }),
    ...(obj.idToken && { idToken: SENSITIVE_STRING }),
});
const RegisterClientResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.clientSecret && { clientSecret: SENSITIVE_STRING }),
});
const StartDeviceAuthorizationRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.clientSecret && { clientSecret: SENSITIVE_STRING }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/protocols/Aws_restJson1.js





const se_CreateTokenCommand = async (input, context) => {
    const b = (0,core_dist_es.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/token");
    let body;
    body = JSON.stringify(object_mapping_take(input, {
        clientId: [],
        clientSecret: [],
        code: [],
        codeVerifier: [],
        deviceCode: [],
        grantType: [],
        redirectUri: [],
        refreshToken: [],
        scope: (_) => serde_json_json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
const se_CreateTokenWithIAMCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/token");
    const query = map({
        [_ai]: [, "t"],
    });
    let body;
    body = JSON.stringify(take(input, {
        assertion: [],
        clientId: [],
        code: [],
        codeVerifier: [],
        grantType: [],
        redirectUri: [],
        refreshToken: [],
        requestedTokenType: [],
        scope: (_) => _json(_),
        subjectToken: [],
        subjectTokenType: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
const se_RegisterClientCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/client/register");
    let body;
    body = JSON.stringify(take(input, {
        clientName: [],
        clientType: [],
        entitledApplicationArn: [],
        grantTypes: (_) => _json(_),
        issuerUrl: [],
        redirectUris: (_) => _json(_),
        scopes: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
const se_StartDeviceAuthorizationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/device_authorization");
    let body;
    body = JSON.stringify(take(input, {
        clientId: [],
        clientSecret: [],
        startUrl: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
const de_CreateTokenCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = object_mapping_map({
        $metadata: Aws_restJson1_deserializeMetadata(output),
    });
    const data = expectNonNull(expectObject(await (0,dist_cjs.parseJsonBody)(output.body, context)), "body");
    const doc = object_mapping_take(data, {
        accessToken: expectString,
        expiresIn: expectInt32,
        idToken: expectString,
        refreshToken: expectString,
        tokenType: expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateTokenWithIAMCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: Aws_restJson1_deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessToken: __expectString,
        expiresIn: __expectInt32,
        idToken: __expectString,
        issuedTokenType: __expectString,
        refreshToken: __expectString,
        scope: _json,
        tokenType: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_RegisterClientCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: Aws_restJson1_deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authorizationEndpoint: __expectString,
        clientId: __expectString,
        clientIdIssuedAt: __expectLong,
        clientSecret: __expectString,
        clientSecretExpiresAt: __expectLong,
        tokenEndpoint: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_StartDeviceAuthorizationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: Aws_restJson1_deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        deviceCode: __expectString,
        expiresIn: __expectInt32,
        interval: __expectInt32,
        userCode: __expectString,
        verificationUri: __expectString,
        verificationUriComplete: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await (0,dist_cjs.parseJsonErrorBody)(output.body, context),
    };
    const errorCode = (0,dist_cjs.loadRestJsonErrorCode)(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ssooidc#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "AuthorizationPendingException":
        case "com.amazonaws.ssooidc#AuthorizationPendingException":
            throw await de_AuthorizationPendingExceptionRes(parsedOutput, context);
        case "ExpiredTokenException":
        case "com.amazonaws.ssooidc#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
            throw await de_InvalidClientExceptionRes(parsedOutput, context);
        case "InvalidGrantException":
        case "com.amazonaws.ssooidc#InvalidGrantException":
            throw await de_InvalidGrantExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
            throw await de_InvalidScopeExceptionRes(parsedOutput, context);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
            throw await de_SlowDownExceptionRes(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
            throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
        case "UnsupportedGrantTypeException":
        case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
            throw await de_UnsupportedGrantTypeExceptionRes(parsedOutput, context);
        case "InvalidRequestRegionException":
        case "com.amazonaws.ssooidc#InvalidRequestRegionException":
            throw await de_InvalidRequestRegionExceptionRes(parsedOutput, context);
        case "InvalidClientMetadataException":
        case "com.amazonaws.ssooidc#InvalidClientMetadataException":
            throw await de_InvalidClientMetadataExceptionRes(parsedOutput, context);
        case "InvalidRedirectUriException":
        case "com.amazonaws.ssooidc#InvalidRedirectUriException":
            throw await de_InvalidRedirectUriExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return Aws_restJson1_throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const Aws_restJson1_throwDefaultError = withBaseException(SSOOIDCServiceException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_AuthorizationPendingExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new AuthorizationPendingException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new ExpiredTokenException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidClientExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidClientException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidClientMetadataExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidClientMetadataException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidGrantExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidGrantException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidRedirectUriExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidRedirectUriException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidRequestRegionExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        endpoint: expectString,
        error: expectString,
        error_description: expectString,
        region: expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestRegionException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidScopeExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidScopeException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_SlowDownExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new SlowDownException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_UnauthorizedClientExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedClientException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_UnsupportedGrantTypeExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        error: expectString,
        error_description: expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnsupportedGrantTypeException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const Aws_restJson1_deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _ai = "aws_iam";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/CreateTokenCommand.js







class CreateTokenCommand extends Command
    .classBuilder()
    .ep({
    ...commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSSSOOIDCService", "CreateToken", {})
    .n("SSOOIDCClient", "CreateTokenCommand")
    .f(CreateTokenRequestFilterSensitiveLog, CreateTokenResponseFilterSensitiveLog)
    .ser(se_CreateTokenCommand)
    .de(de_CreateTokenCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/index.js





;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso-oidc/dist-es/index.js







/***/ }),

/***/ 8658:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  i: () => (/* binding */ STSClient)
});

// UNUSED EXPORTS: __Client

// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-host-header/dist-es/index.js + 14 modules
var dist_es = __webpack_require__(9813);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-logger/dist-es/index.js + 1 modules
var middleware_logger_dist_es = __webpack_require__(9359);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js + 14 modules
var middleware_recursion_detection_dist_es = __webpack_require__(2163);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js + 17 modules
var middleware_user_agent_dist_es = __webpack_require__(4725);
// EXTERNAL MODULE: ./node_modules/@smithy/config-resolver/dist-es/index.js + 26 modules
var config_resolver_dist_es = __webpack_require__(7373);
// EXTERNAL MODULE: ./node_modules/@smithy/core/dist-es/index.js + 110 modules
var core_dist_es = __webpack_require__(2073);
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-content-length/dist-es/index.js + 14 modules
var middleware_content_length_dist_es = __webpack_require__(9587);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/index.js + 10 modules
var middleware_endpoint_dist_es = __webpack_require__(1496);
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-retry/dist-es/index.js + 69 modules
var middleware_retry_dist_es = __webpack_require__(2467);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/index.js + 29 modules
var smithy_client_dist_es = __webpack_require__(3810);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/core/dist-cjs/index.js
var dist_cjs = __webpack_require__(5685);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-middleware/dist-es/index.js + 2 modules
var util_middleware_dist_es = __webpack_require__(5162);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/auth/httpAuthSchemeProvider.js



const defaultSTSHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
        operation: (0,util_middleware_dist_es/* getSmithyContext */.u)(context).operation,
        region: (await (0,util_middleware_dist_es/* normalizeProvider */.t)(config.region)()) ||
            (() => {
                throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
            })(),
    };
};
function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
            name: "sts",
            region: authParameters.region,
        },
        propertiesExtractor: (config, context) => ({
            signingProperties: {
                config,
                context,
            },
        }),
    };
}
function createSmithyApiNoAuthHttpAuthOption(authParameters) {
    return {
        schemeId: "smithy.api#noAuth",
    };
}
const defaultSTSHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
        case "AssumeRoleWithSAML": {
            options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
            break;
        }
        case "AssumeRoleWithWebIdentity": {
            options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
            break;
        }
        default: {
            options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
        }
    }
    return options;
};
const resolveStsAuthConfig = (input) => ({
    ...input,
    stsClientCtor: STSClient,
});
const resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = resolveStsAuthConfig(config);
    const config_1 = (0,dist_cjs.resolveAwsSdkSigV4Config)(config_0);
    return {
        ...config_1,
    };
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/endpoint/EndpointParameters.js
var EndpointParameters = __webpack_require__(7207);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/package.json
const package_namespaceObject = {"rE":"3.582.0"};
// EXTERNAL MODULE: ./node_modules/@aws-sdk/credential-provider-node/dist-es/index.js + 33 modules
var credential_provider_node_dist_es = __webpack_require__(2528);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js + 40 modules
var util_user_agent_node_dist_es = __webpack_require__(4733);
// EXTERNAL MODULE: ./node_modules/@smithy/hash-node/dist-es/index.js + 6 modules
var hash_node_dist_es = __webpack_require__(5914);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-config-provider/dist-es/index.js + 11 modules
var node_config_provider_dist_es = __webpack_require__(3794);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/index.js + 14 modules
var node_http_handler_dist_es = __webpack_require__(7286);
// EXTERNAL MODULE: ./node_modules/@smithy/util-body-length-node/dist-es/index.js + 1 modules
var util_body_length_node_dist_es = __webpack_require__(7809);
// EXTERNAL MODULE: ./node_modules/@smithy/util-retry/dist-es/index.js + 8 modules
var util_retry_dist_es = __webpack_require__(3323);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/url-parser/dist-es/index.js + 1 modules
var url_parser_dist_es = __webpack_require__(1842);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-base64/dist-es/index.js + 2 modules
var util_base64_dist_es = __webpack_require__(6397);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-utf8/dist-es/index.js + 3 modules
var util_utf8_dist_es = __webpack_require__(4100);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/index.js + 9 modules
var util_endpoints_dist_es = __webpack_require__(6652);
// EXTERNAL MODULE: ./node_modules/@smithy/util-endpoints/dist-es/index.js + 45 modules
var _smithy_util_endpoints_dist_es = __webpack_require__(6275);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/endpoint/ruleset.js
const F = "required", G = "type", H = "fn", I = "argv", J = "ref";
const a = false, b = true, c = "booleanEquals", d = "stringEquals", e = "sigv4", f = "sts", g = "us-east-1", h = "endpoint", i = "https://sts.{Region}.{PartitionResult#dnsSuffix}", j = "tree", k = "error", l = "getAttr", m = { [F]: false, [G]: "String" }, n = { [F]: true, "default": false, [G]: "Boolean" }, o = { [J]: "Endpoint" }, p = { [H]: "isSet", [I]: [{ [J]: "Region" }] }, q = { [J]: "Region" }, r = { [H]: "aws.partition", [I]: [q], "assign": "PartitionResult" }, s = { [J]: "UseFIPS" }, t = { [J]: "UseDualStack" }, u = { "url": "https://sts.amazonaws.com", "properties": { "authSchemes": [{ "name": e, "signingName": f, "signingRegion": g }] }, "headers": {} }, v = {}, w = { "conditions": [{ [H]: d, [I]: [q, "aws-global"] }], [h]: u, [G]: h }, x = { [H]: c, [I]: [s, true] }, y = { [H]: c, [I]: [t, true] }, z = { [H]: l, [I]: [{ [J]: "PartitionResult" }, "supportsFIPS"] }, A = { [J]: "PartitionResult" }, B = { [H]: c, [I]: [true, { [H]: l, [I]: [A, "supportsDualStack"] }] }, C = [{ [H]: "isSet", [I]: [o] }], D = [x], E = [y];
const _data = { version: "1.0", parameters: { Region: m, UseDualStack: n, UseFIPS: n, Endpoint: m, UseGlobalEndpoint: n }, rules: [{ conditions: [{ [H]: c, [I]: [{ [J]: "UseGlobalEndpoint" }, b] }, { [H]: "not", [I]: C }, p, r, { [H]: c, [I]: [s, a] }, { [H]: c, [I]: [t, a] }], rules: [{ conditions: [{ [H]: d, [I]: [q, "ap-northeast-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "ap-south-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "ap-southeast-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "ap-southeast-2"] }], endpoint: u, [G]: h }, w, { conditions: [{ [H]: d, [I]: [q, "ca-central-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-central-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-north-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-west-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-west-2"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-west-3"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "sa-east-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, g] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "us-east-2"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "us-west-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "us-west-2"] }], endpoint: u, [G]: h }, { endpoint: { url: i, properties: { authSchemes: [{ name: e, signingName: f, signingRegion: "{Region}" }] }, headers: v }, [G]: h }], [G]: j }, { conditions: C, rules: [{ conditions: D, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G]: k }, { conditions: E, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G]: k }, { endpoint: { url: o, properties: v, headers: v }, [G]: h }], [G]: j }, { conditions: [p], rules: [{ conditions: [r], rules: [{ conditions: [x, y], rules: [{ conditions: [{ [H]: c, [I]: [b, z] }, B], rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v, headers: v }, [G]: h }], [G]: j }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G]: k }], [G]: j }, { conditions: D, rules: [{ conditions: [{ [H]: c, [I]: [z, b] }], rules: [{ conditions: [{ [H]: d, [I]: [{ [H]: l, [I]: [A, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v, headers: v }, [G]: h }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v, headers: v }, [G]: h }], [G]: j }, { error: "FIPS is enabled but this partition does not support FIPS", [G]: k }], [G]: j }, { conditions: E, rules: [{ conditions: [B], rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v, headers: v }, [G]: h }], [G]: j }, { error: "DualStack is enabled but this partition does not support DualStack", [G]: k }], [G]: j }, w, { endpoint: { url: i, properties: v, headers: v }, [G]: h }], [G]: j }], [G]: j }, { error: "Invalid Configuration: Missing Region", [G]: k }] };
const ruleSet = _data;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/endpoint/endpointResolver.js



const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0,_smithy_util_endpoints_dist_es/* resolveEndpoint */.sO)(ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
_smithy_util_endpoints_dist_es/* customEndpointFunctions */.mw.aws = util_endpoints_dist_es/* awsEndpointFunctions */.UF;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.shared.js








const getRuntimeConfig = (config) => {
    return {
        apiVersion: "2011-06-15",
        base64Decoder: config?.base64Decoder ?? util_base64_dist_es/* fromBase64 */.E,
        base64Encoder: config?.base64Encoder ?? util_base64_dist_es/* toBase64 */.n,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSTSHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                signer: new dist_cjs.AwsSdkSigV4Signer(),
            },
            {
                schemeId: "smithy.api#noAuth",
                identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
                signer: new core_dist_es.NoAuthSigner(),
            },
        ],
        logger: config?.logger ?? new smithy_client_dist_es/* NoOpLogger */.N4(),
        serviceId: config?.serviceId ?? "STS",
        urlParser: config?.urlParser ?? url_parser_dist_es/* parseUrl */.D,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_dist_es/* fromUtf8 */.ar,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_dist_es/* toUtf8 */.Pq,
    };
};

// EXTERNAL MODULE: ./node_modules/@smithy/util-defaults-mode-node/dist-es/index.js + 40 modules
var util_defaults_mode_node_dist_es = __webpack_require__(2);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.js
















const runtimeConfig_getRuntimeConfig = (config) => {
    (0,smithy_client_dist_es/* emitWarningIfUnsupportedVersion */.I9)(process.version);
    const defaultsMode = (0,util_defaults_mode_node_dist_es/* resolveDefaultsModeConfig */.I)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_dist_es/* loadConfigsForDefaultMode */.lT);
    const clientSharedValues = getRuntimeConfig(config);
    (0,dist_cjs.emitWarningIfUnsupportedVersion)(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_dist_es/* calculateBodyLength */.n,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? credential_provider_node_dist_es/* defaultProvider */.v6,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0,util_user_agent_node_dist_es/* defaultUserAgent */.mJ)({ serviceId: clientSharedValues.serviceId, clientVersion: package_namespaceObject.rE }),
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4") ||
                    (async (idProps) => await (0,credential_provider_node_dist_es/* defaultProvider */.v6)(idProps?.__config || {})()),
                signer: new dist_cjs.AwsSdkSigV4Signer(),
            },
            {
                schemeId: "smithy.api#noAuth",
                identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
                signer: new core_dist_es.NoAuthSigner(),
            },
        ],
        maxAttempts: config?.maxAttempts ?? (0,node_config_provider_dist_es/* loadConfig */.Z)(middleware_retry_dist_es/* NODE_MAX_ATTEMPT_CONFIG_OPTIONS */.qs),
        region: config?.region ?? (0,node_config_provider_dist_es/* loadConfig */.Z)(config_resolver_dist_es/* NODE_REGION_CONFIG_OPTIONS */.GG, config_resolver_dist_es/* NODE_REGION_CONFIG_FILE_OPTIONS */.zH),
        requestHandler: node_http_handler_dist_es/* NodeHttpHandler */.$c.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0,node_config_provider_dist_es/* loadConfig */.Z)({
                ...middleware_retry_dist_es/* NODE_RETRY_MODE_CONFIG_OPTIONS */.kN,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_dist_es/* DEFAULT_RETRY_MODE */.L0,
            }),
        sha256: config?.sha256 ?? hash_node_dist_es/* Hash */.V.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_dist_es/* streamCollector */.kv,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0,node_config_provider_dist_es/* loadConfig */.Z)(config_resolver_dist_es/* NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS */.e$),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0,node_config_provider_dist_es/* loadConfig */.Z)(config_resolver_dist_es/* NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS */.Ko),
    };
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/region-config-resolver/dist-es/index.js + 3 modules
var region_config_resolver_dist_es = __webpack_require__(4547);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/protocol-http/dist-es/index.js + 5 modules
var protocol_http_dist_es = __webpack_require__(1462);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/auth/httpAuthExtensionConfiguration.js
const getHttpAuthExtensionConfiguration = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
const resolveHttpAuthRuntimeConfig = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/runtimeExtensions.js




const asPartial = (t) => t;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial((0,region_config_resolver_dist_es/* getAwsRegionExtensionConfiguration */.Rq)(runtimeConfig)),
        ...asPartial((0,smithy_client_dist_es/* getDefaultExtensionConfiguration */.xA)(runtimeConfig)),
        ...asPartial((0,protocol_http_dist_es/* getHttpHandlerExtensionConfiguration */.eS)(runtimeConfig)),
        ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0,region_config_resolver_dist_es/* resolveAwsRegionExtensionConfiguration */.$3)(extensionConfiguration),
        ...(0,smithy_client_dist_es/* resolveDefaultRuntimeConfig */.uv)(extensionConfiguration),
        ...(0,protocol_http_dist_es/* resolveHttpHandlerRuntimeConfig */.jt)(extensionConfiguration),
        ...resolveHttpAuthRuntimeConfig(extensionConfiguration),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/STSClient.js















class STSClient extends smithy_client_dist_es/* Client */.Kj {
    constructor(...[configuration]) {
        const _config_0 = runtimeConfig_getRuntimeConfig(configuration || {});
        const _config_1 = (0,EndpointParameters/* resolveClientEndpointParameters */.v)(_config_0);
        const _config_2 = (0,config_resolver_dist_es/* resolveRegionConfig */.TD)(_config_1);
        const _config_3 = (0,middleware_endpoint_dist_es/* resolveEndpointConfig */.Co)(_config_2);
        const _config_4 = (0,middleware_retry_dist_es/* resolveRetryConfig */.$z)(_config_3);
        const _config_5 = (0,dist_es/* resolveHostHeaderConfig */.OV)(_config_4);
        const _config_6 = (0,middleware_user_agent_dist_es/* resolveUserAgentConfig */.Dc)(_config_5);
        const _config_7 = resolveHttpAuthSchemeConfig(_config_6);
        const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0,middleware_retry_dist_es/* getRetryPlugin */.ey)(this.config));
        this.middlewareStack.use((0,middleware_content_length_dist_es/* getContentLengthPlugin */.vK)(this.config));
        this.middlewareStack.use((0,dist_es/* getHostHeaderPlugin */.TC)(this.config));
        this.middlewareStack.use((0,middleware_logger_dist_es/* getLoggerPlugin */.Y7)(this.config));
        this.middlewareStack.use((0,middleware_recursion_detection_dist_es/* getRecursionDetectionPlugin */.n4)(this.config));
        this.middlewareStack.use((0,middleware_user_agent_dist_es/* getUserAgentPlugin */.sM)(this.config));
        this.middlewareStack.use((0,core_dist_es.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
            httpAuthSchemeParametersProvider: this.getDefaultHttpAuthSchemeParametersProvider(),
            identityProviderConfigProvider: this.getIdentityProviderConfigProvider(),
        }));
        this.middlewareStack.use((0,core_dist_es.getHttpSigningPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
    getDefaultHttpAuthSchemeParametersProvider() {
        return defaultSTSHttpAuthSchemeParametersProvider;
    }
    getIdentityProviderConfigProvider() {
        return async (config) => new core_dist_es.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials,
        });
    }
}


/***/ }),

/***/ 7207:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ commonParams),
/* harmony export */   v: () => (/* binding */ resolveClientEndpointParameters)
/* harmony export */ });
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        defaultSigningName: "sts",
    };
};
const commonParams = {
    UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};


/***/ }),

/***/ 4276:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  getDefaultRoleAssumer: () => (/* reexport */ defaultRoleAssumers_getDefaultRoleAssumer),
  getDefaultRoleAssumerWithWebIdentity: () => (/* reexport */ defaultRoleAssumers_getDefaultRoleAssumerWithWebIdentity)
});

// UNUSED EXPORTS: $Command, AssumeRoleCommand, AssumeRoleResponseFilterSensitiveLog, AssumeRoleWithSAMLCommand, AssumeRoleWithSAMLRequestFilterSensitiveLog, AssumeRoleWithSAMLResponseFilterSensitiveLog, AssumeRoleWithWebIdentityCommand, AssumeRoleWithWebIdentityRequestFilterSensitiveLog, AssumeRoleWithWebIdentityResponseFilterSensitiveLog, CredentialsFilterSensitiveLog, DecodeAuthorizationMessageCommand, ExpiredTokenException, GetAccessKeyInfoCommand, GetCallerIdentityCommand, GetFederationTokenCommand, GetFederationTokenResponseFilterSensitiveLog, GetSessionTokenCommand, GetSessionTokenResponseFilterSensitiveLog, IDPCommunicationErrorException, IDPRejectedClaimException, InvalidAuthorizationMessageException, InvalidIdentityTokenException, MalformedPolicyDocumentException, PackedPolicyTooLargeException, RegionDisabledException, STS, STSClient, STSServiceException, __Client, decorateDefaultCredentialProvider

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/index.js + 10 modules
var dist_es = __webpack_require__(1496);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-serde/dist-es/index.js + 3 modules
var middleware_serde_dist_es = __webpack_require__(6391);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/index.js + 29 modules
var smithy_client_dist_es = __webpack_require__(3810);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/endpoint/EndpointParameters.js
var EndpointParameters = __webpack_require__(7207);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/models/models_0.js
var models_0 = __webpack_require__(8766);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/protocols/Aws_query.js
var Aws_query = __webpack_require__(784);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleCommand.js







class AssumeRoleCommand extends smithy_client_dist_es/* Command */.uB
    .classBuilder()
    .ep({
    ...EndpointParameters/* commonParams */.S,
})
    .m(function (Command, cs, config, o) {
    return [
        (0,middleware_serde_dist_es/* getSerdePlugin */.TM)(config, this.serialize, this.deserialize),
        (0,dist_es/* getEndpointPlugin */.rD)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSSecurityTokenServiceV20110615", "AssumeRole", {})
    .n("STSClient", "AssumeRoleCommand")
    .f(void 0, models_0/* AssumeRoleResponseFilterSensitiveLog */.kl)
    .ser(Aws_query/* se_AssumeRoleCommand */.JC)
    .de(Aws_query/* de_AssumeRoleCommand */.aP)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleWithWebIdentityCommand.js







class AssumeRoleWithWebIdentityCommand extends smithy_client_dist_es/* Command */.uB
    .classBuilder()
    .ep({
    ...EndpointParameters/* commonParams */.S,
})
    .m(function (Command, cs, config, o) {
    return [
        (0,middleware_serde_dist_es/* getSerdePlugin */.TM)(config, this.serialize, this.deserialize),
        (0,dist_es/* getEndpointPlugin */.rD)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {})
    .n("STSClient", "AssumeRoleWithWebIdentityCommand")
    .f(models_0/* AssumeRoleWithWebIdentityRequestFilterSensitiveLog */.KT, models_0/* AssumeRoleWithWebIdentityResponseFilterSensitiveLog */.AA)
    .ser(Aws_query/* se_AssumeRoleWithWebIdentityCommand */.$3)
    .de(Aws_query/* de_AssumeRoleWithWebIdentityCommand */.MV)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/defaultStsRoleAssumers.js


const ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
const resolveRegion = async (_region, _parentRegion, credentialProviderLogger) => {
    const region = typeof _region === "function" ? await _region() : _region;
    const parentRegion = typeof _parentRegion === "function" ? await _parentRegion() : _parentRegion;
    credentialProviderLogger?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${region} (provider)`, `${parentRegion} (parent client)`, `${ASSUME_ROLE_DEFAULT_REGION} (STS default)`);
    return region ?? parentRegion ?? ASSUME_ROLE_DEFAULT_REGION;
};
const getDefaultRoleAssumer = (stsOptions, stsClientCtor) => {
    let stsClient;
    let closureSourceCreds;
    return async (sourceCreds, params) => {
        closureSourceCreds = sourceCreds;
        if (!stsClient) {
            const { logger = stsOptions?.parentClientConfig?.logger, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger, } = stsOptions;
            const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger);
            stsClient = new stsClientCtor({
                credentialDefaultProvider: () => async () => closureSourceCreds,
                region: resolvedRegion,
                requestHandler: requestHandler,
                logger: logger,
            });
        }
        const { Credentials } = await stsClient.send(new AssumeRoleCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
            throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
        }
        return {
            accessKeyId: Credentials.AccessKeyId,
            secretAccessKey: Credentials.SecretAccessKey,
            sessionToken: Credentials.SessionToken,
            expiration: Credentials.Expiration,
            credentialScope: Credentials.CredentialScope,
        };
    };
};
const getDefaultRoleAssumerWithWebIdentity = (stsOptions, stsClientCtor) => {
    let stsClient;
    return async (params) => {
        if (!stsClient) {
            const { logger = stsOptions?.parentClientConfig?.logger, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger, } = stsOptions;
            const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger);
            stsClient = new stsClientCtor({
                region: resolvedRegion,
                requestHandler: requestHandler,
                logger: logger,
            });
        }
        const { Credentials } = await stsClient.send(new AssumeRoleWithWebIdentityCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
            throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
        }
        return {
            accessKeyId: Credentials.AccessKeyId,
            secretAccessKey: Credentials.SecretAccessKey,
            sessionToken: Credentials.SessionToken,
            expiration: Credentials.Expiration,
            credentialScope: Credentials.CredentialScope,
        };
    };
};
const decorateDefaultCredentialProvider = (provider) => (input) => provider({
    roleAssumer: getDefaultRoleAssumer(input, input.stsClientCtor),
    roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity(input, input.stsClientCtor),
    ...input,
});

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/STSClient.js + 8 modules
var STSClient = __webpack_require__(8658);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/defaultRoleAssumers.js


const getCustomizableStsClientCtor = (baseCtor, customizations) => {
    if (!customizations)
        return baseCtor;
    else
        return class CustomizableSTSClient extends baseCtor {
            constructor(config) {
                super(config);
                for (const customization of customizations) {
                    this.middlewareStack.use(customization);
                }
            }
        };
};
const defaultRoleAssumers_getDefaultRoleAssumer = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumer(stsOptions, getCustomizableStsClientCtor(STSClient/* STSClient */.i, stsPlugins));
const defaultRoleAssumers_getDefaultRoleAssumerWithWebIdentity = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity(stsOptions, getCustomizableStsClientCtor(STSClient/* STSClient */.i, stsPlugins));
const defaultRoleAssumers_decorateDefaultCredentialProvider = (provider) => (input) => provider({
    roleAssumer: defaultRoleAssumers_getDefaultRoleAssumer(input),
    roleAssumerWithWebIdentity: defaultRoleAssumers_getDefaultRoleAssumerWithWebIdentity(input),
    ...input,
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/index.js








/***/ }),

/***/ 391:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ STSServiceException)
/* harmony export */ });
/* harmony import */ var _smithy_smithy_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3810);


class STSServiceException extends _smithy_smithy_client__WEBPACK_IMPORTED_MODULE_0__/* .ServiceException */ .TJ {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, STSServiceException.prototype);
    }
}


/***/ }),

/***/ 8766:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AA: () => (/* binding */ AssumeRoleWithWebIdentityResponseFilterSensitiveLog),
/* harmony export */   KT: () => (/* binding */ AssumeRoleWithWebIdentityRequestFilterSensitiveLog),
/* harmony export */   Nd: () => (/* binding */ IDPCommunicationErrorException),
/* harmony export */   V1: () => (/* binding */ PackedPolicyTooLargeException),
/* harmony export */   _A: () => (/* binding */ ExpiredTokenException),
/* harmony export */   _Z: () => (/* binding */ MalformedPolicyDocumentException),
/* harmony export */   fi: () => (/* binding */ IDPRejectedClaimException),
/* harmony export */   kl: () => (/* binding */ AssumeRoleResponseFilterSensitiveLog),
/* harmony export */   po: () => (/* binding */ InvalidAuthorizationMessageException),
/* harmony export */   wU: () => (/* binding */ RegionDisabledException),
/* harmony export */   ye: () => (/* binding */ InvalidIdentityTokenException)
/* harmony export */ });
/* unused harmony exports CredentialsFilterSensitiveLog, AssumeRoleWithSAMLRequestFilterSensitiveLog, AssumeRoleWithSAMLResponseFilterSensitiveLog, GetFederationTokenResponseFilterSensitiveLog, GetSessionTokenResponseFilterSensitiveLog */
/* harmony import */ var _smithy_smithy_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3810);
/* harmony import */ var _STSServiceException__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(391);


class ExpiredTokenException extends _STSServiceException__WEBPACK_IMPORTED_MODULE_1__/* .STSServiceException */ .L {
    constructor(opts) {
        super({
            name: "ExpiredTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "ExpiredTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ExpiredTokenException.prototype);
    }
}
class MalformedPolicyDocumentException extends _STSServiceException__WEBPACK_IMPORTED_MODULE_1__/* .STSServiceException */ .L {
    constructor(opts) {
        super({
            name: "MalformedPolicyDocumentException",
            $fault: "client",
            ...opts,
        });
        this.name = "MalformedPolicyDocumentException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
    }
}
class PackedPolicyTooLargeException extends _STSServiceException__WEBPACK_IMPORTED_MODULE_1__/* .STSServiceException */ .L {
    constructor(opts) {
        super({
            name: "PackedPolicyTooLargeException",
            $fault: "client",
            ...opts,
        });
        this.name = "PackedPolicyTooLargeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
    }
}
class RegionDisabledException extends _STSServiceException__WEBPACK_IMPORTED_MODULE_1__/* .STSServiceException */ .L {
    constructor(opts) {
        super({
            name: "RegionDisabledException",
            $fault: "client",
            ...opts,
        });
        this.name = "RegionDisabledException";
        this.$fault = "client";
        Object.setPrototypeOf(this, RegionDisabledException.prototype);
    }
}
class IDPRejectedClaimException extends _STSServiceException__WEBPACK_IMPORTED_MODULE_1__/* .STSServiceException */ .L {
    constructor(opts) {
        super({
            name: "IDPRejectedClaimException",
            $fault: "client",
            ...opts,
        });
        this.name = "IDPRejectedClaimException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
    }
}
class InvalidIdentityTokenException extends _STSServiceException__WEBPACK_IMPORTED_MODULE_1__/* .STSServiceException */ .L {
    constructor(opts) {
        super({
            name: "InvalidIdentityTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidIdentityTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
    }
}
class IDPCommunicationErrorException extends _STSServiceException__WEBPACK_IMPORTED_MODULE_1__/* .STSServiceException */ .L {
    constructor(opts) {
        super({
            name: "IDPCommunicationErrorException",
            $fault: "client",
            ...opts,
        });
        this.name = "IDPCommunicationErrorException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
    }
}
class InvalidAuthorizationMessageException extends _STSServiceException__WEBPACK_IMPORTED_MODULE_1__/* .STSServiceException */ .L {
    constructor(opts) {
        super({
            name: "InvalidAuthorizationMessageException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidAuthorizationMessageException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidAuthorizationMessageException.prototype);
    }
}
const CredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SecretAccessKey && { SecretAccessKey: _smithy_smithy_client__WEBPACK_IMPORTED_MODULE_0__/* .SENSITIVE_STRING */ .$H }),
});
const AssumeRoleResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }),
});
const AssumeRoleWithSAMLRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SAMLAssertion && { SAMLAssertion: SENSITIVE_STRING }),
});
const AssumeRoleWithSAMLResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }),
});
const AssumeRoleWithWebIdentityRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.WebIdentityToken && { WebIdentityToken: _smithy_smithy_client__WEBPACK_IMPORTED_MODULE_0__/* .SENSITIVE_STRING */ .$H }),
});
const AssumeRoleWithWebIdentityResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }),
});
const GetFederationTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }),
});
const GetSessionTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }),
});


/***/ }),

/***/ 784:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $3: () => (/* binding */ se_AssumeRoleWithWebIdentityCommand),
/* harmony export */   GQ: () => (/* binding */ se_GetCallerIdentityCommand),
/* harmony export */   JC: () => (/* binding */ se_AssumeRoleCommand),
/* harmony export */   MV: () => (/* binding */ de_AssumeRoleWithWebIdentityCommand),
/* harmony export */   aP: () => (/* binding */ de_AssumeRoleCommand),
/* harmony export */   hW: () => (/* binding */ de_GetCallerIdentityCommand)
/* harmony export */ });
/* unused harmony exports se_AssumeRoleWithSAMLCommand, se_DecodeAuthorizationMessageCommand, se_GetAccessKeyInfoCommand, se_GetFederationTokenCommand, se_GetSessionTokenCommand, de_AssumeRoleWithSAMLCommand, de_DecodeAuthorizationMessageCommand, de_GetAccessKeyInfoCommand, de_GetFederationTokenCommand, de_GetSessionTokenCommand */
/* harmony import */ var _aws_sdk_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5685);
/* harmony import */ var _aws_sdk_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_aws_sdk_core__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _smithy_protocol_http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1462);
/* harmony import */ var _smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3810);
/* harmony import */ var _models_models_0__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8766);
/* harmony import */ var _models_STSServiceException__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(391);





const se_AssumeRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssumeRoleRequest(input, context),
        [_A]: _AR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_AssumeRoleWithSAMLCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssumeRoleWithSAMLRequest(input, context),
        [_A]: _ARWSAML,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_AssumeRoleWithWebIdentityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssumeRoleWithWebIdentityRequest(input, context),
        [_A]: _ARWWI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DecodeAuthorizationMessageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DecodeAuthorizationMessageRequest(input, context),
        [_A]: _DAM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetAccessKeyInfoCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAccessKeyInfoRequest(input, context),
        [_A]: _GAKI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetCallerIdentityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetCallerIdentityRequest(input, context),
        [_A]: _GCI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetFederationTokenCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetFederationTokenRequest(input, context),
        [_A]: _GFT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetSessionTokenCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSessionTokenRequest(input, context),
        [_A]: _GST,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const de_AssumeRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await (0,_aws_sdk_core__WEBPACK_IMPORTED_MODULE_2__.parseXmlBody)(output.body, context);
    let contents = {};
    contents = de_AssumeRoleResponse(data.AssumeRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_AssumeRoleWithSAMLCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssumeRoleWithSAMLResponse(data.AssumeRoleWithSAMLResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_AssumeRoleWithWebIdentityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await (0,_aws_sdk_core__WEBPACK_IMPORTED_MODULE_2__.parseXmlBody)(output.body, context);
    let contents = {};
    contents = de_AssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DecodeAuthorizationMessageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DecodeAuthorizationMessageResponse(data.DecodeAuthorizationMessageResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetAccessKeyInfoCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccessKeyInfoResponse(data.GetAccessKeyInfoResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetCallerIdentityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await (0,_aws_sdk_core__WEBPACK_IMPORTED_MODULE_2__.parseXmlBody)(output.body, context);
    let contents = {};
    contents = de_GetCallerIdentityResponse(data.GetCallerIdentityResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetFederationTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetFederationTokenResponse(data.GetFederationTokenResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetSessionTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSessionTokenResponse(data.GetSessionTokenResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await (0,_aws_sdk_core__WEBPACK_IMPORTED_MODULE_2__.parseXmlErrorBody)(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
            throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
            throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
            throw await de_IDPCommunicationErrorExceptionRes(parsedOutput, context);
        case "InvalidAuthorizationMessageException":
        case "com.amazonaws.sts#InvalidAuthorizationMessageException":
            throw await de_InvalidAuthorizationMessageExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ExpiredTokenException(body.Error, context);
    const exception = new _models_models_0__WEBPACK_IMPORTED_MODULE_3__/* .ExpiredTokenException */ ._A({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .decorateServiceException */ .Mw)(exception, body);
};
const de_IDPCommunicationErrorExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IDPCommunicationErrorException(body.Error, context);
    const exception = new _models_models_0__WEBPACK_IMPORTED_MODULE_3__/* .IDPCommunicationErrorException */ .Nd({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .decorateServiceException */ .Mw)(exception, body);
};
const de_IDPRejectedClaimExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IDPRejectedClaimException(body.Error, context);
    const exception = new _models_models_0__WEBPACK_IMPORTED_MODULE_3__/* .IDPRejectedClaimException */ .fi({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .decorateServiceException */ .Mw)(exception, body);
};
const de_InvalidAuthorizationMessageExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAuthorizationMessageException(body.Error, context);
    const exception = new _models_models_0__WEBPACK_IMPORTED_MODULE_3__/* .InvalidAuthorizationMessageException */ .po({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .decorateServiceException */ .Mw)(exception, body);
};
const de_InvalidIdentityTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidIdentityTokenException(body.Error, context);
    const exception = new _models_models_0__WEBPACK_IMPORTED_MODULE_3__/* .InvalidIdentityTokenException */ .ye({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .decorateServiceException */ .Mw)(exception, body);
};
const de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MalformedPolicyDocumentException(body.Error, context);
    const exception = new _models_models_0__WEBPACK_IMPORTED_MODULE_3__/* .MalformedPolicyDocumentException */ ._Z({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .decorateServiceException */ .Mw)(exception, body);
};
const de_PackedPolicyTooLargeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PackedPolicyTooLargeException(body.Error, context);
    const exception = new _models_models_0__WEBPACK_IMPORTED_MODULE_3__/* .PackedPolicyTooLargeException */ .V1({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .decorateServiceException */ .Mw)(exception, body);
};
const de_RegionDisabledExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RegionDisabledException(body.Error, context);
    const exception = new _models_models_0__WEBPACK_IMPORTED_MODULE_3__/* .RegionDisabledException */ .wU({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .decorateServiceException */ .Mw)(exception, body);
};
const se_AssumeRoleRequest = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
        entries[_RA] = input[_RA];
    }
    if (input[_RSN] != null) {
        entries[_RSN] = input[_RSN];
    }
    if (input[_PA] != null) {
        const memberEntries = se_policyDescriptorListType(input[_PA], context);
        if (input[_PA]?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_DS] != null) {
        entries[_DS] = input[_DS];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TTK] != null) {
        const memberEntries = se_tagKeyListType(input[_TTK], context);
        if (input[_TTK]?.length === 0) {
            entries.TransitiveTagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitiveTagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EI] != null) {
        entries[_EI] = input[_EI];
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_TC] != null) {
        entries[_TC] = input[_TC];
    }
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_PC] != null) {
        const memberEntries = se_ProvidedContextsListType(input[_PC], context);
        if (input[_PC]?.length === 0) {
            entries.ProvidedContexts = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ProvidedContexts.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AssumeRoleWithSAMLRequest = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
        entries[_RA] = input[_RA];
    }
    if (input[_PAr] != null) {
        entries[_PAr] = input[_PAr];
    }
    if (input[_SAMLA] != null) {
        entries[_SAMLA] = input[_SAMLA];
    }
    if (input[_PA] != null) {
        const memberEntries = se_policyDescriptorListType(input[_PA], context);
        if (input[_PA]?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_DS] != null) {
        entries[_DS] = input[_DS];
    }
    return entries;
};
const se_AssumeRoleWithWebIdentityRequest = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
        entries[_RA] = input[_RA];
    }
    if (input[_RSN] != null) {
        entries[_RSN] = input[_RSN];
    }
    if (input[_WIT] != null) {
        entries[_WIT] = input[_WIT];
    }
    if (input[_PI] != null) {
        entries[_PI] = input[_PI];
    }
    if (input[_PA] != null) {
        const memberEntries = se_policyDescriptorListType(input[_PA], context);
        if (input[_PA]?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_DS] != null) {
        entries[_DS] = input[_DS];
    }
    return entries;
};
const se_DecodeAuthorizationMessageRequest = (input, context) => {
    const entries = {};
    if (input[_EM] != null) {
        entries[_EM] = input[_EM];
    }
    return entries;
};
const se_GetAccessKeyInfoRequest = (input, context) => {
    const entries = {};
    if (input[_AKI] != null) {
        entries[_AKI] = input[_AKI];
    }
    return entries;
};
const se_GetCallerIdentityRequest = (input, context) => {
    const entries = {};
    return entries;
};
const se_GetFederationTokenRequest = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_PA] != null) {
        const memberEntries = se_policyDescriptorListType(input[_PA], context);
        if (input[_PA]?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DS] != null) {
        entries[_DS] = input[_DS];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetSessionTokenRequest = (input, context) => {
    const entries = {};
    if (input[_DS] != null) {
        entries[_DS] = input[_DS];
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_TC] != null) {
        entries[_TC] = input[_TC];
    }
    return entries;
};
const se_policyDescriptorListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PolicyDescriptorType(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PolicyDescriptorType = (input, context) => {
    const entries = {};
    if (input[_a] != null) {
        entries[_a] = input[_a];
    }
    return entries;
};
const se_ProvidedContext = (input, context) => {
    const entries = {};
    if (input[_PAro] != null) {
        entries[_PAro] = input[_PAro];
    }
    if (input[_CA] != null) {
        entries[_CA] = input[_CA];
    }
    return entries;
};
const se_ProvidedContextsListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ProvidedContext(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_tagKeyListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_tagListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const de_AssumedRoleUser = (output, context) => {
    const contents = {};
    if (output[_ARI] != null) {
        contents[_ARI] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_ARI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_Ar]);
    }
    return contents;
};
const de_AssumeRoleResponse = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = de_Credentials(output[_C], context);
    }
    if (output[_ARU] != null) {
        contents[_ARU] = de_AssumedRoleUser(output[_ARU], context);
    }
    if (output[_PPS] != null) {
        contents[_PPS] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .strictParseInt32 */ .xW)(output[_PPS]);
    }
    if (output[_SI] != null) {
        contents[_SI] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_SI]);
    }
    return contents;
};
const de_AssumeRoleWithSAMLResponse = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = de_Credentials(output[_C], context);
    }
    if (output[_ARU] != null) {
        contents[_ARU] = de_AssumedRoleUser(output[_ARU], context);
    }
    if (output[_PPS] != null) {
        contents[_PPS] = __strictParseInt32(output[_PPS]);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    if (output[_ST] != null) {
        contents[_ST] = __expectString(output[_ST]);
    }
    if (output[_I] != null) {
        contents[_I] = __expectString(output[_I]);
    }
    if (output[_Au] != null) {
        contents[_Au] = __expectString(output[_Au]);
    }
    if (output[_NQ] != null) {
        contents[_NQ] = __expectString(output[_NQ]);
    }
    if (output[_SI] != null) {
        contents[_SI] = __expectString(output[_SI]);
    }
    return contents;
};
const de_AssumeRoleWithWebIdentityResponse = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = de_Credentials(output[_C], context);
    }
    if (output[_SFWIT] != null) {
        contents[_SFWIT] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_SFWIT]);
    }
    if (output[_ARU] != null) {
        contents[_ARU] = de_AssumedRoleUser(output[_ARU], context);
    }
    if (output[_PPS] != null) {
        contents[_PPS] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .strictParseInt32 */ .xW)(output[_PPS]);
    }
    if (output[_Pr] != null) {
        contents[_Pr] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_Pr]);
    }
    if (output[_Au] != null) {
        contents[_Au] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_Au]);
    }
    if (output[_SI] != null) {
        contents[_SI] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_SI]);
    }
    return contents;
};
const de_Credentials = (output, context) => {
    const contents = {};
    if (output[_AKI] != null) {
        contents[_AKI] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_AKI]);
    }
    if (output[_SAK] != null) {
        contents[_SAK] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_SAK]);
    }
    if (output[_STe] != null) {
        contents[_STe] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_STe]);
    }
    if (output[_E] != null) {
        contents[_E] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectNonNull */ .Y0)((0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .parseRfc3339DateTimeWithOffset */ .t_)(output[_E]));
    }
    return contents;
};
const de_DecodeAuthorizationMessageResponse = (output, context) => {
    const contents = {};
    if (output[_DM] != null) {
        contents[_DM] = __expectString(output[_DM]);
    }
    return contents;
};
const de_ExpiredTokenException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_m]);
    }
    return contents;
};
const de_FederatedUser = (output, context) => {
    const contents = {};
    if (output[_FUI] != null) {
        contents[_FUI] = __expectString(output[_FUI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    return contents;
};
const de_GetAccessKeyInfoResponse = (output, context) => {
    const contents = {};
    if (output[_Ac] != null) {
        contents[_Ac] = __expectString(output[_Ac]);
    }
    return contents;
};
const de_GetCallerIdentityResponse = (output, context) => {
    const contents = {};
    if (output[_UI] != null) {
        contents[_UI] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_UI]);
    }
    if (output[_Ac] != null) {
        contents[_Ac] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_Ac]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_Ar]);
    }
    return contents;
};
const de_GetFederationTokenResponse = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = de_Credentials(output[_C], context);
    }
    if (output[_FU] != null) {
        contents[_FU] = de_FederatedUser(output[_FU], context);
    }
    if (output[_PPS] != null) {
        contents[_PPS] = __strictParseInt32(output[_PPS]);
    }
    return contents;
};
const de_GetSessionTokenResponse = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = de_Credentials(output[_C], context);
    }
    return contents;
};
const de_IDPCommunicationErrorException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_m]);
    }
    return contents;
};
const de_IDPRejectedClaimException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_m]);
    }
    return contents;
};
const de_InvalidAuthorizationMessageException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_m]);
    }
    return contents;
};
const de_InvalidIdentityTokenException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_m]);
    }
    return contents;
};
const de_MalformedPolicyDocumentException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_m]);
    }
    return contents;
};
const de_PackedPolicyTooLargeException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_m]);
    }
    return contents;
};
const de_RegionDisabledException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .expectString */ .lK)(output[_m]);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .withBaseException */ .jr)(_models_STSServiceException__WEBPACK_IMPORTED_MODULE_4__/* .STSServiceException */ .L);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new _smithy_protocol_http__WEBPACK_IMPORTED_MODULE_0__/* .HttpRequest */ .Kd(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const _ = "2011-06-15";
const _A = "Action";
const _AKI = "AccessKeyId";
const _AR = "AssumeRole";
const _ARI = "AssumedRoleId";
const _ARU = "AssumedRoleUser";
const _ARWSAML = "AssumeRoleWithSAML";
const _ARWWI = "AssumeRoleWithWebIdentity";
const _Ac = "Account";
const _Ar = "Arn";
const _Au = "Audience";
const _C = "Credentials";
const _CA = "ContextAssertion";
const _DAM = "DecodeAuthorizationMessage";
const _DM = "DecodedMessage";
const _DS = "DurationSeconds";
const _E = "Expiration";
const _EI = "ExternalId";
const _EM = "EncodedMessage";
const _FU = "FederatedUser";
const _FUI = "FederatedUserId";
const _GAKI = "GetAccessKeyInfo";
const _GCI = "GetCallerIdentity";
const _GFT = "GetFederationToken";
const _GST = "GetSessionToken";
const _I = "Issuer";
const _K = "Key";
const _N = "Name";
const _NQ = "NameQualifier";
const _P = "Policy";
const _PA = "PolicyArns";
const _PAr = "PrincipalArn";
const _PAro = "ProviderArn";
const _PC = "ProvidedContexts";
const _PI = "ProviderId";
const _PPS = "PackedPolicySize";
const _Pr = "Provider";
const _RA = "RoleArn";
const _RSN = "RoleSessionName";
const _S = "Subject";
const _SAK = "SecretAccessKey";
const _SAMLA = "SAMLAssertion";
const _SFWIT = "SubjectFromWebIdentityToken";
const _SI = "SourceIdentity";
const _SN = "SerialNumber";
const _ST = "SubjectType";
const _STe = "SessionToken";
const _T = "Tags";
const _TC = "TokenCode";
const _TTK = "TransitiveTagKeys";
const _UI = "UserId";
const _V = "Version";
const _Va = "Value";
const _WIT = "WebIdentityToken";
const _a = "arn";
const _m = "message";
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .extendedEncodeURIComponent */ .$6)(key) + "=" + (0,_smithy_smithy_client__WEBPACK_IMPORTED_MODULE_1__/* .extendedEncodeURIComponent */ .$6)(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};


/***/ }),

/***/ 1496:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  rD: () => (/* reexport */ getEndpointPlugin),
  Co: () => (/* reexport */ resolveEndpointConfig)
});

// UNUSED EXPORTS: endpointMiddleware, endpointMiddlewareOptions, getEndpointFromInstructions, resolveParams, toEndpointV1

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
const resolveParamsForS3 = async (endpointParams) => {
    const bucket = endpointParams?.Bucket || "";
    if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if (isArnBucketName(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
            throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
    }
    else if (!isDnsCompatibleBucketName(bucket) ||
        (bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:")) ||
        bucket.toLowerCase() !== bucket ||
        bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
    }
    return endpointParams;
};
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
const DOT_PATTERN = /\./;
const S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
const isArnBucketName = (bucketName) => {
    const [arn, partition, service, , , bucket] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = Boolean(isArn && partition && service && bucket);
    if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return isValidArn;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
    const configProvider = async () => {
        const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
            return configValue();
        }
        return configValue;
    };
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
        return async () => {
            const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
            const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
            return configValue;
        };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
            const endpoint = await configProvider();
            if (endpoint && typeof endpoint === "object") {
                if ("url" in endpoint) {
                    return endpoint.url.href;
                }
                if ("hostname" in endpoint) {
                    const { protocol, hostname, port, path } = endpoint;
                    return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
                }
            }
            return endpoint;
        };
    }
    return configProvider;
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-config-provider/dist-es/index.js + 11 modules
var dist_es = __webpack_require__(3794);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js + 13 modules
var shared_ini_file_loader_dist_es = __webpack_require__(4826);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointUrlConfig.js

const ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
const CONFIG_ENDPOINT_URL = "endpoint_url";
const getEndpointUrlConfig = (serviceId) => ({
    environmentVariableSelector: (env) => {
        const serviceSuffixParts = serviceId.split(" ").map((w) => w.toUpperCase());
        const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
        if (serviceEndpointUrl)
            return serviceEndpointUrl;
        const endpointUrl = env[ENV_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    configFileSelector: (profile, config) => {
        if (config && profile.services) {
            const servicesSection = config[["services", profile.services].join(shared_ini_file_loader_dist_es/* CONFIG_PREFIX_SEPARATOR */.QD)];
            if (servicesSection) {
                const servicePrefixParts = serviceId.split(" ").map((w) => w.toLowerCase());
                const endpointUrl = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(shared_ini_file_loader_dist_es/* CONFIG_PREFIX_SEPARATOR */.QD)];
                if (endpointUrl)
                    return endpointUrl;
            }
        }
        const endpointUrl = profile[CONFIG_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    default: undefined,
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.js


const getEndpointFromConfig = async (serviceId) => (0,dist_es/* loadConfig */.Z)(getEndpointUrlConfig(serviceId))();

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/url-parser/dist-es/index.js + 1 modules
var url_parser_dist_es = __webpack_require__(1842);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js

const toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
        if ("url" in endpoint) {
            return (0,url_parser_dist_es/* parseUrl */.D)(endpoint.url);
        }
        return endpoint;
    }
    return (0,url_parser_dist_es/* parseUrl */.D)(endpoint);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js




const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.endpoint) {
        const endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId || "");
        if (endpointFromConfig) {
            clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
        }
    }
    const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
};
const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
            case "staticContextParams":
                endpointParams[name] = instruction.value;
                break;
            case "contextParams":
                endpointParams[name] = commandInput[instruction.name];
                break;
            case "clientContextParams":
            case "builtInParams":
                endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
                break;
            default:
                throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
    }
    if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await resolveParamsForS3(endpointParams);
    }
    return endpointParams;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js



// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-middleware/dist-es/index.js + 2 modules
var util_middleware_dist_es = __webpack_require__(5162);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js


const endpointMiddleware = ({ config, instructions, }) => {
    return (next, context) => async (args) => {
        const endpoint = await getEndpointFromInstructions(args.input, {
            getEndpointParameterInstructions() {
                return instructions;
            },
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
            context["signing_region"] = authScheme.signingRegion;
            context["signing_service"] = authScheme.signingName;
            const smithyContext = (0,util_middleware_dist_es/* getSmithyContext */.u)(context);
            const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
            if (httpAuthOption) {
                httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
                    signing_region: authScheme.signingRegion,
                    signingRegion: authScheme.signingRegion,
                    signing_service: authScheme.signingName,
                    signingName: authScheme.signingName,
                    signingRegionSet: authScheme.signingRegionSet,
                }, authScheme.properties);
            }
        }
        return next({
            ...args,
        });
    };
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-serde/dist-es/index.js + 3 modules
var middleware_serde_dist_es = __webpack_require__(6391);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js


const endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: middleware_serde_dist_es/* serializerMiddlewareOption */.Ou.name,
};
const getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(endpointMiddleware({
            config,
            instructions,
        }), endpointMiddlewareOptions);
    },
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js


const resolveEndpointConfig = (input) => {
    const tls = input.tls ?? true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await (0,util_middleware_dist_es/* normalizeProvider */.t)(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    return {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: (0,util_middleware_dist_es/* normalizeProvider */.t)(input.useDualstackEndpoint ?? false),
        useFipsEndpoint: (0,util_middleware_dist_es/* normalizeProvider */.t)(input.useFipsEndpoint ?? false),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/index.js







/***/ }),

/***/ 6391:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  TM: () => (/* reexport */ getSerdePlugin),
  Ou: () => (/* reexport */ serializerMiddlewareOption)
});

// UNUSED EXPORTS: deserializerMiddleware, deserializerMiddlewareOption, serializerMiddleware

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
const deserializerMiddleware = (options, deserializer) => (next) => async (args) => {
    const { response } = await next(args);
    try {
        const parsed = await deserializer(response, options);
        return {
            response,
            output: parsed,
        };
    }
    catch (error) {
        Object.defineProperty(error, "$response", {
            value: response,
        });
        if (!("$metadata" in error)) {
            const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
            error.message += "\n  " + hint;
            if (typeof error.$responseBodyText !== "undefined") {
                if (error.$response) {
                    error.$response.body = error.$responseBodyText;
                }
            }
        }
        throw error;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    const endpoint = context.endpointV2?.url && options.urlParser
        ? async () => options.urlParser(context.endpointV2.url)
        : options.endpoint;
    if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
        ...args,
        request,
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js


const deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true,
};
const serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true,
};
function getSerdePlugin(config, serializer, deserializer) {
    return {
        applyToStack: (commandStack) => {
            commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
            commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
        },
    };
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-serde/dist-es/index.js





/***/ }),

/***/ 3794:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* reexport */ loadConfig)
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/property-provider/dist-es/fromStatic.js
const fromStatic = (staticValue) => () => Promise.resolve(staticValue);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/property-provider/dist-es/memoize.js
const memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-config-provider/dist-es/fromEnv.js

const fromEnv = (envVarSelector) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js + 13 modules
var dist_es = __webpack_require__(4826);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js


const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = (0,dist_es/* getProfileName */.Bz)(init);
    const { configFile, credentialsFile } = await (0,dist_es/* loadSharedConfigFiles */.p6)(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message ||
            `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-config-provider/dist-es/fromStatic.js

const isFunction = (func) => typeof func === "function";
const fromStatic_fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : fromStatic(defaultValue);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-config-provider/dist-es/configLoader.js




const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize(chain(fromEnv(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic_fromStatic(defaultValue)));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-config-provider/dist-es/index.js



/***/ }),

/***/ 7286:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  $c: () => (/* reexport */ NodeHttpHandler),
  kv: () => (/* reexport */ streamCollector)
});

// UNUSED EXPORTS: DEFAULT_REQUEST_TIMEOUT, NodeHttp2Handler

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/protocol-http/dist-es/index.js + 5 modules
var dist_es = __webpack_require__(1462);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/querystring-builder/dist-es/index.js

function dist_es_buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = escapeUri(key);
        if (Array.isArray(value)) {
            for (let i = 0, iLen = value.length; i < iLen; i++) {
                parts.push(`${key}=${escapeUri(value[i])}`);
            }
        }
        else {
            let qsEntry = key;
            if (value || typeof value === "string") {
                qsEntry += `=${escapeUri(value)}`;
            }
            parts.push(qsEntry);
        }
    }
    return parts.join("&");
}

// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(8611);
// EXTERNAL MODULE: external "https"
var external_https_ = __webpack_require__(5692);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/constants.js
const NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/get-transformed-headers.js
const get_transformed_headers_getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
};


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/set-connection-timeout.js
const setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
        return;
    }
    const timeoutId = setTimeout(() => {
        request.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
            name: "TimeoutError",
        }));
    }, timeoutInMs);
    request.on("socket", (socket) => {
        if (socket.connecting) {
            socket.on("connect", () => {
                clearTimeout(timeoutId);
            });
        }
        else {
            clearTimeout(timeoutId);
        }
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/set-socket-keep-alive.js
const setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }) => {
    if (keepAlive !== true) {
        return;
    }
    request.on("socket", (socket) => {
        socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/set-socket-timeout.js
const setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    request.setTimeout(timeoutInMs, () => {
        request.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
    });
};

// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(2203);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/write-request-body.js

const MIN_WAIT_TIME = 1000;
async function write_request_body_writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", () => {
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            }),
        ]);
    }
    if (!hasError) {
        writeBody(httpRequest, request.body);
    }
}
function writeBody(httpRequest, body) {
    if (body instanceof external_stream_.Readable) {
        body.pipe(httpRequest);
        return;
    }
    if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
            httpRequest.end(body);
            return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" &&
            uint8.buffer &&
            typeof uint8.byteOffset === "number" &&
            typeof uint8.byteLength === "number") {
            httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
            return;
        }
        httpRequest.end(Buffer.from(body));
        return;
    }
    httpRequest.end();
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js










const DEFAULT_REQUEST_TIMEOUT = 0;
class NodeHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
            return socketWarningTimestamp;
        }
        const interval = 15000;
        if (Date.now() - interval < socketWarningTimestamp) {
            return socketWarningTimestamp;
        }
        if (sockets && requests) {
            for (const origin in sockets) {
                const socketsInUse = sockets[origin]?.length ?? 0;
                const requestsEnqueued = requests[origin]?.length ?? 0;
                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
                    console.warn("@smithy/node-http-handler:WARN", `socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.`, "See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html", "or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.");
                    return Date.now();
                }
            }
        }
        return socketWarningTimestamp;
    }
    constructor(options) {
        this.socketWarningTimestamp = 0;
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout ?? socketTimeout,
            httpAgent: (() => {
                if (httpAgent instanceof external_http_.Agent || typeof httpAgent?.destroy === "function") {
                    return httpAgent;
                }
                return new external_http_.Agent({ keepAlive, maxSockets, ...httpAgent });
            })(),
            httpsAgent: (() => {
                if (httpsAgent instanceof external_https_.Agent || typeof httpsAgent?.destroy === "function") {
                    return httpsAgent;
                }
                return new external_https_.Agent({ keepAlive, maxSockets, ...httpsAgent });
            })(),
        };
    }
    destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        let socketCheckTimeoutId;
        return new Promise((_resolve, _reject) => {
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                clearTimeout(socketCheckTimeoutId);
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
            socketCheckTimeoutId = setTimeout(() => {
                this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp);
            }, this.config.socketAcquisitionWarningTimeout ??
                (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000));
            const queryString = dist_es_buildQueryString(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent,
                auth,
            };
            const requestFunc = isSSL ? external_https_.request : external_http_.request;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new dist_es/* HttpResponse */.cS({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: get_transformed_headers_getTransformedHeaders(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            setConnectionTimeout(req, reject, this.config.connectionTimeout);
            setSocketTimeout(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                setSocketKeepAlive(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                });
            }
            writeRequestBodyPromise = write_request_body_writeRequestBody(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

// EXTERNAL MODULE: external "http2"
var external_http2_ = __webpack_require__(5675);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
class node_http2_connection_pool_NodeHttp2ConnectionPool {
    constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions ?? [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-manager.js


class node_http2_connection_manager_NodeHttp2ConnectionManager {
    constructor(config) {
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/node-http2-handler.js






class NodeHttp2Handler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal?.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: this.config?.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = buildQueryString(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [constants.HTTP2_HEADER_PATH]: path,
                [constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: getTransformedHeaders(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js

class Collector extends external_stream_.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js

const streamCollector = (stream) => {
    if (isReadableStreamInstance(stream)) {
        return collectReadableStream(stream);
    }
    return new Promise((resolve, reject) => {
        const collector = new Collector();
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
            resolve(bytes);
        });
    });
};
const isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
async function collectReadableStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/index.js





/***/ }),

/***/ 1462:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Kd: () => (/* reexport */ HttpRequest),
  cS: () => (/* reexport */ HttpResponse),
  eS: () => (/* reexport */ getHttpHandlerExtensionConfiguration),
  jt: () => (/* reexport */ resolveHttpHandlerRuntimeConfig)
});

// UNUSED EXPORTS: Field, Fields, isValidHostname

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
const getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
    let httpHandler = runtimeConfig.httpHandler;
    return {
        setHttpHandler(handler) {
            httpHandler = handler;
        },
        httpHandler() {
            return httpHandler;
        },
        updateHttpClientConfig(key, value) {
            httpHandler.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
            return httpHandler.httpHandlerConfigs();
        },
    };
};
const resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
    return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/protocol-http/dist-es/extensions/index.js


// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/index.js + 11 modules
var dist_es = __webpack_require__(2898);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/protocol-http/dist-es/httpResponse.js
class HttpResponse {
    constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/protocol-http/dist-es/index.js










/***/ }),

/***/ 4826:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  QD: () => (/* reexport */ loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR),
  Bz: () => (/* reexport */ getProfileName),
  p6: () => (/* reexport */ loadSharedConfigFiles_loadSharedConfigFiles)
});

// UNUSED EXPORTS: DEFAULT_PROFILE, ENV_PROFILE, getHomeDir, getSSOTokenFilepath, getSSOTokenFromFile, loadSsoSessionData, parseKnownFiles

// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${external_path_.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0,external_os_.homedir)();
    return homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = createHash("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile } = external_fs_.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/index.js + 11 modules
var dist_es = __webpack_require__(2898);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(dist_es/* IniSectionType */.Ip).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === dist_es/* IniSectionType */.Ip.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath_getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(dist_es/* IniSectionType */.Ip).includes(prefix)) {
                    currentSection = [prefix, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: slurpFile_readFile } = external_fs_.promises;
const filePromisesHash = {};
const slurpFile_slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = slurpFile_readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const swallowError = () => ({});
const loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles_loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath_getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile_slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile_slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js










/***/ }),

/***/ 3810:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Kj: () => (/* reexport */ Client),
  uB: () => (/* reexport */ Command),
  N4: () => (/* reexport */ NoOpLogger),
  $H: () => (/* reexport */ SENSITIVE_STRING),
  TJ: () => (/* reexport */ ServiceException),
  Mw: () => (/* reexport */ decorateServiceException),
  I9: () => (/* reexport */ emitWarningIfUnsupportedVersion),
  Y0: () => (/* reexport */ expectNonNull),
  lK: () => (/* reexport */ expectString),
  $6: () => (/* reexport */ extendedEncodeURIComponent),
  xA: () => (/* reexport */ getDefaultExtensionConfiguration),
  lT: () => (/* reexport */ loadConfigsForDefaultMode),
  t_: () => (/* reexport */ parseRfc3339DateTimeWithOffset),
  uv: () => (/* reexport */ resolveDefaultRuntimeConfig),
  xW: () => (/* reexport */ strictParseInt32),
  jr: () => (/* reexport */ withBaseException)
});

// UNUSED EXPORTS: LazyJsonString, StringWrapper, _json, collectBody, convertMap, createAggregatedClient, dateToUtcString, expectBoolean, expectByte, expectFloat32, expectInt, expectInt32, expectLong, expectNumber, expectObject, expectShort, expectUnion, getArrayIfSingleItem, getDefaultClientConfiguration, getValueFromTextNode, handleFloat, limitedParseDouble, limitedParseFloat, limitedParseFloat32, logger, map, parseBoolean, parseEpochTimestamp, parseRfc3339DateTime, parseRfc7231DateTime, resolvedPath, serializeFloat, splitEvery, strictParseByte, strictParseDouble, strictParseFloat, strictParseFloat32, strictParseInt, strictParseLong, strictParseShort, take, throwDefaultError

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
class NoOpLogger {
    trace() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
const getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo(constructStack()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo(constructStack());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                const step = mw.step ??
                    mw.relation +
                        " " +
                        mw.toMiddleware;
                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-stack/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/client.js

class Client {
    constructor(config) {
        this.middlewareStack = constructStack();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-base64/dist-es/index.js + 2 modules
var dist_es = __webpack_require__(6397);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-utf8/dist-es/index.js + 3 modules
var util_utf8_dist_es = __webpack_require__(4100);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-stream/dist-es/blob/transforms.js



function transforms_transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return toBase64(payload);
    }
    return toUtf8(payload);
}
function transforms_transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js

class Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter extends (/* unused pure expression or super */ null && (Uint8Array)) {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return transformFromString(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
    }
}

// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(2203);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.js

const getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/node-http-handler/dist-es/index.js + 14 modules
var node_http_handler_dist_es = __webpack_require__(7286);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-buffer-from/dist-es/index.js + 1 modules
var util_buffer_from_dist_es = __webpack_require__(2654);
// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(9023);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/protocol-http/dist-es/index.js + 5 modules
var protocol_http_dist_es = __webpack_require__(1462);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js



const keepAliveSupport = {
    supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
};
class FetchHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
        if (typeof options === "function") {
            this.configProvider = options().then((opts) => opts || {});
        }
        else {
            this.config = options ?? {};
            this.configProvider = Promise.resolve(this.config);
        }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        const requestTimeoutInMs = this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = buildQueryString(request.query || {});
        if (queryString) {
            path += `?${queryString}`;
        }
        if (request.fragment) {
            path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? undefined : request.body;
        const requestOptions = {
            body,
            headers: new Headers(request.headers),
            method: method,
        };
        if (body) {
            requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
            requestOptions.signal = abortSignal;
        }
        if (keepAliveSupport.supported) {
            requestOptions.keepalive = keepAlive;
        }
        const fetchRequest = new Request(url, requestOptions);
        const raceOfPromises = [
            fetch(fetchRequest).then((response) => {
                const fetchHeaders = response.headers;
                const transformedHeaders = {};
                for (const pair of fetchHeaders.entries()) {
                    transformedHeaders[pair[0]] = pair[1];
                }
                const hasReadableStream = response.body != undefined;
                if (!hasReadableStream) {
                    return response.blob().then((body) => ({
                        response: new HttpResponse({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body,
                        }),
                    }));
                }
                return {
                    response: new HttpResponse({
                        headers: transformedHeaders,
                        reason: response.statusText,
                        statusCode: response.status,
                        body: response.body,
                    }),
                };
            }),
            requestTimeout(requestTimeoutInMs),
        ];
        if (abortSignal) {
            raceOfPromises.push(new Promise((resolve, reject) => {
                abortSignal.onabort = () => {
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }));
        }
        return Promise.race(raceOfPromises);
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            config[key] = value;
            return config;
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js

const stream_collector_streamCollector = (stream) => {
    if (typeof Blob === "function" && stream instanceof Blob) {
        return collectBlob(stream);
    }
    return collectStream(stream);
};
async function collectBlob(blob) {
    const base64 = await readToBase64(blob);
    const arrayBuffer = fromBase64(base64);
    return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}
function readToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (reader.readyState !== 2) {
                return reject(new Error("Reader aborted too early"));
            }
            const result = (reader.result ?? "");
            const commaIndex = result.indexOf(",");
            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
            resolve(result.substring(dataOffset));
        };
        reader.onabort = () => reject(new Error("Read aborted"));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
    });
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/fetch-http-handler/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-hex-encoding/dist-es/index.js
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function dist_es_toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js




const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    if (!isBlobInstance(stream) && !isReadableStreamInstance(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
            throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" +
                "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
    };
    return Object.assign(stream, {
        transformToByteArray: transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === "base64") {
                return toBase64(buf);
            }
            else if (encoding === "hex") {
                return toHex(buf);
            }
            else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
                return toUtf8(buf);
            }
            else if (typeof TextDecoder === "function") {
                return new TextDecoder(encoding).decode(buf);
            }
            else {
                throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            transformed = true;
            if (isBlobInstance(stream)) {
                return blobToWebStream(stream);
            }
            else if (isReadableStreamInstance(stream)) {
                return stream;
            }
            else {
                throw new Error(`Cannot transform payload to web stream, got ${stream}`);
            }
        },
    });
};
const isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
const isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js





const sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdk_stream_mixin_sdkStreamMixin = (stream) => {
    if (!(stream instanceof Readable)) {
        try {
            return sdkStreamMixinReadableStream(stream);
        }
        catch (e) {
            const name = stream?.__proto__?.constructor?.name || stream;
            throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return Readable.toWeb(stream);
        },
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-stream/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js

const collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/index.js + 11 modules
var types_dist_es = __webpack_require__(2898);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/command.js


class Command {
    constructor() {
        this.middlewareStack = constructStack();
    }
    static classBuilder() {
        return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [types_dist_es/* SMITHY_CONTEXT_KEY */.Vf]: {
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
class ClassBuilder {
    constructor() {
        this._init = () => { };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
    }
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends Command {
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(...[input]) {
                super();
                this.serialize = closure._serializer;
                this.deserialize = closure._deserializer;
                this.input = input ?? {};
                closure._init(this);
            }
            resolveMiddleware(stack, configuration, options) {
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/constants.js
const SENSITIVE_STRING = "***SensitiveInformation***";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/parse-utils.js
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
const expectInt = (/* unused pure expression or super */ null && (expectLong));
const expectInt32 = (value) => expectSizedInt(value, 32);
const expectShort = (value) => expectSizedInt(value, 16);
const expectByte = (value) => expectSizedInt(value, 8);
const expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = expectObject(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
const parse_utils_strictParseDouble = (value) => {
    if (typeof value == "string") {
        return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
};
const strictParseFloat = (/* unused pure expression or super */ null && (parse_utils_strictParseDouble));
const strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
};
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectNumber(value);
};
const handleFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectFloat32(value);
};
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value) => {
    if (typeof value === "string") {
        return expectLong(parseNumber(value));
    }
    return expectLong(value);
};
const strictParseInt = (/* unused pure expression or super */ null && (strictParseLong));
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
};
const parse_utils_strictParseShort = (value) => {
    if (typeof value === "string") {
        return expectShort(parseNumber(value));
    }
    return expectShort(value);
};
const strictParseByte = (value) => {
    if (typeof value === "string") {
        return expectByte(parseNumber(value));
    }
    return expectByte(value);
};
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
const logger = {
    warn: console.warn,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/date-utils.js

const DAYS = (/* unused pure expression or super */ null && (["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]));
const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
const RFC3339 = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/)));
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
const RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
const parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = parse_utils_strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
const IMF_FIXDATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const RFC_850_DATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const ASC_TIME = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/)));
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = (/* unused pure expression or super */ null && (50 * 365 * 24 * 60 * 60 * 1000));
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/exceptions.js
class ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
const decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/default-error-handler.js

const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw decorateServiceException(response, parsedBody);
};
const withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
const loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
        case "standard":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "in-region":
            return {
                retryMode: "standard",
                connectionTimeout: 1100,
            };
        case "cross-region":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "mobile":
            return {
                retryMode: "standard",
                connectionTimeout: 30000,
            };
        default:
            return {};
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
let warningEmitted = false;
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
        warningEmitted = true;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js


const getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in types_dist_es/* AlgorithmId */.dB) {
        const algorithmId = types_dist_es/* AlgorithmId */.dB[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
const getRetryConfiguration = (runtimeConfig) => {
    let _retryStrategy = runtimeConfig.retryStrategy;
    return {
        setRetryStrategy(retryStrategy) {
            _retryStrategy = retryStrategy;
        },
        retryStrategy() {
            return _retryStrategy;
        },
    };
};
const resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js


const getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
        ...getRetryConfiguration(runtimeConfig),
    };
};
const getDefaultClientConfiguration = (/* unused pure expression or super */ null && (getDefaultExtensionConfiguration));
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
        ...resolveRetryRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/lazy-json.js
const StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(StringWrapper, String);
class LazyJsonString extends (/* unused pure expression or super */ null && (StringWrapper)) {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
        }
        return new LazyJsonString(JSON.stringify(object));
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/index.js
























/***/ }),

/***/ 2898:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  dB: () => (/* reexport */ AlgorithmId),
  Ip: () => (/* reexport */ IniSectionType),
  Vf: () => (/* reexport */ SMITHY_CONTEXT_KEY)
});

// UNUSED EXPORTS: EndpointURLScheme, FieldPosition, HttpApiKeyAuthLocation, HttpAuthLocation, RequestHandlerProtocol, getDefaultClientConfiguration, resolveDefaultRuntimeConfig

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/middleware.js
const SMITHY_CONTEXT_KEY = "__smithy_context";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/index.js






































/***/ }),

/***/ 1842:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  D: () => (/* binding */ parseUrl)
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
        for (const pair of querystring.split("&")) {
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
                value = decodeURIComponent(value);
            }
            if (!(key in query)) {
                query[key] = value;
            }
            else if (Array.isArray(query[key])) {
                query[key].push(value);
            }
            else {
                query[key] = [query[key], value];
            }
        }
    }
    return query;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/url-parser/dist-es/index.js

const parseUrl = (url) => {
    if (typeof url === "string") {
        return parseUrl(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
        query = parseQueryString(search);
    }
    return {
        hostname,
        port: port ? parseInt(port) : undefined,
        protocol,
        path: pathname,
        query,
    };
};


/***/ }),

/***/ 6397:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  E: () => (/* reexport */ fromBase64),
  n: () => (/* reexport */ toBase64)
});

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-buffer-from/dist-es/index.js + 1 modules
var dist_es = __webpack_require__(2654);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-base64/dist-es/fromBase64.js

const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = (0,dist_es/* fromString */.s)(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-utf8/dist-es/index.js + 3 modules
var util_utf8_dist_es = __webpack_require__(4100);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-base64/dist-es/toBase64.js


const toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
        input = (0,util_utf8_dist_es/* fromUtf8 */.ar)(_input);
    }
    else {
        input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return (0,dist_es/* fromArrayBuffer */.Q)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-base64/dist-es/index.js




/***/ }),

/***/ 2654:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Q: () => (/* binding */ fromArrayBuffer),
  s: () => (/* binding */ fromString)
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/is-array-buffer/dist-es/index.js
const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// EXTERNAL MODULE: external "buffer"
var external_buffer_ = __webpack_require__(181);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-buffer-from/dist-es/index.js


const fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return external_buffer_.Buffer.from(input, offset, length);
};
const fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? external_buffer_.Buffer.from(input, encoding) : external_buffer_.Buffer.from(input);
};


/***/ }),

/***/ 5162:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  u: () => (/* reexport */ getSmithyContext),
  t: () => (/* reexport */ normalizeProvider)
});

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/types/dist-es/index.js + 11 modules
var dist_es = __webpack_require__(2898);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js

const getSmithyContext = (context) => context[dist_es/* SMITHY_CONTEXT_KEY */.Vf] || (context[dist_es/* SMITHY_CONTEXT_KEY */.Vf] = {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-middleware/dist-es/index.js




/***/ }),

/***/ 4100:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ar: () => (/* reexport */ fromUtf8_fromUtf8),
  Pq: () => (/* reexport */ toUtf8)
});

// UNUSED EXPORTS: toUint8Array

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-buffer-from/dist-es/index.js + 1 modules
var dist_es = __webpack_require__(2654);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js

const fromUtf8_fromUtf8 = (input) => {
    const buf = (0,dist_es/* fromString */.s)(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js

const toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-utf8/dist-es/toUtf8.js

const toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return (0,dist_es/* fromArrayBuffer */.Q)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/util-utf8/dist-es/index.js





/***/ }),

/***/ 5685:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(1635);
tslib_1.__exportStar(__webpack_require__(3477), exports);
tslib_1.__exportStar(__webpack_require__(7864), exports);
tslib_1.__exportStar(__webpack_require__(5051), exports);


/***/ }),

/***/ 3477:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/submodules/client/index.ts
var client_exports = {};
__export(client_exports, {
  emitWarningIfUnsupportedVersion: () => emitWarningIfUnsupportedVersion
});
module.exports = __toCommonJS(client_exports);

// src/submodules/client/emitWarningIfUnsupportedVersion.ts
var warningEmitted = false;
var emitWarningIfUnsupportedVersion = /* @__PURE__ */ __name((version) => {
  if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
    warningEmitted = true;
  }
}, "emitWarningIfUnsupportedVersion");
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 7864:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/submodules/httpAuthSchemes/index.ts
var httpAuthSchemes_exports = {};
__export(httpAuthSchemes_exports, {
  AWSSDKSigV4Signer: () => AWSSDKSigV4Signer,
  AwsSdkSigV4Signer: () => AwsSdkSigV4Signer,
  resolveAWSSDKSigV4Config: () => resolveAWSSDKSigV4Config,
  resolveAwsSdkSigV4Config: () => resolveAwsSdkSigV4Config
});
module.exports = __toCommonJS(httpAuthSchemes_exports);

// src/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.ts
var import_protocol_http2 = __webpack_require__(3900);

// src/submodules/httpAuthSchemes/utils/getDateHeader.ts
var import_protocol_http = __webpack_require__(3900);
var getDateHeader = /* @__PURE__ */ __name((response) => {
  var _a, _b;
  return import_protocol_http.HttpResponse.isInstance(response) ? ((_a = response.headers) == null ? void 0 : _a.date) ?? ((_b = response.headers) == null ? void 0 : _b.Date) : void 0;
}, "getDateHeader");

// src/submodules/httpAuthSchemes/utils/getSkewCorrectedDate.ts
var getSkewCorrectedDate = /* @__PURE__ */ __name((systemClockOffset) => new Date(Date.now() + systemClockOffset), "getSkewCorrectedDate");

// src/submodules/httpAuthSchemes/utils/isClockSkewed.ts
var isClockSkewed = /* @__PURE__ */ __name((clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5, "isClockSkewed");

// src/submodules/httpAuthSchemes/utils/getUpdatedSystemClockOffset.ts
var getUpdatedSystemClockOffset = /* @__PURE__ */ __name((clockTime, currentSystemClockOffset) => {
  const clockTimeInMs = Date.parse(clockTime);
  if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
    return clockTimeInMs - Date.now();
  }
  return currentSystemClockOffset;
}, "getUpdatedSystemClockOffset");

// src/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.ts
var throwSigningPropertyError = /* @__PURE__ */ __name((name, property) => {
  if (!property) {
    throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
  }
  return property;
}, "throwSigningPropertyError");
var validateSigningProperties = /* @__PURE__ */ __name(async (signingProperties) => {
  var _a, _b, _c;
  const context = throwSigningPropertyError(
    "context",
    signingProperties.context
  );
  const config = throwSigningPropertyError("config", signingProperties.config);
  const authScheme = (_c = (_b = (_a = context.endpointV2) == null ? void 0 : _a.properties) == null ? void 0 : _b.authSchemes) == null ? void 0 : _c[0];
  const signerFunction = throwSigningPropertyError(
    "signer",
    config.signer
  );
  const signer = await signerFunction(authScheme);
  const signingRegion = signingProperties == null ? void 0 : signingProperties.signingRegion;
  const signingName = signingProperties == null ? void 0 : signingProperties.signingName;
  return {
    config,
    signer,
    signingRegion,
    signingName
  };
}, "validateSigningProperties");
var _AwsSdkSigV4Signer = class _AwsSdkSigV4Signer {
  async sign(httpRequest, identity, signingProperties) {
    if (!import_protocol_http2.HttpRequest.isInstance(httpRequest)) {
      throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
    }
    const { config, signer, signingRegion, signingName } = await validateSigningProperties(signingProperties);
    const signedRequest = await signer.sign(httpRequest, {
      signingDate: getSkewCorrectedDate(config.systemClockOffset),
      signingRegion,
      signingService: signingName
    });
    return signedRequest;
  }
  errorHandler(signingProperties) {
    return (error) => {
      const serverTime = error.ServerTime ?? getDateHeader(error.$response);
      if (serverTime) {
        const config = throwSigningPropertyError("config", signingProperties.config);
        const initialSystemClockOffset = config.systemClockOffset;
        config.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config.systemClockOffset);
        const clockSkewCorrected = config.systemClockOffset !== initialSystemClockOffset;
        if (clockSkewCorrected && error.$metadata) {
          error.$metadata.clockSkewCorrected = true;
        }
      }
      throw error;
    };
  }
  successHandler(httpResponse, signingProperties) {
    const dateHeader = getDateHeader(httpResponse);
    if (dateHeader) {
      const config = throwSigningPropertyError("config", signingProperties.config);
      config.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config.systemClockOffset);
    }
  }
};
__name(_AwsSdkSigV4Signer, "AwsSdkSigV4Signer");
var AwsSdkSigV4Signer = _AwsSdkSigV4Signer;
var AWSSDKSigV4Signer = AwsSdkSigV4Signer;

// src/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.ts
var import_core = __webpack_require__(2073);
var import_signature_v4 = __webpack_require__(9439);
var resolveAwsSdkSigV4Config = /* @__PURE__ */ __name((config) => {
  let normalizedCreds;
  if (config.credentials) {
    normalizedCreds = (0, import_core.memoizeIdentityProvider)(config.credentials, import_core.isIdentityExpired, import_core.doesIdentityRequireRefresh);
  }
  if (!normalizedCreds) {
    if (config.credentialDefaultProvider) {
      normalizedCreds = (0, import_core.normalizeProvider)(
        config.credentialDefaultProvider(
          Object.assign({}, config, {
            parentClientConfig: config
          })
        )
      );
    } else {
      normalizedCreds = /* @__PURE__ */ __name(async () => {
        throw new Error("`credentials` is missing");
      }, "normalizedCreds");
    }
  }
  const {
    // Default for signingEscapePath
    signingEscapePath = true,
    // Default for systemClockOffset
    systemClockOffset = config.systemClockOffset || 0,
    // No default for sha256 since it is platform dependent
    sha256
  } = config;
  let signer;
  if (config.signer) {
    signer = (0, import_core.normalizeProvider)(config.signer);
  } else if (config.regionInfoProvider) {
    signer = /* @__PURE__ */ __name(() => (0, import_core.normalizeProvider)(config.region)().then(
      async (region) => [
        await config.regionInfoProvider(region, {
          useFipsEndpoint: await config.useFipsEndpoint(),
          useDualstackEndpoint: await config.useDualstackEndpoint()
        }) || {},
        region
      ]
    ).then(([regionInfo, region]) => {
      const { signingRegion, signingService } = regionInfo;
      config.signingRegion = config.signingRegion || signingRegion || region;
      config.signingName = config.signingName || signingService || config.serviceId;
      const params = {
        ...config,
        credentials: normalizedCreds,
        region: config.signingRegion,
        service: config.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = config.signerConstructor || import_signature_v4.SignatureV4;
      return new SignerCtor(params);
    }), "signer");
  } else {
    signer = /* @__PURE__ */ __name(async (authScheme) => {
      authScheme = Object.assign(
        {},
        {
          name: "sigv4",
          signingName: config.signingName || config.defaultSigningName,
          signingRegion: await (0, import_core.normalizeProvider)(config.region)(),
          properties: {}
        },
        authScheme
      );
      const signingRegion = authScheme.signingRegion;
      const signingService = authScheme.signingName;
      config.signingRegion = config.signingRegion || signingRegion;
      config.signingName = config.signingName || signingService || config.serviceId;
      const params = {
        ...config,
        credentials: normalizedCreds,
        region: config.signingRegion,
        service: config.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = config.signerConstructor || import_signature_v4.SignatureV4;
      return new SignerCtor(params);
    }, "signer");
  }
  return {
    ...config,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer
  };
}, "resolveAwsSdkSigV4Config");
var resolveAWSSDKSigV4Config = resolveAwsSdkSigV4Config;
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 5051:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/submodules/protocols/index.ts
var protocols_exports = {};
__export(protocols_exports, {
  _toBool: () => _toBool,
  _toNum: () => _toNum,
  _toStr: () => _toStr,
  awsExpectUnion: () => awsExpectUnion,
  loadRestJsonErrorCode: () => loadRestJsonErrorCode,
  loadRestXmlErrorCode: () => loadRestXmlErrorCode,
  parseJsonBody: () => parseJsonBody,
  parseJsonErrorBody: () => parseJsonErrorBody,
  parseXmlBody: () => parseXmlBody,
  parseXmlErrorBody: () => parseXmlErrorBody
});
module.exports = __toCommonJS(protocols_exports);

// src/submodules/protocols/coercing-serializers.ts
var _toStr = /* @__PURE__ */ __name((val) => {
  if (val == null) {
    return val;
  }
  if (typeof val === "number" || typeof val === "bigint") {
    const warning = new Error(`Received number ${val} where a string was expected.`);
    warning.name = "Warning";
    console.warn(warning);
    return String(val);
  }
  if (typeof val === "boolean") {
    const warning = new Error(`Received boolean ${val} where a string was expected.`);
    warning.name = "Warning";
    console.warn(warning);
    return String(val);
  }
  return val;
}, "_toStr");
var _toBool = /* @__PURE__ */ __name((val) => {
  if (val == null) {
    return val;
  }
  if (typeof val === "number") {
  }
  if (typeof val === "string") {
    const lowercase = val.toLowerCase();
    if (val !== "" && lowercase !== "false" && lowercase !== "true") {
      const warning = new Error(`Received string "${val}" where a boolean was expected.`);
      warning.name = "Warning";
      console.warn(warning);
    }
    return val !== "" && lowercase !== "false";
  }
  return val;
}, "_toBool");
var _toNum = /* @__PURE__ */ __name((val) => {
  if (val == null) {
    return val;
  }
  if (typeof val === "boolean") {
  }
  if (typeof val === "string") {
    const num = Number(val);
    if (num.toString() !== val) {
      const warning = new Error(`Received string "${val}" where a number was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return val;
    }
    return num;
  }
  return val;
}, "_toNum");

// src/submodules/protocols/json/awsExpectUnion.ts
var import_smithy_client = __webpack_require__(7152);
var awsExpectUnion = /* @__PURE__ */ __name((value) => {
  if (value == null) {
    return void 0;
  }
  if (typeof value === "object" && "__type" in value) {
    delete value.__type;
  }
  return (0, import_smithy_client.expectUnion)(value);
}, "awsExpectUnion");

// src/submodules/protocols/common.ts
var import_smithy_client2 = __webpack_require__(7152);
var collectBodyString = /* @__PURE__ */ __name((streamBody, context) => (0, import_smithy_client2.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body)), "collectBodyString");

// src/submodules/protocols/json/parseJsonBody.ts
var parseJsonBody = /* @__PURE__ */ __name((streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
  if (encoded.length) {
    try {
      return JSON.parse(encoded);
    } catch (e) {
      if ((e == null ? void 0 : e.name) === "SyntaxError") {
        Object.defineProperty(e, "$responseBodyText", {
          value: encoded
        });
      }
      throw e;
    }
  }
  return {};
}), "parseJsonBody");
var parseJsonErrorBody = /* @__PURE__ */ __name(async (errorBody, context) => {
  const value = await parseJsonBody(errorBody, context);
  value.message = value.message ?? value.Message;
  return value;
}, "parseJsonErrorBody");
var loadRestJsonErrorCode = /* @__PURE__ */ __name((output, data) => {
  const findKey = /* @__PURE__ */ __name((object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase()), "findKey");
  const sanitizeErrorCode = /* @__PURE__ */ __name((rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  }, "sanitizeErrorCode");
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
}, "loadRestJsonErrorCode");

// src/submodules/protocols/xml/parseXmlBody.ts
var import_smithy_client3 = __webpack_require__(7152);
var import_fast_xml_parser = __webpack_require__(6454);
var parseXmlBody = /* @__PURE__ */ __name((streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val) => val.trim() === "" && val.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    let parsedObj;
    try {
      parsedObj = parser.parse(encoded, true);
    } catch (e) {
      if (e && typeof e === "object") {
        Object.defineProperty(e, "$responseBodyText", {
          value: encoded
        });
      }
      throw e;
    }
    const textNodeName = "#text";
    const key = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return (0, import_smithy_client3.getValueFromTextNode)(parsedObjToReturn);
  }
  return {};
}), "parseXmlBody");
var parseXmlErrorBody = /* @__PURE__ */ __name(async (errorBody, context) => {
  const value = await parseXmlBody(errorBody, context);
  if (value.Error) {
    value.Error.message = value.Error.message ?? value.Error.Message;
  }
  return value;
}, "parseXmlErrorBody");
var loadRestXmlErrorCode = /* @__PURE__ */ __name((output, data) => {
  var _a;
  if (((_a = data == null ? void 0 : data.Error) == null ? void 0 : _a.Code) !== void 0) {
    return data.Error.Code;
  }
  if ((data == null ? void 0 : data.Code) !== void 0) {
    return data.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
}, "loadRestXmlErrorCode");
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 3900:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Field: () => (/* reexport */ Field),
  Fields: () => (/* reexport */ Fields),
  HttpRequest: () => (/* reexport */ HttpRequest),
  HttpResponse: () => (/* reexport */ HttpResponse),
  getHttpHandlerExtensionConfiguration: () => (/* reexport */ getHttpHandlerExtensionConfiguration),
  isValidHostname: () => (/* reexport */ isValidHostname),
  resolveHttpHandlerRuntimeConfig: () => (/* reexport */ resolveHttpHandlerRuntimeConfig)
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
const getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
    let httpHandler = runtimeConfig.httpHandler;
    return {
        setHttpHandler(handler) {
            httpHandler = handler;
        },
        httpHandler() {
            return httpHandler;
        },
        updateHttpClientConfig(key, value) {
            httpHandler.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
            return httpHandler.httpHandlerConfigs();
        },
    };
};
const resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
    return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/protocol-http/dist-es/extensions/index.js


// EXTERNAL MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/index.js + 11 modules
var dist_es = __webpack_require__(4687);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field {
    constructor({ name, kind = dist_es/* FieldPosition */.wb.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/protocol-http/dist-es/Fields.js
class Fields {
    constructor({ fields = [], encoding = "utf-8" }) {
        this.entries = {};
        fields.forEach(this.setField.bind(this));
        this.encoding = encoding;
    }
    setField(field) {
        this.entries[field.name.toLowerCase()] = field;
    }
    getField(name) {
        return this.entries[name.toLowerCase()];
    }
    removeField(name) {
        delete this.entries[name.toLowerCase()];
    }
    getByType(kind) {
        return Object.values(this.entries).filter((field) => field.kind === kind);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/protocol-http/dist-es/httpResponse.js
class HttpResponse {
    constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/protocol-http/dist-es/isValidHostname.js
function isValidHostname(hostname) {
    const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
    return hostPattern.test(hostname);
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/protocol-http/dist-es/index.js










/***/ }),

/***/ 7152:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Client: () => (/* reexport */ Client),
  Command: () => (/* reexport */ Command),
  LazyJsonString: () => (/* reexport */ LazyJsonString),
  NoOpLogger: () => (/* reexport */ NoOpLogger),
  SENSITIVE_STRING: () => (/* reexport */ SENSITIVE_STRING),
  ServiceException: () => (/* reexport */ ServiceException),
  StringWrapper: () => (/* reexport */ StringWrapper),
  _json: () => (/* reexport */ _json),
  collectBody: () => (/* reexport */ collectBody),
  convertMap: () => (/* reexport */ convertMap),
  createAggregatedClient: () => (/* reexport */ createAggregatedClient),
  dateToUtcString: () => (/* reexport */ dateToUtcString),
  decorateServiceException: () => (/* reexport */ decorateServiceException),
  emitWarningIfUnsupportedVersion: () => (/* reexport */ emitWarningIfUnsupportedVersion),
  expectBoolean: () => (/* reexport */ expectBoolean),
  expectByte: () => (/* reexport */ expectByte),
  expectFloat32: () => (/* reexport */ expectFloat32),
  expectInt: () => (/* reexport */ expectInt),
  expectInt32: () => (/* reexport */ expectInt32),
  expectLong: () => (/* reexport */ expectLong),
  expectNonNull: () => (/* reexport */ expectNonNull),
  expectNumber: () => (/* reexport */ expectNumber),
  expectObject: () => (/* reexport */ expectObject),
  expectShort: () => (/* reexport */ expectShort),
  expectString: () => (/* reexport */ expectString),
  expectUnion: () => (/* reexport */ expectUnion),
  extendedEncodeURIComponent: () => (/* reexport */ extendedEncodeURIComponent),
  getArrayIfSingleItem: () => (/* reexport */ getArrayIfSingleItem),
  getDefaultClientConfiguration: () => (/* reexport */ getDefaultClientConfiguration),
  getDefaultExtensionConfiguration: () => (/* reexport */ getDefaultExtensionConfiguration),
  getValueFromTextNode: () => (/* reexport */ getValueFromTextNode),
  handleFloat: () => (/* reexport */ handleFloat),
  limitedParseDouble: () => (/* reexport */ limitedParseDouble),
  limitedParseFloat: () => (/* reexport */ limitedParseFloat),
  limitedParseFloat32: () => (/* reexport */ limitedParseFloat32),
  loadConfigsForDefaultMode: () => (/* reexport */ loadConfigsForDefaultMode),
  logger: () => (/* reexport */ logger),
  map: () => (/* reexport */ map),
  parseBoolean: () => (/* reexport */ parseBoolean),
  parseEpochTimestamp: () => (/* reexport */ parseEpochTimestamp),
  parseRfc3339DateTime: () => (/* reexport */ parseRfc3339DateTime),
  parseRfc3339DateTimeWithOffset: () => (/* reexport */ parseRfc3339DateTimeWithOffset),
  parseRfc7231DateTime: () => (/* reexport */ parseRfc7231DateTime),
  resolveDefaultRuntimeConfig: () => (/* reexport */ resolveDefaultRuntimeConfig),
  resolvedPath: () => (/* reexport */ resolvedPath),
  serializeFloat: () => (/* reexport */ serializeFloat),
  splitEvery: () => (/* reexport */ splitEvery),
  strictParseByte: () => (/* reexport */ strictParseByte),
  strictParseDouble: () => (/* reexport */ strictParseDouble),
  strictParseFloat: () => (/* reexport */ strictParseFloat),
  strictParseFloat32: () => (/* reexport */ strictParseFloat32),
  strictParseInt: () => (/* reexport */ strictParseInt),
  strictParseInt32: () => (/* reexport */ strictParseInt32),
  strictParseLong: () => (/* reexport */ strictParseLong),
  strictParseShort: () => (/* reexport */ strictParseShort),
  take: () => (/* reexport */ take),
  throwDefaultError: () => (/* reexport */ throwDefaultError),
  withBaseException: () => (/* reexport */ withBaseException)
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
class NoOpLogger {
    trace() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
const getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo(constructStack()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo(constructStack());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                const step = mw.step ??
                    mw.relation +
                        " " +
                        mw.toMiddleware;
                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/middleware-stack/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/client.js

class Client {
    constructor(config) {
        this.middlewareStack = constructStack();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/is-array-buffer/dist-es/index.js
const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// EXTERNAL MODULE: external "buffer"
var external_buffer_ = __webpack_require__(181);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-buffer-from/dist-es/index.js


const dist_es_fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return external_buffer_.Buffer.from(input, offset, length);
};
const fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? external_buffer_.Buffer.from(input, encoding) : external_buffer_.Buffer.from(input);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-base64/dist-es/fromBase64.js

const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64_fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = fromString(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js

const fromUtf8_fromUtf8 = (input) => {
    const buf = fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js

const toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-utf8/dist-es/toUtf8.js

const toUtf8_toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return dist_es_fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-utf8/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-base64/dist-es/toBase64.js


const toBase64_toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
        input = fromUtf8_fromUtf8(_input);
    }
    else {
        input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return dist_es_fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-base64/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-stream/dist-es/blob/transforms.js



function transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return toBase64_toBase64(payload);
    }
    return toUtf8_toUtf8(payload);
}
function transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter.mutate(fromBase64_fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8_fromUtf8(str));
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js

class Uint8ArrayBlobAdapter extends Uint8Array {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return transformFromString(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
    }
}

// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(2203);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.js

const getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/protocol-http/dist-es/index.js + 7 modules
var dist_es = __webpack_require__(3900);
// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(8611);
// EXTERNAL MODULE: external "https"
var external_https_ = __webpack_require__(5692);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/node-http-handler/dist-es/write-request-body.js

const MIN_WAIT_TIME = 1000;
async function write_request_body_writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", () => {
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            }),
        ]);
    }
    if (!hasError) {
        writeBody(httpRequest, request.body);
    }
}
function writeBody(httpRequest, body) {
    if (body instanceof Readable) {
        body.pipe(httpRequest);
        return;
    }
    if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
            httpRequest.end(body);
            return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" &&
            uint8.buffer &&
            typeof uint8.byteOffset === "number" &&
            typeof uint8.byteLength === "number") {
            httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
            return;
        }
        httpRequest.end(Buffer.from(body));
        return;
    }
    httpRequest.end();
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js










const DEFAULT_REQUEST_TIMEOUT = 0;
class NodeHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
            return socketWarningTimestamp;
        }
        const interval = 15000;
        if (Date.now() - interval < socketWarningTimestamp) {
            return socketWarningTimestamp;
        }
        if (sockets && requests) {
            for (const origin in sockets) {
                const socketsInUse = sockets[origin]?.length ?? 0;
                const requestsEnqueued = requests[origin]?.length ?? 0;
                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
                    console.warn("@smithy/node-http-handler:WARN", `socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.`, "See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html", "or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.");
                    return Date.now();
                }
            }
        }
        return socketWarningTimestamp;
    }
    constructor(options) {
        this.socketWarningTimestamp = 0;
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout ?? socketTimeout,
            httpAgent: (() => {
                if (httpAgent instanceof hAgent || typeof httpAgent?.destroy === "function") {
                    return httpAgent;
                }
                return new hAgent({ keepAlive, maxSockets, ...httpAgent });
            })(),
            httpsAgent: (() => {
                if (httpsAgent instanceof hsAgent || typeof httpsAgent?.destroy === "function") {
                    return httpsAgent;
                }
                return new hsAgent({ keepAlive, maxSockets, ...httpsAgent });
            })(),
        };
    }
    destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        let socketCheckTimeoutId;
        return new Promise((_resolve, _reject) => {
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                clearTimeout(socketCheckTimeoutId);
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
            socketCheckTimeoutId = setTimeout(() => {
                this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp);
            }, this.config.socketAcquisitionWarningTimeout ??
                (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000));
            const queryString = buildQueryString(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent,
                auth,
            };
            const requestFunc = isSSL ? hsRequest : hRequest;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: getTransformedHeaders(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            setConnectionTimeout(req, reject, this.config.connectionTimeout);
            setSocketTimeout(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                setSocketKeepAlive(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                });
            }
            writeRequestBodyPromise = writeRequestBody(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

// EXTERNAL MODULE: external "http2"
var external_http2_ = __webpack_require__(5675);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
class node_http2_connection_pool_NodeHttp2ConnectionPool {
    constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions ?? [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-manager.js


class node_http2_connection_manager_NodeHttp2ConnectionManager {
    constructor(config) {
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/node-http-handler/dist-es/node-http2-handler.js






class NodeHttp2Handler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal?.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: this.config?.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = buildQueryString(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [constants.HTTP2_HEADER_PATH]: path,
                [constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: getTransformedHeaders(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js

class collector_Collector extends external_stream_.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js

const stream_collector_streamCollector = (stream) => {
    if (isReadableStreamInstance(stream)) {
        return collectReadableStream(stream);
    }
    return new Promise((resolve, reject) => {
        const collector = new Collector();
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
            resolve(bytes);
        });
    });
};
const isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
async function collectReadableStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/node-http-handler/dist-es/index.js




// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(9023);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js



const keepAliveSupport = {
    supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
};
class FetchHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
        if (typeof options === "function") {
            this.configProvider = options().then((opts) => opts || {});
        }
        else {
            this.config = options ?? {};
            this.configProvider = Promise.resolve(this.config);
        }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        const requestTimeoutInMs = this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = buildQueryString(request.query || {});
        if (queryString) {
            path += `?${queryString}`;
        }
        if (request.fragment) {
            path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? undefined : request.body;
        const requestOptions = {
            body,
            headers: new Headers(request.headers),
            method: method,
        };
        if (body) {
            requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
            requestOptions.signal = abortSignal;
        }
        if (keepAliveSupport.supported) {
            requestOptions.keepalive = keepAlive;
        }
        const fetchRequest = new Request(url, requestOptions);
        const raceOfPromises = [
            fetch(fetchRequest).then((response) => {
                const fetchHeaders = response.headers;
                const transformedHeaders = {};
                for (const pair of fetchHeaders.entries()) {
                    transformedHeaders[pair[0]] = pair[1];
                }
                const hasReadableStream = response.body != undefined;
                if (!hasReadableStream) {
                    return response.blob().then((body) => ({
                        response: new HttpResponse({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body,
                        }),
                    }));
                }
                return {
                    response: new HttpResponse({
                        headers: transformedHeaders,
                        reason: response.statusText,
                        statusCode: response.status,
                        body: response.body,
                    }),
                };
            }),
            requestTimeout(requestTimeoutInMs),
        ];
        if (abortSignal) {
            raceOfPromises.push(new Promise((resolve, reject) => {
                abortSignal.onabort = () => {
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }));
        }
        return Promise.race(raceOfPromises);
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            config[key] = value;
            return config;
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js

const dist_es_stream_collector_streamCollector = (stream) => {
    if (typeof Blob === "function" && stream instanceof Blob) {
        return collectBlob(stream);
    }
    return collectStream(stream);
};
async function collectBlob(blob) {
    const base64 = await readToBase64(blob);
    const arrayBuffer = fromBase64(base64);
    return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}
function readToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (reader.readyState !== 2) {
                return reject(new Error("Reader aborted too early"));
            }
            const result = (reader.result ?? "");
            const commaIndex = result.indexOf(",");
            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
            resolve(result.substring(dataOffset));
        };
        reader.onabort = () => reject(new Error("Read aborted"));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
    });
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/fetch-http-handler/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-hex-encoding/dist-es/index.js
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function dist_es_toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js




const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    if (!isBlobInstance(stream) && !sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
            throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" +
                "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
    };
    return Object.assign(stream, {
        transformToByteArray: transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === "base64") {
                return toBase64(buf);
            }
            else if (encoding === "hex") {
                return toHex(buf);
            }
            else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
                return toUtf8(buf);
            }
            else if (typeof TextDecoder === "function") {
                return new TextDecoder(encoding).decode(buf);
            }
            else {
                throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            transformed = true;
            if (isBlobInstance(stream)) {
                return blobToWebStream(stream);
            }
            else if (sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
                return stream;
            }
            else {
                throw new Error(`Cannot transform payload to web stream, got ${stream}`);
            }
        },
    });
};
const isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
const sdk_stream_mixin_browser_isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js





const sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdk_stream_mixin_sdkStreamMixin = (stream) => {
    if (!(stream instanceof Readable)) {
        try {
            return sdkStreamMixinReadableStream(stream);
        }
        catch (e) {
            const name = stream?.__proto__?.constructor?.name || stream;
            throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return Readable.toWeb(stream);
        },
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/util-stream/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js

const collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/index.js + 11 modules
var types_dist_es = __webpack_require__(4687);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/command.js


class Command {
    constructor() {
        this.middlewareStack = constructStack();
    }
    static classBuilder() {
        return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [types_dist_es/* SMITHY_CONTEXT_KEY */.Vf]: {
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
class ClassBuilder {
    constructor() {
        this._init = () => { };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
    }
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends Command {
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(...[input]) {
                super();
                this.serialize = closure._serializer;
                this.deserialize = closure._deserializer;
                this.input = input ?? {};
                closure._init(this);
            }
            resolveMiddleware(stack, configuration, options) {
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/constants.js
const SENSITIVE_STRING = "***SensitiveInformation***";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js
const createAggregatedClient = (commands, Client) => {
    for (const command of Object.keys(commands)) {
        const CommandCtor = commands[command];
        const methodImpl = async function (args, optionsOrCb, cb) {
            const command = new CommandCtor(args);
            if (typeof optionsOrCb === "function") {
                this.send(command, optionsOrCb);
            }
            else if (typeof cb === "function") {
                if (typeof optionsOrCb !== "object")
                    throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
                this.send(command, optionsOrCb || {}, cb);
            }
            else {
                return this.send(command, optionsOrCb);
            }
        };
        const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
        Client.prototype[methodName] = methodImpl;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/parse-utils.js
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
const expectInt = expectLong;
const expectInt32 = (value) => expectSizedInt(value, 32);
const expectShort = (value) => expectSizedInt(value, 16);
const expectByte = (value) => expectSizedInt(value, 8);
const expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = expectObject(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
const strictParseDouble = (value) => {
    if (typeof value == "string") {
        return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
};
const strictParseFloat = strictParseDouble;
const strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
};
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectNumber(value);
};
const handleFloat = limitedParseDouble;
const limitedParseFloat = limitedParseDouble;
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectFloat32(value);
};
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value) => {
    if (typeof value === "string") {
        return expectLong(parseNumber(value));
    }
    return expectLong(value);
};
const strictParseInt = strictParseLong;
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
};
const strictParseShort = (value) => {
    if (typeof value === "string") {
        return expectShort(parseNumber(value));
    }
    return expectShort(value);
};
const strictParseByte = (value) => {
    if (typeof value === "string") {
        return expectByte(parseNumber(value));
    }
    return expectByte(value);
};
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
const logger = {
    warn: console.warn,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/date-utils.js

const DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
const RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
const RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
const parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
const IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
const RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
const ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/exceptions.js
class ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
const decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/default-error-handler.js

const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw decorateServiceException(response, parsedBody);
};
const withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
const loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
        case "standard":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "in-region":
            return {
                retryMode: "standard",
                connectionTimeout: 1100,
            };
        case "cross-region":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "mobile":
            return {
                retryMode: "standard",
                connectionTimeout: 30000,
            };
        default:
            return {};
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
let warningEmitted = false;
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
        warningEmitted = true;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js


const getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in types_dist_es/* AlgorithmId */.dB) {
        const algorithmId = types_dist_es/* AlgorithmId */.dB[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
const getRetryConfiguration = (runtimeConfig) => {
    let _retryStrategy = runtimeConfig.retryStrategy;
    return {
        setRetryStrategy(retryStrategy) {
            _retryStrategy = retryStrategy;
        },
        retryStrategy() {
            return _retryStrategy;
        },
    };
};
const resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js


const getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
        ...getRetryConfiguration(runtimeConfig),
    };
};
const getDefaultClientConfiguration = getDefaultExtensionConfiguration;
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
        ...resolveRetryRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js
const getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js
const getValueFromTextNode = (obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
            obj[key] = obj[key][textNodeName];
        }
        else if (typeof obj[key] === "object" && obj[key] !== null) {
            obj[key] = getValueFromTextNode(obj[key]);
        }
    }
    return obj;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/lazy-json.js
const StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(StringWrapper, String);
class LazyJsonString extends StringWrapper {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
        }
        return new LazyJsonString(JSON.stringify(object));
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/object-mapping.js
function map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
        target = {};
        instructions = arg0;
    }
    else {
        target = arg0;
        if (typeof arg1 === "function") {
            filter = arg1;
            instructions = arg2;
            return mapWithFilter(target, filter, instructions);
        }
        else {
            instructions = arg1;
        }
    }
    for (const key of Object.keys(instructions)) {
        if (!Array.isArray(instructions[key])) {
            target[key] = instructions[key];
            continue;
        }
        applyInstruction(target, null, instructions, key);
    }
    return target;
}
const convertMap = (target) => {
    const output = {};
    for (const [k, v] of Object.entries(target || {})) {
        output[k] = [, v];
    }
    return output;
};
const take = (source, instructions) => {
    const out = {};
    for (const key in instructions) {
        applyInstruction(out, source, instructions, key);
    }
    return out;
};
const mapWithFilter = (target, filter, instructions) => {
    return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
            _instructions[key] = value;
        }
        else {
            if (typeof value === "function") {
                _instructions[key] = [filter, value()];
            }
            else {
                _instructions[key] = [filter, value];
            }
        }
        return _instructions;
    }, {}));
};
const applyInstruction = (target, source, instructions, targetKey) => {
    if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
            instruction = [, instruction];
        }
        const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if ((typeof filter === "function" && filter(source[sourceKey])) || (typeof filter !== "function" && !!filter)) {
            target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter === undefined && (_value = value()) != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed) {
            target[targetKey] = _value;
        }
        else if (customFilterPassed) {
            target[targetKey] = value();
        }
    }
    else {
        const defaultFilterPassed = filter === undefined && value != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed || customFilterPassed) {
            target[targetKey] = value;
        }
    }
};
const nonNullish = (_) => _ != null;
const pass = (_) => _;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/resolve-path.js

const resolvedPath = (resolvedPath, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== undefined) {
        const labelValue = labelValueProvider();
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
        }
        resolvedPath = resolvedPath.replace(uriLabel, isGreedyLabel
            ? labelValue
                .split("/")
                .map((segment) => extendedEncodeURIComponent(segment))
                .join("/")
            : extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/ser-utils.js
const serializeFloat = (value) => {
    if (value !== value) {
        return "NaN";
    }
    switch (value) {
        case Infinity:
            return "Infinity";
        case -Infinity:
            return "-Infinity";
        default:
            return value;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/serde-json.js
const _json = (obj) => {
    if (obj == null) {
        return {};
    }
    if (Array.isArray(obj)) {
        return obj.filter((_) => _ != null).map(_json);
    }
    if (typeof obj === "object") {
        const target = {};
        for (const key of Object.keys(obj)) {
            if (obj[key] == null) {
                continue;
            }
            target[key] = _json(obj[key]);
        }
        return target;
    }
    return obj;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/split-every.js
function splitEvery(value, delimiter, numDelimiters) {
    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
        throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
    }
    const segments = value.split(delimiter);
    if (numDelimiters === 1) {
        return segments;
    }
    const compoundSegments = [];
    let currentSegment = "";
    for (let i = 0; i < segments.length; i++) {
        if (currentSegment === "") {
            currentSegment = segments[i];
        }
        else {
            currentSegment += delimiter + segments[i];
        }
        if ((i + 1) % numDelimiters === 0) {
            compoundSegments.push(currentSegment);
            currentSegment = "";
        }
    }
    if (currentSegment !== "") {
        compoundSegments.push(currentSegment);
    }
    return compoundSegments;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/smithy-client/dist-es/index.js
























/***/ }),

/***/ 4687:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  dB: () => (/* reexport */ AlgorithmId),
  wb: () => (/* reexport */ FieldPosition),
  Vf: () => (/* reexport */ SMITHY_CONTEXT_KEY)
});

// UNUSED EXPORTS: EndpointURLScheme, HttpApiKeyAuthLocation, HttpAuthLocation, IniSectionType, RequestHandlerProtocol, getDefaultClientConfiguration, resolveDefaultRuntimeConfig

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/middleware.js
const SMITHY_CONTEXT_KEY = "__smithy_context";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/core/node_modules/@smithy/types/dist-es/index.js






































/***/ }),

/***/ 3758:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ENV_CREDENTIAL_SCOPE: () => (/* reexport */ ENV_CREDENTIAL_SCOPE),
  ENV_EXPIRATION: () => (/* reexport */ ENV_EXPIRATION),
  ENV_KEY: () => (/* reexport */ ENV_KEY),
  ENV_SECRET: () => (/* reexport */ ENV_SECRET),
  ENV_SESSION: () => (/* reexport */ ENV_SESSION),
  fromEnv: () => (/* reexport */ fromEnv)
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-env/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError_ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError_ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-env/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-env/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-env/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-env/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-env/dist-es/fromEnv.js

const ENV_KEY = "AWS_ACCESS_KEY_ID";
const ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
const ENV_SESSION = "AWS_SESSION_TOKEN";
const ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
const ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE";
const fromEnv = (init) => async () => {
    init?.logger?.debug("@aws-sdk/credential-provider-env", "fromEnv");
    const accessKeyId = process.env[ENV_KEY];
    const secretAccessKey = process.env[ENV_SECRET];
    const sessionToken = process.env[ENV_SESSION];
    const expiry = process.env[ENV_EXPIRATION];
    const credentialScope = process.env[ENV_CREDENTIAL_SCOPE];
    if (accessKeyId && secretAccessKey) {
        return {
            accessKeyId,
            secretAccessKey,
            ...(sessionToken && { sessionToken }),
            ...(expiry && { expiration: new Date(expiry) }),
            ...(credentialScope && { credentialScope }),
        };
    }
    throw new CredentialsProviderError("Unable to find environment variable credentials.");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-env/dist-es/index.js



/***/ }),

/***/ 7819:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  fromHttp: () => (/* reexport */ fromHttp)
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/types/dist-es/extensions/checksum.js
var checksum_AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(checksum_AlgorithmId || (checksum_AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => checksum_AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => checksum_AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/types/dist-es/http.js
var http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(http_FieldPosition || (http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/protocol-http/dist-es/httpResponse.js
class httpResponse_HttpResponse {
    constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/protocol-http/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/querystring-builder/dist-es/index.js

function dist_es_buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = escapeUri(key);
        if (Array.isArray(value)) {
            for (let i = 0, iLen = value.length; i < iLen; i++) {
                parts.push(`${key}=${escapeUri(value[i])}`);
            }
        }
        else {
            let qsEntry = key;
            if (value || typeof value === "string") {
                qsEntry += `=${escapeUri(value)}`;
            }
            parts.push(qsEntry);
        }
    }
    return parts.join("&");
}

// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(8611);
// EXTERNAL MODULE: external "https"
var external_https_ = __webpack_require__(5692);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/constants.js
const NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/get-transformed-headers.js
const get_transformed_headers_getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
};


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/set-connection-timeout.js
const setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
        return;
    }
    const timeoutId = setTimeout(() => {
        request.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
            name: "TimeoutError",
        }));
    }, timeoutInMs);
    request.on("socket", (socket) => {
        if (socket.connecting) {
            socket.on("connect", () => {
                clearTimeout(timeoutId);
            });
        }
        else {
            clearTimeout(timeoutId);
        }
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/set-socket-keep-alive.js
const setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }) => {
    if (keepAlive !== true) {
        return;
    }
    request.on("socket", (socket) => {
        socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/set-socket-timeout.js
const setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    request.setTimeout(timeoutInMs, () => {
        request.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
    });
};

// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(2203);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/write-request-body.js

const MIN_WAIT_TIME = 1000;
async function write_request_body_writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", () => {
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            }),
        ]);
    }
    if (!hasError) {
        writeBody(httpRequest, request.body);
    }
}
function writeBody(httpRequest, body) {
    if (body instanceof external_stream_.Readable) {
        body.pipe(httpRequest);
        return;
    }
    if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
            httpRequest.end(body);
            return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" &&
            uint8.buffer &&
            typeof uint8.byteOffset === "number" &&
            typeof uint8.byteLength === "number") {
            httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
            return;
        }
        httpRequest.end(Buffer.from(body));
        return;
    }
    httpRequest.end();
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js










const DEFAULT_REQUEST_TIMEOUT = 0;
class NodeHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
            return socketWarningTimestamp;
        }
        const interval = 15000;
        if (Date.now() - interval < socketWarningTimestamp) {
            return socketWarningTimestamp;
        }
        if (sockets && requests) {
            for (const origin in sockets) {
                const socketsInUse = sockets[origin]?.length ?? 0;
                const requestsEnqueued = requests[origin]?.length ?? 0;
                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
                    console.warn("@smithy/node-http-handler:WARN", `socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.`, "See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html", "or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.");
                    return Date.now();
                }
            }
        }
        return socketWarningTimestamp;
    }
    constructor(options) {
        this.socketWarningTimestamp = 0;
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout ?? socketTimeout,
            httpAgent: (() => {
                if (httpAgent instanceof external_http_.Agent || typeof httpAgent?.destroy === "function") {
                    return httpAgent;
                }
                return new external_http_.Agent({ keepAlive, maxSockets, ...httpAgent });
            })(),
            httpsAgent: (() => {
                if (httpsAgent instanceof external_https_.Agent || typeof httpsAgent?.destroy === "function") {
                    return httpsAgent;
                }
                return new external_https_.Agent({ keepAlive, maxSockets, ...httpsAgent });
            })(),
        };
    }
    destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        let socketCheckTimeoutId;
        return new Promise((_resolve, _reject) => {
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                clearTimeout(socketCheckTimeoutId);
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
            socketCheckTimeoutId = setTimeout(() => {
                this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp);
            }, this.config.socketAcquisitionWarningTimeout ??
                (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000));
            const queryString = dist_es_buildQueryString(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent,
                auth,
            };
            const requestFunc = isSSL ? external_https_.request : external_http_.request;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new httpResponse_HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: get_transformed_headers_getTransformedHeaders(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            setConnectionTimeout(req, reject, this.config.connectionTimeout);
            setSocketTimeout(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                setSocketKeepAlive(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                });
            }
            writeRequestBodyPromise = write_request_body_writeRequestBody(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

// EXTERNAL MODULE: external "http2"
var external_http2_ = __webpack_require__(5675);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
class node_http2_connection_pool_NodeHttp2ConnectionPool {
    constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions ?? [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-manager.js


class node_http2_connection_manager_NodeHttp2ConnectionManager {
    constructor(config) {
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/node-http2-handler.js






class NodeHttp2Handler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal?.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: this.config?.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = buildQueryString(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [constants.HTTP2_HEADER_PATH]: path,
                [constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: getTransformedHeaders(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js

class Collector extends external_stream_.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js

const streamCollector = (stream) => {
    if (isReadableStreamInstance(stream)) {
        return collectReadableStream(stream);
    }
    return new Promise((resolve, reject) => {
        const collector = new Collector();
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
            resolve(bytes);
        });
    });
};
const isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
async function collectReadableStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/node-http-handler/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError_ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError_ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: external "fs/promises"
const promises_namespaceObject = require("fs/promises");
var promises_default = /*#__PURE__*/__webpack_require__.n(promises_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/checkUrl.js

const LOOPBACK_CIDR_IPv4 = "127.0.0.0/8";
const LOOPBACK_CIDR_IPv6 = "::1/128";
const ECS_CONTAINER_HOST = "169.254.170.2";
const EKS_CONTAINER_HOST_IPv4 = "169.254.170.23";
const EKS_CONTAINER_HOST_IPv6 = "[fd00:ec2::23]";
const checkUrl = (url) => {
    if (url.protocol === "https:") {
        return;
    }
    if (url.hostname === ECS_CONTAINER_HOST ||
        url.hostname === EKS_CONTAINER_HOST_IPv4 ||
        url.hostname === EKS_CONTAINER_HOST_IPv6) {
        return;
    }
    if (url.hostname.includes("[")) {
        if (url.hostname === "[::1]" || url.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") {
            return;
        }
    }
    else {
        if (url.hostname === "localhost") {
            return;
        }
        const ipComponents = url.hostname.split(".");
        const inRange = (component) => {
            const num = parseInt(component, 10);
            return 0 <= num && num <= 255;
        };
        if (ipComponents[0] === "127" &&
            inRange(ipComponents[1]) &&
            inRange(ipComponents[2]) &&
            inRange(ipComponents[3]) &&
            ipComponents.length === 4) {
            return;
        }
    }
    throw new CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
const getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const MiddlewareStack_constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo(MiddlewareStack_constructStack()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo(MiddlewareStack_constructStack());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                const step = mw.step ??
                    mw.relation +
                        " " +
                        mw.toMiddleware;
                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/middleware-stack/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/smithy-client/dist-es/client.js

class Client {
    constructor(config) {
        this.middlewareStack = constructStack();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/is-array-buffer/dist-es/index.js
const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// EXTERNAL MODULE: external "buffer"
var external_buffer_ = __webpack_require__(181);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-buffer-from/dist-es/index.js


const fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return external_buffer_.Buffer.from(input, offset, length);
};
const fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? external_buffer_.Buffer.from(input, encoding) : external_buffer_.Buffer.from(input);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-base64/dist-es/fromBase64.js

const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64_fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = fromString(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js

const fromUtf8_fromUtf8 = (input) => {
    const buf = fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js

const toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-utf8/dist-es/toUtf8.js

const toUtf8_toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-utf8/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-base64/dist-es/toBase64.js


const toBase64_toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
        input = fromUtf8_fromUtf8(_input);
    }
    else {
        input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-base64/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-stream/dist-es/blob/transforms.js



function transforms_transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return toBase64(payload);
    }
    return toUtf8(payload);
}
function transforms_transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js

class Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter extends (/* unused pure expression or super */ null && (Uint8Array)) {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return transformFromString(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.js

const getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};

// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(9023);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js



const keepAliveSupport = {
    supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
};
class FetchHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
        if (typeof options === "function") {
            this.configProvider = options().then((opts) => opts || {});
        }
        else {
            this.config = options ?? {};
            this.configProvider = Promise.resolve(this.config);
        }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        const requestTimeoutInMs = this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = buildQueryString(request.query || {});
        if (queryString) {
            path += `?${queryString}`;
        }
        if (request.fragment) {
            path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? undefined : request.body;
        const requestOptions = {
            body,
            headers: new Headers(request.headers),
            method: method,
        };
        if (body) {
            requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
            requestOptions.signal = abortSignal;
        }
        if (keepAliveSupport.supported) {
            requestOptions.keepalive = keepAlive;
        }
        const fetchRequest = new Request(url, requestOptions);
        const raceOfPromises = [
            fetch(fetchRequest).then((response) => {
                const fetchHeaders = response.headers;
                const transformedHeaders = {};
                for (const pair of fetchHeaders.entries()) {
                    transformedHeaders[pair[0]] = pair[1];
                }
                const hasReadableStream = response.body != undefined;
                if (!hasReadableStream) {
                    return response.blob().then((body) => ({
                        response: new HttpResponse({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body,
                        }),
                    }));
                }
                return {
                    response: new HttpResponse({
                        headers: transformedHeaders,
                        reason: response.statusText,
                        statusCode: response.status,
                        body: response.body,
                    }),
                };
            }),
            requestTimeout(requestTimeoutInMs),
        ];
        if (abortSignal) {
            raceOfPromises.push(new Promise((resolve, reject) => {
                abortSignal.onabort = () => {
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }));
        }
        return Promise.race(raceOfPromises);
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            config[key] = value;
            return config;
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js

const stream_collector_streamCollector = (stream) => {
    if (typeof Blob === "function" && stream instanceof Blob) {
        return collectBlob(stream);
    }
    return collectStream(stream);
};
async function collectBlob(blob) {
    const base64 = await readToBase64(blob);
    const arrayBuffer = fromBase64_fromBase64(base64);
    return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}
function readToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (reader.readyState !== 2) {
                return reject(new Error("Reader aborted too early"));
            }
            const result = (reader.result ?? "");
            const commaIndex = result.indexOf(",");
            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
            resolve(result.substring(dataOffset));
        };
        reader.onabort = () => reject(new Error("Read aborted"));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
    });
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/fetch-http-handler/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-hex-encoding/dist-es/index.js
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js




const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    if (!isBlobInstance(stream) && !sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await stream_collector_streamCollector(stream);
    };
    const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
            throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" +
                "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
    };
    return Object.assign(stream, {
        transformToByteArray: transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === "base64") {
                return toBase64_toBase64(buf);
            }
            else if (encoding === "hex") {
                return toHex(buf);
            }
            else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
                return toUtf8_toUtf8(buf);
            }
            else if (typeof TextDecoder === "function") {
                return new TextDecoder(encoding).decode(buf);
            }
            else {
                throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            transformed = true;
            if (isBlobInstance(stream)) {
                return blobToWebStream(stream);
            }
            else if (sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
                return stream;
            }
            else {
                throw new Error(`Cannot transform payload to web stream, got ${stream}`);
            }
        },
    });
};
const isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
const sdk_stream_mixin_browser_isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js





const sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdk_stream_mixin_sdkStreamMixin = (stream) => {
    if (!(stream instanceof external_stream_.Readable)) {
        try {
            return sdkStreamMixin(stream);
        }
        catch (e) {
            const name = stream?.__proto__?.constructor?.name || stream;
            throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new external_util_.TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof external_stream_.Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return external_stream_.Readable.toWeb(stream);
        },
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/util-stream/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js

const collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/smithy-client/dist-es/command.js


class Command {
    constructor() {
        this.middlewareStack = constructStack();
    }
    static classBuilder() {
        return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [SMITHY_CONTEXT_KEY]: {
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
class ClassBuilder {
    constructor() {
        this._init = () => { };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
    }
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends Command {
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(...[input]) {
                super();
                this.serialize = closure._serializer;
                this.deserialize = closure._deserializer;
                this.input = input ?? {};
                closure._init(this);
            }
            resolveMiddleware(stack, configuration, options) {
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/smithy-client/dist-es/parse-utils.js
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
const expectInt = (/* unused pure expression or super */ null && (expectLong));
const expectInt32 = (value) => expectSizedInt(value, 32);
const expectShort = (value) => expectSizedInt(value, 16);
const expectByte = (value) => expectSizedInt(value, 8);
const expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = expectObject(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
const parse_utils_strictParseDouble = (value) => {
    if (typeof value == "string") {
        return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
};
const strictParseFloat = (/* unused pure expression or super */ null && (parse_utils_strictParseDouble));
const strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
};
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectNumber(value);
};
const handleFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectFloat32(value);
};
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value) => {
    if (typeof value === "string") {
        return expectLong(parseNumber(value));
    }
    return expectLong(value);
};
const strictParseInt = (/* unused pure expression or super */ null && (strictParseLong));
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
};
const parse_utils_strictParseShort = (value) => {
    if (typeof value === "string") {
        return expectShort(parseNumber(value));
    }
    return expectShort(value);
};
const strictParseByte = (value) => {
    if (typeof value === "string") {
        return expectByte(parseNumber(value));
    }
    return expectByte(value);
};
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
const logger = {
    warn: console.warn,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/smithy-client/dist-es/date-utils.js

const DAYS = (/* unused pure expression or super */ null && (["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]));
const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
const RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = parse_utils_strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
const RFC3339_WITH_OFFSET = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/)));
const parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
const IMF_FIXDATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const RFC_850_DATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const ASC_TIME = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/)));
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = (/* unused pure expression or super */ null && (50 * 365 * 24 * 60 * 60 * 1000));
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/smithy-client/dist-es/exceptions.js
class ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
const exceptions_decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/smithy-client/dist-es/default-error-handler.js

const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw decorateServiceException(response, parsedBody);
};
const withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js


const extensions_checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in AlgorithmId) {
        const algorithmId = AlgorithmId[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const extensions_checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js


const getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
        ...getRetryConfiguration(runtimeConfig),
    };
};
const defaultExtensionConfiguration_getDefaultClientConfiguration = (/* unused pure expression or super */ null && (getDefaultExtensionConfiguration));
const defaultExtensionConfiguration_resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
        ...resolveRetryRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/smithy-client/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/smithy-client/dist-es/lazy-json.js
const StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(StringWrapper, String);
class LazyJsonString extends (/* unused pure expression or super */ null && (StringWrapper)) {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
        }
        return new LazyJsonString(JSON.stringify(object));
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/node_modules/@smithy/smithy-client/dist-es/index.js























;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/requestHelpers.js




function createGetRequest(url) {
    return new HttpRequest({
        protocol: url.protocol,
        hostname: url.hostname,
        port: Number(url.port),
        path: url.pathname,
        query: Array.from(url.searchParams.entries()).reduce((acc, [k, v]) => {
            acc[k] = v;
            return acc;
        }, {}),
        fragment: url.hash,
    });
}
async function getCredentials(response) {
    const contentType = response?.headers["content-type"] ?? response?.headers["Content-Type"] ?? "";
    if (!contentType.includes("json")) {
        console.warn("HTTP credential provider response header content-type was not application/json. Observed: " + contentType + ".");
    }
    const stream = sdk_stream_mixin_sdkStreamMixin(response.body);
    const str = await stream.transformToString();
    if (response.statusCode === 200) {
        const parsed = JSON.parse(str);
        if (typeof parsed.AccessKeyId !== "string" ||
            typeof parsed.SecretAccessKey !== "string" ||
            typeof parsed.Token !== "string" ||
            typeof parsed.Expiration !== "string") {
            throw new CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: " +
                "{ AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }");
        }
        return {
            accessKeyId: parsed.AccessKeyId,
            secretAccessKey: parsed.SecretAccessKey,
            sessionToken: parsed.Token,
            expiration: parseRfc3339DateTime(parsed.Expiration),
        };
    }
    if (response.statusCode >= 400 && response.statusCode < 500) {
        let parsedBody = {};
        try {
            parsedBody = JSON.parse(str);
        }
        catch (e) { }
        throw Object.assign(new CredentialsProviderError(`Server responded with status: ${response.statusCode}`), {
            Code: parsedBody.Code,
            Message: parsedBody.Message,
        });
    }
    throw new CredentialsProviderError(`Server responded with status: ${response.statusCode}`);
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/retry-wrapper.js
const retryWrapper = (toRetry, maxRetries, delayMs) => {
    return async () => {
        for (let i = 0; i < maxRetries; ++i) {
            try {
                return await toRetry();
            }
            catch (e) {
                await new Promise((resolve) => setTimeout(resolve, delayMs));
            }
        }
        return await toRetry();
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/fromHttp.js






const AWS_CONTAINER_CREDENTIALS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
const DEFAULT_LINK_LOCAL_HOST = "http://169.254.170.2";
const AWS_CONTAINER_CREDENTIALS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
const AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE";
const AWS_CONTAINER_AUTHORIZATION_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
const fromHttp = (options) => {
    options.logger?.debug("@aws-sdk/credential-provider-http", "fromHttp");
    let host;
    const relative = options.awsContainerCredentialsRelativeUri ?? process.env[AWS_CONTAINER_CREDENTIALS_RELATIVE_URI];
    const full = options.awsContainerCredentialsFullUri ?? process.env[AWS_CONTAINER_CREDENTIALS_FULL_URI];
    const token = options.awsContainerAuthorizationToken ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN];
    const tokenFile = options.awsContainerAuthorizationTokenFile ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE];
    if (relative && full) {
        console.warn("AWS SDK HTTP credentials provider:", "you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri.");
        console.warn("awsContainerCredentialsFullUri will take precedence.");
    }
    if (token && tokenFile) {
        console.warn("AWS SDK HTTP credentials provider:", "you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile.");
        console.warn("awsContainerAuthorizationToken will take precedence.");
    }
    if (full) {
        host = full;
    }
    else if (relative) {
        host = `${DEFAULT_LINK_LOCAL_HOST}${relative}`;
    }
    else {
        throw new CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`);
    }
    const url = new URL(host);
    checkUrl(url);
    const requestHandler = new NodeHttpHandler({
        requestTimeout: options.timeout ?? 1000,
        connectionTimeout: options.timeout ?? 1000,
    });
    return retryWrapper(async () => {
        const request = createGetRequest(url);
        if (token) {
            request.headers.Authorization = token;
        }
        else if (tokenFile) {
            request.headers.Authorization = (await promises_default().readFile(tokenFile)).toString();
        }
        try {
            const result = await requestHandler.handle(request);
            return getCredentials(result.response);
        }
        catch (e) {
            throw new CredentialsProviderError(String(e));
        }
    }, options.maxRetries ?? 3, options.timeout ?? 1000);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-http/dist-es/index.js



/***/ }),

/***/ 4021:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  fromIni: () => (/* reexport */ fromIni)
});

// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${external_path_.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0,external_os_.homedir)();
    return homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = createHash("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile } = external_fs_.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/types/dist-es/profile.js
var profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(profile_IniSectionType || (profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(profile_IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === profile_IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath_getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(profile_IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: slurpFile_readFile } = external_fs_.promises;
const filePromisesHash = {};
const slurpFile_slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = slurpFile_readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const swallowError = () => ({});
const loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath_getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile_slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile_slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/mergeConfigFiles.js
const mergeConfigFiles = (...files) => {
    const merged = {};
    for (const file of files) {
        for (const [key, values] of Object.entries(file)) {
            if (merged[key] !== undefined) {
                Object.assign(merged[key], values);
            }
            else {
                merged[key] = values;
            }
        }
    }
    return merged;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError_ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError_ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveCredentialSource.js

const resolveCredentialSource = (credentialSource, profileName) => {
    const sourceProvidersMap = {
        EcsContainer: (options) => Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 3060)).then(({ fromContainerMetadata }) => fromContainerMetadata(options)),
        Ec2InstanceMetadata: (options) => Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 3060)).then(({ fromInstanceMetadata }) => fromInstanceMetadata(options)),
        Environment: (options) => Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 3758)).then(({ fromEnv }) => fromEnv(options)),
    };
    if (credentialSource in sourceProvidersMap) {
        return sourceProvidersMap[credentialSource];
    }
    else {
        throw new CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, ` +
            `expected EcsContainer or Ec2InstanceMetadata or Environment.`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveAssumeRoleCredentials.js




const isAssumeRoleProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.role_arn === "string" &&
    ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 &&
    ["undefined", "string"].indexOf(typeof arg.external_id) > -1 &&
    ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 &&
    (isAssumeRoleWithSourceProfile(arg) || isAssumeRoleWithProviderProfile(arg));
const isAssumeRoleWithSourceProfile = (arg) => typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
const isAssumeRoleWithProviderProfile = (arg) => typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
const resolveAssumeRoleCredentials = async (profileName, profiles, options, visitedProfiles = {}) => {
    options.logger?.debug("@aws-sdk/credential-provider-ini", "resolveAssumeRoleCredentials (STS)");
    const data = profiles[profileName];
    if (!options.roleAssumer) {
        const { getDefaultRoleAssumer } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 4276));
        options.roleAssumer = getDefaultRoleAssumer({
            ...options.clientConfig,
            credentialProviderLogger: options.logger,
            parentClientConfig: options?.parentClientConfig,
        }, options.clientPlugins);
    }
    const { source_profile } = data;
    if (source_profile && source_profile in visitedProfiles) {
        throw new CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile` +
            ` ${getProfileName(options)}. Profiles visited: ` +
            Object.keys(visitedProfiles).join(", "), false);
    }
    const sourceCredsProvider = source_profile
        ? resolveProfileData(source_profile, profiles, options, {
            ...visitedProfiles,
            [source_profile]: true,
        })
        : (await resolveCredentialSource(data.credential_source, profileName)(options))();
    const params = {
        RoleArn: data.role_arn,
        RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
        ExternalId: data.external_id,
        DurationSeconds: parseInt(data.duration_seconds || "3600", 10),
    };
    const { mfa_serial } = data;
    if (mfa_serial) {
        if (!options.mfaCodeProvider) {
            throw new CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
        }
        params.SerialNumber = mfa_serial;
        params.TokenCode = await options.mfaCodeProvider(mfa_serial);
    }
    const sourceCreds = await sourceCredsProvider;
    return options.roleAssumer(sourceCreds, params);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProcessCredentials.js
const isProcessProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string";
const resolveProcessCredentials = async (options, profile) => Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 8512)).then(({ fromProcess }) => fromProcess({
    ...options,
    profile,
})());

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveSsoCredentials.js
const resolveSsoCredentials = async (profile, options = {}) => {
    const { fromSSO } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 326));
    return fromSSO({
        profile,
        logger: options.logger,
    })();
};
const isSsoProfile = (arg) => arg &&
    (typeof arg.sso_start_url === "string" ||
        typeof arg.sso_account_id === "string" ||
        typeof arg.sso_session === "string" ||
        typeof arg.sso_region === "string" ||
        typeof arg.sso_role_name === "string");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveStaticCredentials.js
const isStaticCredsProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.aws_access_key_id === "string" &&
    typeof arg.aws_secret_access_key === "string" &&
    ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1;
const resolveStaticCredentials = (profile, options) => {
    options?.logger?.debug("@aws-sdk/credential-provider-ini", "resolveStaticCredentials");
    return Promise.resolve({
        accessKeyId: profile.aws_access_key_id,
        secretAccessKey: profile.aws_secret_access_key,
        sessionToken: profile.aws_session_token,
        credentialScope: profile.aws_credential_scope,
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveWebIdentityCredentials.js
const isWebIdentityProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.web_identity_token_file === "string" &&
    typeof arg.role_arn === "string" &&
    ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
const resolveWebIdentityCredentials = async (profile, options) => Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 3503)).then(({ fromTokenFile }) => fromTokenFile({
    webIdentityTokenFile: profile.web_identity_token_file,
    roleArn: profile.role_arn,
    roleSessionName: profile.role_session_name,
    roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity,
    logger: options.logger,
    parentClientConfig: options.parentClientConfig,
})());

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProfileData.js






const resolveProfileData = async (profileName, profiles, options, visitedProfiles = {}) => {
    const data = profiles[profileName];
    if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile(data)) {
        return resolveStaticCredentials(data, options);
    }
    if (isAssumeRoleProfile(data)) {
        return resolveAssumeRoleCredentials(profileName, profiles, options, visitedProfiles);
    }
    if (isStaticCredsProfile(data)) {
        return resolveStaticCredentials(data, options);
    }
    if (isWebIdentityProfile(data)) {
        return resolveWebIdentityCredentials(data, options);
    }
    if (isProcessProfile(data)) {
        return resolveProcessCredentials(options, profileName);
    }
    if (isSsoProfile(data)) {
        return await resolveSsoCredentials(profileName, options);
    }
    throw new CredentialsProviderError(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/dist-es/fromIni.js


const fromIni = (init = {}) => async () => {
    init.logger?.debug("@aws-sdk/credential-provider-ini", "fromIni");
    const profiles = await parseKnownFiles(init);
    return resolveProfileData(getProfileName(init), profiles, init);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-ini/dist-es/index.js



/***/ }),

/***/ 2528:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  v6: () => (/* reexport */ defaultProvider)
});

// UNUSED EXPORTS: credentialsTreatedAsExpired, credentialsWillNeedRefresh

// EXTERNAL MODULE: ./node_modules/@aws-sdk/credential-provider-env/dist-es/index.js + 6 modules
var dist_es = __webpack_require__(3758);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/property-provider/dist-es/memoize.js
const memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/property-provider/dist-es/index.js







// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = homedir();
    return homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = createHash("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile } = external_fs_.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/types/dist-es/profile.js
var profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(profile_IniSectionType || (profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData_getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath_getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || join(getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath_getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || join(getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = (/* unused pure expression or super */ null && (["__proto__", "profile __proto__"]));
const parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: slurpFile_readFile } = external_fs_.promises;
const filePromisesHash = {};
const slurpFile_slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = slurpFile_readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const swallowError = () => ({});
const loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles_loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/dist-es/remoteProvider.js

const ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
const remoteProvider = async (init) => {
    const { ENV_CMDS_FULL_URI, ENV_CMDS_RELATIVE_URI, fromContainerMetadata, fromInstanceMetadata } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 3060));
    if (process.env[ENV_CMDS_RELATIVE_URI] || process.env[ENV_CMDS_FULL_URI]) {
        init.logger?.debug("@aws-sdk/credential-provider-node", "remoteProvider::fromHttp/fromContainerMetadata");
        const { fromHttp } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 7819));
        return chain(fromHttp(init), fromContainerMetadata(init));
    }
    if (process.env[ENV_IMDS_DISABLED]) {
        return async () => {
            throw new CredentialsProviderError("EC2 Instance Metadata Service access disabled");
        };
    }
    init.logger?.debug("@aws-sdk/credential-provider-node", "remoteProvider::fromInstanceMetadata");
    return fromInstanceMetadata(init);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js




const defaultProvider = (init = {}) => memoize(chain(...(init.profile || process.env[ENV_PROFILE]
    ? []
    : [
        async () => {
            init.logger?.debug("@aws-sdk/credential-provider-node", "defaultProvider::fromEnv");
            return (0,dist_es.fromEnv)(init)();
        },
    ]), async () => {
    init.logger?.debug("@aws-sdk/credential-provider-node", "defaultProvider::fromSSO");
    const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
    if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
        throw new CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).");
    }
    const { fromSSO } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 326));
    return fromSSO(init)();
}, async () => {
    init.logger?.debug("@aws-sdk/credential-provider-node", "defaultProvider::fromIni");
    const { fromIni } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 4021));
    return fromIni(init)();
}, async () => {
    init.logger?.debug("@aws-sdk/credential-provider-node", "defaultProvider::fromProcess");
    const { fromProcess } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 8512));
    return fromProcess(init)();
}, async () => {
    init.logger?.debug("@aws-sdk/credential-provider-node", "defaultProvider::fromTokenFile");
    const { fromTokenFile } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 3503));
    return fromTokenFile(init)();
}, async () => {
    init.logger?.debug("@aws-sdk/credential-provider-node", "defaultProvider::remoteProvider");
    return (await remoteProvider(init))();
}, async () => {
    throw new CredentialsProviderError("Could not load credentials from any providers", false);
}), credentialsTreatedAsExpired, credentialsWillNeedRefresh);
const credentialsWillNeedRefresh = (credentials) => credentials?.expiration !== undefined;
const credentialsTreatedAsExpired = (credentials) => credentials?.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-node/dist-es/index.js



/***/ }),

/***/ 8512:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  fromProcess: () => (/* reexport */ fromProcess)
});

// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${external_path_.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0,external_os_.homedir)();
    return homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = createHash("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile } = external_fs_.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/types/dist-es/profile.js
var profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(profile_IniSectionType || (profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(profile_IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === profile_IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath_getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(profile_IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: slurpFile_readFile } = external_fs_.promises;
const filePromisesHash = {};
const slurpFile_slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = slurpFile_readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const swallowError = () => ({});
const loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath_getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile_slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile_slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/mergeConfigFiles.js
const mergeConfigFiles = (...files) => {
    const merged = {};
    for (const file of files) {
        for (const [key, values] of Object.entries(file)) {
            if (merged[key] !== undefined) {
                Object.assign(merged[key], values);
            }
            else {
                merged[key] = values;
            }
        }
    }
    return merged;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError_ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError_ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: external "child_process"
const external_child_process_namespaceObject = require("child_process");
// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(9023);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/dist-es/getValidatedProcessCredentials.js
const getValidatedProcessCredentials = (profileName, data) => {
    if (data.Version !== 1) {
        throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
    }
    if (data.AccessKeyId === undefined || data.SecretAccessKey === undefined) {
        throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
    }
    if (data.Expiration) {
        const currentTime = new Date();
        const expireTime = new Date(data.Expiration);
        if (expireTime < currentTime) {
            throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
        }
    }
    return {
        accessKeyId: data.AccessKeyId,
        secretAccessKey: data.SecretAccessKey,
        ...(data.SessionToken && { sessionToken: data.SessionToken }),
        ...(data.Expiration && { expiration: new Date(data.Expiration) }),
        ...(data.CredentialScope && { credentialScope: data.CredentialScope }),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js




const resolveProcessCredentials = async (profileName, profiles) => {
    const profile = profiles[profileName];
    if (profiles[profileName]) {
        const credentialProcess = profile["credential_process"];
        if (credentialProcess !== undefined) {
            const execPromise = (0,external_util_.promisify)(external_child_process_namespaceObject.exec);
            try {
                const { stdout } = await execPromise(credentialProcess);
                let data;
                try {
                    data = JSON.parse(stdout.trim());
                }
                catch {
                    throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
                }
                return getValidatedProcessCredentials(profileName, data);
            }
            catch (error) {
                throw new CredentialsProviderError(error.message);
            }
        }
        else {
            throw new CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`);
        }
    }
    else {
        throw new CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/dist-es/fromProcess.js


const fromProcess = (init = {}) => async () => {
    init.logger?.debug("@aws-sdk/credential-provider-process", "fromProcess");
    const profiles = await parseKnownFiles(init);
    return resolveProcessCredentials(getProfileName(init), profiles);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-process/dist-es/index.js



/***/ }),

/***/ 326:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  fromSSO: () => (/* reexport */ fromSSO)
});

// UNUSED EXPORTS: isSsoProfile, validateSsoProfile

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError_ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError_ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/property-provider/dist-es/index.js







// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${external_path_.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0,external_os_.homedir)();
    return homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath = (id) => {
    const hasher = (0,external_crypto_.createHash)("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return (0,external_path_.join)(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile } = external_fs_.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || (0,external_path_.join)(getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || (0,external_path_.join)(getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: slurpFile_readFile } = external_fs_.promises;
const filePromisesHash = {};
const slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = slurpFile_readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const swallowError = () => ({});
const CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/mergeConfigFiles.js
const mergeConfigFiles = (...files) => {
    const merged = {};
    for (const file of files) {
        for (const [key, values] of Object.entries(file)) {
            if (merged[key] !== undefined) {
                Object.assign(merged[key], values);
            }
            else {
                merged[key] = values;
            }
        }
    }
    return merged;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/dist-es/isSsoProfile.js
const isSsoProfile = (arg) => arg &&
    (typeof arg.sso_start_url === "string" ||
        typeof arg.sso_account_id === "string" ||
        typeof arg.sso_session === "string" ||
        typeof arg.sso_region === "string" ||
        typeof arg.sso_role_name === "string");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class dist_es_ProviderError_ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, dist_es_ProviderError_ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError_CredentialsProviderError extends dist_es_ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError_CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError_TokenProviderError extends dist_es_ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError_TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/property-provider/dist-es/chain.js

const chain_chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const getHomeDir_homeDirCache = {};
const getHomeDir_getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${external_path_.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDir_getHomeDirCacheKey();
    if (!getHomeDir_homeDirCache[homeDirCacheKey])
        getHomeDir_homeDirCache[homeDirCacheKey] = (0,external_os_.homedir)();
    return getHomeDir_homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const getProfileName_ENV_PROFILE = "AWS_PROFILE";
const getProfileName_DEFAULT_PROFILE = "default";
const getProfileName_getProfileName = (init) => init.profile || process.env[getProfileName_ENV_PROFILE] || getProfileName_DEFAULT_PROFILE;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = (0,external_crypto_.createHash)("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile: getSSOTokenFromFile_readFile } = external_fs_.promises;
const getSSOTokenFromFile_getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath_getSSOTokenFilepath(id);
    const ssoTokenText = await getSSOTokenFromFile_readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/types/dist-es/auth/auth.js
var auth_HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(auth_HttpAuthLocation || (auth_HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuth_HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuth_HttpApiKeyAuthLocation || (HttpApiKeyAuth_HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/types/dist-es/endpoint.js
var endpoint_EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(endpoint_EndpointURLScheme || (endpoint_EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/types/dist-es/extensions/checksum.js
var checksum_AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(checksum_AlgorithmId || (checksum_AlgorithmId = {}));
const extensions_checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => checksum_AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => checksum_AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const extensions_checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const defaultClientConfiguration_getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const defaultClientConfiguration_resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/types/dist-es/http.js
var http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(http_FieldPosition || (http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/types/dist-es/profile.js
var profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(profile_IniSectionType || (profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/types/dist-es/transfer.js
var transfer_RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(transfer_RequestHandlerProtocol || (transfer_RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData_getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(profile_IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === profile_IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const getConfigFilepath_ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath_getConfigFilepath = () => process.env[getConfigFilepath_ENV_CONFIG_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const getCredentialsFilepath_ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath_getCredentialsFilepath = () => process.env[getCredentialsFilepath_ENV_CREDENTIALS_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const parseIni_prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const parseIni_profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = parseIni_prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(profile_IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (parseIni_profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: dist_es_slurpFile_readFile } = external_fs_.promises;
const slurpFile_filePromisesHash = {};
const slurpFile_slurpFile = (path, options) => {
    if (!slurpFile_filePromisesHash[path] || options?.ignoreCache) {
        slurpFile_filePromisesHash[path] = dist_es_slurpFile_readFile(path, "utf8");
    }
    return slurpFile_filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const loadSharedConfigFiles_swallowError = () => ({});
const loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles_loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath_getCredentialsFilepath(), configFilepath = getConfigFilepath_getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile_slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .then(getConfigData_getConfigData)
            .catch(loadSharedConfigFiles_swallowError),
        slurpFile_slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .catch(loadSharedConfigFiles_swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(profile_IniSectionType.SSO_SESSION + loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const dist_es_loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData_loadSsoSessionData = async (init = {}) => slurpFile_slurpFile(init.configFilepath ?? getConfigFilepath_getConfigFilepath())
    .then(parseIni_parseIni)
    .then(getSsoSessionData_getSsoSessionData)
    .catch(dist_es_loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/mergeConfigFiles.js
const mergeConfigFiles_mergeConfigFiles = (...files) => {
    const merged = {};
    for (const file of files) {
        for (const [key, values] of Object.entries(file)) {
            if (merged[key] !== undefined) {
                Object.assign(merged[key], values);
            }
            else {
                merged[key] = values;
            }
        }
    }
    return merged;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles_parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles_loadSharedConfigFiles(init);
    return mergeConfigFiles_mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/dist-es/constants.js
const EXPIRE_WINDOW_MS = 5 * 60 * 1000;
const REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/dist-es/getSsoOidcClient.js
const ssoOidcClientsHash = {};
const getSsoOidcClient = async (ssoRegion) => {
    const { SSOOIDCClient } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 8565));
    if (ssoOidcClientsHash[ssoRegion]) {
        return ssoOidcClientsHash[ssoRegion];
    }
    const ssoOidcClient = new SSOOIDCClient({ region: ssoRegion });
    ssoOidcClientsHash[ssoRegion] = ssoOidcClient;
    return ssoOidcClient;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js

const getNewSsoOidcToken = async (ssoToken, ssoRegion) => {
    const { CreateTokenCommand } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 8565));
    const ssoOidcClient = await getSsoOidcClient(ssoRegion);
    return ssoOidcClient.send(new CreateTokenCommand({
        clientId: ssoToken.clientId,
        clientSecret: ssoToken.clientSecret,
        refreshToken: ssoToken.refreshToken,
        grantType: "refresh_token",
    }));
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/dist-es/validateTokenExpiry.js


const validateTokenExpiry = (token) => {
    if (token.expiration && token.expiration.getTime() < Date.now()) {
        throw new TokenProviderError_TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/dist-es/validateTokenKey.js


const validateTokenKey = (key, value, forRefresh = false) => {
    if (typeof value === "undefined") {
        throw new TokenProviderError_TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE}`, false);
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js


const { writeFile } = external_fs_.promises;
const writeSSOTokenToFile = (id, ssoToken) => {
    const tokenFilepath = getSSOTokenFilepath_getSSOTokenFilepath(id);
    const tokenString = JSON.stringify(ssoToken, null, 2);
    return writeFile(tokenFilepath, tokenString);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/token-providers/dist-es/fromSso.js







const lastRefreshAttemptTime = new Date(0);
const fromSso = (init = {}) => async () => {
    init.logger?.debug("@aws-sdk/token-providers", "fromSso");
    const profiles = await parseKnownFiles_parseKnownFiles(init);
    const profileName = getProfileName_getProfileName(init);
    const profile = profiles[profileName];
    if (!profile) {
        throw new TokenProviderError_TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
    }
    else if (!profile["sso_session"]) {
        throw new TokenProviderError_TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
    }
    const ssoSessionName = profile["sso_session"];
    const ssoSessions = await loadSsoSessionData_loadSsoSessionData(init);
    const ssoSession = ssoSessions[ssoSessionName];
    if (!ssoSession) {
        throw new TokenProviderError_TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
    }
    for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
        if (!ssoSession[ssoSessionRequiredKey]) {
            throw new TokenProviderError_TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
        }
    }
    const ssoStartUrl = ssoSession["sso_start_url"];
    const ssoRegion = ssoSession["sso_region"];
    let ssoToken;
    try {
        ssoToken = await getSSOTokenFromFile_getSSOTokenFromFile(ssoSessionName);
    }
    catch (e) {
        throw new TokenProviderError_TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`, false);
    }
    validateTokenKey("accessToken", ssoToken.accessToken);
    validateTokenKey("expiresAt", ssoToken.expiresAt);
    const { accessToken, expiresAt } = ssoToken;
    const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
    if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) {
        return existingToken;
    }
    if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1000) {
        validateTokenExpiry(existingToken);
        return existingToken;
    }
    validateTokenKey("clientId", ssoToken.clientId, true);
    validateTokenKey("clientSecret", ssoToken.clientSecret, true);
    validateTokenKey("refreshToken", ssoToken.refreshToken, true);
    try {
        lastRefreshAttemptTime.setTime(Date.now());
        const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion);
        validateTokenKey("accessToken", newSsoOidcToken.accessToken);
        validateTokenKey("expiresIn", newSsoOidcToken.expiresIn);
        const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);
        try {
            await writeSSOTokenToFile(ssoSessionName, {
                ...ssoToken,
                accessToken: newSsoOidcToken.accessToken,
                expiresAt: newTokenExpiration.toISOString(),
                refreshToken: newSsoOidcToken.refreshToken,
            });
        }
        catch (error) {
        }
        return {
            token: newSsoOidcToken.accessToken,
            expiration: newTokenExpiration,
        };
    }
    catch (error) {
        validateTokenExpiry(existingToken);
        return existingToken;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js



const SHOULD_FAIL_CREDENTIAL_CHAIN = false;
const resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, clientConfig, profile, }) => {
    let token;
    const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
    if (ssoSession) {
        try {
            const _token = await fromSso({ profile })();
            token = {
                accessToken: _token.token,
                expiresAt: new Date(_token.expiration).toISOString(),
            };
        }
        catch (e) {
            throw new CredentialsProviderError(e.message, SHOULD_FAIL_CREDENTIAL_CHAIN);
        }
    }
    else {
        try {
            token = await getSSOTokenFromFile(ssoStartUrl);
        }
        catch (e) {
            throw new CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
        }
    }
    if (new Date(token.expiresAt).getTime() - Date.now() <= 0) {
        throw new CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    const { accessToken } = token;
    const { SSOClient, GetRoleCredentialsCommand } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 4170));
    const sso = ssoClient ||
        new SSOClient(Object.assign({}, clientConfig ?? {}, {
            region: clientConfig?.region ?? ssoRegion,
        }));
    let ssoResp;
    try {
        ssoResp = await sso.send(new GetRoleCredentialsCommand({
            accountId: ssoAccountId,
            roleName: ssoRoleName,
            accessToken,
        }));
    }
    catch (e) {
        throw CredentialsProviderError.from(e, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration, credentialScope } = {} } = ssoResp;
    if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
        throw new CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    return { accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration), credentialScope };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/dist-es/validateSsoProfile.js

const validateSsoProfile = (profile) => {
    const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
    if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
        throw new CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", ` +
            `"sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}\nReference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
    }
    return profile;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/dist-es/fromSSO.js





const fromSSO = (init = {}) => async () => {
    init.logger?.debug("@aws-sdk/credential-provider-sso", "fromSSO");
    const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
    const { ssoClient } = init;
    const profileName = getProfileName(init);
    if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
        const profiles = await parseKnownFiles(init);
        const profile = profiles[profileName];
        if (!profile) {
            throw new CredentialsProviderError(`Profile ${profileName} was not found.`);
        }
        if (!isSsoProfile(profile)) {
            throw new CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`);
        }
        if (profile?.sso_session) {
            const ssoSessions = await loadSsoSessionData(init);
            const session = ssoSessions[profile.sso_session];
            const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
            if (ssoRegion && ssoRegion !== session.sso_region) {
                throw new CredentialsProviderError(`Conflicting SSO region` + conflictMsg, false);
            }
            if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
                throw new CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, false);
            }
            profile.sso_region = session.sso_region;
            profile.sso_start_url = session.sso_start_url;
        }
        const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile(profile);
        return resolveSSOCredentials({
            ssoStartUrl: sso_start_url,
            ssoSession: sso_session,
            ssoAccountId: sso_account_id,
            ssoRegion: sso_region,
            ssoRoleName: sso_role_name,
            ssoClient: ssoClient,
            clientConfig: init.clientConfig,
            profile: profileName,
        });
    }
    else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
        throw new CredentialsProviderError("Incomplete configuration. The fromSSO() argument hash must include " +
            '"ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"');
    }
    else {
        return resolveSSOCredentials({
            ssoStartUrl,
            ssoSession,
            ssoAccountId,
            ssoRegion,
            ssoRoleName,
            ssoClient,
            clientConfig: init.clientConfig,
            profile: profileName,
        });
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/dist-es/index.js






/***/ }),

/***/ 4170:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  GetRoleCredentialsCommand: () => (/* reexport */ GetRoleCredentialsCommand),
  SSOClient: () => (/* reexport */ SSOClient)
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
const resolveParamsForS3 = async (endpointParams) => {
    const bucket = endpointParams?.Bucket || "";
    if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if (isArnBucketName(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
            throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
    }
    else if (!isDnsCompatibleBucketName(bucket) ||
        (bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:")) ||
        bucket.toLowerCase() !== bucket ||
        bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
    }
    return endpointParams;
};
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
const DOT_PATTERN = /\./;
const S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
const isArnBucketName = (bucketName) => {
    const [arn, partition, service, , , bucket] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = Boolean(isArn && partition && service && bucket);
    if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return isValidArn;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
    const configProvider = async () => {
        const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
            return configValue();
        }
        return configValue;
    };
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
        return async () => {
            const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
            const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
            return configValue;
        };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
            const endpoint = await configProvider();
            if (endpoint && typeof endpoint === "object") {
                if ("url" in endpoint) {
                    return endpoint.url.href;
                }
                if ("hostname" in endpoint) {
                    const { protocol, hostname, port, path } = endpoint;
                    return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
                }
            }
            return endpoint;
        };
    }
    return configProvider;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/property-provider/dist-es/fromStatic.js
const fromStatic = (staticValue) => () => Promise.resolve(staticValue);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/property-provider/dist-es/memoize.js
const memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-config-provider/dist-es/fromEnv.js

const fromEnv = (envVarSelector) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
};

// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${external_path_.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0,external_os_.homedir)();
    return homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = createHash("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile } = external_fs_.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/types/dist-es/http.js
var http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(http_FieldPosition || (http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/types/dist-es/middleware.js
const SMITHY_CONTEXT_KEY = "__smithy_context";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/types/dist-es/profile.js
var profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(profile_IniSectionType || (profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(profile_IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === profile_IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath_getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(profile_IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: slurpFile_readFile } = external_fs_.promises;
const filePromisesHash = {};
const slurpFile_slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = slurpFile_readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const swallowError = () => ({});
const loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles_loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath_getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile_slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile_slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js


const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = getProfileName(init);
    const { configFile, credentialsFile } = await loadSharedConfigFiles_loadSharedConfigFiles(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message ||
            `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-config-provider/dist-es/fromStatic.js

const isFunction = (func) => typeof func === "function";
const fromStatic_fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : fromStatic(defaultValue);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-config-provider/dist-es/configLoader.js




const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize(chain(fromEnv(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic_fromStatic(defaultValue)));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-config-provider/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointUrlConfig.js

const ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
const CONFIG_ENDPOINT_URL = "endpoint_url";
const getEndpointUrlConfig = (serviceId) => ({
    environmentVariableSelector: (env) => {
        const serviceSuffixParts = serviceId.split(" ").map((w) => w.toUpperCase());
        const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
        if (serviceEndpointUrl)
            return serviceEndpointUrl;
        const endpointUrl = env[ENV_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    configFileSelector: (profile, config) => {
        if (config && profile.services) {
            const servicesSection = config[["services", profile.services].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR)];
            if (servicesSection) {
                const servicePrefixParts = serviceId.split(" ").map((w) => w.toLowerCase());
                const endpointUrl = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR)];
                if (endpointUrl)
                    return endpointUrl;
            }
        }
        const endpointUrl = profile[CONFIG_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    default: undefined,
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.js


const getEndpointFromConfig = async (serviceId) => loadConfig(getEndpointUrlConfig(serviceId))();

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
        for (const pair of querystring.split("&")) {
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
                value = decodeURIComponent(value);
            }
            if (!(key in query)) {
                query[key] = value;
            }
            else if (Array.isArray(query[key])) {
                query[key].push(value);
            }
            else {
                query[key] = [query[key], value];
            }
        }
    }
    return query;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/url-parser/dist-es/index.js

const parseUrl = (url) => {
    if (typeof url === "string") {
        return parseUrl(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
        query = parseQueryString(search);
    }
    return {
        hostname,
        port: port ? parseInt(port) : undefined,
        protocol,
        path: pathname,
        query,
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js

const toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
        if ("url" in endpoint) {
            return parseUrl(endpoint.url);
        }
        return endpoint;
    }
    return parseUrl(endpoint);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js




const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.endpoint) {
        const endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId || "");
        if (endpointFromConfig) {
            clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
        }
    }
    const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
};
const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
            case "staticContextParams":
                endpointParams[name] = instruction.value;
                break;
            case "contextParams":
                endpointParams[name] = commandInput[instruction.name];
                break;
            case "clientContextParams":
            case "builtInParams":
                endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
                break;
            default:
                throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
    }
    if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await resolveParamsForS3(endpointParams);
    }
    return endpointParams;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js

const getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-middleware/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js


const endpointMiddleware = ({ config, instructions, }) => {
    return (next, context) => async (args) => {
        const endpoint = await getEndpointFromInstructions(args.input, {
            getEndpointParameterInstructions() {
                return instructions;
            },
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
            context["signing_region"] = authScheme.signingRegion;
            context["signing_service"] = authScheme.signingName;
            const smithyContext = getSmithyContext(context);
            const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
            if (httpAuthOption) {
                httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
                    signing_region: authScheme.signingRegion,
                    signingRegion: authScheme.signingRegion,
                    signing_service: authScheme.signingName,
                    signingName: authScheme.signingName,
                    signingRegionSet: authScheme.signingRegionSet,
                }, authScheme.properties);
            }
        }
        return next({
            ...args,
        });
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
const deserializerMiddleware = (options, deserializer) => (next) => async (args) => {
    const { response } = await next(args);
    try {
        const parsed = await deserializer(response, options);
        return {
            response,
            output: parsed,
        };
    }
    catch (error) {
        Object.defineProperty(error, "$response", {
            value: response,
        });
        if (!("$metadata" in error)) {
            const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
            error.message += "\n  " + hint;
            if (typeof error.$responseBodyText !== "undefined") {
                if (error.$response) {
                    error.$response.body = error.$responseBodyText;
                }
            }
        }
        throw error;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    const endpoint = context.endpointV2?.url && options.urlParser
        ? async () => options.urlParser(context.endpointV2.url)
        : options.endpoint;
    if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
        ...args,
        request,
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js


const deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true,
};
const serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true,
};
function getSerdePlugin(config, serializer, deserializer) {
    return {
        applyToStack: (commandStack) => {
            commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
            commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
        },
    };
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-serde/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js


const endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: serializerMiddlewareOption.name,
};
const getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(endpointMiddleware({
            config,
            instructions,
        }), endpointMiddlewareOptions);
    },
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js


const resolveEndpointConfig = (input) => {
    const tls = input.tls ?? true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    return {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
        useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-endpoint/dist-es/index.js






;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
class NoOpLogger {
    trace() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
const getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo(constructStack()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo(constructStack());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                const step = mw.step ??
                    mw.relation +
                        " " +
                        mw.toMiddleware;
                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/middleware-stack/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/client.js

class Client {
    constructor(config) {
        this.middlewareStack = constructStack();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/is-array-buffer/dist-es/index.js
const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// EXTERNAL MODULE: external "buffer"
var external_buffer_ = __webpack_require__(181);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-buffer-from/dist-es/index.js


const dist_es_fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return external_buffer_.Buffer.from(input, offset, length);
};
const fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? external_buffer_.Buffer.from(input, encoding) : external_buffer_.Buffer.from(input);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-base64/dist-es/fromBase64.js

const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64_fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = fromString(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js

const fromUtf8_fromUtf8 = (input) => {
    const buf = fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js

const toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-utf8/dist-es/toUtf8.js

const toUtf8_toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return dist_es_fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-utf8/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-base64/dist-es/toBase64.js


const toBase64_toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
        input = fromUtf8_fromUtf8(_input);
    }
    else {
        input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return dist_es_fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-base64/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-stream/dist-es/blob/transforms.js



function transforms_transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return toBase64(payload);
    }
    return toUtf8(payload);
}
function transforms_transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js

class Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter extends (/* unused pure expression or super */ null && (Uint8Array)) {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return transformFromString(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
    }
}

// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(2203);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.js

const getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
const getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
    let httpHandler = runtimeConfig.httpHandler;
    return {
        setHttpHandler(handler) {
            httpHandler = handler;
        },
        httpHandler() {
            return httpHandler;
        },
        updateHttpClientConfig(key, value) {
            httpHandler.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
            return httpHandler.httpHandlerConfigs();
        },
    };
};
const resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
    return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/protocol-http/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/protocol-http/dist-es/httpResponse.js
class httpResponse_HttpResponse {
    constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/protocol-http/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/querystring-builder/dist-es/index.js

function dist_es_buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = escapeUri(key);
        if (Array.isArray(value)) {
            for (let i = 0, iLen = value.length; i < iLen; i++) {
                parts.push(`${key}=${escapeUri(value[i])}`);
            }
        }
        else {
            let qsEntry = key;
            if (value || typeof value === "string") {
                qsEntry += `=${escapeUri(value)}`;
            }
            parts.push(qsEntry);
        }
    }
    return parts.join("&");
}

// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(8611);
// EXTERNAL MODULE: external "https"
var external_https_ = __webpack_require__(5692);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/constants.js
const NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/get-transformed-headers.js
const get_transformed_headers_getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
};


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/set-connection-timeout.js
const setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
        return;
    }
    const timeoutId = setTimeout(() => {
        request.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
            name: "TimeoutError",
        }));
    }, timeoutInMs);
    request.on("socket", (socket) => {
        if (socket.connecting) {
            socket.on("connect", () => {
                clearTimeout(timeoutId);
            });
        }
        else {
            clearTimeout(timeoutId);
        }
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/set-socket-keep-alive.js
const setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }) => {
    if (keepAlive !== true) {
        return;
    }
    request.on("socket", (socket) => {
        socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/set-socket-timeout.js
const setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    request.setTimeout(timeoutInMs, () => {
        request.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/write-request-body.js

const MIN_WAIT_TIME = 1000;
async function write_request_body_writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", () => {
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            }),
        ]);
    }
    if (!hasError) {
        writeBody(httpRequest, request.body);
    }
}
function writeBody(httpRequest, body) {
    if (body instanceof external_stream_.Readable) {
        body.pipe(httpRequest);
        return;
    }
    if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
            httpRequest.end(body);
            return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" &&
            uint8.buffer &&
            typeof uint8.byteOffset === "number" &&
            typeof uint8.byteLength === "number") {
            httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
            return;
        }
        httpRequest.end(Buffer.from(body));
        return;
    }
    httpRequest.end();
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js










const DEFAULT_REQUEST_TIMEOUT = 0;
class NodeHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
            return socketWarningTimestamp;
        }
        const interval = 15000;
        if (Date.now() - interval < socketWarningTimestamp) {
            return socketWarningTimestamp;
        }
        if (sockets && requests) {
            for (const origin in sockets) {
                const socketsInUse = sockets[origin]?.length ?? 0;
                const requestsEnqueued = requests[origin]?.length ?? 0;
                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
                    console.warn("@smithy/node-http-handler:WARN", `socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.`, "See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html", "or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.");
                    return Date.now();
                }
            }
        }
        return socketWarningTimestamp;
    }
    constructor(options) {
        this.socketWarningTimestamp = 0;
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout ?? socketTimeout,
            httpAgent: (() => {
                if (httpAgent instanceof external_http_.Agent || typeof httpAgent?.destroy === "function") {
                    return httpAgent;
                }
                return new external_http_.Agent({ keepAlive, maxSockets, ...httpAgent });
            })(),
            httpsAgent: (() => {
                if (httpsAgent instanceof external_https_.Agent || typeof httpsAgent?.destroy === "function") {
                    return httpsAgent;
                }
                return new external_https_.Agent({ keepAlive, maxSockets, ...httpsAgent });
            })(),
        };
    }
    destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        let socketCheckTimeoutId;
        return new Promise((_resolve, _reject) => {
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                clearTimeout(socketCheckTimeoutId);
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
            socketCheckTimeoutId = setTimeout(() => {
                this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp);
            }, this.config.socketAcquisitionWarningTimeout ??
                (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000));
            const queryString = dist_es_buildQueryString(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent,
                auth,
            };
            const requestFunc = isSSL ? external_https_.request : external_http_.request;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new httpResponse_HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: get_transformed_headers_getTransformedHeaders(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            setConnectionTimeout(req, reject, this.config.connectionTimeout);
            setSocketTimeout(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                setSocketKeepAlive(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                });
            }
            writeRequestBodyPromise = write_request_body_writeRequestBody(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

// EXTERNAL MODULE: external "http2"
var external_http2_ = __webpack_require__(5675);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
class node_http2_connection_pool_NodeHttp2ConnectionPool {
    constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions ?? [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-manager.js


class node_http2_connection_manager_NodeHttp2ConnectionManager {
    constructor(config) {
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/node-http2-handler.js






class NodeHttp2Handler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal?.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: this.config?.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = buildQueryString(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [constants.HTTP2_HEADER_PATH]: path,
                [constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: getTransformedHeaders(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js

class Collector extends external_stream_.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js

const stream_collector_streamCollector = (stream) => {
    if (isReadableStreamInstance(stream)) {
        return collectReadableStream(stream);
    }
    return new Promise((resolve, reject) => {
        const collector = new Collector();
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
            resolve(bytes);
        });
    });
};
const isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
async function collectReadableStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/node-http-handler/dist-es/index.js




// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(9023);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js



const keepAliveSupport = {
    supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
};
class FetchHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
        if (typeof options === "function") {
            this.configProvider = options().then((opts) => opts || {});
        }
        else {
            this.config = options ?? {};
            this.configProvider = Promise.resolve(this.config);
        }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        const requestTimeoutInMs = this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = buildQueryString(request.query || {});
        if (queryString) {
            path += `?${queryString}`;
        }
        if (request.fragment) {
            path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? undefined : request.body;
        const requestOptions = {
            body,
            headers: new Headers(request.headers),
            method: method,
        };
        if (body) {
            requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
            requestOptions.signal = abortSignal;
        }
        if (keepAliveSupport.supported) {
            requestOptions.keepalive = keepAlive;
        }
        const fetchRequest = new Request(url, requestOptions);
        const raceOfPromises = [
            fetch(fetchRequest).then((response) => {
                const fetchHeaders = response.headers;
                const transformedHeaders = {};
                for (const pair of fetchHeaders.entries()) {
                    transformedHeaders[pair[0]] = pair[1];
                }
                const hasReadableStream = response.body != undefined;
                if (!hasReadableStream) {
                    return response.blob().then((body) => ({
                        response: new HttpResponse({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body,
                        }),
                    }));
                }
                return {
                    response: new HttpResponse({
                        headers: transformedHeaders,
                        reason: response.statusText,
                        statusCode: response.status,
                        body: response.body,
                    }),
                };
            }),
            requestTimeout(requestTimeoutInMs),
        ];
        if (abortSignal) {
            raceOfPromises.push(new Promise((resolve, reject) => {
                abortSignal.onabort = () => {
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }));
        }
        return Promise.race(raceOfPromises);
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            config[key] = value;
            return config;
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js

const dist_es_stream_collector_streamCollector = (stream) => {
    if (typeof Blob === "function" && stream instanceof Blob) {
        return collectBlob(stream);
    }
    return collectStream(stream);
};
async function collectBlob(blob) {
    const base64 = await readToBase64(blob);
    const arrayBuffer = fromBase64(base64);
    return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}
function readToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (reader.readyState !== 2) {
                return reject(new Error("Reader aborted too early"));
            }
            const result = (reader.result ?? "");
            const commaIndex = result.indexOf(",");
            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
            resolve(result.substring(dataOffset));
        };
        reader.onabort = () => reject(new Error("Read aborted"));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
    });
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/fetch-http-handler/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-hex-encoding/dist-es/index.js
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function dist_es_toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js




const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    if (!isBlobInstance(stream) && !sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
            throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" +
                "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
    };
    return Object.assign(stream, {
        transformToByteArray: transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === "base64") {
                return toBase64(buf);
            }
            else if (encoding === "hex") {
                return toHex(buf);
            }
            else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
                return toUtf8(buf);
            }
            else if (typeof TextDecoder === "function") {
                return new TextDecoder(encoding).decode(buf);
            }
            else {
                throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            transformed = true;
            if (isBlobInstance(stream)) {
                return blobToWebStream(stream);
            }
            else if (sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
                return stream;
            }
            else {
                throw new Error(`Cannot transform payload to web stream, got ${stream}`);
            }
        },
    });
};
const isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
const sdk_stream_mixin_browser_isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js





const sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdk_stream_mixin_sdkStreamMixin = (stream) => {
    if (!(stream instanceof Readable)) {
        try {
            return sdkStreamMixinReadableStream(stream);
        }
        catch (e) {
            const name = stream?.__proto__?.constructor?.name || stream;
            throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return Readable.toWeb(stream);
        },
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/util-stream/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js

const collect_stream_body_collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/command.js


class Command {
    constructor() {
        this.middlewareStack = constructStack();
    }
    static classBuilder() {
        return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [SMITHY_CONTEXT_KEY]: {
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
class ClassBuilder {
    constructor() {
        this._init = () => { };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
    }
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends Command {
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(...[input]) {
                super();
                this.serialize = closure._serializer;
                this.deserialize = closure._deserializer;
                this.input = input ?? {};
                closure._init(this);
            }
            resolveMiddleware(stack, configuration, options) {
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/constants.js
const constants_SENSITIVE_STRING = "***SensitiveInformation***";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/parse-utils.js
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
const expectInt = (/* unused pure expression or super */ null && (expectLong));
const expectInt32 = (value) => expectSizedInt(value, 32);
const expectShort = (value) => expectSizedInt(value, 16);
const expectByte = (value) => expectSizedInt(value, 8);
const expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = expectObject(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
const parse_utils_strictParseDouble = (value) => {
    if (typeof value == "string") {
        return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
};
const strictParseFloat = (/* unused pure expression or super */ null && (parse_utils_strictParseDouble));
const parse_utils_strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
};
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectNumber(value);
};
const handleFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectFloat32(value);
};
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value) => {
    if (typeof value === "string") {
        return expectLong(parseNumber(value));
    }
    return expectLong(value);
};
const strictParseInt = (/* unused pure expression or super */ null && (strictParseLong));
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
};
const parse_utils_strictParseShort = (value) => {
    if (typeof value === "string") {
        return expectShort(parseNumber(value));
    }
    return expectShort(value);
};
const parse_utils_strictParseByte = (value) => {
    if (typeof value === "string") {
        return expectByte(parseNumber(value));
    }
    return expectByte(value);
};
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
const logger = {
    warn: console.warn,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/date-utils.js

const DAYS = (/* unused pure expression or super */ null && (["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]));
const MONTHS = (/* unused pure expression or super */ null && (["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]));
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
const RFC3339 = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/)));
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
const RFC3339_WITH_OFFSET = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/)));
const parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
const IMF_FIXDATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const RFC_850_DATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const ASC_TIME = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/)));
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = (/* unused pure expression or super */ null && (50 * 365 * 24 * 60 * 60 * 1000));
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = (/* unused pure expression or super */ null && ([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]));
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/exceptions.js
class ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
const decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/default-error-handler.js

const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw decorateServiceException(response, parsedBody);
};
const withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
const loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
        case "standard":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "in-region":
            return {
                retryMode: "standard",
                connectionTimeout: 1100,
            };
        case "cross-region":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "mobile":
            return {
                retryMode: "standard",
                connectionTimeout: 30000,
            };
        default:
            return {};
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
let warningEmitted = false;
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
        warningEmitted = true;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js


const extensions_checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in AlgorithmId) {
        const algorithmId = AlgorithmId[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const extensions_checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
const getRetryConfiguration = (runtimeConfig) => {
    let _retryStrategy = runtimeConfig.retryStrategy;
    return {
        setRetryStrategy(retryStrategy) {
            _retryStrategy = retryStrategy;
        },
        retryStrategy() {
            return _retryStrategy;
        },
    };
};
const resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js


const getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
        ...extensions_checksum_getChecksumConfiguration(runtimeConfig),
        ...getRetryConfiguration(runtimeConfig),
    };
};
const defaultExtensionConfiguration_getDefaultClientConfiguration = (/* unused pure expression or super */ null && (getDefaultExtensionConfiguration));
const defaultExtensionConfiguration_resolveDefaultRuntimeConfig = (config) => {
    return {
        ...extensions_checksum_resolveChecksumRuntimeConfig(config),
        ...resolveRetryRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/lazy-json.js
const StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(StringWrapper, String);
class LazyJsonString extends (/* unused pure expression or super */ null && (StringWrapper)) {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
        }
        return new LazyJsonString(JSON.stringify(object));
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/object-mapping.js
function object_mapping_map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
        target = {};
        instructions = arg0;
    }
    else {
        target = arg0;
        if (typeof arg1 === "function") {
            filter = arg1;
            instructions = arg2;
            return mapWithFilter(target, filter, instructions);
        }
        else {
            instructions = arg1;
        }
    }
    for (const key of Object.keys(instructions)) {
        if (!Array.isArray(instructions[key])) {
            target[key] = instructions[key];
            continue;
        }
        applyInstruction(target, null, instructions, key);
    }
    return target;
}
const convertMap = (target) => {
    const output = {};
    for (const [k, v] of Object.entries(target || {})) {
        output[k] = [, v];
    }
    return output;
};
const object_mapping_take = (source, instructions) => {
    const out = {};
    for (const key in instructions) {
        applyInstruction(out, source, instructions, key);
    }
    return out;
};
const mapWithFilter = (target, filter, instructions) => {
    return object_mapping_map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
            _instructions[key] = value;
        }
        else {
            if (typeof value === "function") {
                _instructions[key] = [filter, value()];
            }
            else {
                _instructions[key] = [filter, value];
            }
        }
        return _instructions;
    }, {}));
};
const applyInstruction = (target, source, instructions, targetKey) => {
    if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
            instruction = [, instruction];
        }
        const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if ((typeof filter === "function" && filter(source[sourceKey])) || (typeof filter !== "function" && !!filter)) {
            target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter === undefined && (_value = value()) != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed) {
            target[targetKey] = _value;
        }
        else if (customFilterPassed) {
            target[targetKey] = value();
        }
    }
    else {
        const defaultFilterPassed = filter === undefined && value != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed || customFilterPassed) {
            target[targetKey] = value;
        }
    }
};
const nonNullish = (_) => _ != null;
const pass = (_) => _;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/serde-json.js
const serde_json_json = (obj) => {
    if (obj == null) {
        return {};
    }
    if (Array.isArray(obj)) {
        return obj.filter((_) => _ != null).map(serde_json_json);
    }
    if (typeof obj === "object") {
        const target = {};
        for (const key of Object.keys(obj)) {
            if (obj[key] == null) {
                continue;
            }
            target[key] = serde_json_json(obj[key]);
        }
        return target;
    }
    return obj;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/node_modules/@smithy/smithy-client/dist-es/index.js























;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "awsssoportal",
    };
};
const commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/models/SSOServiceException.js


class SSOServiceException extends ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, SSOServiceException.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/models/models_0.js


class InvalidRequestException extends SSOServiceException {
    constructor(opts) {
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequestException.prototype);
    }
}
class ResourceNotFoundException extends SSOServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
}
class TooManyRequestsException extends SSOServiceException {
    constructor(opts) {
        super({
            name: "TooManyRequestsException",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyRequestsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyRequestsException.prototype);
    }
}
class UnauthorizedException extends SSOServiceException {
    constructor(opts) {
        super({
            name: "UnauthorizedException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnauthorizedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
}
const GetRoleCredentialsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: constants_SENSITIVE_STRING }),
});
const RoleCredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.secretAccessKey && { secretAccessKey: constants_SENSITIVE_STRING }),
    ...(obj.sessionToken && { sessionToken: constants_SENSITIVE_STRING }),
});
const GetRoleCredentialsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.roleCredentials && { roleCredentials: RoleCredentialsFilterSensitiveLog(obj.roleCredentials) }),
});
const ListAccountRolesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: SENSITIVE_STRING }),
});
const ListAccountsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: SENSITIVE_STRING }),
});
const LogoutRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: SENSITIVE_STRING }),
});

// EXTERNAL MODULE: ./node_modules/@aws-sdk/core/dist-cjs/index.js
var dist_cjs = __webpack_require__(5685);
// EXTERNAL MODULE: ./node_modules/@smithy/core/dist-es/index.js + 110 modules
var dist_es = __webpack_require__(2073);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/protocols/Aws_restJson1.js





const se_GetRoleCredentialsCommand = async (input, context) => {
    const b = (0,dist_es.requestBuilder)(input, context);
    const headers = object_mapping_map({}, isSerializableHeaderValue, {
        [_xasbt]: input[_aT],
    });
    b.bp("/federation/credentials");
    const query = object_mapping_map({
        [_rn]: [, expectNonNull(input[_rN], `roleName`)],
        [_ai]: [, expectNonNull(input[_aI], `accountId`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
const se_ListAccountRolesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xasbt]: input[_aT],
    });
    b.bp("/assignment/roles");
    const query = map({
        [_nt]: [, input[_nT]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_ai]: [, __expectNonNull(input[_aI], `accountId`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
const se_ListAccountsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xasbt]: input[_aT],
    });
    b.bp("/assignment/accounts");
    const query = map({
        [_nt]: [, input[_nT]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
const se_LogoutCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xasbt]: input[_aT],
    });
    b.bp("/logout");
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
const de_GetRoleCredentialsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = object_mapping_map({
        $metadata: Aws_restJson1_deserializeMetadata(output),
    });
    const data = expectNonNull(expectObject(await (0,dist_cjs.parseJsonBody)(output.body, context)), "body");
    const doc = object_mapping_take(data, {
        roleCredentials: serde_json_json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListAccountRolesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: Aws_restJson1_deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        roleList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListAccountsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: Aws_restJson1_deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accountList: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_LogoutCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: Aws_restJson1_deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await (0,dist_cjs.parseJsonErrorBody)(output.body, context),
    };
    const errorCode = (0,dist_cjs.loadRestJsonErrorCode)(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return Aws_restJson1_throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const Aws_restJson1_throwDefaultError = withBaseException(SSOServiceException);
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        message: expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        message: expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        message: expectString,
    });
    Object.assign(contents, doc);
    const exception = new TooManyRequestsException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = object_mapping_map({});
    const data = parsedOutput.body;
    const doc = object_mapping_take(data, {
        message: expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedException({
        $metadata: Aws_restJson1_deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const Aws_restJson1_deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _aI = "accountId";
const _aT = "accessToken";
const _ai = "account_id";
const _mR = "maxResults";
const _mr = "max_result";
const _nT = "nextToken";
const _nt = "next_token";
const _rN = "roleName";
const _rn = "role_name";
const _xasbt = "x-amz-sso_bearer_token";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js







class GetRoleCredentialsCommand extends Command
    .classBuilder()
    .ep({
    ...commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("SWBPortalService", "GetRoleCredentials", {})
    .n("SSOClient", "GetRoleCredentialsCommand")
    .f(GetRoleCredentialsRequestFilterSensitiveLog, GetRoleCredentialsResponseFilterSensitiveLog)
    .ser(se_GetRoleCredentialsCommand)
    .de(de_GetRoleCredentialsCommand)
    .build() {
}

// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-host-header/dist-es/index.js + 14 modules
var middleware_host_header_dist_es = __webpack_require__(9813);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-logger/dist-es/index.js + 1 modules
var middleware_logger_dist_es = __webpack_require__(9359);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js + 14 modules
var middleware_recursion_detection_dist_es = __webpack_require__(2163);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js + 17 modules
var middleware_user_agent_dist_es = __webpack_require__(4725);
// EXTERNAL MODULE: ./node_modules/@smithy/config-resolver/dist-es/index.js + 26 modules
var config_resolver_dist_es = __webpack_require__(7373);
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-content-length/dist-es/index.js + 14 modules
var middleware_content_length_dist_es = __webpack_require__(9587);
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-retry/dist-es/index.js + 69 modules
var middleware_retry_dist_es = __webpack_require__(2467);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/auth/httpAuthSchemeProvider.js


const defaultSSOHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
        operation: getSmithyContext(context).operation,
        region: (await normalizeProvider(config.region)()) ||
            (() => {
                throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
            })(),
    };
};
function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
            name: "awsssoportal",
            region: authParameters.region,
        },
        propertiesExtractor: (config, context) => ({
            signingProperties: {
                config,
                context,
            },
        }),
    };
}
function createSmithyApiNoAuthHttpAuthOption(authParameters) {
    return {
        schemeId: "smithy.api#noAuth",
    };
}
const defaultSSOHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
        case "GetRoleCredentials": {
            options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
            break;
        }
        case "ListAccountRoles": {
            options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
            break;
        }
        case "ListAccounts": {
            options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
            break;
        }
        case "Logout": {
            options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
            break;
        }
        default: {
            options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
        }
    }
    return options;
};
const resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = (0,dist_cjs.resolveAwsSdkSigV4Config)(config);
    return {
        ...config_0,
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/package.json
const package_namespaceObject = {"rE":"3.582.0"};
// EXTERNAL MODULE: ./node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js + 40 modules
var util_user_agent_node_dist_es = __webpack_require__(4733);
// EXTERNAL MODULE: ./node_modules/@smithy/hash-node/dist-es/index.js + 6 modules
var hash_node_dist_es = __webpack_require__(5914);
// EXTERNAL MODULE: ./node_modules/@smithy/util-body-length-node/dist-es/index.js + 1 modules
var util_body_length_node_dist_es = __webpack_require__(7809);
// EXTERNAL MODULE: ./node_modules/@smithy/util-retry/dist-es/index.js + 8 modules
var util_retry_dist_es = __webpack_require__(3323);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/index.js + 9 modules
var util_endpoints_dist_es = __webpack_require__(6652);
// EXTERNAL MODULE: ./node_modules/@smithy/util-endpoints/dist-es/index.js + 45 modules
var _smithy_util_endpoints_dist_es = __webpack_require__(6275);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/endpoint/ruleset.js
const u = "required", v = "fn", w = "argv", x = "ref";
const a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = "getAttr", i = { [u]: false, "type": "String" }, j = { [u]: true, "default": false, "type": "Boolean" }, k = { [x]: "Endpoint" }, l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] }, m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] }, n = {}, o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] }, p = { [x]: g }, q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] }, r = [l], s = [m], t = [{ [x]: "Region" }];
const _data = { version: "1.0", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
const ruleSet = _data;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/endpoint/endpointResolver.js



const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0,_smithy_util_endpoints_dist_es/* resolveEndpoint */.sO)(ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
_smithy_util_endpoints_dist_es/* customEndpointFunctions */.mw.aws = util_endpoints_dist_es/* awsEndpointFunctions */.UF;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js








const getRuntimeConfig = (config) => {
    return {
        apiVersion: "2019-06-10",
        base64Decoder: config?.base64Decoder ?? fromBase64_fromBase64,
        base64Encoder: config?.base64Encoder ?? toBase64_toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSSOHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                signer: new dist_cjs.AwsSdkSigV4Signer(),
            },
            {
                schemeId: "smithy.api#noAuth",
                identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
                signer: new dist_es.NoAuthSigner(),
            },
        ],
        logger: config?.logger ?? new NoOpLogger(),
        serviceId: config?.serviceId ?? "SSO",
        urlParser: config?.urlParser ?? parseUrl,
        utf8Decoder: config?.utf8Decoder ?? fromUtf8_fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? toUtf8_toUtf8,
    };
};

// EXTERNAL MODULE: ./node_modules/@smithy/util-defaults-mode-node/dist-es/index.js + 40 modules
var util_defaults_mode_node_dist_es = __webpack_require__(2);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.js














const runtimeConfig_getRuntimeConfig = (config) => {
    emitWarningIfUnsupportedVersion(process.version);
    const defaultsMode = (0,util_defaults_mode_node_dist_es/* resolveDefaultsModeConfig */.I)(config);
    const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
    const clientSharedValues = getRuntimeConfig(config);
    (0,dist_cjs.emitWarningIfUnsupportedVersion)(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_dist_es/* calculateBodyLength */.n,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0,util_user_agent_node_dist_es/* defaultUserAgent */.mJ)({ serviceId: clientSharedValues.serviceId, clientVersion: package_namespaceObject.rE }),
        maxAttempts: config?.maxAttempts ?? loadConfig(middleware_retry_dist_es/* NODE_MAX_ATTEMPT_CONFIG_OPTIONS */.qs),
        region: config?.region ?? loadConfig(config_resolver_dist_es/* NODE_REGION_CONFIG_OPTIONS */.GG, config_resolver_dist_es/* NODE_REGION_CONFIG_FILE_OPTIONS */.zH),
        requestHandler: NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ??
            loadConfig({
                ...middleware_retry_dist_es/* NODE_RETRY_MODE_CONFIG_OPTIONS */.kN,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_dist_es/* DEFAULT_RETRY_MODE */.L0,
            }),
        sha256: config?.sha256 ?? hash_node_dist_es/* Hash */.V.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? stream_collector_streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(config_resolver_dist_es/* NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS */.e$),
        useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(config_resolver_dist_es/* NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS */.Ko),
    };
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/region-config-resolver/dist-es/index.js + 3 modules
var region_config_resolver_dist_es = __webpack_require__(4547);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/auth/httpAuthExtensionConfiguration.js
const getHttpAuthExtensionConfiguration = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
const resolveHttpAuthRuntimeConfig = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/runtimeExtensions.js




const asPartial = (t) => t;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial((0,region_config_resolver_dist_es/* getAwsRegionExtensionConfiguration */.Rq)(runtimeConfig)),
        ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
        ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig)),
        ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0,region_config_resolver_dist_es/* resolveAwsRegionExtensionConfiguration */.$3)(extensionConfiguration),
        ...defaultExtensionConfiguration_resolveDefaultRuntimeConfig(extensionConfiguration),
        ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
        ...resolveHttpAuthRuntimeConfig(extensionConfiguration),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js















class SSOClient extends Client {
    constructor(...[configuration]) {
        const _config_0 = runtimeConfig_getRuntimeConfig(configuration || {});
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = (0,config_resolver_dist_es/* resolveRegionConfig */.TD)(_config_1);
        const _config_3 = resolveEndpointConfig(_config_2);
        const _config_4 = (0,middleware_retry_dist_es/* resolveRetryConfig */.$z)(_config_3);
        const _config_5 = (0,middleware_host_header_dist_es/* resolveHostHeaderConfig */.OV)(_config_4);
        const _config_6 = (0,middleware_user_agent_dist_es/* resolveUserAgentConfig */.Dc)(_config_5);
        const _config_7 = resolveHttpAuthSchemeConfig(_config_6);
        const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0,middleware_retry_dist_es/* getRetryPlugin */.ey)(this.config));
        this.middlewareStack.use((0,middleware_content_length_dist_es/* getContentLengthPlugin */.vK)(this.config));
        this.middlewareStack.use((0,middleware_host_header_dist_es/* getHostHeaderPlugin */.TC)(this.config));
        this.middlewareStack.use((0,middleware_logger_dist_es/* getLoggerPlugin */.Y7)(this.config));
        this.middlewareStack.use((0,middleware_recursion_detection_dist_es/* getRecursionDetectionPlugin */.n4)(this.config));
        this.middlewareStack.use((0,middleware_user_agent_dist_es/* getUserAgentPlugin */.sM)(this.config));
        this.middlewareStack.use((0,dist_es.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
            httpAuthSchemeParametersProvider: this.getDefaultHttpAuthSchemeParametersProvider(),
            identityProviderConfigProvider: this.getIdentityProviderConfigProvider(),
        }));
        this.middlewareStack.use((0,dist_es.getHttpSigningPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
    getDefaultHttpAuthSchemeParametersProvider() {
        return defaultSSOHttpAuthSchemeParametersProvider;
    }
    getIdentityProviderConfigProvider() {
        return async (config) => new dist_es.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials,
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-sso/dist-es/loadSso.js




/***/ }),

/***/ 3503:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  fromTokenFile: () => (/* reexport */ fromTokenFile),
  fromWebToken: () => (/* reexport */ fromWebToken)
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-web-identity/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError_ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError_ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-web-identity/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-web-identity/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-web-identity/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-web-identity/node_modules/@smithy/property-provider/dist-es/index.js







// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromWebToken.js
const fromWebToken = (init) => async () => {
    init.logger?.debug("@aws-sdk/credential-provider-web-identity", "fromWebToken");
    const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds } = init;
    let { roleAssumerWithWebIdentity } = init;
    if (!roleAssumerWithWebIdentity) {
        const { getDefaultRoleAssumerWithWebIdentity } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 4276));
        roleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity({
            ...init.clientConfig,
            credentialProviderLogger: init.logger,
            parentClientConfig: init.parentClientConfig,
        }, init.clientPlugins);
    }
    return roleAssumerWithWebIdentity({
        RoleArn: roleArn,
        RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
        WebIdentityToken: webIdentityToken,
        ProviderId: providerId,
        PolicyArns: policyArns,
        Policy: policy,
        DurationSeconds: durationSeconds,
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js



const ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
const ENV_ROLE_ARN = "AWS_ROLE_ARN";
const ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
const fromTokenFile = (init = {}) => async () => {
    init.logger?.debug("@aws-sdk/credential-provider-web-identity", "fromTokenFile");
    const webIdentityTokenFile = init?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE];
    const roleArn = init?.roleArn ?? process.env[ENV_ROLE_ARN];
    const roleSessionName = init?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME];
    if (!webIdentityTokenFile || !roleArn) {
        throw new CredentialsProviderError("Web identity configuration not specified");
    }
    return fromWebToken({
        ...init,
        webIdentityToken: (0,external_fs_.readFileSync)(webIdentityTokenFile, { encoding: "ascii" }),
        roleArn,
        roleSessionName,
    })();
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/credential-provider-web-identity/dist-es/index.js




/***/ }),

/***/ 9813:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  TC: () => (/* binding */ getHostHeaderPlugin),
  OV: () => (/* binding */ resolveHostHeaderConfig)
});

// UNUSED EXPORTS: hostHeaderMiddleware, hostHeaderMiddlewareOptions

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/types/dist-es/http.js
var http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(http_FieldPosition || (http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/node_modules/@smithy/protocol-http/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-host-header/dist-es/index.js

function resolveHostHeaderConfig(input) {
    return input;
}
const hostHeaderMiddleware = (options) => (next) => async (args) => {
    if (!HttpRequest.isInstance(args.request))
        return next(args);
    const { request } = args;
    const { handlerProtocol = "" } = options.requestHandler.metadata || {};
    if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
        delete request.headers["host"];
        request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
    }
    else if (!request.headers["host"]) {
        let host = request.hostname;
        if (request.port != null)
            host += `:${request.port}`;
        request.headers["host"] = host;
    }
    return next(args);
};
const hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true,
};
const getHostHeaderPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
    },
});


/***/ }),

/***/ 9359:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Y7: () => (/* reexport */ getLoggerPlugin)
});

// UNUSED EXPORTS: loggerMiddleware, loggerMiddlewareOptions

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
const loggerMiddleware = () => (next, context) => async (args) => {
    try {
        const response = await next(args);
        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
        const { $metadata, ...outputWithoutMetadata } = response.output;
        logger?.info?.({
            clientName,
            commandName,
            input: inputFilterSensitiveLog(args.input),
            output: outputFilterSensitiveLog(outputWithoutMetadata),
            metadata: $metadata,
        });
        return response;
    }
    catch (error) {
        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        logger?.error?.({
            clientName,
            commandName,
            input: inputFilterSensitiveLog(args.input),
            error,
            metadata: error.$metadata,
        });
        throw error;
    }
};
const loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true,
};
const getLoggerPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
    },
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-logger/dist-es/index.js



/***/ }),

/***/ 2163:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  n4: () => (/* binding */ getRecursionDetectionPlugin)
});

// UNUSED EXPORTS: addRecursionDetectionMiddlewareOptions, recursionDetectionMiddleware

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/types/dist-es/http.js
var http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(http_FieldPosition || (http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/node_modules/@smithy/protocol-http/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js

const TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
const ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
const ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
const recursionDetectionMiddleware = (options) => (next) => async (args) => {
    const { request } = args;
    if (!HttpRequest.isInstance(request) ||
        options.runtime !== "node" ||
        request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
        return next(args);
    }
    const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
    const traceId = process.env[ENV_TRACE_ID];
    const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
    if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
        request.headers[TRACE_ID_HEADER_NAME] = traceId;
    }
    return next({
        ...args,
        request,
    });
};
const addRecursionDetectionMiddlewareOptions = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low",
};
const getRecursionDetectionPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
    },
});


/***/ }),

/***/ 4725:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  sM: () => (/* reexport */ getUserAgentPlugin),
  Dc: () => (/* reexport */ resolveUserAgentConfig)
});

// UNUSED EXPORTS: getUserAgentMiddlewareOptions, userAgentMiddleware

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
function resolveUserAgentConfig(input) {
    return {
        ...input,
        customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
    };
}

// EXTERNAL MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/index.js + 9 modules
var dist_es = __webpack_require__(6652);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/types/dist-es/http.js
var http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(http_FieldPosition || (http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/node_modules/@smithy/protocol-http/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
const USER_AGENT = "user-agent";
const X_AMZ_USER_AGENT = "x-amz-user-agent";
const SPACE = " ";
const UA_NAME_SEPARATOR = "/";
const UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
const UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
const UA_ESCAPE_CHAR = "-";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js



const userAgentMiddleware = (options) => (next, context) => async (args) => {
    const { request } = args;
    if (!HttpRequest.isInstance(request))
        return next(args);
    const { headers } = request;
    const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
    const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
    const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
    const prefix = (0,dist_es/* getUserAgentPrefix */.vL)();
    const sdkUserAgentValue = (prefix ? [prefix] : [])
        .concat([...defaultUserAgent, ...userAgent, ...customUserAgent])
        .join(SPACE);
    const normalUAValue = [
        ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
        ...customUserAgent,
    ].join(SPACE);
    if (options.runtime !== "browser") {
        if (normalUAValue) {
            headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT]
                ? `${headers[USER_AGENT]} ${normalUAValue}`
                : normalUAValue;
        }
        headers[USER_AGENT] = sdkUserAgentValue;
    }
    else {
        headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
    }
    return next({
        ...args,
        request,
    });
};
const escapeUserAgent = (userAgentPair) => {
    const name = userAgentPair[0]
        .split(UA_NAME_SEPARATOR)
        .map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR))
        .join(UA_NAME_SEPARATOR);
    const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
    const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
    const prefix = name.substring(0, prefixSeparatorIndex);
    let uaName = name.substring(prefixSeparatorIndex + 1);
    if (prefix === "api") {
        uaName = uaName.toLowerCase();
    }
    return [prefix, uaName, version]
        .filter((item) => item && item.length > 0)
        .reduce((acc, item, index) => {
        switch (index) {
            case 0:
                return item;
            case 1:
                return `${acc}/${item}`;
            default:
                return `${acc}#${item}`;
        }
    }, "");
};
const getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true,
};
const getUserAgentPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
    },
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js




/***/ }),

/***/ 4547:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Rq: () => (/* reexport */ getAwsRegionExtensionConfiguration),
  $3: () => (/* reexport */ resolveAwsRegionExtensionConfiguration)
});

// UNUSED EXPORTS: NODE_REGION_CONFIG_FILE_OPTIONS, NODE_REGION_CONFIG_OPTIONS, REGION_ENV_NAME, REGION_INI_NAME, resolveRegionConfig

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/region-config-resolver/dist-es/extensions/index.js
const getAwsRegionExtensionConfiguration = (runtimeConfig) => {
    let runtimeConfigRegion = async () => {
        if (runtimeConfig.region === undefined) {
            throw new Error("Region is missing from runtimeConfig");
        }
        const region = runtimeConfig.region;
        if (typeof region === "string") {
            return region;
        }
        return region();
    };
    return {
        setRegion(region) {
            runtimeConfigRegion = region;
        },
        region() {
            return runtimeConfigRegion;
        },
    };
};
const resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
    return {
        region: awsRegionExtensionConfiguration.region(),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/config.js
const REGION_ENV_NAME = "AWS_REGION";
const REGION_INI_NAME = "region";
const NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[REGION_ENV_NAME],
    configFileSelector: (profile) => profile[REGION_INI_NAME],
    default: () => {
        throw new Error("Region is missing");
    },
};
const NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials",
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/region-config-resolver/dist-es/index.js




/***/ }),

/***/ 6652:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  UF: () => (/* reexport */ awsEndpointFunctions),
  vL: () => (/* reexport */ getUserAgentPrefix)
});

// UNUSED EXPORTS: EndpointError, isIpAddress, partition, resolveEndpoint, setPartitionInfo, useDefaultPartitionInfo

// EXTERNAL MODULE: ./node_modules/@smithy/util-endpoints/dist-es/index.js + 45 modules
var dist_es = __webpack_require__(6275);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js


const isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
    if (allowSubDomains) {
        for (const label of value.split(".")) {
            if (!isVirtualHostableS3Bucket(label)) {
                return false;
            }
        }
        return true;
    }
    if (!(0,dist_es/* isValidHostLabel */.X8)(value)) {
        return false;
    }
    if (value.length < 3 || value.length > 63) {
        return false;
    }
    if (value !== value.toLowerCase()) {
        return false;
    }
    if ((0,dist_es/* isIpAddress */.oX)(value)) {
        return false;
    }
    return true;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
const parseArn = (value) => {
    const segments = value.split(":");
    if (segments.length < 6)
        return null;
    const [arn, partition, service, region, accountId, ...resourceId] = segments;
    if (arn !== "arn" || partition === "" || service === "" || resourceId[0] === "")
        return null;
    return {
        partition,
        service,
        region,
        accountId,
        resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId,
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
const partitions_namespaceObject = /*#__PURE__*/JSON.parse('{"partitions":[{"id":"aws","outputs":{"dnsSuffix":"amazonaws.com","dualStackDnsSuffix":"api.aws","implicitGlobalRegion":"us-east-1","name":"aws","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^(us|eu|ap|sa|ca|me|af|il)\\\\-\\\\w+\\\\-\\\\d+$","regions":{"af-south-1":{"description":"Africa (Cape Town)"},"ap-east-1":{"description":"Asia Pacific (Hong Kong)"},"ap-northeast-1":{"description":"Asia Pacific (Tokyo)"},"ap-northeast-2":{"description":"Asia Pacific (Seoul)"},"ap-northeast-3":{"description":"Asia Pacific (Osaka)"},"ap-south-1":{"description":"Asia Pacific (Mumbai)"},"ap-south-2":{"description":"Asia Pacific (Hyderabad)"},"ap-southeast-1":{"description":"Asia Pacific (Singapore)"},"ap-southeast-2":{"description":"Asia Pacific (Sydney)"},"ap-southeast-3":{"description":"Asia Pacific (Jakarta)"},"ap-southeast-4":{"description":"Asia Pacific (Melbourne)"},"aws-global":{"description":"AWS Standard global region"},"ca-central-1":{"description":"Canada (Central)"},"ca-west-1":{"description":"Canada West (Calgary)"},"eu-central-1":{"description":"Europe (Frankfurt)"},"eu-central-2":{"description":"Europe (Zurich)"},"eu-north-1":{"description":"Europe (Stockholm)"},"eu-south-1":{"description":"Europe (Milan)"},"eu-south-2":{"description":"Europe (Spain)"},"eu-west-1":{"description":"Europe (Ireland)"},"eu-west-2":{"description":"Europe (London)"},"eu-west-3":{"description":"Europe (Paris)"},"il-central-1":{"description":"Israel (Tel Aviv)"},"me-central-1":{"description":"Middle East (UAE)"},"me-south-1":{"description":"Middle East (Bahrain)"},"sa-east-1":{"description":"South America (Sao Paulo)"},"us-east-1":{"description":"US East (N. Virginia)"},"us-east-2":{"description":"US East (Ohio)"},"us-west-1":{"description":"US West (N. California)"},"us-west-2":{"description":"US West (Oregon)"}}},{"id":"aws-cn","outputs":{"dnsSuffix":"amazonaws.com.cn","dualStackDnsSuffix":"api.amazonwebservices.com.cn","implicitGlobalRegion":"cn-northwest-1","name":"aws-cn","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^cn\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-cn-global":{"description":"AWS China global region"},"cn-north-1":{"description":"China (Beijing)"},"cn-northwest-1":{"description":"China (Ningxia)"}}},{"id":"aws-us-gov","outputs":{"dnsSuffix":"amazonaws.com","dualStackDnsSuffix":"api.aws","implicitGlobalRegion":"us-gov-west-1","name":"aws-us-gov","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-us-gov-global":{"description":"AWS GovCloud (US) global region"},"us-gov-east-1":{"description":"AWS GovCloud (US-East)"},"us-gov-west-1":{"description":"AWS GovCloud (US-West)"}}},{"id":"aws-iso","outputs":{"dnsSuffix":"c2s.ic.gov","dualStackDnsSuffix":"c2s.ic.gov","implicitGlobalRegion":"us-iso-east-1","name":"aws-iso","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-iso-global":{"description":"AWS ISO (US) global region"},"us-iso-east-1":{"description":"US ISO East"},"us-iso-west-1":{"description":"US ISO WEST"}}},{"id":"aws-iso-b","outputs":{"dnsSuffix":"sc2s.sgov.gov","dualStackDnsSuffix":"sc2s.sgov.gov","implicitGlobalRegion":"us-isob-east-1","name":"aws-iso-b","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-iso-b-global":{"description":"AWS ISOB (US) global region"},"us-isob-east-1":{"description":"US ISOB East (Ohio)"}}},{"id":"aws-iso-e","outputs":{"dnsSuffix":"cloud.adc-e.uk","dualStackDnsSuffix":"cloud.adc-e.uk","implicitGlobalRegion":"eu-isoe-west-1","name":"aws-iso-e","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^eu\\\\-isoe\\\\-\\\\w+\\\\-\\\\d+$","regions":{}},{"id":"aws-iso-f","outputs":{"dnsSuffix":"csp.hci.ic.gov","dualStackDnsSuffix":"csp.hci.ic.gov","implicitGlobalRegion":"us-isof-south-1","name":"aws-iso-f","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-isof\\\\-\\\\w+\\\\-\\\\d+$","regions":{}}],"version":"1.1"}');
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js

let selectedPartitionsInfo = partitions_namespaceObject;
let selectedUserAgentPrefix = "";
const partition = (value) => {
    const { partitions } = selectedPartitionsInfo;
    for (const partition of partitions) {
        const { regions, outputs } = partition;
        for (const [region, regionData] of Object.entries(regions)) {
            if (region === value) {
                return {
                    ...outputs,
                    ...regionData,
                };
            }
        }
    }
    for (const partition of partitions) {
        const { regionRegex, outputs } = partition;
        if (new RegExp(regionRegex).test(value)) {
            return {
                ...outputs,
            };
        }
    }
    const DEFAULT_PARTITION = partitions.find((partition) => partition.id === "aws");
    if (!DEFAULT_PARTITION) {
        throw new Error("Provided region was not found in the partition array or regex," +
            " and default partition with id 'aws' doesn't exist.");
    }
    return {
        ...DEFAULT_PARTITION.outputs,
    };
};
const setPartitionInfo = (partitionsInfo, userAgentPrefix = "") => {
    selectedPartitionsInfo = partitionsInfo;
    selectedUserAgentPrefix = userAgentPrefix;
};
const useDefaultPartitionInfo = () => {
    setPartitionInfo(partitionsInfo, "");
};
const getUserAgentPrefix = () => selectedUserAgentPrefix;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/aws.js




const awsEndpointFunctions = {
    isVirtualHostableS3Bucket: isVirtualHostableS3Bucket,
    parseArn: parseArn,
    partition: partition,
};
dist_es/* customEndpointFunctions */.mw.aws = awsEndpointFunctions;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/types/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/index.js







/***/ }),

/***/ 4733:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  mJ: () => (/* binding */ defaultUserAgent)
});

// UNUSED EXPORTS: UA_APP_ID_ENV_NAME, UA_APP_ID_INI_NAME, crtAvailability

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/property-provider/dist-es/fromStatic.js
const fromStatic = (staticValue) => () => Promise.resolve(staticValue);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/property-provider/dist-es/memoize.js
const memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/node-config-provider/dist-es/fromEnv.js

const fromEnv = (envVarSelector) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
};

// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${external_path_.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0,external_os_.homedir)();
    return homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = createHash("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile } = external_fs_.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/types/dist-es/profile.js
var profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(profile_IniSectionType || (profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(profile_IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === profile_IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath_getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(profile_IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: slurpFile_readFile } = external_fs_.promises;
const filePromisesHash = {};
const slurpFile_slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = slurpFile_readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const swallowError = () => ({});
const loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles_loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath_getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile_slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile_slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js


const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = getProfileName(init);
    const { configFile, credentialsFile } = await loadSharedConfigFiles_loadSharedConfigFiles(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message ||
            `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/node-config-provider/dist-es/fromStatic.js

const isFunction = (func) => typeof func === "function";
const fromStatic_fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : fromStatic(defaultValue);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/node-config-provider/dist-es/configLoader.js




const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize(chain(fromEnv(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic_fromStatic(defaultValue)));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/node_modules/@smithy/node-config-provider/dist-es/index.js


;// CONCATENATED MODULE: external "process"
const external_process_namespaceObject = require("process");
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/dist-es/crt-availability.js
const crtAvailability = {
    isCrtAvailable: false,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/dist-es/is-crt-available.js

const isCrtAvailable = () => {
    if (crtAvailability.isCrtAvailable) {
        return ["md/crt-avail"];
    }
    return null;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js





const UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
const UA_APP_ID_INI_NAME = "sdk-ua-app-id";
const defaultUserAgent = ({ serviceId, clientVersion }) => {
    const sections = [
        ["aws-sdk-js", clientVersion],
        ["ua", "2.0"],
        [`os/${(0,external_os_.platform)()}`, (0,external_os_.release)()],
        ["lang/js"],
        ["md/nodejs", `${external_process_namespaceObject.versions.node}`],
    ];
    const crtAvailable = isCrtAvailable();
    if (crtAvailable) {
        sections.push(crtAvailable);
    }
    if (serviceId) {
        sections.push([`api/${serviceId}`, clientVersion]);
    }
    if (external_process_namespaceObject.env.AWS_EXECUTION_ENV) {
        sections.push([`exec-env/${external_process_namespaceObject.env.AWS_EXECUTION_ENV}`]);
    }
    const appIdPromise = loadConfig({
        environmentVariableSelector: (env) => env[UA_APP_ID_ENV_NAME],
        configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME],
        default: undefined,
    })();
    let resolvedUserAgent = undefined;
    return async () => {
        if (!resolvedUserAgent) {
            const appId = await appIdPromise;
            resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
        }
        return resolvedUserAgent;
    };
};


/***/ }),

/***/ 7373:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  zH: () => (/* reexport */ NODE_REGION_CONFIG_FILE_OPTIONS),
  GG: () => (/* reexport */ NODE_REGION_CONFIG_OPTIONS),
  e$: () => (/* reexport */ NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
  Ko: () => (/* reexport */ NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
  TD: () => (/* reexport */ resolveRegionConfig)
});

// UNUSED EXPORTS: CONFIG_USE_DUALSTACK_ENDPOINT, CONFIG_USE_FIPS_ENDPOINT, DEFAULT_USE_DUALSTACK_ENDPOINT, DEFAULT_USE_FIPS_ENDPOINT, ENV_USE_DUALSTACK_ENDPOINT, ENV_USE_FIPS_ENDPOINT, REGION_ENV_NAME, REGION_INI_NAME, getRegionInfo, resolveCustomEndpointsConfig, resolveEndpointsConfig

;// CONCATENATED MODULE: ./node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js
const booleanSelector = (obj, key, type) => {
    if (!(key in obj))
        return undefined;
    if (obj[key] === "true")
        return true;
    if (obj[key] === "false")
        return false;
    throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-config-provider/dist-es/types.js
var SelectorType;
(function (SelectorType) {
    SelectorType["ENV"] = "env";
    SelectorType["CONFIG"] = "shared config entry";
})(SelectorType || (SelectorType = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-config-provider/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js

const ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
const CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
const DEFAULT_USE_DUALSTACK_ENDPOINT = false;
const NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => booleanSelector(env, ENV_USE_DUALSTACK_ENDPOINT, SelectorType.ENV),
    configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, SelectorType.CONFIG),
    default: false,
};

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js

const ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
const CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
const DEFAULT_USE_FIPS_ENDPOINT = false;
const NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => booleanSelector(env, ENV_USE_FIPS_ENDPOINT, SelectorType.ENV),
    configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, SelectorType.CONFIG),
    default: false,
};

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js

const getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/node_modules/@smithy/util-middleware/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js

const resolveCustomEndpointsConfig = (input) => {
    const { endpoint, urlParser } = input;
    return {
        ...input,
        tls: input.tls ?? true,
        endpoint: normalizeProvider(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
        isCustomEndpoint: true,
        useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js


const resolveEndpointsConfig = (input) => {
    const useDualstackEndpoint = normalizeProvider(input.useDualstackEndpoint ?? false);
    const { endpoint, useFipsEndpoint, urlParser } = input;
    return {
        ...input,
        tls: input.tls ?? true,
        endpoint: endpoint
            ? normalizeProvider(typeof endpoint === "string" ? urlParser(endpoint) : endpoint)
            : () => getEndpointFromRegion({ ...input, useDualstackEndpoint, useFipsEndpoint }),
        isCustomEndpoint: !!endpoint,
        useDualstackEndpoint,
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/dist-es/endpointsConfig/index.js





;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/dist-es/regionConfig/config.js
const REGION_ENV_NAME = "AWS_REGION";
const REGION_INI_NAME = "region";
const NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[REGION_ENV_NAME],
    configFileSelector: (profile) => profile[REGION_INI_NAME],
    default: () => {
        throw new Error("Region is missing");
    },
};
const NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials",
};

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js
const isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js

const getRealRegion = (region) => isFipsRegion(region)
    ? ["fips-aws-global", "aws-fips"].includes(region)
        ? "us-east-1"
        : region.replace(/fips-(dkr-|prod-)?|-fips/, "")
    : region;

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js


const resolveRegionConfig = (input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
        throw new Error("Region is missing");
    }
    return {
        ...input,
        region: async () => {
            if (typeof region === "string") {
                return getRealRegion(region);
            }
            const providedRegion = await region();
            return getRealRegion(providedRegion);
        },
        useFipsEndpoint: async () => {
            const providedRegion = typeof region === "string" ? region : await region();
            if (isFipsRegion(providedRegion)) {
                return true;
            }
            return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        },
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/dist-es/regionConfig/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/config-resolver/dist-es/index.js





/***/ }),

/***/ 2073:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  DefaultIdentityProviderConfig: () => (/* reexport */ DefaultIdentityProviderConfig),
  EXPIRATION_MS: () => (/* reexport */ EXPIRATION_MS),
  HttpApiKeyAuthSigner: () => (/* reexport */ HttpApiKeyAuthSigner),
  HttpBearerAuthSigner: () => (/* reexport */ HttpBearerAuthSigner),
  NoAuthSigner: () => (/* reexport */ NoAuthSigner),
  RequestBuilder: () => (/* reexport */ RequestBuilder),
  createIsIdentityExpiredFunction: () => (/* reexport */ createIsIdentityExpiredFunction),
  createPaginator: () => (/* reexport */ createPaginator),
  doesIdentityRequireRefresh: () => (/* reexport */ doesIdentityRequireRefresh),
  getHttpAuthSchemeEndpointRuleSetPlugin: () => (/* reexport */ getHttpAuthSchemeEndpointRuleSetPlugin),
  getHttpAuthSchemePlugin: () => (/* reexport */ getHttpAuthSchemePlugin),
  getHttpSigningPlugin: () => (/* reexport */ getHttpSigningPlugin),
  getSmithyContext: () => (/* reexport */ dist_es_getSmithyContext_getSmithyContext),
  httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => (/* reexport */ httpAuthSchemeEndpointRuleSetMiddlewareOptions),
  httpAuthSchemeMiddleware: () => (/* reexport */ httpAuthSchemeMiddleware),
  httpAuthSchemeMiddlewareOptions: () => (/* reexport */ httpAuthSchemeMiddlewareOptions),
  httpSigningMiddleware: () => (/* reexport */ httpSigningMiddleware),
  httpSigningMiddlewareOptions: () => (/* reexport */ httpSigningMiddlewareOptions),
  isIdentityExpired: () => (/* reexport */ isIdentityExpired),
  memoizeIdentityProvider: () => (/* reexport */ memoizeIdentityProvider),
  normalizeProvider: () => (/* reexport */ normalizeProvider_normalizeProvider),
  requestBuilder: () => (/* reexport */ requestBuilder)
});

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/types/dist-es/extensions/checksum.js
var checksum_AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(checksum_AlgorithmId || (checksum_AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => checksum_AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => checksum_AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/types/dist-es/http.js
var http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(http_FieldPosition || (http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/types/dist-es/middleware.js
const middleware_SMITHY_CONTEXT_KEY = "__smithy_context";

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/types/dist-es/profile.js
var profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(profile_IniSectionType || (profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js

const getSmithyContext_getSmithyContext = (context) => context[middleware_SMITHY_CONTEXT_KEY] || (context[middleware_SMITHY_CONTEXT_KEY] = {});

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-middleware/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js


function convertHttpAuthSchemesToMap(httpAuthSchemes) {
    const map = new Map();
    for (const scheme of httpAuthSchemes) {
        map.set(scheme.schemeId, scheme);
    }
    return map;
}
const httpAuthSchemeMiddleware = (config, mwOptions) => (next, context) => async (args) => {
    const options = config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config, context, args.input));
    const authSchemes = convertHttpAuthSchemesToMap(config.httpAuthSchemes);
    const smithyContext = getSmithyContext_getSmithyContext(context);
    const failureReasons = [];
    for (const option of options) {
        const scheme = authSchemes.get(option.schemeId);
        if (!scheme) {
            failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
            continue;
        }
        const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));
        if (!identityProvider) {
            failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
            continue;
        }
        const { identityProperties = {}, signingProperties = {} } = option.propertiesExtractor?.(config, context) || {};
        option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
        option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
        smithyContext.selectedHttpAuthScheme = {
            httpAuthOption: option,
            identity: await identityProvider(option.identityProperties),
            signer: scheme.signer,
        };
        break;
    }
    if (!smithyContext.selectedHttpAuthScheme) {
        throw new Error(failureReasons.join("\n"));
    }
    return next(args);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError_ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError_ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError_CredentialsProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError_CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/property-provider/dist-es/chain.js

const chain_chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-config-provider/dist-es/fromEnv.js

const fromEnv_fromEnv = (envVarSelector) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
};

// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = homedir();
    return homeDirCache[homeDirCacheKey];
};

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = createHash("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile } = external_fs_.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData_getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath_getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || join(getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath_getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || join(getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = (/* unused pure expression or super */ null && (["__proto__", "profile __proto__"]));
const parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: slurpFile_readFile } = external_fs_.promises;
const filePromisesHash = {};
const slurpFile_slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = slurpFile_readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const swallowError = () => ({});
const loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles_loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js


const fromSharedConfigFiles_fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = getProfileName(init);
    const { configFile, credentialsFile } = await loadSharedConfigFiles(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message ||
            `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-config-provider/dist-es/fromStatic.js

const isFunction = (func) => typeof func === "function";
const fromStatic_fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : convertToProvider(defaultValue);

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-config-provider/dist-es/configLoader.js




const configLoader_loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize(chain(fromEnv(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic(defaultValue)));

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-config-provider/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointUrlConfig.js

const ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
const CONFIG_ENDPOINT_URL = "endpoint_url";
const getEndpointUrlConfig_getEndpointUrlConfig = (serviceId) => ({
    environmentVariableSelector: (env) => {
        const serviceSuffixParts = serviceId.split(" ").map((w) => w.toUpperCase());
        const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
        if (serviceEndpointUrl)
            return serviceEndpointUrl;
        const endpointUrl = env[ENV_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    configFileSelector: (profile, config) => {
        if (config && profile.services) {
            const servicesSection = config[["services", profile.services].join(CONFIG_PREFIX_SEPARATOR)];
            if (servicesSection) {
                const servicePrefixParts = serviceId.split(" ").map((w) => w.toLowerCase());
                const endpointUrl = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(CONFIG_PREFIX_SEPARATOR)];
                if (endpointUrl)
                    return endpointUrl;
            }
        }
        const endpointUrl = profile[CONFIG_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    default: undefined,
});

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.js


const getEndpointFromConfig_getEndpointFromConfig = async (serviceId) => loadConfig(getEndpointUrlConfig(serviceId))();

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js




const getEndpointFromInstructions_getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.endpoint) {
        const endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId || "");
        if (endpointFromConfig) {
            clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
        }
    }
    const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
};
const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
            case "staticContextParams":
                endpointParams[name] = instruction.value;
                break;
            case "contextParams":
                endpointParams[name] = commandInput[instruction.name];
                break;
            case "clientContextParams":
            case "builtInParams":
                endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
                break;
            default:
                throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
    }
    if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await resolveParamsForS3(endpointParams);
    }
    return endpointParams;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js


const endpointMiddleware_endpointMiddleware = ({ config, instructions, }) => {
    return (next, context) => async (args) => {
        const endpoint = await getEndpointFromInstructions(args.input, {
            getEndpointParameterInstructions() {
                return instructions;
            },
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
            context["signing_region"] = authScheme.signingRegion;
            context["signing_service"] = authScheme.signingName;
            const smithyContext = getSmithyContext(context);
            const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
            if (httpAuthOption) {
                httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
                    signing_region: authScheme.signingRegion,
                    signingRegion: authScheme.signingRegion,
                    signing_service: authScheme.signingName,
                    signingName: authScheme.signingName,
                    signingRegionSet: authScheme.signingRegionSet,
                }, authScheme.properties);
            }
        }
        return next({
            ...args,
        });
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js


const deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true,
};
const serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true,
};
function getSerdePlugin(config, serializer, deserializer) {
    return {
        applyToStack: (commandStack) => {
            commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
            commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
        },
    };
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/middleware-serde/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js


const endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: serializerMiddlewareOption.name,
};
const getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(endpointMiddleware({
            config,
            instructions,
        }), endpointMiddlewareOptions);
    },
});

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js


const resolveEndpointConfig = (input) => {
    const tls = input.tls ?? true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    return {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
        useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/middleware-endpoint/dist-es/index.js






;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js


const httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: endpointMiddlewareOptions.name,
};
const getHttpAuthSchemeEndpointRuleSetPlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
            httpAuthSchemeParametersProvider,
            identityProviderConfigProvider,
        }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
    },
});

;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js


const httpAuthSchemeMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: serializerMiddlewareOption.name,
};
const getHttpAuthSchemePlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
            httpAuthSchemeParametersProvider,
            identityProviderConfigProvider,
        }), httpAuthSchemeMiddlewareOptions);
    },
});

;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/protocol-http/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js



const defaultErrorHandler = (signingProperties) => (error) => {
    throw error;
};
const defaultSuccessHandler = (httpResponse, signingProperties) => { };
const httpSigningMiddleware = (config) => (next, context) => async (args) => {
    if (!HttpRequest.isInstance(args.request)) {
        return next(args);
    }
    const smithyContext = getSmithyContext_getSmithyContext(context);
    const scheme = smithyContext.selectedHttpAuthScheme;
    if (!scheme) {
        throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
    }
    const { httpAuthOption: { signingProperties = {} }, identity, signer, } = scheme;
    const output = await next({
        ...args,
        request: await signer.sign(args.request, identity, signingProperties),
    }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
    (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
    return output;
};

// EXTERNAL MODULE: ./node_modules/@smithy/middleware-retry/dist-es/index.js + 69 modules
var dist_es = __webpack_require__(2467);
;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js


const httpSigningMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["HTTP_SIGNING"],
    name: "httpSigningMiddleware",
    aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
    override: true,
    relation: "after",
    toMiddleware: dist_es/* retryMiddlewareOptions */.j7.name,
};
const getHttpSigningPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpSigningMiddleware(config), httpSigningMiddlewareOptions);
    },
});

;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/middleware-http-signing/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js
class DefaultIdentityProviderConfig {
    constructor(config) {
        this.authSchemes = new Map();
        for (const [key, value] of Object.entries(config)) {
            if (value !== undefined) {
                this.authSchemes.set(key, value);
            }
        }
    }
    getIdentityProvider(schemeId) {
        return this.authSchemes.get(schemeId);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js

class HttpApiKeyAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
        if (!signingProperties) {
            throw new Error("request could not be signed with `apiKey` since the `name` and `in` signer properties are missing");
        }
        if (!signingProperties.name) {
            throw new Error("request could not be signed with `apiKey` since the `name` signer property is missing");
        }
        if (!signingProperties.in) {
            throw new Error("request could not be signed with `apiKey` since the `in` signer property is missing");
        }
        if (!identity.apiKey) {
            throw new Error("request could not be signed with `apiKey` since the `apiKey` is not defined");
        }
        const clonedRequest = httpRequest.clone();
        if (signingProperties.in === HttpApiKeyAuthLocation.QUERY) {
            clonedRequest.query[signingProperties.name] = identity.apiKey;
        }
        else if (signingProperties.in === HttpApiKeyAuthLocation.HEADER) {
            clonedRequest.headers[signingProperties.name] = signingProperties.scheme
                ? `${signingProperties.scheme} ${identity.apiKey}`
                : identity.apiKey;
        }
        else {
            throw new Error("request can only be signed with `apiKey` locations `query` or `header`, " +
                "but found: `" +
                signingProperties.in +
                "`");
        }
        return clonedRequest;
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js
class HttpBearerAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
        const clonedRequest = httpRequest.clone();
        if (!identity.token) {
            throw new Error("request could not be signed with `token` since the `token` is not defined");
        }
        clonedRequest.headers["Authorization"] = `Bearer ${identity.token}`;
        return clonedRequest;
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js
class NoAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
        return httpRequest;
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js
const createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
const EXPIRATION_MS = 300000;
const isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
const doesIdentityRequireRefresh = (identity) => identity.expiration !== undefined;
const memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {
    if (provider === undefined) {
        return undefined;
    }
    const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async (options) => {
        if (!pending) {
            pending = normalizedProvider(options);
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider(options);
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider(options);
        }
        if (isConstant) {
            return resolved;
        }
        if (!requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider(options);
            return resolved;
        }
        return resolved;
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/getSmithyContext.js

const dist_es_getSmithyContext_getSmithyContext = (context) => context[middleware_SMITHY_CONTEXT_KEY] || (context[middleware_SMITHY_CONTEXT_KEY] = {});

;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/normalizeProvider.js
const normalizeProvider_normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
const getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const MiddlewareStack_constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo(MiddlewareStack_constructStack()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo(MiddlewareStack_constructStack());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                const step = mw.step ??
                    mw.relation +
                        " " +
                        mw.toMiddleware;
                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/middleware-stack/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/client.js

class Client {
    constructor(config) {
        this.middlewareStack = constructStack();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}

// EXTERNAL MODULE: external "buffer"
var external_buffer_ = __webpack_require__(181);
;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-buffer-from/dist-es/index.js


const dist_es_fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return Buffer.from(input, offset, length);
};
const dist_es_fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? Buffer.from(input, encoding) : Buffer.from(input);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-base64/dist-es/fromBase64.js

const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64_fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = fromString(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js

const fromUtf8_fromUtf8 = (input) => {
    const buf = fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js

const toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-utf8/dist-es/toUtf8.js

const toUtf8_toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-utf8/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-base64/dist-es/toBase64.js


const toBase64_toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
        input = fromUtf8(_input);
    }
    else {
        input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-base64/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-stream/dist-es/blob/transforms.js



function transforms_transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return toBase64(payload);
    }
    return toUtf8(payload);
}
function transforms_transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js

class Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter extends (/* unused pure expression or super */ null && (Uint8Array)) {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return transformFromString(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
    }
}

// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(2203);
;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.js

const getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};

// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(8611);
// EXTERNAL MODULE: external "https"
var external_https_ = __webpack_require__(5692);
;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-http-handler/dist-es/write-request-body.js

const MIN_WAIT_TIME = 1000;
async function write_request_body_writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", () => {
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            }),
        ]);
    }
    if (!hasError) {
        writeBody(httpRequest, request.body);
    }
}
function writeBody(httpRequest, body) {
    if (body instanceof Readable) {
        body.pipe(httpRequest);
        return;
    }
    if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
            httpRequest.end(body);
            return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" &&
            uint8.buffer &&
            typeof uint8.byteOffset === "number" &&
            typeof uint8.byteLength === "number") {
            httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
            return;
        }
        httpRequest.end(Buffer.from(body));
        return;
    }
    httpRequest.end();
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js










const DEFAULT_REQUEST_TIMEOUT = 0;
class NodeHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
            return socketWarningTimestamp;
        }
        const interval = 15000;
        if (Date.now() - interval < socketWarningTimestamp) {
            return socketWarningTimestamp;
        }
        if (sockets && requests) {
            for (const origin in sockets) {
                const socketsInUse = sockets[origin]?.length ?? 0;
                const requestsEnqueued = requests[origin]?.length ?? 0;
                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
                    console.warn("@smithy/node-http-handler:WARN", `socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.`, "See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html", "or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.");
                    return Date.now();
                }
            }
        }
        return socketWarningTimestamp;
    }
    constructor(options) {
        this.socketWarningTimestamp = 0;
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout ?? socketTimeout,
            httpAgent: (() => {
                if (httpAgent instanceof hAgent || typeof httpAgent?.destroy === "function") {
                    return httpAgent;
                }
                return new hAgent({ keepAlive, maxSockets, ...httpAgent });
            })(),
            httpsAgent: (() => {
                if (httpsAgent instanceof hsAgent || typeof httpsAgent?.destroy === "function") {
                    return httpsAgent;
                }
                return new hsAgent({ keepAlive, maxSockets, ...httpsAgent });
            })(),
        };
    }
    destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        let socketCheckTimeoutId;
        return new Promise((_resolve, _reject) => {
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                clearTimeout(socketCheckTimeoutId);
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
            socketCheckTimeoutId = setTimeout(() => {
                this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp);
            }, this.config.socketAcquisitionWarningTimeout ??
                (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000));
            const queryString = buildQueryString(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent,
                auth,
            };
            const requestFunc = isSSL ? hsRequest : hRequest;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: getTransformedHeaders(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            setConnectionTimeout(req, reject, this.config.connectionTimeout);
            setSocketTimeout(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                setSocketKeepAlive(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                });
            }
            writeRequestBodyPromise = writeRequestBody(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

// EXTERNAL MODULE: external "http2"
var external_http2_ = __webpack_require__(5675);
;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
class node_http2_connection_pool_NodeHttp2ConnectionPool {
    constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions ?? [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-manager.js


class node_http2_connection_manager_NodeHttp2ConnectionManager {
    constructor(config) {
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-http-handler/dist-es/node-http2-handler.js






class NodeHttp2Handler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal?.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: this.config?.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = buildQueryString(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [constants.HTTP2_HEADER_PATH]: path,
                [constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: getTransformedHeaders(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js

class collector_Collector extends external_stream_.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js

const stream_collector_streamCollector = (stream) => {
    if (isReadableStreamInstance(stream)) {
        return collectReadableStream(stream);
    }
    return new Promise((resolve, reject) => {
        const collector = new Collector();
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
            resolve(bytes);
        });
    });
};
const isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
async function collectReadableStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/node-http-handler/dist-es/index.js




// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(9023);
;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js



const keepAliveSupport = {
    supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
};
class FetchHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
        if (typeof options === "function") {
            this.configProvider = options().then((opts) => opts || {});
        }
        else {
            this.config = options ?? {};
            this.configProvider = Promise.resolve(this.config);
        }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        const requestTimeoutInMs = this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = buildQueryString(request.query || {});
        if (queryString) {
            path += `?${queryString}`;
        }
        if (request.fragment) {
            path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? undefined : request.body;
        const requestOptions = {
            body,
            headers: new Headers(request.headers),
            method: method,
        };
        if (body) {
            requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
            requestOptions.signal = abortSignal;
        }
        if (keepAliveSupport.supported) {
            requestOptions.keepalive = keepAlive;
        }
        const fetchRequest = new Request(url, requestOptions);
        const raceOfPromises = [
            fetch(fetchRequest).then((response) => {
                const fetchHeaders = response.headers;
                const transformedHeaders = {};
                for (const pair of fetchHeaders.entries()) {
                    transformedHeaders[pair[0]] = pair[1];
                }
                const hasReadableStream = response.body != undefined;
                if (!hasReadableStream) {
                    return response.blob().then((body) => ({
                        response: new HttpResponse({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body,
                        }),
                    }));
                }
                return {
                    response: new HttpResponse({
                        headers: transformedHeaders,
                        reason: response.statusText,
                        statusCode: response.status,
                        body: response.body,
                    }),
                };
            }),
            requestTimeout(requestTimeoutInMs),
        ];
        if (abortSignal) {
            raceOfPromises.push(new Promise((resolve, reject) => {
                abortSignal.onabort = () => {
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }));
        }
        return Promise.race(raceOfPromises);
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            config[key] = value;
            return config;
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js

const dist_es_stream_collector_streamCollector = (stream) => {
    if (typeof Blob === "function" && stream instanceof Blob) {
        return collectBlob(stream);
    }
    return collectStream(stream);
};
async function collectBlob(blob) {
    const base64 = await readToBase64(blob);
    const arrayBuffer = fromBase64(base64);
    return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}
function readToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (reader.readyState !== 2) {
                return reject(new Error("Reader aborted too early"));
            }
            const result = (reader.result ?? "");
            const commaIndex = result.indexOf(",");
            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
            resolve(result.substring(dataOffset));
        };
        reader.onabort = () => reject(new Error("Read aborted"));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
    });
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/fetch-http-handler/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-hex-encoding/dist-es/index.js
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function dist_es_toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js




const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    if (!isBlobInstance(stream) && !sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
            throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" +
                "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
    };
    return Object.assign(stream, {
        transformToByteArray: transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === "base64") {
                return toBase64(buf);
            }
            else if (encoding === "hex") {
                return toHex(buf);
            }
            else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
                return toUtf8(buf);
            }
            else if (typeof TextDecoder === "function") {
                return new TextDecoder(encoding).decode(buf);
            }
            else {
                throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            transformed = true;
            if (isBlobInstance(stream)) {
                return blobToWebStream(stream);
            }
            else if (sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
                return stream;
            }
            else {
                throw new Error(`Cannot transform payload to web stream, got ${stream}`);
            }
        },
    });
};
const isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
const sdk_stream_mixin_browser_isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js





const sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdk_stream_mixin_sdkStreamMixin = (stream) => {
    if (!(stream instanceof Readable)) {
        try {
            return sdkStreamMixinReadableStream(stream);
        }
        catch (e) {
            const name = stream?.__proto__?.constructor?.name || stream;
            throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return Readable.toWeb(stream);
        },
    });
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/util-stream/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js

const collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/command.js


class Command {
    constructor() {
        this.middlewareStack = constructStack();
    }
    static classBuilder() {
        return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [SMITHY_CONTEXT_KEY]: {
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
class ClassBuilder {
    constructor() {
        this._init = () => { };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
    }
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends Command {
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(...[input]) {
                super();
                this.serialize = closure._serializer;
                this.deserialize = closure._deserializer;
                this.input = input ?? {};
                closure._init(this);
            }
            resolveMiddleware(stack, configuration, options) {
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/parse-utils.js
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
const expectInt = (/* unused pure expression or super */ null && (expectLong));
const expectInt32 = (value) => expectSizedInt(value, 32);
const expectShort = (value) => expectSizedInt(value, 16);
const expectByte = (value) => expectSizedInt(value, 8);
const expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = expectObject(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
const parse_utils_strictParseDouble = (value) => {
    if (typeof value == "string") {
        return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
};
const strictParseFloat = (/* unused pure expression or super */ null && (parse_utils_strictParseDouble));
const parse_utils_strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
};
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectNumber(value);
};
const handleFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectFloat32(value);
};
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value) => {
    if (typeof value === "string") {
        return expectLong(parseNumber(value));
    }
    return expectLong(value);
};
const strictParseInt = (/* unused pure expression or super */ null && (strictParseLong));
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
};
const parse_utils_strictParseShort = (value) => {
    if (typeof value === "string") {
        return expectShort(parseNumber(value));
    }
    return expectShort(value);
};
const parse_utils_strictParseByte = (value) => {
    if (typeof value === "string") {
        return expectByte(parseNumber(value));
    }
    return expectByte(value);
};
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
const logger = {
    warn: console.warn,
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/date-utils.js

const DAYS = (/* unused pure expression or super */ null && (["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]));
const MONTHS = (/* unused pure expression or super */ null && (["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]));
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
const RFC3339 = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/)));
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
const RFC3339_WITH_OFFSET = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/)));
const parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
const IMF_FIXDATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const RFC_850_DATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const ASC_TIME = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/)));
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = (/* unused pure expression or super */ null && (50 * 365 * 24 * 60 * 60 * 1000));
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = (/* unused pure expression or super */ null && ([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]));
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/exceptions.js
class ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
const exceptions_decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/default-error-handler.js

const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw decorateServiceException(response, parsedBody);
};
const withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js


const extensions_checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in AlgorithmId) {
        const algorithmId = AlgorithmId[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const extensions_checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js


const getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
        ...getRetryConfiguration(runtimeConfig),
    };
};
const defaultExtensionConfiguration_getDefaultClientConfiguration = (/* unused pure expression or super */ null && (getDefaultExtensionConfiguration));
const defaultExtensionConfiguration_resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
        ...resolveRetryRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/lazy-json.js
const StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(StringWrapper, String);
class LazyJsonString extends (/* unused pure expression or super */ null && (StringWrapper)) {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
        }
        return new LazyJsonString(JSON.stringify(object));
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/resolve-path.js

const resolvedPath = (resolvedPath, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== undefined) {
        const labelValue = labelValueProvider();
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
        }
        resolvedPath = resolvedPath.replace(uriLabel, isGreedyLabel
            ? labelValue
                .split("/")
                .map((segment) => extendedEncodeURIComponent(segment))
                .join("/")
            : extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/node_modules/@smithy/smithy-client/dist-es/index.js























;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/protocols/requestBuilder.js


function requestBuilder(input, context) {
    return new RequestBuilder(input, context);
}
class RequestBuilder {
    constructor(input, context) {
        this.input = input;
        this.context = context;
        this.query = {};
        this.method = "";
        this.headers = {};
        this.path = "";
        this.body = null;
        this.hostname = "";
        this.resolvePathStack = [];
    }
    async build() {
        const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
        this.path = basePath;
        for (const resolvePath of this.resolvePathStack) {
            resolvePath(this.path);
        }
        return new HttpRequest({
            protocol,
            hostname: this.hostname || hostname,
            port,
            method: this.method,
            path: this.path,
            query: this.query,
            body: this.body,
            headers: this.headers,
        });
    }
    hn(hostname) {
        this.hostname = hostname;
        return this;
    }
    bp(uriLabel) {
        this.resolvePathStack.push((basePath) => {
            this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
        });
        return this;
    }
    p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
        this.resolvePathStack.push((path) => {
            this.path = resolvedPath(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
        });
        return this;
    }
    h(headers) {
        this.headers = headers;
        return this;
    }
    q(query) {
        this.query = query;
        return this;
    }
    b(body) {
        this.body = body;
        return this;
    }
    m(method) {
        this.method = method;
        return this;
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/pagination/createPaginator.js
const makePagedClientRequest = async (CommandCtor, client, input, ...args) => {
    return await client.send(new CommandCtor(input), ...args);
};
function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
    return async function* paginateOperation(config, input, ...additionalArguments) {
        let token = config.startingToken || undefined;
        let hasNext = true;
        let page;
        while (hasNext) {
            input[inputTokenName] = token;
            if (pageSizeTokenName) {
                input[pageSizeTokenName] = input[pageSizeTokenName] ?? config.pageSize;
            }
            if (config.client instanceof ClientCtor) {
                page = await makePagedClientRequest(CommandCtor, config.client, input, ...additionalArguments);
            }
            else {
                throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
            }
            yield page;
            const prevToken = token;
            token = get(page, outputTokenName);
            hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
        }
        return undefined;
    };
}
const get = (fromObject, path) => {
    let cursor = fromObject;
    const pathComponents = path.split(".");
    for (const step of pathComponents) {
        if (!cursor || typeof cursor !== "object") {
            return undefined;
        }
        cursor = cursor[step];
    }
    return cursor;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/core/dist-es/index.js









/***/ }),

/***/ 3060:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  DEFAULT_MAX_RETRIES: () => (/* reexport */ DEFAULT_MAX_RETRIES),
  DEFAULT_TIMEOUT: () => (/* reexport */ DEFAULT_TIMEOUT),
  ENV_CMDS_AUTH_TOKEN: () => (/* reexport */ ENV_CMDS_AUTH_TOKEN),
  ENV_CMDS_FULL_URI: () => (/* reexport */ ENV_CMDS_FULL_URI),
  ENV_CMDS_RELATIVE_URI: () => (/* reexport */ ENV_CMDS_RELATIVE_URI),
  Endpoint: () => (/* reexport */ Endpoint),
  fromContainerMetadata: () => (/* reexport */ fromContainerMetadata),
  fromInstanceMetadata: () => (/* reexport */ fromInstanceMetadata),
  getInstanceMetadataEndpoint: () => (/* reexport */ getInstanceMetadataEndpoint),
  httpRequest: () => (/* reexport */ httpRequest),
  providerConfigFromInit: () => (/* reexport */ providerConfigFromInit)
});

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/property-provider/dist-es/fromStatic.js
const fromStatic = (staticValue) => () => Promise.resolve(staticValue);

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/property-provider/dist-es/memoize.js
const memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: external "url"
const external_url_namespaceObject = require("url");
// EXTERNAL MODULE: external "buffer"
var external_buffer_ = __webpack_require__(181);
// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(8611);
;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/httpRequest.js



function httpRequest(options) {
    return new Promise((resolve, reject) => {
        const req = (0,external_http_.request)({
            method: "GET",
            ...options,
            hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1"),
        });
        req.on("error", (err) => {
            reject(Object.assign(new ProviderError("Unable to connect to instance metadata service"), err));
            req.destroy();
        });
        req.on("timeout", () => {
            reject(new ProviderError("TimeoutError from instance metadata service"));
            req.destroy();
        });
        req.on("response", (res) => {
            const { statusCode = 400 } = res;
            if (statusCode < 200 || 300 <= statusCode) {
                reject(Object.assign(new ProviderError("Error response received from instance metadata service"), { statusCode }));
                req.destroy();
            }
            const chunks = [];
            res.on("data", (chunk) => {
                chunks.push(chunk);
            });
            res.on("end", () => {
                resolve(external_buffer_.Buffer.concat(chunks));
                req.destroy();
            });
        });
        req.end();
    });
}

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/ImdsCredentials.js
const isImdsCredentials = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.AccessKeyId === "string" &&
    typeof arg.SecretAccessKey === "string" &&
    typeof arg.Token === "string" &&
    typeof arg.Expiration === "string";
const fromImdsCredentials = (creds) => ({
    accessKeyId: creds.AccessKeyId,
    secretAccessKey: creds.SecretAccessKey,
    sessionToken: creds.Token,
    expiration: new Date(creds.Expiration),
});

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/RemoteProviderInit.js
const DEFAULT_TIMEOUT = 1000;
const DEFAULT_MAX_RETRIES = 0;
const providerConfigFromInit = ({ maxRetries = DEFAULT_MAX_RETRIES, timeout = DEFAULT_TIMEOUT, }) => ({ maxRetries, timeout });

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/retry.js
const retry = (toRetry, maxRetries) => {
    let promise = toRetry();
    for (let i = 0; i < maxRetries; i++) {
        promise = promise.catch(toRetry);
    }
    return promise;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/fromContainerMetadata.js






const ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
const ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
const ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
const fromContainerMetadata = (init = {}) => {
    const { timeout, maxRetries } = providerConfigFromInit(init);
    return () => retry(async () => {
        const requestOptions = await getCmdsUri();
        const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
        if (!isImdsCredentials(credsResponse)) {
            throw new CredentialsProviderError("Invalid response received from instance metadata service.");
        }
        return fromImdsCredentials(credsResponse);
    }, maxRetries);
};
const requestFromEcsImds = async (timeout, options) => {
    if (process.env[ENV_CMDS_AUTH_TOKEN]) {
        options.headers = {
            ...options.headers,
            Authorization: process.env[ENV_CMDS_AUTH_TOKEN],
        };
    }
    const buffer = await httpRequest({
        ...options,
        timeout,
    });
    return buffer.toString();
};
const CMDS_IP = "169.254.170.2";
const GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true,
};
const GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true,
};
const getCmdsUri = async () => {
    if (process.env[ENV_CMDS_RELATIVE_URI]) {
        return {
            hostname: CMDS_IP,
            path: process.env[ENV_CMDS_RELATIVE_URI],
        };
    }
    if (process.env[ENV_CMDS_FULL_URI]) {
        const parsed = (0,external_url_namespaceObject.parse)(process.env[ENV_CMDS_FULL_URI]);
        if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
            throw new CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, false);
        }
        if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
            throw new CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, false);
        }
        return {
            ...parsed,
            port: parsed.port ? parseInt(parsed.port, 10) : undefined,
        };
    }
    throw new CredentialsProviderError("The container metadata credential provider cannot be used unless" +
        ` the ${ENV_CMDS_RELATIVE_URI} or ${ENV_CMDS_FULL_URI} environment` +
        " variable is set", false);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/node-config-provider/dist-es/fromEnv.js

const fromEnv = (envVarSelector) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
};

// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${external_path_.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0,external_os_.homedir)();
    return homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = createHash("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile } = external_fs_.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/types/dist-es/profile.js
var profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(profile_IniSectionType || (profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(profile_IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === profile_IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath_getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(profile_IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: slurpFile_readFile } = external_fs_.promises;
const filePromisesHash = {};
const slurpFile_slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = slurpFile_readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const swallowError = () => ({});
const loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles_loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath_getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile_slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile_slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js


const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = getProfileName(init);
    const { configFile, credentialsFile } = await loadSharedConfigFiles_loadSharedConfigFiles(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message ||
            `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/node-config-provider/dist-es/fromStatic.js

const isFunction = (func) => typeof func === "function";
const fromStatic_fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : fromStatic(defaultValue);

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/node-config-provider/dist-es/configLoader.js




const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize(chain(fromEnv(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic_fromStatic(defaultValue)));

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/node-config-provider/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/error/InstanceMetadataV1FallbackError.js

class InstanceMetadataV1FallbackError extends CredentialsProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "InstanceMetadataV1FallbackError";
        Object.setPrototypeOf(this, InstanceMetadataV1FallbackError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
        for (const pair of querystring.split("&")) {
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
                value = decodeURIComponent(value);
            }
            if (!(key in query)) {
                query[key] = value;
            }
            else if (Array.isArray(query[key])) {
                query[key].push(value);
            }
            else {
                query[key] = [query[key], value];
            }
        }
    }
    return query;
}

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/node_modules/@smithy/url-parser/dist-es/index.js

const parseUrl = (url) => {
    if (typeof url === "string") {
        return parseUrl(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
        query = parseQueryString(search);
    }
    return {
        hostname,
        port: port ? parseInt(port) : undefined,
        protocol,
        path: pathname,
        query,
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/config/Endpoint.js
var Endpoint;
(function (Endpoint) {
    Endpoint["IPv4"] = "http://169.254.169.254";
    Endpoint["IPv6"] = "http://[fd00:ec2::254]";
})(Endpoint || (Endpoint = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointConfigOptions.js
const ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
const CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
const ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[ENV_ENDPOINT_NAME],
    configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME],
    default: undefined,
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointMode.js
var EndpointMode;
(function (EndpointMode) {
    EndpointMode["IPv4"] = "IPv4";
    EndpointMode["IPv6"] = "IPv6";
})(EndpointMode || (EndpointMode = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointModeConfigOptions.js

const ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
const CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
const ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[ENV_ENDPOINT_MODE_NAME],
    configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME],
    default: EndpointMode.IPv4,
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/utils/getInstanceMetadataEndpoint.js






const getInstanceMetadataEndpoint = async () => parseUrl((await getFromEndpointConfig()) || (await getFromEndpointModeConfig()));
const getFromEndpointConfig = async () => loadConfig(ENDPOINT_CONFIG_OPTIONS)();
const getFromEndpointModeConfig = async () => {
    const endpointMode = await loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS)();
    switch (endpointMode) {
        case EndpointMode.IPv4:
            return Endpoint.IPv4;
        case EndpointMode.IPv6:
            return Endpoint.IPv6;
        default:
            throw new Error(`Unsupported endpoint mode: ${endpointMode}.` + ` Select from ${Object.values(EndpointMode)}`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/utils/getExtendedInstanceMetadataCredentials.js
const STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
const STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
const STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
const getExtendedInstanceMetadataCredentials = (credentials, logger) => {
    const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS +
        Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
    const newExpiration = new Date(Date.now() + refreshInterval * 1000);
    logger.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these " +
        `credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: ` +
        STATIC_STABILITY_DOC_URL);
    const originalExpiration = credentials.originalExpiration ?? credentials.expiration;
    return {
        ...credentials,
        ...(originalExpiration ? { originalExpiration } : {}),
        expiration: newExpiration,
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/utils/staticStabilityProvider.js

const staticStabilityProvider = (provider, options = {}) => {
    const logger = options?.logger || console;
    let pastCredentials;
    return async () => {
        let credentials;
        try {
            credentials = await provider();
            if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
                credentials = getExtendedInstanceMetadataCredentials(credentials, logger);
            }
        }
        catch (e) {
            if (pastCredentials) {
                logger.warn("Credential renew failed: ", e);
                credentials = getExtendedInstanceMetadataCredentials(pastCredentials, logger);
            }
            else {
                throw e;
            }
        }
        pastCredentials = credentials;
        return credentials;
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/fromInstanceMetadata.js









const IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
const IMDS_TOKEN_PATH = "/latest/api/token";
const AWS_EC2_METADATA_V1_DISABLED = "AWS_EC2_METADATA_V1_DISABLED";
const PROFILE_AWS_EC2_METADATA_V1_DISABLED = "ec2_metadata_v1_disabled";
const X_AWS_EC2_METADATA_TOKEN = "x-aws-ec2-metadata-token";
const fromInstanceMetadata = (init = {}) => staticStabilityProvider(getInstanceImdsProvider(init), { logger: init.logger });
const getInstanceImdsProvider = (init) => {
    let disableFetchToken = false;
    const { logger, profile } = init;
    const { timeout, maxRetries } = providerConfigFromInit(init);
    const getCredentials = async (maxRetries, options) => {
        const isImdsV1Fallback = disableFetchToken || options.headers?.[X_AWS_EC2_METADATA_TOKEN] == null;
        if (isImdsV1Fallback) {
            let fallbackBlockedFromProfile = false;
            let fallbackBlockedFromProcessEnv = false;
            const configValue = await loadConfig({
                environmentVariableSelector: (env) => {
                    const envValue = env[AWS_EC2_METADATA_V1_DISABLED];
                    fallbackBlockedFromProcessEnv = !!envValue && envValue !== "false";
                    if (envValue === undefined) {
                        throw new CredentialsProviderError(`${AWS_EC2_METADATA_V1_DISABLED} not set in env, checking config file next.`);
                    }
                    return fallbackBlockedFromProcessEnv;
                },
                configFileSelector: (profile) => {
                    const profileValue = profile[PROFILE_AWS_EC2_METADATA_V1_DISABLED];
                    fallbackBlockedFromProfile = !!profileValue && profileValue !== "false";
                    return fallbackBlockedFromProfile;
                },
                default: false,
            }, {
                profile,
            })();
            if (init.ec2MetadataV1Disabled || configValue) {
                const causes = [];
                if (init.ec2MetadataV1Disabled)
                    causes.push("credential provider initialization (runtime option ec2MetadataV1Disabled)");
                if (fallbackBlockedFromProfile)
                    causes.push(`config file profile (${PROFILE_AWS_EC2_METADATA_V1_DISABLED})`);
                if (fallbackBlockedFromProcessEnv)
                    causes.push(`process environment variable (${AWS_EC2_METADATA_V1_DISABLED})`);
                throw new InstanceMetadataV1FallbackError(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${causes.join(", ")}].`);
            }
        }
        const imdsProfile = (await retry(async () => {
            let profile;
            try {
                profile = await getProfile(options);
            }
            catch (err) {
                if (err.statusCode === 401) {
                    disableFetchToken = false;
                }
                throw err;
            }
            return profile;
        }, maxRetries)).trim();
        return retry(async () => {
            let creds;
            try {
                creds = await getCredentialsFromProfile(imdsProfile, options);
            }
            catch (err) {
                if (err.statusCode === 401) {
                    disableFetchToken = false;
                }
                throw err;
            }
            return creds;
        }, maxRetries);
    };
    return async () => {
        const endpoint = await getInstanceMetadataEndpoint();
        if (disableFetchToken) {
            logger?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)");
            return getCredentials(maxRetries, { ...endpoint, timeout });
        }
        else {
            let token;
            try {
                token = (await getMetadataToken({ ...endpoint, timeout })).toString();
            }
            catch (error) {
                if (error?.statusCode === 400) {
                    throw Object.assign(error, {
                        message: "EC2 Metadata token request returned error",
                    });
                }
                else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
                    disableFetchToken = true;
                }
                logger?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)");
                return getCredentials(maxRetries, { ...endpoint, timeout });
            }
            return getCredentials(maxRetries, {
                ...endpoint,
                headers: {
                    [X_AWS_EC2_METADATA_TOKEN]: token,
                },
                timeout,
            });
        }
    };
};
const getMetadataToken = async (options) => httpRequest({
    ...options,
    path: IMDS_TOKEN_PATH,
    method: "PUT",
    headers: {
        "x-aws-ec2-metadata-token-ttl-seconds": "21600",
    },
});
const getProfile = async (options) => (await httpRequest({ ...options, path: IMDS_PATH })).toString();
const getCredentialsFromProfile = async (profile, options) => {
    const credsResponse = JSON.parse((await httpRequest({
        ...options,
        path: IMDS_PATH + profile,
    })).toString());
    if (!isImdsCredentials(credsResponse)) {
        throw new CredentialsProviderError("Invalid response received from instance metadata service.");
    }
    return fromImdsCredentials(credsResponse);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/credential-provider-imds/dist-es/index.js









/***/ }),

/***/ 5914:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  V: () => (/* binding */ Hash)
});

;// CONCATENATED MODULE: ./node_modules/@smithy/hash-node/node_modules/@smithy/is-array-buffer/dist-es/index.js
const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// EXTERNAL MODULE: external "buffer"
var external_buffer_ = __webpack_require__(181);
;// CONCATENATED MODULE: ./node_modules/@smithy/hash-node/node_modules/@smithy/util-buffer-from/dist-es/index.js


const dist_es_fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return external_buffer_.Buffer.from(input, offset, length);
};
const fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? external_buffer_.Buffer.from(input, encoding) : external_buffer_.Buffer.from(input);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/hash-node/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js

const fromUtf8 = (input) => {
    const buf = fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/hash-node/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js

const toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/hash-node/node_modules/@smithy/util-utf8/dist-es/toUtf8.js

const toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

;// CONCATENATED MODULE: ./node_modules/@smithy/hash-node/node_modules/@smithy/util-utf8/dist-es/index.js




// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@smithy/hash-node/dist-es/index.js




class Hash {
    constructor(algorithmIdentifier, secret) {
        this.algorithmIdentifier = algorithmIdentifier;
        this.secret = secret;
        this.reset();
    }
    update(toHash, encoding) {
        this.hash.update(toUint8Array(castSourceData(toHash, encoding)));
    }
    digest() {
        return Promise.resolve(this.hash.digest());
    }
    reset() {
        this.hash = this.secret
            ? (0,external_crypto_.createHmac)(this.algorithmIdentifier, castSourceData(this.secret))
            : (0,external_crypto_.createHash)(this.algorithmIdentifier);
    }
}
function castSourceData(toCast, encoding) {
    if (external_buffer_.Buffer.isBuffer(toCast)) {
        return toCast;
    }
    if (typeof toCast === "string") {
        return fromString(toCast, encoding);
    }
    if (ArrayBuffer.isView(toCast)) {
        return dist_es_fromArrayBuffer(toCast.buffer, toCast.byteOffset, toCast.byteLength);
    }
    return dist_es_fromArrayBuffer(toCast);
}


/***/ }),

/***/ 9587:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  vK: () => (/* binding */ getContentLengthPlugin)
});

// UNUSED EXPORTS: contentLengthMiddleware, contentLengthMiddlewareOptions

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/types/dist-es/http.js
var http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(http_FieldPosition || (http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/node_modules/@smithy/protocol-http/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-content-length/dist-es/index.js

const CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
    return (next) => async (args) => {
        const request = args.request;
        if (HttpRequest.isInstance(request)) {
            const { body, headers } = request;
            if (body &&
                Object.keys(headers)
                    .map((str) => str.toLowerCase())
                    .indexOf(CONTENT_LENGTH_HEADER) === -1) {
                try {
                    const length = bodyLengthChecker(body);
                    request.headers = {
                        ...request.headers,
                        [CONTENT_LENGTH_HEADER]: String(length),
                    };
                }
                catch (error) {
                }
            }
        }
        return next({
            ...args,
            request,
        });
    };
}
const contentLengthMiddlewareOptions = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true,
};
const getContentLengthPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
    },
});


/***/ }),

/***/ 2467:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  qs: () => (/* reexport */ NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
  kN: () => (/* reexport */ NODE_RETRY_MODE_CONFIG_OPTIONS),
  ey: () => (/* reexport */ getRetryPlugin),
  $z: () => (/* reexport */ resolveRetryConfig),
  j7: () => (/* reexport */ retryMiddlewareOptions)
});

// UNUSED EXPORTS: AdaptiveRetryStrategy, CONFIG_MAX_ATTEMPTS, CONFIG_RETRY_MODE, ENV_MAX_ATTEMPTS, ENV_RETRY_MODE, StandardRetryStrategy, defaultDelayDecider, defaultRetryDecider, getOmitRetryHeadersPlugin, getRetryAfterHint, omitRetryHeadersMiddleware, omitRetryHeadersMiddlewareOptions, retryMiddleware

// EXTERNAL MODULE: ./node_modules/@smithy/util-retry/dist-es/index.js + 8 modules
var dist_es = __webpack_require__(3323);
;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/types/dist-es/extensions/checksum.js
var checksum_AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(checksum_AlgorithmId || (checksum_AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => checksum_AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => checksum_AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/types/dist-es/http.js
var http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(http_FieldPosition || (http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class httpRequest_HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new httpRequest_HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/protocol-http/dist-es/httpResponse.js
class httpResponse_HttpResponse {
    constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/protocol-http/dist-es/index.js









// EXTERNAL MODULE: ./node_modules/@smithy/service-error-classification/dist-es/index.js + 1 modules
var service_error_classification_dist_es = __webpack_require__(4542);
// EXTERNAL MODULE: ./node_modules/uuid/dist/esm-node/v4.js + 3 modules
var v4 = __webpack_require__(4349);
;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/dist-es/defaultRetryQuota.js

const getDefaultRetryQuota = (initialRetryTokens, options) => {
    const MAX_CAPACITY = initialRetryTokens;
    const noRetryIncrement = options?.noRetryIncrement ?? dist_es/* NO_RETRY_INCREMENT */.XP;
    const retryCost = options?.retryCost ?? dist_es/* RETRY_COST */.XS;
    const timeoutRetryCost = options?.timeoutRetryCost ?? dist_es/* TIMEOUT_RETRY_COST */.Rn;
    let availableCapacity = initialRetryTokens;
    const getCapacityAmount = (error) => (error.name === "TimeoutError" ? timeoutRetryCost : retryCost);
    const hasRetryTokens = (error) => getCapacityAmount(error) <= availableCapacity;
    const retrieveRetryTokens = (error) => {
        if (!hasRetryTokens(error)) {
            throw new Error("No retry token available");
        }
        const capacityAmount = getCapacityAmount(error);
        availableCapacity -= capacityAmount;
        return capacityAmount;
    };
    const releaseRetryTokens = (capacityReleaseAmount) => {
        availableCapacity += capacityReleaseAmount ?? noRetryIncrement;
        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
    };
    return Object.freeze({
        hasRetryTokens,
        retrieveRetryTokens,
        releaseRetryTokens,
    });
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/dist-es/delayDecider.js

const defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(dist_es/* MAXIMUM_RETRY_DELAY */.G8, Math.random() * 2 ** attempts * delayBase));

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/dist-es/retryDecider.js

const defaultRetryDecider = (error) => {
    if (!error) {
        return false;
    }
    return (0,service_error_classification_dist_es/* isRetryableByTrait */.S0)(error) || (0,service_error_classification_dist_es/* isClockSkewError */.h5)(error) || (0,service_error_classification_dist_es/* isThrottlingError */.Qb)(error) || (0,service_error_classification_dist_es/* isTransientError */.bV)(error);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/dist-es/util.js
const asSdkError = (error) => {
    if (error instanceof Error)
        return error;
    if (error instanceof Object)
        return Object.assign(new Error(), error);
    if (typeof error === "string")
        return new Error(error);
    return new Error(`AWS SDK error wrapper for ${error}`);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/dist-es/StandardRetryStrategy.js








class StandardRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = dist_es/* RETRY_MODES */.cm.STANDARD;
        this.retryDecider = options?.retryDecider ?? defaultRetryDecider;
        this.delayDecider = options?.delayDecider ?? defaultDelayDecider;
        this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(dist_es/* INITIAL_RETRY_TOKENS */.Df);
    }
    shouldRetry(error, attempts, maxAttempts) {
        return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
    }
    async getMaxAttempts() {
        let maxAttempts;
        try {
            maxAttempts = await this.maxAttemptsProvider();
        }
        catch (error) {
            maxAttempts = dist_es/* DEFAULT_MAX_ATTEMPTS */.Gz;
        }
        return maxAttempts;
    }
    async retry(next, args, options) {
        let retryTokenAmount;
        let attempts = 0;
        let totalDelay = 0;
        const maxAttempts = await this.getMaxAttempts();
        const { request } = args;
        if (httpRequest_HttpRequest.isInstance(request)) {
            request.headers[dist_es/* INVOCATION_ID_HEADER */.l5] = (0,v4/* default */.A)();
        }
        while (true) {
            try {
                if (httpRequest_HttpRequest.isInstance(request)) {
                    request.headers[dist_es/* REQUEST_HEADER */.ok] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                }
                if (options?.beforeRequest) {
                    await options.beforeRequest();
                }
                const { response, output } = await next(args);
                if (options?.afterRequest) {
                    options.afterRequest(response);
                }
                this.retryQuota.releaseRetryTokens(retryTokenAmount);
                output.$metadata.attempts = attempts + 1;
                output.$metadata.totalRetryDelay = totalDelay;
                return { response, output };
            }
            catch (e) {
                const err = asSdkError(e);
                attempts++;
                if (this.shouldRetry(err, attempts, maxAttempts)) {
                    retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
                    const delayFromDecider = this.delayDecider((0,service_error_classification_dist_es/* isThrottlingError */.Qb)(err) ? dist_es/* THROTTLING_RETRY_DELAY_BASE */.jh : dist_es/* DEFAULT_RETRY_DELAY_BASE */.bp, attempts);
                    const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
                    const delay = Math.max(delayFromResponse || 0, delayFromDecider);
                    totalDelay += delay;
                    await new Promise((resolve) => setTimeout(resolve, delay));
                    continue;
                }
                if (!err.$metadata) {
                    err.$metadata = {};
                }
                err.$metadata.attempts = attempts;
                err.$metadata.totalRetryDelay = totalDelay;
                throw err;
            }
        }
    }
}
const getDelayFromRetryAfterHeader = (response) => {
    if (!httpResponse_HttpResponse.isInstance(response))
        return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
        return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
        return retryAfterSeconds * 1000;
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate.getTime() - Date.now();
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/dist-es/AdaptiveRetryStrategy.js


class AdaptiveRetryStrategy extends StandardRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        const { rateLimiter, ...superOptions } = options ?? {};
        super(maxAttemptsProvider, superOptions);
        this.rateLimiter = rateLimiter ?? new dist_es/* DefaultRateLimiter */.QJ();
        this.mode = dist_es/* RETRY_MODES */.cm.ADAPTIVE;
    }
    async retry(next, args) {
        return super.retry(next, args, {
            beforeRequest: async () => {
                return this.rateLimiter.getSendToken();
            },
            afterRequest: (response) => {
                this.rateLimiter.updateClientSendingRate(response);
            },
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js

const getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-middleware/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/dist-es/configurations.js


const ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
const CONFIG_MAX_ATTEMPTS = "max_attempts";
const NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        const value = env[ENV_MAX_ATTEMPTS];
        if (!value)
            return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    configFileSelector: (profile) => {
        const value = profile[CONFIG_MAX_ATTEMPTS];
        if (!value)
            return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    default: dist_es/* DEFAULT_MAX_ATTEMPTS */.Gz,
};
const resolveRetryConfig = (input) => {
    const { retryStrategy } = input;
    const maxAttempts = normalizeProvider(input.maxAttempts ?? dist_es/* DEFAULT_MAX_ATTEMPTS */.Gz);
    return {
        ...input,
        maxAttempts,
        retryStrategy: async () => {
            if (retryStrategy) {
                return retryStrategy;
            }
            const retryMode = await normalizeProvider(input.retryMode)();
            if (retryMode === dist_es/* RETRY_MODES */.cm.ADAPTIVE) {
                return new dist_es/* AdaptiveRetryStrategy */.Y(maxAttempts);
            }
            return new dist_es/* StandardRetryStrategy */.ru(maxAttempts);
        },
    };
};
const ENV_RETRY_MODE = "AWS_RETRY_MODE";
const CONFIG_RETRY_MODE = "retry_mode";
const NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[ENV_RETRY_MODE],
    configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],
    default: dist_es/* DEFAULT_RETRY_MODE */.L0,
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/dist-es/omitRetryHeadersMiddleware.js


const omitRetryHeadersMiddleware = () => (next) => async (args) => {
    const { request } = args;
    if (HttpRequest.isInstance(request)) {
        delete request.headers[INVOCATION_ID_HEADER];
        delete request.headers[REQUEST_HEADER];
    }
    return next(args);
};
const omitRetryHeadersMiddlewareOptions = {
    name: "omitRetryHeadersMiddleware",
    tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
    relation: "before",
    toMiddleware: "awsAuthMiddleware",
    override: true,
};
const getOmitRetryHeadersPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(omitRetryHeadersMiddleware(), omitRetryHeadersMiddlewareOptions);
    },
});

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
class NoOpLogger {
    trace() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
const getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const MiddlewareStack_constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo(MiddlewareStack_constructStack()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo(MiddlewareStack_constructStack());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                const step = mw.step ??
                    mw.relation +
                        " " +
                        mw.toMiddleware;
                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/middleware-stack/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/client.js

class Client {
    constructor(config) {
        this.middlewareStack = constructStack();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}

// EXTERNAL MODULE: external "buffer"
var external_buffer_ = __webpack_require__(181);
;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-buffer-from/dist-es/index.js


const dist_es_fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return Buffer.from(input, offset, length);
};
const dist_es_fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? Buffer.from(input, encoding) : Buffer.from(input);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-base64/dist-es/fromBase64.js

const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64_fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = fromString(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js

const fromUtf8_fromUtf8 = (input) => {
    const buf = fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js

const toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-utf8/dist-es/toUtf8.js

const toUtf8_toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-utf8/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-base64/dist-es/toBase64.js


const toBase64_toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
        input = fromUtf8(_input);
    }
    else {
        input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-base64/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-stream/dist-es/blob/transforms.js



function transforms_transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return toBase64(payload);
    }
    return toUtf8(payload);
}
function transforms_transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js

class Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter extends (/* unused pure expression or super */ null && (Uint8Array)) {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return transformFromString(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
    }
}

// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(2203);
;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.js

const getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};

// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(8611);
// EXTERNAL MODULE: external "https"
var external_https_ = __webpack_require__(5692);
;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/node-http-handler/dist-es/write-request-body.js

const MIN_WAIT_TIME = 1000;
async function write_request_body_writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", () => {
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            }),
        ]);
    }
    if (!hasError) {
        writeBody(httpRequest, request.body);
    }
}
function writeBody(httpRequest, body) {
    if (body instanceof Readable) {
        body.pipe(httpRequest);
        return;
    }
    if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
            httpRequest.end(body);
            return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" &&
            uint8.buffer &&
            typeof uint8.byteOffset === "number" &&
            typeof uint8.byteLength === "number") {
            httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
            return;
        }
        httpRequest.end(Buffer.from(body));
        return;
    }
    httpRequest.end();
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js










const DEFAULT_REQUEST_TIMEOUT = 0;
class NodeHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
            return socketWarningTimestamp;
        }
        const interval = 15000;
        if (Date.now() - interval < socketWarningTimestamp) {
            return socketWarningTimestamp;
        }
        if (sockets && requests) {
            for (const origin in sockets) {
                const socketsInUse = sockets[origin]?.length ?? 0;
                const requestsEnqueued = requests[origin]?.length ?? 0;
                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
                    console.warn("@smithy/node-http-handler:WARN", `socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.`, "See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html", "or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.");
                    return Date.now();
                }
            }
        }
        return socketWarningTimestamp;
    }
    constructor(options) {
        this.socketWarningTimestamp = 0;
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout ?? socketTimeout,
            httpAgent: (() => {
                if (httpAgent instanceof hAgent || typeof httpAgent?.destroy === "function") {
                    return httpAgent;
                }
                return new hAgent({ keepAlive, maxSockets, ...httpAgent });
            })(),
            httpsAgent: (() => {
                if (httpsAgent instanceof hsAgent || typeof httpsAgent?.destroy === "function") {
                    return httpsAgent;
                }
                return new hsAgent({ keepAlive, maxSockets, ...httpsAgent });
            })(),
        };
    }
    destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        let socketCheckTimeoutId;
        return new Promise((_resolve, _reject) => {
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                clearTimeout(socketCheckTimeoutId);
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
            socketCheckTimeoutId = setTimeout(() => {
                this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp);
            }, this.config.socketAcquisitionWarningTimeout ??
                (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000));
            const queryString = buildQueryString(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent,
                auth,
            };
            const requestFunc = isSSL ? hsRequest : hRequest;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: getTransformedHeaders(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            setConnectionTimeout(req, reject, this.config.connectionTimeout);
            setSocketTimeout(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                setSocketKeepAlive(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                });
            }
            writeRequestBodyPromise = writeRequestBody(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

// EXTERNAL MODULE: external "http2"
var external_http2_ = __webpack_require__(5675);
;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
class node_http2_connection_pool_NodeHttp2ConnectionPool {
    constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions ?? [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-manager.js


class node_http2_connection_manager_NodeHttp2ConnectionManager {
    constructor(config) {
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/node-http-handler/dist-es/node-http2-handler.js






class NodeHttp2Handler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal?.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: this.config?.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = buildQueryString(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [constants.HTTP2_HEADER_PATH]: path,
                [constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: getTransformedHeaders(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js

class collector_Collector extends external_stream_.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js

const stream_collector_streamCollector = (stream) => {
    if (isReadableStreamInstance(stream)) {
        return collectReadableStream(stream);
    }
    return new Promise((resolve, reject) => {
        const collector = new Collector();
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
            resolve(bytes);
        });
    });
};
const isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
async function collectReadableStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/node-http-handler/dist-es/index.js




// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(9023);
;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js



const keepAliveSupport = {
    supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
};
class FetchHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
        if (typeof options === "function") {
            this.configProvider = options().then((opts) => opts || {});
        }
        else {
            this.config = options ?? {};
            this.configProvider = Promise.resolve(this.config);
        }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        const requestTimeoutInMs = this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = buildQueryString(request.query || {});
        if (queryString) {
            path += `?${queryString}`;
        }
        if (request.fragment) {
            path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? undefined : request.body;
        const requestOptions = {
            body,
            headers: new Headers(request.headers),
            method: method,
        };
        if (body) {
            requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
            requestOptions.signal = abortSignal;
        }
        if (keepAliveSupport.supported) {
            requestOptions.keepalive = keepAlive;
        }
        const fetchRequest = new Request(url, requestOptions);
        const raceOfPromises = [
            fetch(fetchRequest).then((response) => {
                const fetchHeaders = response.headers;
                const transformedHeaders = {};
                for (const pair of fetchHeaders.entries()) {
                    transformedHeaders[pair[0]] = pair[1];
                }
                const hasReadableStream = response.body != undefined;
                if (!hasReadableStream) {
                    return response.blob().then((body) => ({
                        response: new HttpResponse({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body,
                        }),
                    }));
                }
                return {
                    response: new HttpResponse({
                        headers: transformedHeaders,
                        reason: response.statusText,
                        statusCode: response.status,
                        body: response.body,
                    }),
                };
            }),
            requestTimeout(requestTimeoutInMs),
        ];
        if (abortSignal) {
            raceOfPromises.push(new Promise((resolve, reject) => {
                abortSignal.onabort = () => {
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }));
        }
        return Promise.race(raceOfPromises);
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            config[key] = value;
            return config;
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js

const dist_es_stream_collector_streamCollector = (stream) => {
    if (typeof Blob === "function" && stream instanceof Blob) {
        return collectBlob(stream);
    }
    return collectStream(stream);
};
async function collectBlob(blob) {
    const base64 = await readToBase64(blob);
    const arrayBuffer = fromBase64(base64);
    return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}
function readToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (reader.readyState !== 2) {
                return reject(new Error("Reader aborted too early"));
            }
            const result = (reader.result ?? "");
            const commaIndex = result.indexOf(",");
            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
            resolve(result.substring(dataOffset));
        };
        reader.onabort = () => reject(new Error("Read aborted"));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
    });
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/fetch-http-handler/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-hex-encoding/dist-es/index.js
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function dist_es_toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js




const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    if (!isBlobInstance(stream) && !sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
            throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" +
                "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
    };
    return Object.assign(stream, {
        transformToByteArray: transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === "base64") {
                return toBase64(buf);
            }
            else if (encoding === "hex") {
                return toHex(buf);
            }
            else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
                return toUtf8(buf);
            }
            else if (typeof TextDecoder === "function") {
                return new TextDecoder(encoding).decode(buf);
            }
            else {
                throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            transformed = true;
            if (isBlobInstance(stream)) {
                return blobToWebStream(stream);
            }
            else if (sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
                return stream;
            }
            else {
                throw new Error(`Cannot transform payload to web stream, got ${stream}`);
            }
        },
    });
};
const isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
const sdk_stream_mixin_browser_isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js





const sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdk_stream_mixin_sdkStreamMixin = (stream) => {
    if (!(stream instanceof Readable)) {
        try {
            return sdkStreamMixinReadableStream(stream);
        }
        catch (e) {
            const name = stream?.__proto__?.constructor?.name || stream;
            throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return Readable.toWeb(stream);
        },
    });
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/util-stream/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js

const collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/command.js


class Command {
    constructor() {
        this.middlewareStack = constructStack();
    }
    static classBuilder() {
        return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [SMITHY_CONTEXT_KEY]: {
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
class ClassBuilder {
    constructor() {
        this._init = () => { };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
    }
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends Command {
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(...[input]) {
                super();
                this.serialize = closure._serializer;
                this.deserialize = closure._deserializer;
                this.input = input ?? {};
                closure._init(this);
            }
            resolveMiddleware(stack, configuration, options) {
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/parse-utils.js
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
const expectInt = (/* unused pure expression or super */ null && (expectLong));
const expectInt32 = (value) => expectSizedInt(value, 32);
const expectShort = (value) => expectSizedInt(value, 16);
const expectByte = (value) => expectSizedInt(value, 8);
const expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = expectObject(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
const parse_utils_strictParseDouble = (value) => {
    if (typeof value == "string") {
        return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
};
const strictParseFloat = (/* unused pure expression or super */ null && (parse_utils_strictParseDouble));
const parse_utils_strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
};
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectNumber(value);
};
const handleFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectFloat32(value);
};
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value) => {
    if (typeof value === "string") {
        return expectLong(parseNumber(value));
    }
    return expectLong(value);
};
const strictParseInt = (/* unused pure expression or super */ null && (strictParseLong));
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
};
const parse_utils_strictParseShort = (value) => {
    if (typeof value === "string") {
        return expectShort(parseNumber(value));
    }
    return expectShort(value);
};
const parse_utils_strictParseByte = (value) => {
    if (typeof value === "string") {
        return expectByte(parseNumber(value));
    }
    return expectByte(value);
};
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
const logger = {
    warn: console.warn,
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/date-utils.js

const DAYS = (/* unused pure expression or super */ null && (["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]));
const MONTHS = (/* unused pure expression or super */ null && (["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]));
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
const RFC3339 = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/)));
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
const RFC3339_WITH_OFFSET = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/)));
const parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
const IMF_FIXDATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const RFC_850_DATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const ASC_TIME = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/)));
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = (/* unused pure expression or super */ null && (50 * 365 * 24 * 60 * 60 * 1000));
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = (/* unused pure expression or super */ null && ([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]));
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/exceptions.js
class ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
const exceptions_decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/default-error-handler.js

const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw decorateServiceException(response, parsedBody);
};
const withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js


const extensions_checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in AlgorithmId) {
        const algorithmId = AlgorithmId[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const extensions_checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js


const getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
        ...getRetryConfiguration(runtimeConfig),
    };
};
const defaultExtensionConfiguration_getDefaultClientConfiguration = (/* unused pure expression or super */ null && (getDefaultExtensionConfiguration));
const defaultExtensionConfiguration_resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
        ...resolveRetryRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/lazy-json.js
const StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(StringWrapper, String);
class LazyJsonString extends (/* unused pure expression or super */ null && (StringWrapper)) {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
        }
        return new LazyJsonString(JSON.stringify(object));
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/node_modules/@smithy/smithy-client/dist-es/index.js























;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/dist-es/isStreamingPayload/isStreamingPayload.js

const isStreamingPayload = (request) => request?.body instanceof external_stream_.Readable ||
    (typeof ReadableStream !== "undefined" && request?.body instanceof ReadableStream);

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js







const retryMiddleware = (options) => (next, context) => async (args) => {
    let retryStrategy = await options.retryStrategy();
    const maxAttempts = await options.maxAttempts();
    if (isRetryStrategyV2(retryStrategy)) {
        retryStrategy = retryStrategy;
        let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
        let lastError = new Error();
        let attempts = 0;
        let totalRetryDelay = 0;
        const { request } = args;
        const isRequest = httpRequest_HttpRequest.isInstance(request);
        if (isRequest) {
            request.headers[dist_es/* INVOCATION_ID_HEADER */.l5] = (0,v4/* default */.A)();
        }
        while (true) {
            try {
                if (isRequest) {
                    request.headers[dist_es/* REQUEST_HEADER */.ok] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                }
                const { response, output } = await next(args);
                retryStrategy.recordSuccess(retryToken);
                output.$metadata.attempts = attempts + 1;
                output.$metadata.totalRetryDelay = totalRetryDelay;
                return { response, output };
            }
            catch (e) {
                const retryErrorInfo = getRetryErrorInfo(e);
                lastError = asSdkError(e);
                if (isRequest && isStreamingPayload(request)) {
                    (context.logger instanceof NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
                    throw lastError;
                }
                try {
                    retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
                }
                catch (refreshError) {
                    if (!lastError.$metadata) {
                        lastError.$metadata = {};
                    }
                    lastError.$metadata.attempts = attempts + 1;
                    lastError.$metadata.totalRetryDelay = totalRetryDelay;
                    throw lastError;
                }
                attempts = retryToken.getRetryCount();
                const delay = retryToken.getRetryDelay();
                totalRetryDelay += delay;
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
        }
    }
    else {
        retryStrategy = retryStrategy;
        if (retryStrategy?.mode)
            context.userAgent = [...(context.userAgent || []), ["cfg/retry-mode", retryStrategy.mode]];
        return retryStrategy.retry(next, args);
    }
};
const isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" &&
    typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" &&
    typeof retryStrategy.recordSuccess !== "undefined";
const getRetryErrorInfo = (error) => {
    const errorInfo = {
        error,
        errorType: getRetryErrorType(error),
    };
    const retryAfterHint = getRetryAfterHint(error.$response);
    if (retryAfterHint) {
        errorInfo.retryAfterHint = retryAfterHint;
    }
    return errorInfo;
};
const getRetryErrorType = (error) => {
    if ((0,service_error_classification_dist_es/* isThrottlingError */.Qb)(error))
        return "THROTTLING";
    if ((0,service_error_classification_dist_es/* isTransientError */.bV)(error))
        return "TRANSIENT";
    if ((0,service_error_classification_dist_es/* isServerError */.GQ)(error))
        return "SERVER_ERROR";
    return "CLIENT_ERROR";
};
const retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true,
};
const getRetryPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
    },
});
const getRetryAfterHint = (response) => {
    if (!httpResponse_HttpResponse.isInstance(response))
        return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
        return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
        return new Date(retryAfterSeconds * 1000);
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-retry/dist-es/index.js









/***/ }),

/***/ 4542:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  h5: () => (/* binding */ isClockSkewError),
  S0: () => (/* binding */ isRetryableByTrait),
  GQ: () => (/* binding */ isServerError),
  Qb: () => (/* binding */ isThrottlingError),
  bV: () => (/* binding */ isTransientError)
});

// UNUSED EXPORTS: isClockSkewCorrectedError

;// CONCATENATED MODULE: ./node_modules/@smithy/service-error-classification/dist-es/constants.js
const CLOCK_SKEW_ERROR_CODES = [
    "AuthFailure",
    "InvalidSignatureException",
    "RequestExpired",
    "RequestInTheFuture",
    "RequestTimeTooSkewed",
    "SignatureDoesNotMatch",
];
const THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException",
];
const TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
const TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
const NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];

;// CONCATENATED MODULE: ./node_modules/@smithy/service-error-classification/dist-es/index.js

const isRetryableByTrait = (error) => error.$retryable !== undefined;
const isClockSkewError = (error) => CLOCK_SKEW_ERROR_CODES.includes(error.name);
const isClockSkewCorrectedError = (error) => error.$metadata?.clockSkewCorrected;
const isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 ||
    THROTTLING_ERROR_CODES.includes(error.name) ||
    error.$retryable?.throttling == true;
const isTransientError = (error) => isClockSkewCorrectedError(error) ||
    TRANSIENT_ERROR_CODES.includes(error.name) ||
    NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") ||
    TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0);
const isServerError = (error) => {
    if (error.$metadata?.httpStatusCode !== undefined) {
        const statusCode = error.$metadata.httpStatusCode;
        if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
            return true;
        }
        return false;
    }
    return false;
};


/***/ }),

/***/ 9439:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  SignatureV4: () => (/* reexport */ SignatureV4),
  clearCredentialCache: () => (/* reexport */ clearCredentialCache),
  createScope: () => (/* reexport */ createScope),
  getCanonicalHeaders: () => (/* reexport */ getCanonicalHeaders),
  getCanonicalQuery: () => (/* reexport */ getCanonicalQuery),
  getPayloadHash: () => (/* reexport */ getPayloadHash),
  getSigningKey: () => (/* reexport */ getSigningKey),
  moveHeadersToQuery: () => (/* reexport */ moveHeadersToQuery),
  prepareRequest: () => (/* reexport */ prepareRequest)
});

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/util-hex-encoding/dist-es/index.js
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js

const getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/util-middleware/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

// EXTERNAL MODULE: external "buffer"
var external_buffer_ = __webpack_require__(181);
;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/util-buffer-from/dist-es/index.js


const dist_es_fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return Buffer.from(input, offset, length);
};
const fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? external_buffer_.Buffer.from(input, encoding) : external_buffer_.Buffer.from(input);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js

const fromUtf8 = (input) => {
    const buf = fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js

const toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/util-utf8/dist-es/toUtf8.js

const toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/util-utf8/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/constants.js
const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
const SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
const EXPIRES_QUERY_PARAM = "X-Amz-Expires";
const SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
const TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
const REGION_SET_PARAM = "X-Amz-Region-Set";
const AUTH_HEADER = "authorization";
const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
const DATE_HEADER = "date";
const GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
const SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
const SHA256_HEADER = "x-amz-content-sha256";
const TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
const HOST_HEADER = "host";
const ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true,
};
const PROXY_HEADER_PATTERN = /^proxy-/;
const SEC_HEADER_PATTERN = /^sec-/;
const UNSIGNABLE_PATTERNS = (/* unused pure expression or super */ null && ([/^proxy-/i, /^sec-/i]));
const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
const ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
const EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
const UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
const MAX_CACHE_SIZE = 50;
const KEY_TYPE_IDENTIFIER = "aws4_request";
const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js



const signingKeyCache = {};
const cacheQueue = [];
const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
        key = await hmac(sha256Constructor, key, signable);
    }
    return (signingKeyCache[cacheKey] = key);
};
const clearCredentialCache = () => {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach((cacheKey) => {
        delete signingKeyCache[cacheKey];
    });
};
const hmac = (ctor, secret, data) => {
    const hash = new ctor(secret);
    hash.update(toUint8Array(data));
    return hash.digest();
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js

const getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()) {
        if (headers[headerName] == undefined) {
            continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS ||
            unsignableHeaders?.has(canonicalHeaderName) ||
            PROXY_HEADER_PATTERN.test(canonicalHeaderName) ||
            SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
            if (!signableHeaders || (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {
                continue;
            }
        }
        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js


const getCanonicalQuery = ({ query = {} }) => {
    const keys = [];
    const serialized = {};
    for (const key of Object.keys(query).sort()) {
        if (key.toLowerCase() === SIGNATURE_HEADER) {
            continue;
        }
        keys.push(key);
        const value = query[key];
        if (typeof value === "string") {
            serialized[key] = `${escapeUri(key)}=${escapeUri(value)}`;
        }
        else if (Array.isArray(value)) {
            serialized[key] = value
                .slice(0)
                .reduce((encoded, value) => encoded.concat([`${escapeUri(key)}=${escapeUri(value)}`]), [])
                .sort()
                .join("&");
        }
    }
    return keys
        .map((key) => serialized[key])
        .filter((serialized) => serialized)
        .join("&");
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/node_modules/@smithy/is-array-buffer/dist-es/index.js
const dist_es_isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js




const getPayloadHash = async ({ headers, body }, hashConstructor) => {
    for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase() === SHA256_HEADER) {
            return headers[headerName];
        }
    }
    if (body == undefined) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    }
    else if (typeof body === "string" || ArrayBuffer.isView(body) || dist_es_isArrayBuffer(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update(toUint8Array(body));
        return toHex(await hashCtor.digest());
    }
    return UNSIGNED_PAYLOAD;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/HeaderFormatter.js


class HeaderFormatter {
    format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
            const bytes = fromUtf8(headerName);
            chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
            out.set(chunk, position);
            position += chunk.byteLength;
        }
        return out;
    }
    formatHeaderValue(header) {
        switch (header.type) {
            case "boolean":
                return Uint8Array.from([header.value ? 0 : 1]);
            case "byte":
                return Uint8Array.from([2, header.value]);
            case "short":
                const shortView = new DataView(new ArrayBuffer(3));
                shortView.setUint8(0, 3);
                shortView.setInt16(1, header.value, false);
                return new Uint8Array(shortView.buffer);
            case "integer":
                const intView = new DataView(new ArrayBuffer(5));
                intView.setUint8(0, 4);
                intView.setInt32(1, header.value, false);
                return new Uint8Array(intView.buffer);
            case "long":
                const longBytes = new Uint8Array(9);
                longBytes[0] = 5;
                longBytes.set(header.value.bytes, 1);
                return longBytes;
            case "binary":
                const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
                binView.setUint8(0, 6);
                binView.setUint16(1, header.value.byteLength, false);
                const binBytes = new Uint8Array(binView.buffer);
                binBytes.set(header.value, 3);
                return binBytes;
            case "string":
                const utf8Bytes = fromUtf8(header.value);
                const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
                strView.setUint8(0, 7);
                strView.setUint16(1, utf8Bytes.byteLength, false);
                const strBytes = new Uint8Array(strView.buffer);
                strBytes.set(utf8Bytes, 3);
                return strBytes;
            case "timestamp":
                const tsBytes = new Uint8Array(9);
                tsBytes[0] = 8;
                tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
                return tsBytes;
            case "uuid":
                if (!UUID_PATTERN.test(header.value)) {
                    throw new Error(`Invalid UUID received: ${header.value}`);
                }
                const uuidBytes = new Uint8Array(17);
                uuidBytes[0] = 9;
                uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
                return uuidBytes;
        }
    }
}
var HEADER_VALUE_TYPE;
(function (HEADER_VALUE_TYPE) {
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolTrue"] = 0] = "boolTrue";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolFalse"] = 1] = "boolFalse";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byte"] = 2] = "byte";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["short"] = 3] = "short";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["integer"] = 4] = "integer";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["long"] = 5] = "long";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byteArray"] = 6] = "byteArray";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["string"] = 7] = "string";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["timestamp"] = 8] = "timestamp";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
class Int64 {
    constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
            throw new Error("Int64 buffers must be exactly 8 bytes");
        }
    }
    static fromNumber(number) {
        if (number > 9223372036854776000 || number < -9223372036854776000) {
            throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
            bytes[i] = remaining;
        }
        if (number < 0) {
            negate(bytes);
        }
        return new Int64(bytes);
    }
    valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 0b10000000;
        if (negative) {
            negate(bytes);
        }
        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
        return String(this.valueOf());
    }
}
function negate(bytes) {
    for (let i = 0; i < 8; i++) {
        bytes[i] ^= 0xff;
    }
    for (let i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0)
            break;
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/headerUtil.js
const hasHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            return true;
        }
    }
    return false;
};
const getHeaderValue = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            return headers[headerName];
        }
    }
    return undefined;
};
const deleteHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            delete headers[headerName];
        }
    }
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/cloneRequest.js
const cloneRequest = ({ headers, query, ...rest }) => ({
    ...rest,
    headers: { ...headers },
    query: query ? cloneQuery(query) : undefined,
});
const cloneQuery = (query) => Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param,
    };
}, {});

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js

const moveHeadersToQuery = (request, options = {}) => {
    const { headers, query = {} } = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
    for (const name of Object.keys(headers)) {
        const lname = name.toLowerCase();
        if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) {
            query[name] = headers[name];
            delete headers[name];
        }
    }
    return {
        ...request,
        headers,
        query,
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/prepareRequest.js


const prepareRequest = (request) => {
    request = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
    for (const headerName of Object.keys(request.headers)) {
        if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
            delete request.headers[headerName];
        }
    }
    return request;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/utilDate.js
const iso8601 = (time) => toDate(time)
    .toISOString()
    .replace(/\.\d{3}Z$/, "Z");
const toDate = (time) => {
    if (typeof time === "number") {
        return new Date(time * 1000);
    }
    if (typeof time === "string") {
        if (Number(time)) {
            return new Date(Number(time) * 1000);
        }
        return new Date(time);
    }
    return time;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/SignatureV4.js














class SignatureV4 {
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {
        this.headerFormatter = new HeaderFormatter();
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = normalizeProvider(region);
        this.credentialProvider = normalizeProvider(credentials);
    }
    async presign(originalRequest, options = {}) {
        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? (await this.regionProvider());
        const { longDate, shortDate } = formatDate(signingDate);
        if (expiresIn > MAX_PRESIGNED_TTL) {
            return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
        }
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });
        if (credentials.sessionToken) {
            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
        request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request.query[AMZ_DATE_QUERY_PARAM] = longDate;
        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
        request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
        return request;
    }
    async sign(toSign, options) {
        if (typeof toSign === "string") {
            return this.signString(toSign, options);
        }
        else if (toSign.headers && toSign.payload) {
            return this.signEvent(toSign, options);
        }
        else if (toSign.message) {
            return this.signMessage(toSign, options);
        }
        else {
            return this.signRequest(toSign, options);
        }
    }
    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion ?? (await this.regionProvider());
        const { shortDate, longDate } = formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
        const hash = new this.sha256();
        hash.update(headers);
        const hashedHeaders = toHex(await hash.digest());
        const stringToSign = [
            EVENT_ALGORITHM_IDENTIFIER,
            longDate,
            scope,
            priorSignature,
            hashedHeaders,
            hashedPayload,
        ].join("\n");
        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
    }
    async signMessage(signableMessage, { signingDate = new Date(), signingRegion, signingService }) {
        const promise = this.signEvent({
            headers: this.headerFormatter.format(signableMessage.message.headers),
            payload: signableMessage.message.body,
        }, {
            signingDate,
            signingRegion,
            signingService,
            priorSignature: signableMessage.priorSignature,
        });
        return promise.then((signature) => {
            return { message: signableMessage.message, signature };
        });
    }
    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? (await this.regionProvider());
        const { shortDate } = formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash.update(toUint8Array(stringToSign));
        return toHex(await hash.digest());
    }
    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? (await this.regionProvider());
        const request = prepareRequest(requestToSign);
        const { longDate, shortDate } = formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        request.headers[AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
            request.headers[TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await getPayloadHash(request, this.sha256);
        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
            request.headers[SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
        request.headers[AUTH_HEADER] =
            `${ALGORITHM_IDENTIFIER} ` +
                `Credential=${credentials.accessKeyId}/${scope}, ` +
                `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +
                `Signature=${signature}`;
        return request;
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest) {
        const hash = new this.sha256();
        hash.update(toUint8Array(canonicalRequest));
        const hashedRequest = await hash.digest();
        return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
            const normalizedPathSegments = [];
            for (const pathSegment of path.split("/")) {
                if (pathSegment?.length === 0)
                    continue;
                if (pathSegment === ".")
                    continue;
                if (pathSegment === "..") {
                    normalizedPathSegments.pop();
                }
                else {
                    normalizedPathSegments.push(pathSegment);
                }
            }
            const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
            const doubleEncoded = escapeUri(normalizedPath);
            return doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
        const hash = new this.sha256(await keyPromise);
        hash.update(toUint8Array(stringToSign));
        return toHex(await hash.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
    }
    validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" ||
            typeof credentials.accessKeyId !== "string" ||
            typeof credentials.secretAccessKey !== "string") {
            throw new Error("Resolved credential object is not valid");
        }
    }
}
const formatDate = (now) => {
    const longDate = iso8601(now).replace(/[\-:]/g, "");
    return {
        longDate,
        shortDate: longDate.slice(0, 8),
    };
};
const getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");

;// CONCATENATED MODULE: ./node_modules/@smithy/signature-v4/dist-es/index.js









/***/ }),

/***/ 7809:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  n: () => (/* reexport */ calculateBodyLength)
});

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@smithy/util-body-length-node/dist-es/calculateBodyLength.js

const calculateBodyLength = (body) => {
    if (!body) {
        return 0;
    }
    if (typeof body === "string") {
        return Buffer.byteLength(body);
    }
    else if (typeof body.byteLength === "number") {
        return body.byteLength;
    }
    else if (typeof body.size === "number") {
        return body.size;
    }
    else if (typeof body.start === "number" && typeof body.end === "number") {
        return body.end + 1 - body.start;
    }
    else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
        return (0,external_fs_.lstatSync)(body.path).size;
    }
    else if (typeof body.fd === "number") {
        return (0,external_fs_.fstatSync)(body.fd).size;
    }
    throw new Error(`Body Length computation failed for ${body}`);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-body-length-node/dist-es/index.js



/***/ }),

/***/ 2:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  I: () => (/* reexport */ resolveDefaultsModeConfig)
});

// EXTERNAL MODULE: ./node_modules/@smithy/config-resolver/dist-es/index.js + 26 modules
var dist_es = __webpack_require__(7373);
;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/property-provider/dist-es/fromStatic.js
const fromStatic = (staticValue) => () => Promise.resolve(staticValue);

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/property-provider/dist-es/memoize.js
const memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/node-config-provider/dist-es/fromEnv.js

const fromEnv = (envVarSelector) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
};

// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${external_path_.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0,external_os_.homedir)();
    return homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = createHash("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile } = external_fs_.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/types/dist-es/profile.js
var profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(profile_IniSectionType || (profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(profile_IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === profile_IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath_getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(profile_IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: slurpFile_readFile } = external_fs_.promises;
const filePromisesHash = {};
const slurpFile_slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = slurpFile_readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const swallowError = () => ({});
const loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles_loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath_getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile_slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile_slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js


const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = getProfileName(init);
    const { configFile, credentialsFile } = await loadSharedConfigFiles_loadSharedConfigFiles(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message ||
            `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/node-config-provider/dist-es/fromStatic.js

const isFunction = (func) => typeof func === "function";
const fromStatic_fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : fromStatic(defaultValue);

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/node-config-provider/dist-es/configLoader.js




const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize(chain(fromEnv(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic_fromStatic(defaultValue)));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/node_modules/@smithy/node-config-provider/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/dist-es/constants.js
const AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
const AWS_REGION_ENV = "AWS_REGION";
const AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
const ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
const DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
const IMDS_REGION_PATH = "/latest/meta-data/placement/region";

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/dist-es/defaultsModeConfig.js
const AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
const AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
const NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        return env[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile) => {
        return profile[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy",
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/dist-es/resolveDefaultsModeConfig.js





const resolveDefaultsModeConfig = ({ region = loadConfig(dist_es/* NODE_REGION_CONFIG_OPTIONS */.GG), defaultsMode = loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS), } = {}) => memoize(async () => {
    const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
    switch (mode?.toLowerCase()) {
        case "auto":
            return resolveNodeDefaultsModeAuto(region);
        case "in-region":
        case "cross-region":
        case "mobile":
        case "standard":
        case "legacy":
            return Promise.resolve(mode?.toLocaleLowerCase());
        case undefined:
            return Promise.resolve("legacy");
        default:
            throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
    }
});
const resolveNodeDefaultsModeAuto = async (clientRegion) => {
    if (clientRegion) {
        const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
        const inferredRegion = await inferPhysicalRegion();
        if (!inferredRegion) {
            return "standard";
        }
        if (resolvedRegion === inferredRegion) {
            return "in-region";
        }
        else {
            return "cross-region";
        }
    }
    return "standard";
};
const inferPhysicalRegion = async () => {
    if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
        return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
    }
    if (!process.env[ENV_IMDS_DISABLED]) {
        try {
            const { getInstanceMetadataEndpoint, httpRequest } = await Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 3060));
            const endpoint = await getInstanceMetadataEndpoint();
            return (await httpRequest({ ...endpoint, path: IMDS_REGION_PATH })).toString();
        }
        catch (e) {
        }
    }
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-defaults-mode-node/dist-es/index.js



/***/ }),

/***/ 6275:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  mw: () => (/* reexport */ customEndpointFunctions),
  oX: () => (/* reexport */ isIpAddress),
  X8: () => (/* reexport */ isValidHostLabel),
  sO: () => (/* reexport */ resolveEndpoint)
});

// UNUSED EXPORTS: EndpointError

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/lib/isIpAddress.js
const IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
const isIpAddress = (value) => IP_V4_REGEX.test(value) || (value.startsWith("[") && value.endsWith("]"));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/lib/isValidHostLabel.js
const VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
const isValidHostLabel = (value, allowSubDomains = false) => {
    if (!allowSubDomains) {
        return VALID_HOST_LABEL_REGEX.test(value);
    }
    const labels = value.split(".");
    for (const label of labels) {
        if (!isValidHostLabel(label)) {
            return false;
        }
    }
    return true;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/customEndpointFunctions.js
const customEndpointFunctions = {};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/debug/debugId.js
const debugId = "endpoints";

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/debug/toDebugString.js
function toDebugString(input) {
    if (typeof input !== "object" || input == null) {
        return input;
    }
    if ("ref" in input) {
        return `$${toDebugString(input.ref)}`;
    }
    if ("fn" in input) {
        return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
    }
    return JSON.stringify(input, null, 2);
}

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/types/EndpointError.js
class EndpointError extends Error {
    constructor(message) {
        super(message);
        this.name = "EndpointError";
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/types/index.js








;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/lib/booleanEquals.js
const booleanEquals = (value1, value2) => value1 === value2;

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/lib/getAttrPathList.js

const getAttrPathList = (path) => {
    const parts = path.split(".");
    const pathList = [];
    for (const part of parts) {
        const squareBracketIndex = part.indexOf("[");
        if (squareBracketIndex !== -1) {
            if (part.indexOf("]") !== part.length - 1) {
                throw new EndpointError(`Path: '${path}' does not end with ']'`);
            }
            const arrayIndex = part.slice(squareBracketIndex + 1, -1);
            if (Number.isNaN(parseInt(arrayIndex))) {
                throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
            }
            if (squareBracketIndex !== 0) {
                pathList.push(part.slice(0, squareBracketIndex));
            }
            pathList.push(arrayIndex);
        }
        else {
            pathList.push(part);
        }
    }
    return pathList;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js


const getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
    if (typeof acc !== "object") {
        throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
    }
    else if (Array.isArray(acc)) {
        return acc[parseInt(index)];
    }
    return acc[index];
}, value);

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/lib/isSet.js
const isSet = (value) => value != null;

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/lib/not.js
const not = (value) => !value;

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/lib/parseURL.js


const DEFAULT_PORTS = {
    [EndpointURLScheme.HTTP]: 80,
    [EndpointURLScheme.HTTPS]: 443,
};
const parseURL = (value) => {
    const whatwgURL = (() => {
        try {
            if (value instanceof URL) {
                return value;
            }
            if (typeof value === "object" && "hostname" in value) {
                const { hostname, port, protocol = "", path = "", query = {} } = value;
                const url = new URL(`${protocol}//${hostname}${port ? `:${port}` : ""}${path}`);
                url.search = Object.entries(query)
                    .map(([k, v]) => `${k}=${v}`)
                    .join("&");
                return url;
            }
            return new URL(value);
        }
        catch (error) {
            return null;
        }
    })();
    if (!whatwgURL) {
        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
        return null;
    }
    const urlString = whatwgURL.href;
    const { host, hostname, pathname, protocol, search } = whatwgURL;
    if (search) {
        return null;
    }
    const scheme = protocol.slice(0, -1);
    if (!Object.values(EndpointURLScheme).includes(scheme)) {
        return null;
    }
    const isIp = isIpAddress(hostname);
    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) ||
        (typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`));
    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
    return {
        scheme,
        authority,
        path: pathname,
        normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
        isIp,
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/lib/stringEquals.js
const stringEquals = (value1, value2) => value1 === value2;

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/lib/substring.js
const substring = (input, start, stop, reverse) => {
    if (start >= stop || input.length < stop) {
        return null;
    }
    if (!reverse) {
        return input.substring(start, stop);
    }
    return input.substring(input.length - stop, input.length - start);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/lib/uriEncode.js
const uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/lib/index.js










;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js

const endpointFunctions = {
    booleanEquals: booleanEquals,
    getAttr: getAttr,
    isSet: isSet,
    isValidHostLabel: isValidHostLabel,
    not: not,
    parseURL: parseURL,
    stringEquals: stringEquals,
    substring: substring,
    uriEncode: uriEncode,
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTemplate.js

const evaluateTemplate = (template, options) => {
    const evaluatedTemplateArr = [];
    const templateContext = {
        ...options.endpointParams,
        ...options.referenceRecord,
    };
    let currentIndex = 0;
    while (currentIndex < template.length) {
        const openingBraceIndex = template.indexOf("{", currentIndex);
        if (openingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(currentIndex));
            break;
        }
        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
        const closingBraceIndex = template.indexOf("}", openingBraceIndex);
        if (closingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex));
            break;
        }
        if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
            currentIndex = closingBraceIndex + 2;
        }
        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
        if (parameterName.includes("#")) {
            const [refName, attrName] = parameterName.split("#");
            evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
        }
        else {
            evaluatedTemplateArr.push(templateContext[parameterName]);
        }
        currentIndex = closingBraceIndex + 1;
    }
    return evaluatedTemplateArr.join("");
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/getReferenceValue.js
const getReferenceValue = ({ ref }, options) => {
    const referenceRecord = {
        ...options.endpointParams,
        ...options.referenceRecord,
    };
    return referenceRecord[ref];
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js




const evaluateExpression = (obj, keyName, options) => {
    if (typeof obj === "string") {
        return evaluateTemplate(obj, options);
    }
    else if (obj["fn"]) {
        return callFunction(obj, options);
    }
    else if (obj["ref"]) {
        return getReferenceValue(obj, options);
    }
    throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js



const callFunction = ({ fn, argv }, options) => {
    const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
    const fnSegments = fn.split(".");
    if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
        return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
    }
    return endpointFunctions[fn](...evaluatedArgs);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js



const evaluateCondition = ({ assign, ...fnArgs }, options) => {
    if (assign && assign in options.referenceRecord) {
        throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
    }
    const value = callFunction(fnArgs, options);
    options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
    return {
        result: value === "" ? true : !!value,
        ...(assign != null && { toAssign: { name: assign, value } }),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js


const evaluateConditions = (conditions = [], options) => {
    const conditionsReferenceRecord = {};
    for (const condition of conditions) {
        const { result, toAssign } = evaluateCondition(condition, {
            ...options,
            referenceRecord: {
                ...options.referenceRecord,
                ...conditionsReferenceRecord,
            },
        });
        if (!result) {
            return { result };
        }
        if (toAssign) {
            conditionsReferenceRecord[toAssign.name] = toAssign.value;
            options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
        }
    }
    return { result: true, referenceRecord: conditionsReferenceRecord };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointHeaders.js


const getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
    ...acc,
    [headerKey]: headerVal.map((headerValEntry) => {
        const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
        if (typeof processedExpr !== "string") {
            throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
        }
        return processedExpr;
    }),
}), {});

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperty.js



const getEndpointProperty = (property, options) => {
    if (Array.isArray(property)) {
        return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
    }
    switch (typeof property) {
        case "string":
            return evaluateTemplate(property, options);
        case "object":
            if (property === null) {
                throw new EndpointError(`Unexpected endpoint property: ${property}`);
            }
            return getEndpointProperties(property, options);
        case "boolean":
            return property;
        default:
            throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js

const getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
    ...acc,
    [propertyKey]: getEndpointProperty(propertyVal, options),
}), {});

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointUrl.js


const getEndpointUrl = (endpointUrl, options) => {
    const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
    if (typeof expression === "string") {
        try {
            return new URL(expression);
        }
        catch (error) {
            console.error(`Failed to construct URL with ${expression}`, error);
            throw error;
        }
    }
    throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js





const evaluateEndpointRule = (endpointRule, options) => {
    const { conditions, endpoint } = endpointRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
        return;
    }
    const endpointRuleOptions = {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    };
    const { url, properties, headers } = endpoint;
    options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
    return {
        ...(headers != undefined && {
            headers: getEndpointHeaders(headers, endpointRuleOptions),
        }),
        ...(properties != undefined && {
            properties: getEndpointProperties(properties, endpointRuleOptions),
        }),
        url: getEndpointUrl(url, endpointRuleOptions),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/evaluateErrorRule.js



const evaluateErrorRule = (errorRule, options) => {
    const { conditions, error } = errorRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
        return;
    }
    throw new EndpointError(evaluateExpression(error, "Error", {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    }));
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTreeRule.js


const evaluateTreeRule = (treeRule, options) => {
    const { conditions, rules } = treeRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
        return;
    }
    return evaluateRules(rules, {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    });
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js




const evaluateRules = (rules, options) => {
    for (const rule of rules) {
        if (rule.type === "endpoint") {
            const endpointOrUndefined = evaluateEndpointRule(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        }
        else if (rule.type === "error") {
            evaluateErrorRule(rule, options);
        }
        else if (rule.type === "tree") {
            const endpointOrUndefined = evaluateTreeRule(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        }
        else {
            throw new EndpointError(`Unknown endpoint rule: ${rule}`);
        }
    }
    throw new EndpointError(`Rules evaluation failed`);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/utils/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js



const resolveEndpoint = (ruleSetObject, options) => {
    const { endpointParams, logger } = options;
    const { parameters, rules } = ruleSetObject;
    options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
    const paramsWithDefault = Object.entries(parameters)
        .filter(([, v]) => v.default != null)
        .map(([k, v]) => [k, v.default]);
    if (paramsWithDefault.length > 0) {
        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
            endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
        }
    }
    const requiredParams = Object.entries(parameters)
        .filter(([, v]) => v.required)
        .map(([k]) => k);
    for (const requiredParam of requiredParams) {
        if (endpointParams[requiredParam] == null) {
            throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
        }
    }
    const endpoint = evaluateRules(rules, { endpointParams, logger, referenceRecord: {} });
    if (options.endpointParams?.Endpoint) {
        try {
            const givenEndpoint = new URL(options.endpointParams.Endpoint);
            const { protocol, port } = givenEndpoint;
            endpoint.url.protocol = protocol;
            endpoint.url.port = port;
        }
        catch (e) {
        }
    }
    options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
    return endpoint;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-endpoints/dist-es/index.js







/***/ }),

/***/ 3323:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Y: () => (/* reexport */ AdaptiveRetryStrategy),
  Gz: () => (/* reexport */ DEFAULT_MAX_ATTEMPTS),
  bp: () => (/* reexport */ DEFAULT_RETRY_DELAY_BASE),
  L0: () => (/* reexport */ DEFAULT_RETRY_MODE),
  QJ: () => (/* reexport */ DefaultRateLimiter),
  Df: () => (/* reexport */ INITIAL_RETRY_TOKENS),
  l5: () => (/* reexport */ INVOCATION_ID_HEADER),
  G8: () => (/* reexport */ MAXIMUM_RETRY_DELAY),
  XP: () => (/* reexport */ NO_RETRY_INCREMENT),
  ok: () => (/* reexport */ REQUEST_HEADER),
  XS: () => (/* reexport */ RETRY_COST),
  cm: () => (/* reexport */ RETRY_MODES),
  ru: () => (/* reexport */ StandardRetryStrategy),
  jh: () => (/* reexport */ THROTTLING_RETRY_DELAY_BASE),
  Rn: () => (/* reexport */ TIMEOUT_RETRY_COST)
});

// UNUSED EXPORTS: ConfiguredRetryStrategy

;// CONCATENATED MODULE: ./node_modules/@smithy/util-retry/dist-es/config.js
var RETRY_MODES;
(function (RETRY_MODES) {
    RETRY_MODES["STANDARD"] = "standard";
    RETRY_MODES["ADAPTIVE"] = "adaptive";
})(RETRY_MODES || (RETRY_MODES = {}));
const DEFAULT_MAX_ATTEMPTS = 3;
const DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;

// EXTERNAL MODULE: ./node_modules/@smithy/service-error-classification/dist-es/index.js + 1 modules
var dist_es = __webpack_require__(4542);
;// CONCATENATED MODULE: ./node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js

class DefaultRateLimiter {
    constructor(options) {
        this.currentCapacity = 0;
        this.enabled = false;
        this.lastMaxRate = 0;
        this.measuredTxRate = 0;
        this.requestCount = 0;
        this.lastTimestamp = 0;
        this.timeWindow = 0;
        this.beta = options?.beta ?? 0.7;
        this.minCapacity = options?.minCapacity ?? 1;
        this.minFillRate = options?.minFillRate ?? 0.5;
        this.scaleConstant = options?.scaleConstant ?? 0.4;
        this.smooth = options?.smooth ?? 0.8;
        const currentTimeInSeconds = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = currentTimeInSeconds;
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
        this.fillRate = this.minFillRate;
        this.maxCapacity = this.minCapacity;
    }
    getCurrentTimeInSeconds() {
        return Date.now() / 1000;
    }
    async getSendToken() {
        return this.acquireTokenBucket(1);
    }
    async acquireTokenBucket(amount) {
        if (!this.enabled) {
            return;
        }
        this.refillTokenBucket();
        if (amount > this.currentCapacity) {
            const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;
            await new Promise((resolve) => setTimeout(resolve, delay));
        }
        this.currentCapacity = this.currentCapacity - amount;
    }
    refillTokenBucket() {
        const timestamp = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
            this.lastTimestamp = timestamp;
            return;
        }
        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
        this.lastTimestamp = timestamp;
    }
    updateClientSendingRate(response) {
        let calculatedRate;
        this.updateMeasuredRate();
        if ((0,dist_es/* isThrottlingError */.Qb)(response)) {
            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
            this.lastMaxRate = rateToUse;
            this.calculateTimeWindow();
            this.lastThrottleTime = this.getCurrentTimeInSeconds();
            calculatedRate = this.cubicThrottle(rateToUse);
            this.enableTokenBucket();
        }
        else {
            this.calculateTimeWindow();
            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
        }
        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(newRate);
    }
    calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));
    }
    cubicThrottle(rateToUse) {
        return this.getPrecise(rateToUse * this.beta);
    }
    cubicSuccess(timestamp) {
        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
    }
    enableTokenBucket() {
        this.enabled = true;
    }
    updateTokenBucketRate(newRate) {
        this.refillTokenBucket();
        this.fillRate = Math.max(newRate, this.minFillRate);
        this.maxCapacity = Math.max(newRate, this.minCapacity);
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
    }
    updateMeasuredRate() {
        const t = this.getCurrentTimeInSeconds();
        const timeBucket = Math.floor(t * 2) / 2;
        this.requestCount++;
        if (timeBucket > this.lastTxRateBucket) {
            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
            this.requestCount = 0;
            this.lastTxRateBucket = timeBucket;
        }
    }
    getPrecise(num) {
        return parseFloat(num.toFixed(8));
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/util-retry/dist-es/constants.js
const DEFAULT_RETRY_DELAY_BASE = 100;
const MAXIMUM_RETRY_DELAY = 20 * 1000;
const THROTTLING_RETRY_DELAY_BASE = 500;
const INITIAL_RETRY_TOKENS = 500;
const RETRY_COST = 5;
const TIMEOUT_RETRY_COST = 10;
const NO_RETRY_INCREMENT = 1;
const INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
const REQUEST_HEADER = "amz-sdk-request";

;// CONCATENATED MODULE: ./node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js

const getDefaultRetryBackoffStrategy = () => {
    let delayBase = DEFAULT_RETRY_DELAY_BASE;
    const computeNextBackoffDelay = (attempts) => {
        return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
    };
    const setDelayBase = (delay) => {
        delayBase = delay;
    };
    return {
        computeNextBackoffDelay,
        setDelayBase,
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js

const createDefaultRetryToken = ({ retryDelay, retryCount, retryCost, }) => {
    const getRetryCount = () => retryCount;
    const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
    const getRetryCost = () => retryCost;
    return {
        getRetryCount,
        getRetryDelay,
        getRetryCost,
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js




class StandardRetryStrategy {
    constructor(maxAttempts) {
        this.maxAttempts = maxAttempts;
        this.mode = RETRY_MODES.STANDARD;
        this.capacity = INITIAL_RETRY_TOKENS;
        this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
        this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
    }
    async acquireInitialRetryToken(retryTokenScope) {
        return createDefaultRetryToken({
            retryDelay: DEFAULT_RETRY_DELAY_BASE,
            retryCount: 0,
        });
    }
    async refreshRetryTokenForRetry(token, errorInfo) {
        const maxAttempts = await this.getMaxAttempts();
        if (this.shouldRetry(token, errorInfo, maxAttempts)) {
            const errorType = errorInfo.errorType;
            this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
            const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
            const retryDelay = errorInfo.retryAfterHint
                ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)
                : delayFromErrorType;
            const capacityCost = this.getCapacityCost(errorType);
            this.capacity -= capacityCost;
            return createDefaultRetryToken({
                retryDelay,
                retryCount: token.getRetryCount() + 1,
                retryCost: capacityCost,
            });
        }
        throw new Error("No retry token available");
    }
    recordSuccess(token) {
        this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
    }
    getCapacity() {
        return this.capacity;
    }
    async getMaxAttempts() {
        try {
            return await this.maxAttemptsProvider();
        }
        catch (error) {
            console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
            return DEFAULT_MAX_ATTEMPTS;
        }
    }
    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
        const attempts = tokenToRenew.getRetryCount() + 1;
        return (attempts < maxAttempts &&
            this.capacity >= this.getCapacityCost(errorInfo.errorType) &&
            this.isRetryableError(errorInfo.errorType));
    }
    getCapacityCost(errorType) {
        return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
    }
    isRetryableError(errorType) {
        return errorType === "THROTTLING" || errorType === "TRANSIENT";
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js



class AdaptiveRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = RETRY_MODES.ADAPTIVE;
        const { rateLimiter } = options ?? {};
        this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
        this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
    }
    async acquireInitialRetryToken(retryTokenScope) {
        await this.rateLimiter.getSendToken();
        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        this.rateLimiter.updateClientSendingRate(errorInfo);
        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
    }
    recordSuccess(token) {
        this.rateLimiter.updateClientSendingRate({});
        this.standardRetryStrategy.recordSuccess(token);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/util-retry/dist-es/ConfiguredRetryStrategy.js


class ConfiguredRetryStrategy extends StandardRetryStrategy {
    constructor(maxAttempts, computeNextBackoffDelay = DEFAULT_RETRY_DELAY_BASE) {
        super(typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts);
        if (typeof computeNextBackoffDelay === "number") {
            this.computeNextBackoffDelay = () => computeNextBackoffDelay;
        }
        else {
            this.computeNextBackoffDelay = computeNextBackoffDelay;
        }
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
        token.getRetryDelay = () => this.computeNextBackoffDelay(token.getRetryCount());
        return token;
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/util-retry/dist-es/index.js









/***/ }),

/***/ 6454:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const validator = __webpack_require__(3918);
const XMLParser = __webpack_require__(2923);
const XMLBuilder = __webpack_require__(8904);

module.exports = {
  XMLParser: XMLParser,
  XMLValidator: validator,
  XMLBuilder: XMLBuilder
}

/***/ }),

/***/ 5334:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'
const regexName = new RegExp('^' + nameRegexp + '$');

const getAllMatches = function(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
};

const isName = function(string) {
  const match = regexName.exec(string);
  return !(match === null || typeof match === 'undefined');
};

exports.isExist = function(v) {
  return typeof v !== 'undefined';
};

exports.isEmptyObject = function(obj) {
  return Object.keys(obj).length === 0;
};

/**
 * Copy all the properties of a into b.
 * @param {*} target
 * @param {*} a
 */
exports.merge = function(target, a, arrayMode) {
  if (a) {
    const keys = Object.keys(a); // will return an array of own properties
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      if (arrayMode === 'strict') {
        target[keys[i]] = [ a[keys[i]] ];
      } else {
        target[keys[i]] = a[keys[i]];
      }
    }
  }
};
/* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

exports.getValue = function(v) {
  if (exports.isExist(v)) {
    return v;
  } else {
    return '';
  }
};

// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};

exports.isName = isName;
exports.getAllMatches = getAllMatches;
exports.nameRegexp = nameRegexp;


/***/ }),

/***/ 3918:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(5334);

const defaultOptions = {
  allowBooleanAttributes: false, //A tag can have attributes without any value
  unpairedTags: []
};

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
exports.validate = function (xmlData, options) {
  options = Object.assign({}, defaultOptions, options);

  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
  const tags = [];
  let tagFound = false;

  //indicates that the root tag has been closed (aka. depth 0 has been reached)
  let reachedRoot = false;

  if (xmlData[0] === '\ufeff') {
    // check for byte order mark (BOM)
    xmlData = xmlData.substr(1);
  }
  
  for (let i = 0; i < xmlData.length; i++) {

    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
      i+=2;
      i = readPI(xmlData,i);
      if (i.err) return i;
    }else if (xmlData[i] === '<') {
      //starting of tag
      //read until you reach to '>' avoiding any '>' in attribute value
      let tagStartPos = i;
      i++;
      
      if (xmlData[i] === '!') {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === '/') {
          //closing tag
          closingTag = true;
          i++;
        }
        //read tagname
        let tagName = '';
        for (; i < xmlData.length &&
          xmlData[i] !== '>' &&
          xmlData[i] !== ' ' &&
          xmlData[i] !== '\t' &&
          xmlData[i] !== '\n' &&
          xmlData[i] !== '\r'; i++
        ) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        //console.log(tagName);

        if (tagName[tagName.length - 1] === '/') {
          //self closing tag without attributes
          tagName = tagName.substring(0, tagName.length - 1);
          //continue;
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '"+tagName+"' is an invalid name.";
          }
          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
        }

        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;

        if (attrStr[attrStr.length - 1] === '/') {
          //self closing tag
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
            //continue; //text may presents after self closing tag
          } else {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject('InvalidTag',
                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
                getLineNumberForPosition(xmlData, tagStartPos));
            }

            //when there are no more tags, we reached the root level.
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }

          //if the root level has been reached before ...
          if (reachedRoot === true) {
            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
          } else if(options.unpairedTags.indexOf(tagName) !== -1){
            //don't push into stack
          } else {
            tags.push({tagName, tagStartPos});
          }
          tagFound = true;
        }

        //skip tag text value
        //It may include comments and CDATA value
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === '<') {
            if (xmlData[i + 1] === '!') {
              //comment or CADATA
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i+1] === '?') {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else{
              break;
            }
          } else if (xmlData[i] === '&') {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          }else{
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        } //end of reading tag text value
        if (xmlData[i] === '<') {
          i--;
        }
      }
    } else {
      if ( isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }

  if (!tagFound) {
    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
  }else if (tags.length == 1) {
      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  }else if (tags.length > 0) {
      return getErrorObject('InvalidXml', "Invalid '"+
          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
          "' found.", {line: 1, col: 1});
  }

  return true;
};

function isWhiteSpace(char){
  return char === ' ' || char === '\t' || char === '\n'  || char === '\r';
}
/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == '?' || xmlData[i] == ' ') {
      //tagname
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === 'xml') {
        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
        //check if valid attribut string
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}

function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    //comment
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  } else if (
    xmlData.length > i + 8 &&
    xmlData[i + 1] === 'D' &&
    xmlData[i + 2] === 'O' &&
    xmlData[i + 3] === 'C' &&
    xmlData[i + 4] === 'T' &&
    xmlData[i + 5] === 'Y' &&
    xmlData[i + 6] === 'P' &&
    xmlData[i + 7] === 'E'
  ) {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === '<') {
        angleBracketsCount++;
      } else if (xmlData[i] === '>') {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (
    xmlData.length > i + 9 &&
    xmlData[i + 1] === '[' &&
    xmlData[i + 2] === 'C' &&
    xmlData[i + 3] === 'D' &&
    xmlData[i + 4] === 'A' &&
    xmlData[i + 5] === 'T' &&
    xmlData[i + 6] === 'A' &&
    xmlData[i + 7] === '['
  ) {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  }

  return i;
}

const doubleQuote = '"';
const singleQuote = "'";

/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */
function readAttributeStr(xmlData, i) {
  let attrStr = '';
  let startChar = '';
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === '') {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
      } else {
        startChar = '';
      }
    } else if (xmlData[i] === '>') {
      if (startChar === '') {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== '') {
    return false;
  }

  return {
    value: attrStr,
    index: i,
    tagClosed: tagClosed
  };
}

/**
 * Select all the attributes whether valid or invalid.
 */
const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

function validateAttributeString(attrStr, options) {
  //console.log("start:"+attrStr+":end");

  //if(attrStr.trim().length === 0) return true; //empty string

  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};

  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      //nospace before attribute name: a="sd"b="saf"
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
      //independent attribute: ab
      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
    }
    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      //check for duplicate attribute.
      attrNames[attrName] = 1;
    } else {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
    }
  }

  return true;
}

function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === 'x') {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ';')
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}

function validateAmpersand(xmlData, i) {
  // https://www.w3.org/TR/xml/#dt-charref
  i++;
  if (xmlData[i] === ';')
    return -1;
  if (xmlData[i] === '#') {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ';')
      break;
    return -1;
  }
  return i;
}

function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code: code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col,
    },
  };
}

function validateAttrName(attrName) {
  return util.isName(attrName);
}

// const startsWithXML = /^xml/i;

function validateTagName(tagname) {
  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
}

//this function returns the line number for the character at the given index
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,

    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}

//this function returns the position of the first character of match within attrStr
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}


/***/ }),

/***/ 8904:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

//parse Empty Node as self closing node
const buildFromOrderedJs = __webpack_require__(2788);

const defaultOptions = {
  attributeNamePrefix: '@_',
  attributesGroupName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: '  ',
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },//it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("\'", "g"), val: "&apos;" },
    { regex: new RegExp("\"", "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};

function Builder(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes || this.options.attributesGroupName) {
    this.isAttribute = function(/*a*/) {
      return false;
    };
  } else {
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }

  this.processTextOrObjNode = processTextOrObjNode

  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = '>\n';
    this.newLine = '\n';
  } else {
    this.indentate = function() {
      return '';
    };
    this.tagEndChar = '>';
    this.newLine = '';
  }
}

Builder.prototype.build = function(jObj) {
  if(this.options.preserveOrder){
    return buildFromOrderedJs(jObj, this.options);
  }else {
    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){
      jObj = {
        [this.options.arrayNodeName] : jObj
      }
    }
    return this.j2x(jObj, 0).val;
  }
};

Builder.prototype.j2x = function(jObj, level) {
  let attrStr = '';
  let val = '';
  for (let key in jObj) {
    if (typeof jObj[key] === 'undefined') {
      // supress undefined node
    } else if (jObj[key] === null) {
      if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
      else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextValNode(jObj[key], key, '', level);
    } else if (typeof jObj[key] !== 'object') {
      //premitive type
      const attr = this.isAttribute(key);
      if (attr) {
        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
      }else {
        //tag value
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
          val += this.replaceEntitiesValue(newval);
        } else {
          val += this.buildTextValNode(jObj[key], key, '', level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      //repeated nodes
      const arrLen = jObj[key].length;
      let listTagVal = "";
      for (let j = 0; j < arrLen; j++) {
        const item = jObj[key][j];
        if (typeof item === 'undefined') {
          // supress undefined node
        } else if (item === null) {
          if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
        } else if (typeof item === 'object') {
          if(this.options.oneListGroup ){
            listTagVal += this.j2x(item, level + 1).val;
          }else{
            listTagVal += this.processTextOrObjNode(item, key, level)
          }
        } else {
          listTagVal += this.buildTextValNode(item, key, '', level);
        }
      }
      if(this.options.oneListGroup){
        listTagVal = this.buildObjectNode(listTagVal, key, '', level);
      }
      val += listTagVal;
    } else {
      //nested node
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
        }
      } else {
        val += this.processTextOrObjNode(jObj[key], key, level)
      }
    }
  }
  return {attrStr: attrStr, val: val};
};

Builder.prototype.buildAttrPairStr = function(attrName, val){
  val = this.options.attributeValueProcessor(attrName, '' + val);
  val = this.replaceEntitiesValue(val);
  if (this.options.suppressBooleanAttributes && val === "true") {
    return ' ' + attrName;
  } else return ' ' + attrName + '="' + val + '"';
}

function processTextOrObjNode (object, key, level) {
  const result = this.j2x(object, level + 1);
  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjectNode(result.val, key, result.attrStr, level);
  }
}

Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
  if(val === ""){
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }
  }else{

    let tagEndExp = '</' + key + this.tagEndChar;
    let piClosingChar = "";
    
    if(key[0] === "?") {
      piClosingChar = "?";
      tagEndExp = "";
    }
  
    if (attrStr && val.indexOf('<') === -1) {
      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
      return this.indentate(level) + `<!--${val}-->` + this.newLine;
    }else {
      return (
        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +
        val +
        this.indentate(level) + tagEndExp    );
    }
  }
}

Builder.prototype.closeTag = function(key){
  let closeTag = "";
  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
    if(!this.options.suppressUnpairedNode) closeTag = "/"
  }else if(this.options.suppressEmptyNode){ //empty
    closeTag = "/";
  }else{
    closeTag = `></${key}`
  }
  return closeTag;
}

function buildEmptyObjNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildObjectNode(val, key, attrStr, level);
  } else {
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
      // return this.buildTagStr(level,key, attrStr);
    }
  }
}

Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;
  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val}-->` +  this.newLine;
  }else if(key[0] === "?") {//PI tag
    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; 
  }else{
    let textValue = this.options.tagValueProcessor(key, val);
    textValue = this.replaceEntitiesValue(textValue);
  
    if( textValue === ''){
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }else{
      return this.indentate(level) + '<' + key + attrStr + '>' +
         textValue +
        '</' + key + this.tagEndChar;
    }
  }
}

Builder.prototype.replaceEntitiesValue = function(textValue){
  if(textValue && textValue.length > 0 && this.options.processEntities){
    for (let i=0; i<this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}

function indentate(level) {
  return this.options.indentBy.repeat(level);
}

function isAttribute(name /*, options*/) {
  if (name.startsWith(this.options.attributeNamePrefix)) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}

module.exports = Builder;


/***/ }),

/***/ 2788:
/***/ ((module) => {

const EOL = "\n";

/**
 * 
 * @param {array} jArray 
 * @param {any} options 
 * @returns 
 */
function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
}

function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;

    for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName
        else newJPath = `${jPath}.${tagName}`;

        if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
                tagText = options.tagValueProcessor(tagName, tagText);
                tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
        } else if (tagName[0] === "?") {
            const attStr = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
            isPreviousElementTag = true;
            continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
            newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
            else xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
                xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
                xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
    }

    return xmlStr;
}

function propName(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key !== ":@") return key;
    }
}

function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
        }
    }
    return attrStr;
}

function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
    }
    return false;
}

function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i = 0; i < options.entities.length; i++) {
            const entity = options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
        }
    }
    return textValue;
}
module.exports = toXml;


/***/ }),

/***/ 9400:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const util = __webpack_require__(5334);

//TODO: handle comments
function readDocType(xmlData, i){
    
    const entities = {};
    if( xmlData[i + 3] === 'O' &&
         xmlData[i + 4] === 'C' &&
         xmlData[i + 5] === 'T' &&
         xmlData[i + 6] === 'Y' &&
         xmlData[i + 7] === 'P' &&
         xmlData[i + 8] === 'E')
    {    
        i = i+9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for(;i<xmlData.length;i++){
            if (xmlData[i] === '<' && !comment) { //Determine the tag type
                if( hasBody && isEntity(xmlData, i)){
                    i += 7; 
                    [entityName, val,i] = readEntityExp(xmlData,i+1);
                    if(val.indexOf("&") === -1) //Parameter entities are not supported
                        entities[ validateEntityName(entityName) ] = {
                            regx : RegExp( `&${entityName};`,"g"),
                            val: val
                        };
                }
                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported
                else if( isComment)                         comment = true;
                else                                        throw new Error("Invalid DOCTYPE");

                angleBracketsCount++;
                exp = "";
            } else if (xmlData[i] === '>') { //Read tag content
                if(comment){
                    if( xmlData[i - 1] === "-" && xmlData[i - 2] === "-"){
                        comment = false;
                        angleBracketsCount--;
                    }
                }else{
                    angleBracketsCount--;
                }
                if (angleBracketsCount === 0) {
                  break;
                }
            }else if( xmlData[i] === '['){
                hasBody = true;
            }else{
                exp += xmlData[i];
            }
        }
        if(angleBracketsCount !== 0){
            throw new Error(`Unclosed DOCTYPE`);
        }
    }else{
        throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return {entities, i};
}

function readEntityExp(xmlData,i){
    //External entities are not supported
    //    <!ENTITY ext SYSTEM "http://normal-website.com" >

    //Parameter entities are not supported
    //    <!ENTITY entityname "&anotherElement;">

    //Internal entities are supported
    //    <!ENTITY entityname "replacement text">
    
    //read EntityName
    let entityName = "";
    for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"' ); i++) {
        // if(xmlData[i] === " ") continue;
        // else 
        entityName += xmlData[i];
    }
    entityName = entityName.trim();
    if(entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");

    //read Entity Value
    const startChar = xmlData[i++];
    let val = ""
    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {
        val += xmlData[i];
    }
    return [entityName, val, i];
}

function isComment(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === '-' &&
    xmlData[i+3] === '-') return true
    return false
}
function isEntity(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'N' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'I' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'Y') return true
    return false
}
function isElement(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'L' &&
    xmlData[i+4] === 'E' &&
    xmlData[i+5] === 'M' &&
    xmlData[i+6] === 'E' &&
    xmlData[i+7] === 'N' &&
    xmlData[i+8] === 'T') return true
    return false
}

function isAttlist(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'A' &&
    xmlData[i+3] === 'T' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'L' &&
    xmlData[i+6] === 'I' &&
    xmlData[i+7] === 'S' &&
    xmlData[i+8] === 'T') return true
    return false
}
function isNotation(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'N' &&
    xmlData[i+3] === 'O' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'A' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'I' &&
    xmlData[i+8] === 'O' &&
    xmlData[i+9] === 'N') return true
    return false
}

function validateEntityName(name){
    if (util.isName(name))
	return name;
    else
        throw new Error(`Invalid entity name ${name}`);
}

module.exports = readDocType;


/***/ }),

/***/ 460:
/***/ ((__unused_webpack_module, exports) => {


const defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: '@_',
    attributesGroupName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    removeNSPrefix: false, // remove NS from tag name or attribute name if true
    allowBooleanAttributes: false, //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true, //Trim string values of tag and attributes
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val) {
      return val;
    },
    attributeValueProcessor: function(attrName, val) {
      return val;
    },
    stopNodes: [], //nested tags will not be parsed even for errors
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs){
      return tagName
    },
    // skipEmptyListItem: false
};
   
const buildOptions = function(options) {
    return Object.assign({}, defaultOptions, options);
};

exports.buildOptions = buildOptions;
exports.defaultOptions = defaultOptions;

/***/ }),

/***/ 7680:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

///@ts-check

const util = __webpack_require__(5334);
const xmlNode = __webpack_require__(3832);
const readDocType = __webpack_require__(9400);
const toNumber = __webpack_require__(7983);

const regx =
  '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
  .replace(/NAME/g, util.nameRegexp);

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

class OrderedObjParser{
  constructor(options){
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos" : { regex: /&(apos|#39|#x27);/g, val : "'"},
      "gt" : { regex: /&(gt|#62|#x3E);/g, val : ">"},
      "lt" : { regex: /&(lt|#60|#x3C);/g, val : "<"},
      "quot" : { regex: /&(quot|#34|#x22);/g, val : "\""},
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : "&"};
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent" : { regex: /&(cent|#162);/g, val: "¢" },
      "pound" : { regex: /&(pound|#163);/g, val: "£" },
      "yen" : { regex: /&(yen|#165);/g, val: "¥" },
      "euro" : { regex: /&(euro|#8364);/g, val: "€" },
      "copyright" : { regex: /&(copy|#169);/g, val: "©" },
      "reg" : { regex: /&(reg|#174);/g, val: "®" },
      "inr" : { regex: /&(inr|#8377);/g, val: "₹" },
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
  }

}

function addExternalEntities(externalEntities){
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
       regex: new RegExp("&"+ent+";","g"),
       val : externalEntities[ent]
    }
  }
}

/**
 * @param {string} val
 * @param {string} tagName
 * @param {string} jPath
 * @param {boolean} dontTrim
 * @param {boolean} hasAttributes
 * @param {boolean} isLeafNode
 * @param {boolean} escapeEntities
 */
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== undefined) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if(val.length > 0){
      if(!escapeEntities) val = this.replaceEntitiesValue(val);
      
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if(newval === null || newval === undefined){
        //don't parse
        return val;
      }else if(typeof newval !== typeof val || newval !== val){
        //overwrite
        return newval;
      }else if(this.options.trimValues){
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      }else{
        const trimmedVal = val.trim();
        if(trimmedVal === val){
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        }else{
          return val;
        }
      }
    }
  }
}

function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(':');
    const prefix = tagname.charAt(0) === '/' ? '/' : '';
    if (tags[0] === 'xmlns') {
      return '';
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');

function buildAttributesMap(attrStr, jPath, tagName) {
  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {
    // attrStr = attrStr.replace(/\r?\n/g, ' ');
    //attrStr = attrStr || attrStr.trim();

    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length; //don't make it inline
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if(aName === "__proto__") aName  = "#__proto__";
        if (oldVal !== undefined) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if(newVal === null || newVal === undefined){
            //don't parse
            attrs[aName] = oldVal;
          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){
            //overwrite
            attrs[aName] = newVal;
          }else{
            //parse
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs
  }
}

const parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
  const xmlObj = new xmlNode('!xml');
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for(let i=0; i< xmlData.length; i++){//for each char in XML data
    const ch = xmlData[i];
    if(ch === '<'){
      // const nextIndex = i+1;
      // const _2ndChar = xmlData[nextIndex];
      if( xmlData[i+1] === '/') {//Closing Tag
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.")
        let tagName = xmlData.substring(i+2,closeIndex).trim();

        if(this.options.removeNSPrefix){
          const colonIndex = tagName.indexOf(":");
          if(colonIndex !== -1){
            tagName = tagName.substr(colonIndex+1);
          }
        }

        if(this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }

        if(currentNode){
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }

        //check if last tag of nested tag was unpaired tag
        const lastTagName = jPath.substring(jPath.lastIndexOf(".")+1);
        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0
        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){
          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)
          this.tagsNodeStack.pop();
        }else{
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);

        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope
        textData = "";
        i = closeIndex;
      } else if( xmlData[i+1] === '?') {

        let tagData = readTagExp(xmlData,i, false, "?>");
        if(!tagData) throw new Error("Pi Tag is not closed.");

        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if( (this.options.ignoreDeclaration && tagData.tagName === "?xml") || this.options.ignorePiTags){

        }else{
  
          const childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          
          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath)

        }


        i = tagData.closeIndex + 1;
      } else if(xmlData.substr(i + 1, 3) === '!--') {
        const endIndex = findClosingIndex(xmlData, "-->", i+4, "Comment is not closed.")
        if(this.options.commentPropName){
          const comment = xmlData.substring(i + 4, endIndex - 2);

          textData = this.saveTextToParentTag(textData, currentNode, jPath);

          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);
        }
        i = endIndex;
      } else if( xmlData.substr(i + 1, 2) === '!D') {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      }else if(xmlData.substr(i + 1, 2) === '![') {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9,closeIndex);

        textData = this.saveTextToParentTag(textData, currentNode, jPath);

        //cdata should be set even if it is 0 length string
        if(this.options.cdataPropName){
          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + "." + this.options.cdataPropName, true, false, true);
          // if(!val) val = "";
          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);
        }else{
          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
          if(val == undefined) val = "";
          currentNode.add(this.options.textNodeName, val);
        }
        
        i = closeIndex + 2;
      }else {//Opening tag
        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);
        let tagName= result.tagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;

        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        
        //save text as child node
        if (currentNode && textData) {
          if(currentNode.tagname !== '!xml'){
            //when nested tag is found
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }

        //check if last tag was unpaired tag
        const lastTag = currentNode;
        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if(tagName !== xmlObj.tagname){
          jPath += jPath ? "." + tagName : tagName;
        }
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace
          let tagContent = "";
          //self-closing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            i = result.closeIndex;
          }
          //unpaired tag
          else if(this.options.unpairedTags.indexOf(tagName) !== -1){
            i = result.closeIndex;
          }
          //normal tag
          else{
            //read until closing tag is found
            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
            if(!result) throw new Error(`Unexpected end of ${tagName}`);
            i = result.i;
            tagContent = result.tagContent;
          }

          const childNode = new xmlNode(tagName);
          if(tagName !== tagExp && attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if(tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          
          this.addChild(currentNode, childNode, jPath)
        }else{
  //selfClosing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              tagExp = tagName;
            }else{
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            
            if(this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }

            const childNode = new xmlNode(tagName);
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath)
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          }
    //opening tag
          else{
            const childNode = new xmlNode( tagName);
            this.tagsNodeStack.push(currentNode);
            
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath)
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    }else{
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
}

function addChild(currentNode, childNode, jPath){
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"])
  if(result === false){
  }else if(typeof result === "string"){
    childNode.tagname = result
    currentNode.addChild(childNode);
  }else{
    currentNode.addChild(childNode);
  }
}

const replaceEntitiesValue = function(val){

  if(this.options.processEntities){
    for(let entityName in this.docTypeEntities){
      const entity = this.docTypeEntities[entityName];
      val = val.replace( entity.regx, entity.val);
    }
    for(let entityName in this.lastEntities){
      const entity = this.lastEntities[entityName];
      val = val.replace( entity.regex, entity.val);
    }
    if(this.options.htmlEntities){
      for(let entityName in this.htmlEntities){
        const entity = this.htmlEntities[entityName];
        val = val.replace( entity.regex, entity.val);
      }
    }
    val = val.replace( this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
}
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) { //store previously collected data as textNode
    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0
    
    textData = this.parseTextData(textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode);

    if (textData !== undefined && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}

//TODO: use jPath to simplify the logic
/**
 * 
 * @param {string[]} stopNodes 
 * @param {string} jPath
 * @param {string} currentTagName 
 */
function isItStopNode(stopNodes, jPath, currentTagName){
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;
  }
  return false;
}

/**
 * Returns the tag Expression and where it is ending handling single-double quotes situation
 * @param {string} xmlData 
 * @param {number} i starting index
 * @returns 
 */
function tagExpWithClosingIndex(xmlData, i, closingChar = ">"){
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
        if (ch === attrBoundary) attrBoundary = "";//reset
    } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if(closingChar[1]){
        if(xmlData[index + 1] === closingChar[1]){
          return {
            data: tagExp,
            index: index
          }
        }
      }else{
        return {
          data: tagExp,
          index: index
        }
      }
    } else if (ch === '\t') {
      ch = " "
    }
    tagExp += ch;
  }
}

function findClosingIndex(xmlData, str, i, errMsg){
  const closingIndex = xmlData.indexOf(str, i);
  if(closingIndex === -1){
    throw new Error(errMsg)
  }else{
    return closingIndex + str.length - 1;
  }
}

function readTagExp(xmlData,i, removeNSPrefix, closingChar = ">"){
  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);
  if(!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if(separatorIndex !== -1){//separate tag name and attributes expression
    tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, '');
    tagExp = tagExp.substr(separatorIndex + 1);
  }

  if(removeNSPrefix){
    const colonIndex = tagName.indexOf(":");
    if(colonIndex !== -1){
      tagName = tagName.substr(colonIndex+1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }

  return {
    tagName: tagName,
    tagExp: tagExp,
    closeIndex: closeIndex,
    attrExpPresent: attrExpPresent,
  }
}
/**
 * find paired tag for a stop node
 * @param {string} xmlData 
 * @param {string} tagName 
 * @param {number} i 
 */
function readStopNodeData(xmlData, tagName, i){
  const startIndex = i;
  // Starting at 1 since we already have an open tag
  let openTagCount = 1;

  for (; i < xmlData.length; i++) {
    if( xmlData[i] === "<"){ 
      if (xmlData[i+1] === "/") {//close tag
          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i+2,closeIndex).trim();
          if(closeTagName === tagName){
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i),
                i : closeIndex
              }
            }
          }
          i=closeIndex;
        } else if(xmlData[i+1] === '?') { 
          const closeIndex = findClosingIndex(xmlData, "?>", i+1, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 3) === '!--') { 
          const closeIndex = findClosingIndex(xmlData, "-->", i+3, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 2) === '![') { 
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
          i=closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i, '>')

          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== "/") {
              openTagCount++;
            }
            i=tagData.closeIndex;
          }
        }
      }
  }//end for loop
}

function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === 'string') {
    //console.log(options)
    const newval = val.trim();
    if(newval === 'true' ) return true;
    else if(newval === 'false' ) return false;
    else return toNumber(val, options);
  } else {
    if (util.isExist(val)) {
      return val;
    } else {
      return '';
    }
  }
}


module.exports = OrderedObjParser;


/***/ }),

/***/ 2923:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { buildOptions} = __webpack_require__(460);
const OrderedObjParser = __webpack_require__(7680);
const { prettify} = __webpack_require__(5629);
const validator = __webpack_require__(3918);

class XMLParser{
    
    constructor(options){
        this.externalEntities = {};
        this.options = buildOptions(options);
        
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */
    parse(xmlData,validationOption){
        if(typeof xmlData === "string"){
        }else if( xmlData.toString){
            xmlData = xmlData.toString();
        }else{
            throw new Error("XML data is accepted in String or Bytes[] form.")
        }
        if( validationOption){
            if(validationOption === true) validationOption = {}; //validate with default options
            
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )
            }
          }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;
        else return prettify(orderedResult, this.options);
    }

    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
    addEntity(key, value){
        if(value.indexOf("&") !== -1){
            throw new Error("Entity value can't have '&'")
        }else if(key.indexOf("&") !== -1 || key.indexOf(";") !== -1){
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'")
        }else if(value === "&"){
            throw new Error("An entity with value '&' is not permitted");
        }else{
            this.externalEntities[key] = value;
        }
    }
}

module.exports = XMLParser;

/***/ }),

/***/ 5629:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * 
 * @param {array} node 
 * @param {any} options 
 * @returns 
 */
function prettify(node, options){
  return compress( node, options);
}

/**
 * 
 * @param {array} arr 
 * @param {object} options 
 * @param {string} jPath 
 * @returns object
 */
function compress(arr, options, jPath){
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName(tagObj);
    let newJpath = "";
    if(jPath === undefined) newJpath = property;
    else newJpath = jPath + "." + property;

    if(property === options.textNodeName){
      if(text === undefined) text = tagObj[property];
      else text += "" + tagObj[property];
    }else if(property === undefined){
      continue;
    }else if(tagObj[property]){
      
      let val = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val, options);

      if(tagObj[":@"]){
        assignAttributes( val, tagObj[":@"], newJpath, options);
      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){
        val = val[options.textNodeName];
      }else if(Object.keys(val).length === 0){
        if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }

      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
        if(!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [ compressedObj[property] ];
        }
        compressedObj[property].push(val);
      }else{
        //TODO: if a node is not an array, then check if it should be an array
        //also determine if it is a leaf node
        if (options.isArray(property, newJpath, isLeaf )) {
          compressedObj[property] = [val];
        }else{
          compressedObj[property] = val;
        }
      }
    }
    
  }
  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
  if(typeof text === "string"){
    if(text.length > 0) compressedObj[options.textNodeName] = text;
  }else if(text !== undefined) compressedObj[options.textNodeName] = text;
  return compressedObj;
}

function propName(obj){
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if(key !== ":@") return key;
  }
}

function assignAttributes(obj, attrMap, jpath, options){
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [ attrMap[atrrName] ];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}

function isLeafTag(obj, options){
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  
  if (propCount === 0) {
    return true;
  }

  if (
    propCount === 1 &&
    (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)
  ) {
    return true;
  }

  return false;
}
exports.prettify = prettify;


/***/ }),

/***/ 3832:
/***/ ((module) => {

"use strict";


class XmlNode{
  constructor(tagname) {
    this.tagname = tagname;
    this.child = []; //nested tags, text, cdata, comments in order
    this[":@"] = {}; //attributes map
  }
  add(key,val){
    // this.child.push( {name : key, val: val, isCdata: isCdata });
    if(key === "__proto__") key = "#__proto__";
    this.child.push( {[key]: val });
  }
  addChild(node) {
    if(node.tagname === "__proto__") node.tagname = "#__proto__";
    if(node[":@"] && Object.keys(node[":@"]).length > 0){
      this.child.push( { [node.tagname]: node.child, [":@"]: node[":@"] });
    }else{
      this.child.push( { [node.tagname]: node.child });
    }
  };
};


module.exports = XmlNode;

/***/ }),

/***/ 1429:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Mnemonist LRUCache
 * ===================
 *
 * JavaScript implementation of the LRU Cache data structure. To save up
 * memory and allocations this implementation represents its underlying
 * doubly-linked list as static arrays and pointers. Thus, memory is allocated
 * only once at instantiation and JS objects are never created to serve as
 * pointers. This also means this implementation does not trigger too many
 * garbage collections.
 *
 * Note that to save up memory, a LRU Cache can be implemented using a singly
 * linked list by storing predecessors' pointers as hashmap values.
 * However, this means more hashmap lookups and would probably slow the whole
 * thing down. What's more, pointers are not the things taking most space in
 * memory.
 */
var Iterator = __webpack_require__(2766),
    forEach = __webpack_require__(156),
    typed = __webpack_require__(5384),
    iterables = __webpack_require__(9938);

/**
 * LRUCache.
 *
 * @constructor
 * @param {function} Keys     - Array class for storing keys.
 * @param {function} Values   - Array class for storing values.
 * @param {number}   capacity - Desired capacity.
 */
function LRUCache(Keys, Values, capacity) {
  if (arguments.length < 2) {
    capacity = Keys;
    Keys = null;
    Values = null;
  }

  this.capacity = capacity;

  if (typeof this.capacity !== 'number' || this.capacity <= 0)
    throw new Error('mnemonist/lru-cache: capacity should be positive number.');

  var PointerArray = typed.getPointerArray(capacity);

  this.forward = new PointerArray(capacity);
  this.backward = new PointerArray(capacity);
  this.K = typeof Keys === 'function' ? new Keys(capacity) : new Array(capacity);
  this.V = typeof Values === 'function' ? new Values(capacity) : new Array(capacity);

  // Properties
  this.size = 0;
  this.head = 0;
  this.tail = 0;
  this.items = {};
}

/**
 * Method used to clear the structure.
 *
 * @return {undefined}
 */
LRUCache.prototype.clear = function() {
  this.size = 0;
  this.head = 0;
  this.tail = 0;
  this.items = {};
};

/**
 * Method used to splay a value on top.
 *
 * @param  {number}   pointer - Pointer of the value to splay on top.
 * @return {LRUCache}
 */
LRUCache.prototype.splayOnTop = function(pointer) {
  var oldHead = this.head;

  if (this.head === pointer)
    return this;

  var previous = this.backward[pointer],
      next = this.forward[pointer];

  if (this.tail === pointer) {
    this.tail = previous;
  }
  else {
    this.backward[next] = previous;
  }

  this.forward[previous] = next;

  this.backward[oldHead] = pointer;
  this.head = pointer;
  this.forward[pointer] = oldHead;

  return this;
};

/**
 * Method used to set the value for the given key in the cache.
 *
 * @param  {any} key   - Key.
 * @param  {any} value - Value.
 * @return {undefined}
 */
LRUCache.prototype.set = function(key, value) {

  // The key already exists, we just need to update the value and splay on top
  var pointer = this.items[key];

  if (typeof pointer !== 'undefined') {
    this.splayOnTop(pointer);
    this.V[pointer] = value;

    return;
  }

  // The cache is not yet full
  if (this.size < this.capacity) {
    pointer = this.size++;
  }

  // Cache is full, we need to drop the last value
  else {
    pointer = this.tail;
    this.tail = this.backward[pointer];
    delete this.items[this.K[pointer]];
  }

  // Storing key & value
  this.items[key] = pointer;
  this.K[pointer] = key;
  this.V[pointer] = value;

  // Moving the item at the front of the list
  this.forward[pointer] = this.head;
  this.backward[this.head] = pointer;
  this.head = pointer;
};

/**
 * Method used to set the value for the given key in the cache
 *
 * @param  {any} key   - Key.
 * @param  {any} value - Value.
 * @return {{evicted: boolean, key: any, value: any}} An object containing the
 * key and value of an item that was overwritten or evicted in the set
 * operation, as well as a boolean indicating whether it was evicted due to
 * limited capacity. Return value is null if nothing was evicted or overwritten
 * during the set operation.
 */
LRUCache.prototype.setpop = function(key, value) {
  var oldValue = null;
  var oldKey = null;
  // The key already exists, we just need to update the value and splay on top
  var pointer = this.items[key];

  if (typeof pointer !== 'undefined') {
    this.splayOnTop(pointer);
    oldValue = this.V[pointer];
    this.V[pointer] = value;
    return {evicted: false, key: key, value: oldValue};
  }

  // The cache is not yet full
  if (this.size < this.capacity) {
    pointer = this.size++;
  }

  // Cache is full, we need to drop the last value
  else {
    pointer = this.tail;
    this.tail = this.backward[pointer];
    oldValue = this.V[pointer];
    oldKey = this.K[pointer];
    delete this.items[this.K[pointer]];
  }

  // Storing key & value
  this.items[key] = pointer;
  this.K[pointer] = key;
  this.V[pointer] = value;

  // Moving the item at the front of the list
  this.forward[pointer] = this.head;
  this.backward[this.head] = pointer;
  this.head = pointer;

  // Return object if eviction took place, otherwise return null
  if (oldKey) {
    return {evicted: true, key: oldKey, value: oldValue};
  }
  else {
    return null;
  }
};

/**
 * Method used to check whether the key exists in the cache.
 *
 * @param  {any} key   - Key.
 * @return {boolean}
 */
LRUCache.prototype.has = function(key) {
  return key in this.items;
};

/**
 * Method used to get the value attached to the given key. Will move the
 * related key to the front of the underlying linked list.
 *
 * @param  {any} key   - Key.
 * @return {any}
 */
LRUCache.prototype.get = function(key) {
  var pointer = this.items[key];

  if (typeof pointer === 'undefined')
    return;

  this.splayOnTop(pointer);

  return this.V[pointer];
};

/**
 * Method used to get the value attached to the given key. Does not modify
 * the ordering of the underlying linked list.
 *
 * @param  {any} key   - Key.
 * @return {any}
 */
LRUCache.prototype.peek = function(key) {
    var pointer = this.items[key];

    if (typeof pointer === 'undefined')
        return;

    return this.V[pointer];
};

/**
 * Method used to iterate over the cache's entries using a callback.
 *
 * @param  {function}  callback - Function to call for each item.
 * @param  {object}    scope    - Optional scope.
 * @return {undefined}
 */
LRUCache.prototype.forEach = function(callback, scope) {
  scope = arguments.length > 1 ? scope : this;

  var i = 0,
      l = this.size;

  var pointer = this.head,
      keys = this.K,
      values = this.V,
      forward = this.forward;

  while (i < l) {

    callback.call(scope, values[pointer], keys[pointer], this);
    pointer = forward[pointer];

    i++;
  }
};

/**
 * Method used to create an iterator over the cache's keys from most
 * recently used to least recently used.
 *
 * @return {Iterator}
 */
LRUCache.prototype.keys = function() {
  var i = 0,
      l = this.size;

  var pointer = this.head,
      keys = this.K,
      forward = this.forward;

  return new Iterator(function() {
    if (i >= l)
      return {done: true};

    var key = keys[pointer];

    i++;

    if (i < l)
      pointer = forward[pointer];

    return {
      done: false,
      value: key
    };
  });
};

/**
 * Method used to create an iterator over the cache's values from most
 * recently used to least recently used.
 *
 * @return {Iterator}
 */
LRUCache.prototype.values = function() {
  var i = 0,
      l = this.size;

  var pointer = this.head,
      values = this.V,
      forward = this.forward;

  return new Iterator(function() {
    if (i >= l)
      return {done: true};

    var value = values[pointer];

    i++;

    if (i < l)
      pointer = forward[pointer];

    return {
      done: false,
      value: value
    };
  });
};

/**
 * Method used to create an iterator over the cache's entries from most
 * recently used to least recently used.
 *
 * @return {Iterator}
 */
LRUCache.prototype.entries = function() {
  var i = 0,
      l = this.size;

  var pointer = this.head,
      keys = this.K,
      values = this.V,
      forward = this.forward;

  return new Iterator(function() {
    if (i >= l)
      return {done: true};

    var key = keys[pointer],
        value = values[pointer];

    i++;

    if (i < l)
      pointer = forward[pointer];

    return {
      done: false,
      value: [key, value]
    };
  });
};

/**
 * Attaching the #.entries method to Symbol.iterator if possible.
 */
if (typeof Symbol !== 'undefined')
  LRUCache.prototype[Symbol.iterator] = LRUCache.prototype.entries;

/**
 * Convenience known methods.
 */
LRUCache.prototype.inspect = function() {
  var proxy = new Map();

  var iterator = this.entries(),
      step;

  while ((step = iterator.next(), !step.done))
    proxy.set(step.value[0], step.value[1]);

  // Trick so that node displays the name of the constructor
  Object.defineProperty(proxy, 'constructor', {
    value: LRUCache,
    enumerable: false
  });

  return proxy;
};

if (typeof Symbol !== 'undefined')
  LRUCache.prototype[Symbol.for('nodejs.util.inspect.custom')] = LRUCache.prototype.inspect;

/**
 * Static @.from function taking an arbitrary iterable & converting it into
 * a structure.
 *
 * @param  {Iterable} iterable - Target iterable.
 * @param  {function} Keys     - Array class for storing keys.
 * @param  {function} Values   - Array class for storing values.
 * @param  {number}   capacity - Cache's capacity.
 * @return {LRUCache}
 */
LRUCache.from = function(iterable, Keys, Values, capacity) {
  if (arguments.length < 2) {
    capacity = iterables.guessLength(iterable);

    if (typeof capacity !== 'number')
      throw new Error('mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.');
  }
  else if (arguments.length === 2) {
    capacity = Keys;
    Keys = null;
    Values = null;
  }

  var cache = new LRUCache(Keys, Values, capacity);

  forEach(iterable, function(value, key) {
    cache.set(key, value);
  });

  return cache;
};

/**
 * Exporting.
 */
module.exports = LRUCache;


/***/ }),

/***/ 9938:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Mnemonist Iterable Function
 * ============================
 *
 * Harmonized iteration helpers over mixed iterable targets.
 */
var forEach = __webpack_require__(156);

var typed = __webpack_require__(5384);

/**
 * Function used to determine whether the given object supports array-like
 * random access.
 *
 * @param  {any} target - Target object.
 * @return {boolean}
 */
function isArrayLike(target) {
  return Array.isArray(target) || typed.isTypedArray(target);
}

/**
 * Function used to guess the length of the structure over which we are going
 * to iterate.
 *
 * @param  {any} target - Target object.
 * @return {number|undefined}
 */
function guessLength(target) {
  if (typeof target.length === 'number')
    return target.length;

  if (typeof target.size === 'number')
    return target.size;

  return;
}

/**
 * Function used to convert an iterable to an array.
 *
 * @param  {any}   target - Iteration target.
 * @return {array}
 */
function toArray(target) {
  var l = guessLength(target);

  var array = typeof l === 'number' ? new Array(l) : [];

  var i = 0;

  // TODO: we could optimize when given target is array like
  forEach(target, function(value) {
    array[i++] = value;
  });

  return array;
}

/**
 * Same as above but returns a supplementary indices array.
 *
 * @param  {any}   target - Iteration target.
 * @return {array}
 */
function toArrayWithIndices(target) {
  var l = guessLength(target);

  var IndexArray = typeof l === 'number' ?
    typed.getPointerArray(l) :
    Array;

  var array = typeof l === 'number' ? new Array(l) : [];
  var indices = typeof l === 'number' ? new IndexArray(l) : [];

  var i = 0;

  // TODO: we could optimize when given target is array like
  forEach(target, function(value) {
    array[i] = value;
    indices[i] = i++;
  });

  return [array, indices];
}

/**
 * Exporting.
 */
exports.isArrayLike = isArrayLike;
exports.guessLength = guessLength;
exports.toArray = toArray;
exports.toArrayWithIndices = toArrayWithIndices;


/***/ }),

/***/ 5384:
/***/ ((__unused_webpack_module, exports) => {

/**
 * Mnemonist Typed Array Helpers
 * ==============================
 *
 * Miscellaneous helpers related to typed arrays.
 */

/**
 * When using an unsigned integer array to store pointers, one might want to
 * choose the optimal word size in regards to the actual numbers of pointers
 * to store.
 *
 * This helpers does just that.
 *
 * @param  {number} size - Expected size of the array to map.
 * @return {TypedArray}
 */
var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,
    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,
    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;

var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,
    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,
    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;

exports.getPointerArray = function(size) {
  var maxIndex = size - 1;

  if (maxIndex <= MAX_8BIT_INTEGER)
    return Uint8Array;

  if (maxIndex <= MAX_16BIT_INTEGER)
    return Uint16Array;

  if (maxIndex <= MAX_32BIT_INTEGER)
    return Uint32Array;

  return Float64Array;
};

exports.getSignedPointerArray = function(size) {
  var maxIndex = size - 1;

  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
    return Int8Array;

  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
    return Int16Array;

  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
    return Int32Array;

  return Float64Array;
};

/**
 * Function returning the minimal type able to represent the given number.
 *
 * @param  {number} value - Value to test.
 * @return {TypedArrayClass}
 */
exports.getNumberType = function(value) {

  // <= 32 bits itnteger?
  if (value === (value | 0)) {

    // Negative
    if (Math.sign(value) === -1) {
      if (value <= 127 && value >= -128)
        return Int8Array;

      if (value <= 32767 && value >= -32768)
        return Int16Array;

      return Int32Array;
    }
    else {

      if (value <= 255)
        return Uint8Array;

      if (value <= 65535)
        return Uint16Array;

      return Uint32Array;
    }
  }

  // 53 bits integer & floats
  // NOTE: it's kinda hard to tell whether we could use 32bits or not...
  return Float64Array;
};

/**
 * Function returning the minimal type able to represent the given array
 * of JavaScript numbers.
 *
 * @param  {array}    array  - Array to represent.
 * @param  {function} getter - Optional getter.
 * @return {TypedArrayClass}
 */
var TYPE_PRIORITY = {
  Uint8Array: 1,
  Int8Array: 2,
  Uint16Array: 3,
  Int16Array: 4,
  Uint32Array: 5,
  Int32Array: 6,
  Float32Array: 7,
  Float64Array: 8
};

// TODO: make this a one-shot for one value
exports.getMinimalRepresentation = function(array, getter) {
  var maxType = null,
      maxPriority = 0,
      p,
      t,
      v,
      i,
      l;

  for (i = 0, l = array.length; i < l; i++) {
    v = getter ? getter(array[i]) : array[i];
    t = exports.getNumberType(v);
    p = TYPE_PRIORITY[t.name];

    if (p > maxPriority) {
      maxPriority = p;
      maxType = t;
    }
  }

  return maxType;
};

/**
 * Function returning whether the given value is a typed array.
 *
 * @param  {any} value - Value to test.
 * @return {boolean}
 */
exports.isTypedArray = function(value) {
  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);
};

/**
 * Function used to concat byte arrays.
 *
 * @param  {...ByteArray}
 * @return {ByteArray}
 */
exports.concat = function() {
  var length = 0,
      i,
      o,
      l;

  for (i = 0, l = arguments.length; i < l; i++)
    length += arguments[i].length;

  var array = new (arguments[0].constructor)(length);

  for (i = 0, o = 0; i < l; i++) {
    array.set(arguments[i], o);
    o += arguments[i].length;
  }

  return array;
};

/**
 * Function used to initialize a byte array of indices.
 *
 * @param  {number}    length - Length of target.
 * @return {ByteArray}
 */
exports.indices = function(length) {
  var PointerArray = exports.getPointerArray(length);

  var array = new PointerArray(length);

  for (var i = 0; i < length; i++)
    array[i] = i;

  return array;
};


/***/ }),

/***/ 156:
/***/ ((module) => {

/**
 * Obliterator ForEach Function
 * =============================
 *
 * Helper function used to easily iterate over mixed values.
 */

/**
 * Constants.
 */
var ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== 'undefined',
    SYMBOL_SUPPORT = typeof Symbol !== 'undefined';

/**
 * Function able to iterate over almost any iterable JS value.
 *
 * @param  {any}      iterable - Iterable value.
 * @param  {function} callback - Callback function.
 */
function forEach(iterable, callback) {
  var iterator, k, i, l, s;

  if (!iterable)
    throw new Error('obliterator/forEach: invalid iterable.');

  if (typeof callback !== 'function')
    throw new Error('obliterator/forEach: expecting a callback.');

  // The target is an array or a string or function arguments
  if (
    Array.isArray(iterable) ||
    (ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable)) ||
    typeof iterable === 'string' ||
    iterable.toString() === '[object Arguments]'
  ) {
    for (i = 0, l = iterable.length; i < l; i++)
      callback(iterable[i], i);
    return;
  }

  // The target has a #.forEach method
  if (typeof iterable.forEach === 'function') {
    iterable.forEach(callback);
    return;
  }

  // The target is iterable
  if (
    SYMBOL_SUPPORT &&
    Symbol.iterator in iterable &&
    typeof iterable.next !== 'function'
  ) {
    iterable = iterable[Symbol.iterator]();
  }

  // The target is an iterator
  if (typeof iterable.next === 'function') {
    iterator = iterable;
    i = 0;

    while ((s = iterator.next(), s.done !== true)) {
      callback(s.value, i);
      i++;
    }

    return;
  }

  // The target is a plain object
  for (k in iterable) {
    if (iterable.hasOwnProperty(k)) {
      callback(iterable[k], k);
    }
  }

  return;
}

/**
 * Same function as the above `forEach` but will yield `null` when the target
 * does not have keys.
 *
 * @param  {any}      iterable - Iterable value.
 * @param  {function} callback - Callback function.
 */
forEach.forEachWithNullKeys = function(iterable, callback) {
  var iterator, k, i, l, s;

  if (!iterable)
    throw new Error('obliterator/forEachWithNullKeys: invalid iterable.');

  if (typeof callback !== 'function')
    throw new Error('obliterator/forEachWithNullKeys: expecting a callback.');

  // The target is an array or a string or function arguments
  if (
    Array.isArray(iterable) ||
    (ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable)) ||
    typeof iterable === 'string' ||
    iterable.toString() === '[object Arguments]'
  ) {
    for (i = 0, l = iterable.length; i < l; i++)
      callback(iterable[i], null);
    return;
  }

  // The target is a Set
  if (iterable instanceof Set) {
    iterable.forEach(function(value) {
      callback(value, null);
    });
    return;
  }

  // The target has a #.forEach method
  if (typeof iterable.forEach === 'function') {
    iterable.forEach(callback);
    return;
  }

  // The target is iterable
  if (
    SYMBOL_SUPPORT &&
    Symbol.iterator in iterable &&
    typeof iterable.next !== 'function'
  ) {
    iterable = iterable[Symbol.iterator]();
  }

  // The target is an iterator
  if (typeof iterable.next === 'function') {
    iterator = iterable;
    i = 0;

    while ((s = iterator.next(), s.done !== true)) {
      callback(s.value, null);
      i++;
    }

    return;
  }

  // The target is a plain object
  for (k in iterable) {
    if (iterable.hasOwnProperty(k)) {
      callback(iterable[k], k);
    }
  }

  return;
};

/**
 * Exporting.
 */
module.exports = forEach;


/***/ }),

/***/ 2766:
/***/ ((module) => {

/**
 * Obliterator Iterator Class
 * ===========================
 *
 * Simple class representing the library's iterators.
 */

/**
 * Iterator class.
 *
 * @constructor
 * @param {function} next - Next function.
 */
function Iterator(next) {

  // Hiding the given function
  Object.defineProperty(this, '_next', {
    writable: false,
    enumerable: false,
    value: next
  });

  // Is the iterator complete?
  this.done = false;
}

/**
 * Next function.
 *
 * @return {object}
 */
// NOTE: maybe this should dropped for performance?
Iterator.prototype.next = function() {
  if (this.done)
    return {done: true};

  var step = this._next();

  if (step.done)
    this.done = true;

  return step;
};

/**
 * If symbols are supported, we add `next` to `Symbol.iterator`.
 */
if (typeof Symbol !== 'undefined')
  Iterator.prototype[Symbol.iterator] = function() {
    return this;
  };

/**
 * Returning an iterator of the given values.
 *
 * @param  {any...} values - Values.
 * @return {Iterator}
 */
Iterator.of = function() {
  var args = arguments,
      l = args.length,
      i = 0;

  return new Iterator(function() {
    if (i >= l)
      return {done: true};

    return {done: false, value: args[i++]};
  });
};

/**
 * Returning an empty iterator.
 *
 * @return {Iterator}
 */
Iterator.empty = function() {
  var iterator = new Iterator(null);
  iterator.done = true;

  return iterator;
};

/**
 * Returning whether the given value is an iterator.
 *
 * @param  {any} value - Value.
 * @return {boolean}
 */
Iterator.is = function(value) {
  if (value instanceof Iterator)
    return true;

  return (
    typeof value === 'object' &&
    value !== null &&
    typeof value.next === 'function'
  );
};

/**
 * Exporting.
 */
module.exports = Iterator;


/***/ }),

/***/ 7983:
/***/ ((module) => {

const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
// const octRegex = /0x[a-z0-9]+/;
// const binRegex = /0x[a-z0-9]+/;


//polyfill
if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
}

  
const consider = {
    hex :  true,
    leadingZeros: true,
    decimalPoint: "\.",
    eNotation: true
    //skipLike: /regex/
};

function toNumber(str, options = {}){
    // const options = Object.assign({}, consider);
    // if(opt.leadingZeros === false){
    //     options.leadingZeros = false;
    // }else if(opt.hex === false){
    //     options.hex = false;
    // }

    options = Object.assign({}, consider, options );
    if(!str || typeof str !== "string" ) return str;
    
    let trimmedStr  = str.trim();
    // if(trimmedStr === "0.0") return 0;
    // else if(trimmedStr === "+0.0") return 0;
    // else if(trimmedStr === "-0.0") return -0;

    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
    // } else if (options.parseOct && octRegex.test(str)) {
    //     return Number.parseInt(val, 8);
    // }else if (options.parseBin && binRegex.test(str)) {
    //     return Number.parseInt(val, 2);
    }else{
        //separate negative sign, leading zeros, and rest number
        const match = numRegex.exec(trimmedStr);
        if(match){
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
            //trim ending zeros for floating number
            
            const eNotation = match[4] || match[6];
            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
            else{//no leading zeros or leading zeros are allowed
                const num = Number(trimmedStr);
                const numStr = "" + num;
                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(eNotation){ //given number has enotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
                    // const decimalPart = match[5].substr(1);
                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

                    
                    // const p = numStr.indexOf(".");
                    // const givenIntPart = numStr.substr(0,p);
                    // const givenDecPart = numStr.substr(p+1);
                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
                    else return str;
                }
                
                if(leadingZeros){
                    // if(numTrimmedByZeros === numStr){
                    //     if(options.leadingZeros) return num;
                    //     else return str;
                    // }else return str;
                    if(numTrimmedByZeros === numStr) return num;
                    else if(sign+numTrimmedByZeros === numStr) return num;
                    else return str;
                }

                if(trimmedStr === numStr) return num;
                else if(trimmedStr === sign+numStr) return num;
                // else{
                //     //number with +/- sign
                //     trimmedStr.test(/[-+][0-9]);

                // }
                return str;
            }
            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
            
        }else{ //non-numeric string
            return str;
        }
    }
}

/**
 * 
 * @param {string} numStr without leading zeros
 * @returns 
 */
function trimZeros(numStr){
    if(numStr && numStr.indexOf(".") !== -1){//float
        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
        if(numStr === ".")  numStr = "0";
        else if(numStr[0] === ".")  numStr = "0"+numStr;
        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
        return numStr;
    }
    return numStr;
}
module.exports = toNumber


/***/ }),

/***/ 4349:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ esm_node_v4)
});

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
var external_crypto_default = /*#__PURE__*/__webpack_require__.n(external_crypto_);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/native.js

/* harmony default export */ const esm_node_native = ({
  randomUUID: (external_crypto_default()).randomUUID
});
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/rng.js

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    external_crypto_default().randomFillSync(rnds8Pool);
    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/stringify.js

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const esm_node_stringify = ((/* unused pure expression or super */ null && (stringify)));
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-node/v4.js




function v4(options, buf, offset) {
  if (esm_node_native.randomUUID && !buf && !options) {
    return esm_node_native.randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return unsafeStringify(rnds);
}

/* harmony default export */ const esm_node_v4 = (v4);

/***/ }),

/***/ 181:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 6982:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 9896:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 8611:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5675:
/***/ ((module) => {

"use strict";
module.exports = require("http2");

/***/ }),

/***/ 5692:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 857:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 6928:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 2203:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 9023:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 1635:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),
/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),
/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),
/* harmony export */   __await: () => (/* binding */ __await),
/* harmony export */   __awaiter: () => (/* binding */ __awaiter),
/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   __createBinding: () => (/* binding */ __createBinding),
/* harmony export */   __decorate: () => (/* binding */ __decorate),
/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),
/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),
/* harmony export */   __exportStar: () => (/* binding */ __exportStar),
/* harmony export */   __extends: () => (/* binding */ __extends),
/* harmony export */   __generator: () => (/* binding */ __generator),
/* harmony export */   __importDefault: () => (/* binding */ __importDefault),
/* harmony export */   __importStar: () => (/* binding */ __importStar),
/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),
/* harmony export */   __metadata: () => (/* binding */ __metadata),
/* harmony export */   __param: () => (/* binding */ __param),
/* harmony export */   __propKey: () => (/* binding */ __propKey),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),
/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),
/* harmony export */   __spread: () => (/* binding */ __spread),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),
/* harmony export */   __values: () => (/* binding */ __values),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
      }
      catch (e) {
          fail(e);
      }
    }
    if (env.hasError) throw env.error;
  }
  return next();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
});


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  WrappedNvimPlugin: () => (/* binding */ WrappedNvimPlugin),
  "default": () => (/* binding */ app)
});

;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Function.js
/**
 * Tests if a value is a `function`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isFunction } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isFunction(isFunction), true)
 * assert.deepStrictEqual(isFunction("function"), false)
 *
 * @category guards
 * @since 2.0.0
 */
const Function_isFunction = input => typeof input === "function";
/**
 * Creates a function that can be used in a data-last (aka `pipe`able) or
 * data-first style.
 *
 * The first parameter to `dual` is either the arity of the uncurried function
 * or a predicate that determines if the function is being used in a data-first
 * or data-last style.
 *
 * Using the arity is the most common use case, but there are some cases where
 * you may want to use a predicate. For example, if you have a function that
 * takes an optional argument, you can use a predicate to determine if the
 * function is being used in a data-first or data-last style.
 *
 * @param arity - Either the arity of the uncurried function or a predicate
 *                which determines if the function is being used in a data-first
 *                or data-last style.
 * @param body - The definition of the uncurried function.
 *
 * @example
 * import { dual, pipe } from "effect/Function"
 *
 * // Exampe using arity to determine data-first or data-last style
 * const sum: {
 *   (that: number): (self: number) => number
 *   (self: number, that: number): number
 * } = dual(2, (self: number, that: number): number => self + that)
 *
 * assert.deepStrictEqual(sum(2, 3), 5)
 * assert.deepStrictEqual(pipe(2, sum(3)), 5)
 *
 * // Example using a predicate to determine data-first or data-last style
 * const sum2: {
 *   (that: number): (self: number) => number
 *   (self: number, that: number): number
 * } = dual((args) => args.length === 1, (self: number, that: number): number => self + that)
 *
 * assert.deepStrictEqual(sum(2, 3), 5)
 * assert.deepStrictEqual(pipe(2, sum(3)), 5)
 *
 * @since 2.0.0
 */
const Function_dual = function (arity, body) {
  if (typeof arity === "function") {
    return function () {
      if (arity(arguments)) {
        // @ts-expect-error
        return body.apply(this, arguments);
      }
      return self => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function (a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function (self) {
          return body(self, a);
        };
      };
    case 3:
      return function (a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function (self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function (a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function (self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function (a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function (self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function () {
        if (arguments.length >= arity) {
          // @ts-expect-error
          return body.apply(this, arguments);
        }
        const args = arguments;
        return function (self) {
          return body(self, ...args);
        };
      };
  }
};
/**
 * Apply a function to a given value.
 *
 * @param a - The value that the function will be applied to.
 * @param self - The function to be applied to a value.
 *
 * @example
 * import { pipe, apply } from "effect/Function"
 * import { length } from "effect/String"
 *
 * assert.deepStrictEqual(pipe(length, apply("hello")), 5)
 *
 * @since 2.0.0
 */
const apply = a => self => self(a);
/**
 * The identity function, i.e. A function that returns its input argument.
 *
 * @param a - The input argument.
 *
 * @example
 * import { identity } from "effect/Function"
 *
 * assert.deepStrictEqual(identity(5), 5)
 *
 * @since 2.0.0
 */
const Function_identity = a => a;
/**
 * A function that ensures that the type of an expression matches some type,
 * without changing the resulting type of that expression.
 *
 * @example
 * import { satisfies } from "effect/Function"
 *
 * const test1 = satisfies<number>()(5 as const)
 *     //^? const test: 5
 *     // @ts-expect-error
 * const test2 = satisfies<string>()(5)
 *     //^? Argument of type 'number' is not assignable to parameter of type 'string'
 *
 * assert.deepStrictEqual(satisfies<number>()(5), 5)
 *
 * @since 2.0.0
 */
const satisfies = () => b => b;
/**
 * Casts the result to the specified type.
 *
 * @param a - The value to be casted to the target type.
 *
 * @example
 * import { unsafeCoerce, identity } from "effect/Function"
 *
 * assert.deepStrictEqual(unsafeCoerce, identity)
 *
 * @since 2.0.0
 */
const Function_unsafeCoerce = (/* unused pure expression or super */ null && (Function_identity));
/**
 * Creates a constant value that never changes.
 *
 * This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)
 * and want that inner function to always use the same value, no matter how many times it is called.
 *
 * @param value - The constant value to be returned.
 *
 * @example
 * import { constant } from "effect/Function"
 *
 * const constNull = constant(null)
 *
 * assert.deepStrictEqual(constNull(), null)
 * assert.deepStrictEqual(constNull(), null)
 *
 * @since 2.0.0
 */
const constant = value => () => value;
/**
 * A thunk that returns always `true`.
 *
 * @example
 * import { constTrue } from "effect/Function"
 *
 * assert.deepStrictEqual(constTrue(), true)
 *
 * @since 2.0.0
 */
const constTrue = /*#__PURE__*/constant(true);
/**
 * A thunk that returns always `false`.
 *
 * @example
 * import { constFalse } from "effect/Function"
 *
 * assert.deepStrictEqual(constFalse(), false)
 *
 * @since 2.0.0
 */
const constFalse = /*#__PURE__*/constant(false);
/**
 * A thunk that returns always `null`.
 *
 * @example
 * import { constNull } from "effect/Function"
 *
 * assert.deepStrictEqual(constNull(), null)
 *
 * @since 2.0.0
 */
const Function_constNull = /*#__PURE__*/(/* unused pure expression or super */ null && (constant(null)));
/**
 * A thunk that returns always `undefined`.
 *
 * @example
 * import { constUndefined } from "effect/Function"
 *
 * assert.deepStrictEqual(constUndefined(), undefined)
 *
 * @since 2.0.0
 */
const Function_constUndefined = /*#__PURE__*/constant(undefined);
/**
 * A thunk that returns always `void`.
 *
 * @example
 * import { constVoid } from "effect/Function"
 *
 * assert.deepStrictEqual(constVoid(), undefined)
 *
 * @since 2.0.0
 */
const Function_constVoid = Function_constUndefined;
/**
 * Reverses the order of arguments for a curried function.
 *
 * @param f - A curried function that takes multiple arguments.
 *
 * @example
 * import { flip } from "effect/Function"
 *
 * const f = (a: number) => (b: string) => a - b.length
 *
 * assert.deepStrictEqual(flip(f)('aaa')(2), -1)
 *
 * @since 2.0.0
 */
const flip = f => (...b) => (...a) => f(...a)(...b);
/**
 * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.
 * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.
 *
 * @param ab - A function that maps from `A` to `B`.
 * @param bc - A function that maps from `B` to `C`.
 *
 * @example
 * import { compose } from "effect/Function"
 *
 * const increment = (n: number) => n + 1;
 * const square = (n: number) => n * n;
 *
 * assert.strictEqual(compose(increment, square)(2), 9);
 *
 * @since 2.0.0
 */
const compose = /*#__PURE__*/(/* unused pure expression or super */ null && (Function_dual(2, (ab, bc) => a => bc(ab(a)))));
/**
 * The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,
 * meaning that it should be impossible for this code to be executed.
 *
 * This function is particularly when it's necessary to specify that certain cases are impossible.
 *
 * @since 2.0.0
 */
const absurd = _ => {
  throw new Error("Called `absurd` function which should be uncallable");
};
/**
 * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.
 *
 * @example
 * import { tupled } from "effect/Function"
 *
 * const sumTupled = tupled((x: number, y: number): number => x + y)
 *
 * assert.deepStrictEqual(sumTupled([1, 2]), 3)
 *
 * @since 2.0.0
 */
const tupled = f => a => f(...a);
/**
 * Inverse function of `tupled`
 *
 * @example
 * import { untupled } from "effect/Function"
 *
 * const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])
 *
 * assert.deepStrictEqual(getFirst(1, 2), 1)
 *
 * @since 2.0.0
 */
const untupled = f => (...a) => f(a);
function Function_pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default:
      {
        let ret = arguments[0];
        for (let i = 1; i < arguments.length; i++) {
          ret = arguments[i](ret);
        }
        return ret;
      }
  }
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function () {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function () {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function () {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function () {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function () {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function () {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function () {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function () {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
/**
 * Type hole simulation.
 *
 * @since 2.0.0
 */
const hole = /*#__PURE__*/(/* unused pure expression or super */ null && (Function_unsafeCoerce(absurd)));
/**
 * The SK combinator, also known as the "S-K combinator" or "S-combinator", is a fundamental combinator in the
 * lambda calculus and the SKI combinator calculus.
 *
 * This function is useful for discarding the first argument passed to it and returning the second argument.
 *
 * @param _ - The first argument to be discarded.
 * @param b - The second argument to be returned.
 *
 * @example
 * import { SK } from "effect/Function";
 *
 * assert.deepStrictEqual(SK(0, "hello"), "hello")
 *
 * @since 2.0.0
 */
const SK = (_, b) => b;
//# sourceMappingURL=Function.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/version.js
let moduleVersion = "3.1.2";
const getCurrentVersion = () => moduleVersion;
const setCurrentVersion = version => {
  moduleVersion = version;
};
//# sourceMappingURL=version.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/GlobalValue.js
/**
 * @since 2.0.0
 */

const globalStoreId = /*#__PURE__*/Symbol.for(`effect/GlobalValue/globalStoreId/${/*#__PURE__*/getCurrentVersion()}`);
if (!(globalStoreId in globalThis)) {
  ;
  globalThis[globalStoreId] = /*#__PURE__*/new Map();
}
const globalStore = globalThis[globalStoreId];
/**
 * @since 2.0.0
 */
const GlobalValue_globalValue = (id, compute) => {
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};
//# sourceMappingURL=GlobalValue.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Predicate.js
/**
 * @since 2.0.0
 */

/**
 * Given a `Predicate<A>` returns a `Predicate<B>`
 *
 * @param self - the `Predicate<A>` to be transformed to `Predicate<B>`.
 * @param f - a function to transform `B` to `A`.
 *
 * @example
 * import { Predicate, Number } from "effect"
 *
 * const minLength3 = Predicate.mapInput(Number.greaterThan(2), (s: string) => s.length)
 *
 * assert.deepStrictEqual(minLength3("a"), false)
 * assert.deepStrictEqual(minLength3("aa"), false)
 * assert.deepStrictEqual(minLength3("aaa"), true)
 * assert.deepStrictEqual(minLength3("aaaa"), true)
 *
 * @category combinators
 * @since 2.0.0
 */
const mapInput = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => b => self(f(b)))));
/**
 * Tests if a value is `truthy`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isTruthy } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isTruthy(1), true)
 * assert.deepStrictEqual(isTruthy(0), false)
 * assert.deepStrictEqual(isTruthy(""), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isTruthy = input => !!input;
/**
 * Tests if a value is a `Set`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isSet } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isSet(new Set([1, 2])), true)
 * assert.deepStrictEqual(isSet(new Set()), true)
 * assert.deepStrictEqual(isSet({}), false)
 * assert.deepStrictEqual(isSet(null), false)
 * assert.deepStrictEqual(isSet(undefined), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isSet = input => input instanceof Set;
/**
 * Tests if a value is a `Map`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isMap } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isMap(new Map()), true)
 * assert.deepStrictEqual(isMap({}), false)
 * assert.deepStrictEqual(isMap(null), false)
 * assert.deepStrictEqual(isMap(undefined), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isMap = input => input instanceof Map;
/**
 * Tests if a value is a `string`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isString } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isString("a"), true)
 *
 * assert.deepStrictEqual(isString(1), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isString = input => typeof input === "string";
/**
 * Tests if a value is a `number`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isNumber } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNumber(2), true)
 *
 * assert.deepStrictEqual(isNumber("2"), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isNumber = input => typeof input === "number";
/**
 * Tests if a value is a `boolean`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isBoolean } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isBoolean(true), true)
 *
 * assert.deepStrictEqual(isBoolean("true"), false)
 *
 * @category guards
 * @since 2.0.0
 */
const Predicate_isBoolean = input => typeof input === "boolean";
/**
 * Tests if a value is a `bigint`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isBigInt } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isBigInt(1n), true)
 *
 * assert.deepStrictEqual(isBigInt(1), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isBigInt = input => typeof input === "bigint";
/**
 * Tests if a value is a `symbol`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isSymbol } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isSymbol(Symbol.for("a")), true)
 *
 * assert.deepStrictEqual(isSymbol("a"), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isSymbol = input => typeof input === "symbol";
/**
 * Tests if a value is a `function`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isFunction } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isFunction(isFunction), true)
 *
 * assert.deepStrictEqual(isFunction("function"), false)
 *
 * @category guards
 * @since 2.0.0
 */
const Predicate_isFunction = Function_isFunction;
/**
 * Tests if a value is `undefined`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isUndefined } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isUndefined(undefined), true)
 *
 * assert.deepStrictEqual(isUndefined(null), false)
 * assert.deepStrictEqual(isUndefined("undefined"), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isUndefined = input => input === undefined;
/**
 * Tests if a value is not `undefined`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isNotUndefined } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNotUndefined(null), true)
 * assert.deepStrictEqual(isNotUndefined("undefined"), true)
 *
 * assert.deepStrictEqual(isNotUndefined(undefined), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isNotUndefined = input => input !== undefined;
/**
 * Tests if a value is `null`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isNull } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNull(null), true)
 *
 * assert.deepStrictEqual(isNull(undefined), false)
 * assert.deepStrictEqual(isNull("null"), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isNull = input => input === null;
/**
 * Tests if a value is not `null`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isNotNull } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNotNull(undefined), true)
 * assert.deepStrictEqual(isNotNull("null"), true)
 *
 * assert.deepStrictEqual(isNotNull(null), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isNotNull = input => input !== null;
/**
 * A guard that always fails.
 *
 * @param _ - The value to test.
 *
 * @example
 * import { isNever } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNever(null), false)
 * assert.deepStrictEqual(isNever(undefined), false)
 * assert.deepStrictEqual(isNever({}), false)
 * assert.deepStrictEqual(isNever([]), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isNever = _ => false;
/**
 * A guard that always succeeds.
 *
 * @param _ - The value to test.
 *
 * @example
 * import { isUnknown } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isUnknown(null), true)
 * assert.deepStrictEqual(isUnknown(undefined), true)
 *
 * assert.deepStrictEqual(isUnknown({}), true)
 * assert.deepStrictEqual(isUnknown([]), true)
 *
 * @category guards
 * @since 2.0.0
 */
const isUnknown = _ => true;
const isRecordOrArray = input => typeof input === "object" && input !== null;
/**
 * Tests if a value is an `object`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isObject } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isObject({}), true)
 * assert.deepStrictEqual(isObject([]), true)
 *
 * assert.deepStrictEqual(isObject(null), false)
 * assert.deepStrictEqual(isObject(undefined), false)
 *
 * @category guards
 * @since 2.0.0
 */
const Predicate_isObject = input => isRecordOrArray(input) || Predicate_isFunction(input);
/**
 * Checks whether a value is an `object` containing a specified property key.
 *
 * @param property - The field to check within the object.
 * @param self - The value to examine.
 *
 * @category guards
 * @since 2.0.0
 */
const Predicate_hasProperty = /*#__PURE__*/Function_dual(2, (self, property) => Predicate_isObject(self) && property in self);
/**
 * Tests if a value is an `object` with a property `_tag` that matches the given tag.
 *
 * @param input - The value to test.
 * @param tag - The tag to test for.
 *
 * @example
 * import { isTagged } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isTagged(1, "a"), false)
 * assert.deepStrictEqual(isTagged(null, "a"), false)
 * assert.deepStrictEqual(isTagged({}, "a"), false)
 * assert.deepStrictEqual(isTagged({ a: "a" }, "a"), false)
 * assert.deepStrictEqual(isTagged({ _tag: "a" }, "a"), true)
 * assert.deepStrictEqual(isTagged("a")({ _tag: "a" }), true)
 *
 * @category guards
 * @since 2.0.0
 */
const isTagged = /*#__PURE__*/Function_dual(2, (self, tag) => Predicate_hasProperty(self, "_tag") && self["_tag"] === tag);
/**
 * A guard that succeeds when the input is `null` or `undefined`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isNullable } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNullable(null), true)
 * assert.deepStrictEqual(isNullable(undefined), true)
 *
 * assert.deepStrictEqual(isNullable({}), false)
 * assert.deepStrictEqual(isNullable([]), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isNullable = input => input === null || input === undefined;
/**
 * A guard that succeeds when the input is not `null` or `undefined`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isNotNullable } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNotNullable({}), true)
 * assert.deepStrictEqual(isNotNullable([]), true)
 *
 * assert.deepStrictEqual(isNotNullable(null), false)
 * assert.deepStrictEqual(isNotNullable(undefined), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isNotNullable = input => input !== null && input !== undefined;
/**
 * A guard that succeeds when the input is an `Error`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isError } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isError(new Error()), true)
 *
 * assert.deepStrictEqual(isError(null), false)
 * assert.deepStrictEqual(isError({}), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isError = input => input instanceof Error;
/**
 * A guard that succeeds when the input is a `Uint8Array`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isUint8Array } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isUint8Array(new Uint8Array()), true)
 *
 * assert.deepStrictEqual(isUint8Array(null), false)
 * assert.deepStrictEqual(isUint8Array({}), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isUint8Array = input => input instanceof Uint8Array;
/**
 * A guard that succeeds when the input is a `Date`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isDate } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isDate(new Date()), true)
 *
 * assert.deepStrictEqual(isDate(null), false)
 * assert.deepStrictEqual(isDate({}), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isDate = input => input instanceof Date;
/**
 * A guard that succeeds when the input is an `Iterable`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isIterable } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isIterable([]), true)
 * assert.deepStrictEqual(isIterable(new Set()), true)
 *
 * assert.deepStrictEqual(isIterable(null), false)
 * assert.deepStrictEqual(isIterable({}), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isIterable = input => Predicate_hasProperty(input, Symbol.iterator);
/**
 * A guard that succeeds when the input is a record.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isRecord } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isRecord({}), true)
 * assert.deepStrictEqual(isRecord({ a: 1 }), true)
 *
 * assert.deepStrictEqual(isRecord([]), false)
 * assert.deepStrictEqual(isRecord([1, 2, 3]), false)
 * assert.deepStrictEqual(isRecord(null), false)
 * assert.deepStrictEqual(isRecord(undefined), false)
 * assert.deepStrictEqual(isRecord(() => null), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isRecord = input => isRecordOrArray(input) && !Array.isArray(input);
/**
 * A guard that succeeds when the input is a readonly record.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isReadonlyRecord } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isReadonlyRecord({}), true)
 * assert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)
 *
 * assert.deepStrictEqual(isReadonlyRecord([]), false)
 * assert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)
 * assert.deepStrictEqual(isReadonlyRecord(null), false)
 * assert.deepStrictEqual(isReadonlyRecord(undefined), false)
 *
 * @category guards
 * @since 2.0.0
 */
const isReadonlyRecord = (/* unused pure expression or super */ null && (isRecord));
/**
 * A guard that succeeds when the input is a Promise.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isPromise } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isPromise({}), false)
 * assert.deepStrictEqual(isPromise(Promise.resolve("hello")), true)
 *
 * @category guards
 * @since 2.0.0
 */
const isPromise = input => Predicate_hasProperty(input, "then") && "catch" in input && Predicate_isFunction(input.then) && Predicate_isFunction(input.catch);
/**
 * @category guards
 * @since 2.0.0
 */
const isPromiseLike = input => Predicate_hasProperty(input, "then") && Predicate_isFunction(input.then);
/**
 * @since 2.0.0
 */
const Predicate_compose = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (ab, bc) => a => ab(a) && bc(a))));
/**
 * @category combining
 * @since 2.0.0
 */
const product = (self, that) => ([a, b]) => self(a) && that(b);
/**
 * @category combining
 * @since 2.0.0
 */
const Predicate_all = collection => {
  return as => {
    let collectionIndex = 0;
    for (const p of collection) {
      if (collectionIndex >= as.length) {
        break;
      }
      if (p(as[collectionIndex]) === false) {
        return false;
      }
      collectionIndex++;
    }
    return true;
  };
};
/**
 * @category combining
 * @since 2.0.0
 */
const productMany = (self, collection) => {
  const rest = Predicate_all(collection);
  return ([head, ...tail]) => self(head) === false ? false : rest(tail);
};
/**
 * Similar to `Promise.all` but operates on `Predicate`s.
 *
 * ```
 * [Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>
 * ```
 *
 * @since 2.0.0
 */
const tuple = (...elements) => Predicate_all(elements);
/**
 * @since 2.0.0
 */
const struct = fields => {
  const keys = Object.keys(fields);
  return a => {
    for (const key of keys) {
      if (!fields[key](a[key])) {
        return false;
      }
    }
    return true;
  };
};
/**
 * Negates the result of a given predicate.
 *
 * @param self - A predicate.
 *
 * @example
 * import { Predicate, Number } from "effect"
 *
 * const isPositive = Predicate.not(Number.lessThan(0))
 *
 * assert.deepStrictEqual(isPositive(-1), false)
 * assert.deepStrictEqual(isPositive(0), true)
 * assert.deepStrictEqual(isPositive(1), true)
 *
 * @category combinators
 * @since 2.0.0
 */
const not = self => a => !self(a);
/**
 * Combines two predicates into a new predicate that returns `true` if at least one of the predicates returns `true`.
 *
 * @param self - A predicate.
 * @param that - A predicate.
 *
 * @example
 * import { Predicate, Number } from "effect"
 *
 * const nonZero = Predicate.or(Number.lessThan(0), Number.greaterThan(0))
 *
 * assert.deepStrictEqual(nonZero(-1), true)
 * assert.deepStrictEqual(nonZero(0), false)
 * assert.deepStrictEqual(nonZero(1), true)
 *
 * @category combinators
 * @since 2.0.0
 */
const or = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => a => self(a) || that(a))));
/**
 * Combines two predicates into a new predicate that returns `true` if both of the predicates returns `true`.
 *
 * @param self - A predicate.
 * @param that - A predicate.
 *
 * @example
 * import { Predicate } from "effect"
 *
 * const minLength = (n: number) => (s: string) => s.length >= n
 * const maxLength = (n: number) => (s: string) => s.length <= n
 *
 * const length = (n: number) => Predicate.and(minLength(n), maxLength(n))
 *
 * assert.deepStrictEqual(length(2)("aa"), true)
 * assert.deepStrictEqual(length(2)("a"), false)
 * assert.deepStrictEqual(length(2)("aaa"), false)
 *
 * @category combinators
 * @since 2.0.0
 */
const and = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => a => self(a) && that(a))));
/**
 * @category combinators
 * @since 2.0.0
 */
const xor = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => a => self(a) !== that(a))));
/**
 * @category combinators
 * @since 2.0.0
 */
const eqv = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => a => self(a) === that(a))));
/**
 * @category combinators
 * @since 2.0.0
 */
const implies = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => a => self(a) ? that(a) : true)));
/**
 * @category combinators
 * @since 2.0.0
 */
const nor = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => a => !(self(a) || that(a)))));
/**
 * @category combinators
 * @since 2.0.0
 */
const nand = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => a => !(self(a) && that(a)))));
/**
 * @category elements
 * @since 2.0.0
 */
const every = collection => a => {
  for (const p of collection) {
    if (!p(a)) {
      return false;
    }
  }
  return true;
};
/**
 * @category elements
 * @since 2.0.0
 */
const some = collection => a => {
  for (const p of collection) {
    if (p(a)) {
      return true;
    }
  }
  return false;
};
//# sourceMappingURL=Predicate.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/errors.js
/**
 * @since 2.0.0
 */
/** @internal */
const getBugErrorMessage = message => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;
//# sourceMappingURL=errors.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Utils.js
/**
 * @since 2.0.0
 */




/*
 * Copyright 2014 Thom Chiovoloni, released under the MIT license.
 *
 * A random number generator based on the basic implementation of the PCG algorithm,
 * as described here: http://www.pcg-random.org/
 *
 * Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random
 *
 * forked from https://github.com/frptools
 *
 * @since 2.0.0
 */
/**
 * @category symbols
 * @since 2.0.0
 */
const GenKindTypeId = /*#__PURE__*/Symbol.for("effect/Gen/GenKind");
/**
 * @category predicates
 * @since 3.0.6
 */
const isGenKind = u => isObject(u) && GenKindTypeId in u;
/**
 * @category constructors
 * @since 2.0.0
 */
class GenKindImpl {
  value;
  constructor(
  /**
   * @since 2.0.0
   */
  value) {
    this.value = value;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return Function_identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return _ => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return _ => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return _ => _;
  }
  /**
   * @since 2.0.0
   */
  [GenKindTypeId] = GenKindTypeId;
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
}
/**
 * @category constructors
 * @since 2.0.0
 */
class SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this.self);
  }
}
/**
 * @category constructors
 * @since 2.0.0
 */
const makeGenKind = kind => new GenKindImpl(kind);
/**
 * @category adapters
 * @since 2.0.0
 */
const adapter = () => function () {
  let x = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    x = arguments[i](x);
  }
  return new GenKindImpl(x);
};
const defaultIncHi = 0x14057b7e;
const defaultIncLo = 0xf767814f;
const MUL_HI = 0x5851f42d >>> 0;
const MUL_LO = 0x4c957f2d >>> 0;
const BIT_53 = 9007199254740992.0;
const BIT_27 = 134217728.0;
/**
 * PCG is a family of simple fast space-efficient statistically good algorithms
 * for random number generation. Unlike many general-purpose RNGs, they are also
 * hard to predict.
 *
 * @category model
 * @since 2.0.0
 */
class PCGRandom {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 0xffffffff >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max) {
    if (!max) {
      return this._next();
    }
    max = max >>> 0;
    if ((max & max - 1) === 0) {
      return this._next() & max - 1; // fast path for power of 2
    }
    let num = 0;
    const skew = (-max >>> 0) % max >>> 0;
    for (num = this._next(); num < skew; num = this._next()) {
      // this loop will rarely execute more than twice,
      // and is intentionally empty
    }
    return num % max;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 0x03ffffff) * 1.0;
    const lo = (this._next() & 0x07ffffff) * 1.0;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    // save current state (what we'll use for this number)
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    // churn LCG.
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    // rotate xorshifted right a random amount, based on the most sig. 5 bits
    // bits of the old state.
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
}
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;
  let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
// add two 64 bit numbers (given in parts), and store the result in `out`.
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
/**
 * @since 3.0.6
 */
const YieldWrapTypeId = /*#__PURE__*/Symbol.for("effect/Utils/YieldWrap");
/**
 * @since 3.0.6
 */
class YieldWrap {
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value) {
    this.#value = value;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
}
/**
 * @since 3.0.6
 */
function yieldWrapGet(self) {
  if (typeof self === "object" && self !== null && YieldWrapTypeId in self) {
    return self[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
/**
 * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code
 *
 * @since 3.1.1
 * @status experimental
 * @category modifiers
 */
const structuralRegionState = /*#__PURE__*/GlobalValue_globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: undefined
}));
/**
 * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code
 *
 * @since 3.1.1
 * @status experimental
 * @category modifiers
 */
const structuralRegion = (body, tester) => {
  const current = structuralRegionState.enabled;
  const currentTester = structuralRegionState.tester;
  structuralRegionState.enabled = true;
  if (tester) {
    structuralRegionState.tester = tester;
  }
  try {
    return body();
  } finally {
    structuralRegionState.enabled = current;
    structuralRegionState.tester = currentTester;
  }
};
//# sourceMappingURL=Utils.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Hash.js
/**
 * @since 2.0.0
 */




/** @internal */
const randomHashCache = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/Hash/randomHashCache"), () => new WeakMap());
/** @internal */
const pcgr = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/Hash/pcgr"), () => new PCGRandom());
/**
 * @since 2.0.0
 * @category symbols
 */
const symbol = /*#__PURE__*/Symbol.for("effect/Hash");
/**
 * @since 2.0.0
 * @category hashing
 */
const Hash_hash = self => {
  switch (typeof self) {
    case "number":
      return number(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object":
      {
        if (self === null) {
          return string("null");
        }
        if (isHash(self)) {
          return self[symbol]();
        } else {
          return random(self);
        }
      }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
/**
 * @since 2.0.0
 * @category hashing
 */
const random = self => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number(pcgr.integer(Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
/**
 * @since 2.0.0
 * @category hashing
 */
const combine = b => self => self * 53 ^ b;
/**
 * @since 2.0.0
 * @category hashing
 */
const optimize = n => n & 0xbfffffff | n >>> 1 & 0x40000000;
/**
 * @since 2.0.0
 * @category guards
 */
const isHash = u => Predicate_hasProperty(u, symbol);
/**
 * @since 2.0.0
 * @category hashing
 */
const number = n => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 0xffffffff;
  }
  while (n > 0xffffffff) {
    h ^= n /= 0xffffffff;
  }
  return optimize(n);
};
/**
 * @since 2.0.0
 * @category hashing
 */
const string = str => {
  let h = 5381,
    i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
/**
 * @since 2.0.0
 * @category hashing
 */
const structureKeys = (o, keys) => {
  let h = 12289;
  for (let i = 0; i < keys.length; i++) {
    h ^= Function_pipe(string(keys[i]), combine(Hash_hash(o[keys[i]])));
  }
  return optimize(h);
};
/**
 * @since 2.0.0
 * @category hashing
 */
const structure = o => structureKeys(o, Object.keys(o));
/**
 * @since 2.0.0
 * @category hashing
 */
const array = arr => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = Function_pipe(h, combine(Hash_hash(arr[i])));
  }
  return optimize(h);
};
/**
 * @since 2.0.0
 * @category hashing
 */
const cached = function () {
  if (arguments.length === 1) {
    const self = arguments[0];
    return function (hash) {
      // @ts-expect-error
      const original = self[symbol].bind(self);
      if (structuralRegionState.enabled === false) {
        Object.defineProperty(self, symbol, {
          value() {
            if (structuralRegionState.enabled === true) {
              return original();
            }
            return hash;
          },
          enumerable: false
        });
      }
      return hash;
    };
  }
  const self = arguments[0];
  const hash = arguments[1];
  // @ts-expect-error
  const original = self[symbol].bind(self);
  if (structuralRegionState.enabled === false) {
    Object.defineProperty(self, symbol, {
      value() {
        if (structuralRegionState.enabled === true) {
          return original();
        }
        return hash;
      },
      enumerable: false
    });
  }
  return hash;
};
//# sourceMappingURL=Hash.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Equal.js



/**
 * @since 2.0.0
 * @category symbols
 */
const Equal_symbol = /*#__PURE__*/Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return self => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        return Hash_hash(self) === Hash_hash(that) && self[Equal_symbol](that);
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            // @ts-expect-error
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
/**
 * @since 2.0.0
 * @category guards
 */
const isEqual = u => Predicate_hasProperty(u, Equal_symbol);
/**
 * @since 2.0.0
 * @category instances
 */
const equivalence = () => equals;
//# sourceMappingURL=Equal.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Inspectable.js
/**
 * @since 2.0.0
 */

/**
 * @since 2.0.0
 * @category symbols
 */
const NodeInspectSymbol = /*#__PURE__*/Symbol.for("nodejs.util.inspect.custom");
/**
 * @since 2.0.0
 */
const toJSON = x => {
  if (Predicate_hasProperty(x, "toJSON") && Predicate_isFunction(x["toJSON"]) && x["toJSON"].length === 0) {
    return x.toJSON();
  } else if (Array.isArray(x)) {
    return x.map(toJSON);
  }
  return x;
};
/**
 * @since 2.0.0
 */
const format = x => JSON.stringify(x, null, 2);
/**
 * @since 2.0.0
 */
const BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
/**
 * @since 2.0.0
 */
class Class {
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
}
/**
 * @since 2.0.0
 */
const toStringUnknown = (u, whitespace = 2) => {
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch (_) {
    return String(u);
  }
};
/**
 * @since 2.0.0
 */
const stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? undefined // circular reference
  : cache.push(value) && value : value, whitespace);
  cache = undefined;
  return retVal;
};
//# sourceMappingURL=Inspectable.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Pipeable.js
/**
 * @since 2.0.0
 */
/**
 * @since 2.0.0
 */
const Pipeable_pipeArguments = (self, args) => {
  switch (args.length) {
    case 1:
      return args[0](self);
    case 2:
      return args[1](args[0](self));
    case 3:
      return args[2](args[1](args[0](self)));
    case 4:
      return args[3](args[2](args[1](args[0](self))));
    case 5:
      return args[4](args[3](args[2](args[1](args[0](self)))));
    case 6:
      return args[5](args[4](args[3](args[2](args[1](args[0](self))))));
    case 7:
      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));
    case 8:
      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));
    case 9:
      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));
    default:
      {
        let ret = self;
        for (let i = 0, len = args.length; i < len; i++) {
          ret = args[i](ret);
        }
        return ret;
      }
  }
};
//# sourceMappingURL=Pipeable.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/opCodes/effect.js
/** @internal */
const OP_ASYNC = "Async";
/** @internal */
const OP_COMMIT = "Commit";
/** @internal */
const OP_FAILURE = "Failure";
/** @internal */
const OP_ON_FAILURE = "OnFailure";
/** @internal */
const OP_ON_SUCCESS = "OnSuccess";
/** @internal */
const OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
/** @internal */
const OP_SUCCESS = "Success";
/** @internal */
const OP_SYNC = "Sync";
/** @internal */
const OP_TAG = "Tag";
/** @internal */
const OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
/** @internal */
const OP_WHILE = "While";
/** @internal */
const OP_WITH_RUNTIME = "WithRuntime";
/** @internal */
const OP_YIELD = "Yield";
/** @internal */
const OP_REVERT_FLAGS = "RevertFlags";
//# sourceMappingURL=effect.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/effectable.js






/** @internal */
const EffectTypeId = /*#__PURE__*/Symbol.for("effect/Effect");
/** @internal */
const StreamTypeId = /*#__PURE__*/Symbol.for("effect/Stream");
/** @internal */
const SinkTypeId = /*#__PURE__*/Symbol.for("effect/Sink");
/** @internal */
const ChannelTypeId = /*#__PURE__*/Symbol.for("effect/Channel");
/** @internal */
const effectVariance = {
  /* c8 ignore next */
  _R: _ => _,
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _,
  _V: /*#__PURE__*/getCurrentVersion()
};
const sinkVariance = {
  /* c8 ignore next */
  _A: _ => _,
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _L: _ => _,
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
const channelVariance = {
  /* c8 ignore next */
  _Env: _ => _,
  /* c8 ignore next */
  _InErr: _ => _,
  /* c8 ignore next */
  _InElem: _ => _,
  /* c8 ignore next */
  _InDone: _ => _,
  /* c8 ignore next */
  _OutErr: _ => _,
  /* c8 ignore next */
  _OutElem: _ => _,
  /* c8 ignore next */
  _OutDone: _ => _
};
/** @internal */
const EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [Equal_symbol](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [Equal_symbol](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
/** @internal */
const CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
/** @internal */
const StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
/** @internal */
const Base = /*#__PURE__*/function () {
  function Base() {}
  Base.prototype = CommitPrototype;
  return Base;
}();
/** @internal */
const StructuralBase = /*#__PURE__*/function () {
  function Base() {}
  Base.prototype = StructuralCommitPrototype;
  return Base;
}();
//# sourceMappingURL=effectable.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/option.js
/**
 * @since 2.0.0
 */





const TypeId = /*#__PURE__*/Symbol.for("effect/Option");
const CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: _ => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
const SomeProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [Equal_symbol](that) {
    return isOption(that) && isSome(that) && equals(that.value, this.value);
  },
  [symbol]() {
    return cached(this, combine(Hash_hash(this._tag))(Hash_hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
const NoneHash = /*#__PURE__*/Hash_hash("None");
const NoneProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [Equal_symbol](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
/** @internal */
const isOption = input => Predicate_hasProperty(input, TypeId);
/** @internal */
const isNone = fa => fa._tag === "None";
/** @internal */
const isSome = fa => fa._tag === "Some";
/** @internal */
const none = /*#__PURE__*/Object.create(NoneProto);
/** @internal */
const option_some = value => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};
//# sourceMappingURL=option.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/context.js








/** @internal */
const TagTypeId = /*#__PURE__*/Symbol.for("effect/Context/Tag");
/** @internal */
const STMSymbolKey = "effect/STM";
/** @internal */
const STMTypeId = /*#__PURE__*/Symbol.for(STMSymbolKey);
/** @internal */
const context_TagProto = {
  ...EffectPrototype,
  _tag: "Tag",
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: _ => _,
    _Identifier: _ => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make(this, self);
  }
};
/** @internal */
const makeGenericTag = key => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag = Object.create(context_TagProto);
  Object.defineProperty(tag, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag.key = key;
  return tag;
};
/** @internal */
const Tag = id => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {}
  Object.setPrototypeOf(TagClass, context_TagProto);
  TagClass.key = id;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
/** @internal */
const context_TypeId = /*#__PURE__*/Symbol.for("effect/Context");
/** @internal */
const ContextProto = {
  [context_TypeId]: {
    _Services: _ => _
  },
  [Equal_symbol](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number(this.unsafeMap.size));
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
/** @internal */
const makeContext = unsafeMap => {
  const context = Object.create(ContextProto);
  context.unsafeMap = unsafeMap;
  return context;
};
const serviceNotFoundError = tag => {
  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
  if (tag.stack) {
    const lines = tag.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error.message = error.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error.stack) {
    const lines = error.stack.split("\n");
    lines.splice(1, 3);
    error.stack = lines.join("\n");
  }
  return error;
};
/** @internal */
const isContext = u => Predicate_hasProperty(u, context_TypeId);
/** @internal */
const isTag = u => Predicate_hasProperty(u, TagTypeId);
const _empty = /*#__PURE__*/makeContext( /*#__PURE__*/new Map());
/** @internal */
const empty = () => _empty;
/** @internal */
const make = (tag, service) => makeContext(new Map([[tag.key, service]]));
/** @internal */
const add = /*#__PURE__*/Function_dual(3, (self, tag, service) => {
  const map = new Map(self.unsafeMap);
  map.set(tag.key, service);
  return makeContext(map);
});
/** @internal */
const unsafeGet = /*#__PURE__*/Function_dual(2, (self, tag) => {
  if (!self.unsafeMap.has(tag.key)) {
    throw serviceNotFoundError(tag);
  }
  return self.unsafeMap.get(tag.key);
});
/** @internal */
const get = unsafeGet;
/** @internal */
const getOption = /*#__PURE__*/Function_dual(2, (self, tag) => {
  if (!self.unsafeMap.has(tag.key)) {
    return none;
  }
  return option_some(self.unsafeMap.get(tag.key));
});
/** @internal */
const merge = /*#__PURE__*/Function_dual(2, (self, that) => {
  const map = new Map(self.unsafeMap);
  for (const [tag, s] of that.unsafeMap) {
    map.set(tag, s);
  }
  return makeContext(map);
});
/** @internal */
const pick = (...tags) => self => {
  const tagSet = new Set(tags.map(_ => _.key));
  const newEnv = new Map();
  for (const [tag, s] of self.unsafeMap.entries()) {
    if (tagSet.has(tag)) {
      newEnv.set(tag, s);
    }
  }
  return makeContext(newEnv);
};
/** @internal */
const omit = (...tags) => self => {
  const newEnv = new Map(self.unsafeMap);
  for (const tag of tags) {
    newEnv.delete(tag.key);
  }
  return makeContext(newEnv);
};
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Context.js

const Context_TagTypeId = TagTypeId;
/**
 * Creates a new `Tag` instance with an optional key parameter.
 *
 * @param key - A key that will be used to compare tags.
 *
 * @example
 * import { Context } from "effect"
 *
 * assert.strictEqual(Context.GenericTag("PORT").key === Context.GenericTag("PORT").key, true)
 *
 * @since 2.0.0
 * @category constructors
 */
const GenericTag = makeGenericTag;
const Context_TypeId = context_TypeId;
/**
 * @since 2.0.0
 * @category constructors
 */
const unsafeMake = makeContext;
/**
 * Checks if the provided argument is a `Context`.
 *
 * @param input - The value to be checked if it is a `Context`.
 *
 * @example
 * import { Context } from "effect"
 *
 * assert.strictEqual(Context.isContext(Context.empty()), true)
 *
 * @since 2.0.0
 * @category guards
 */
const Context_isContext = isContext;
/**
 * Checks if the provided argument is a `Tag`.
 *
 * @param input - The value to be checked if it is a `Tag`.
 *
 * @example
 * import { Context } from "effect"
 *
 * assert.strictEqual(Context.isTag(Context.GenericTag("Tag")), true)
 *
 * @since 2.0.0
 * @category guards
 */
const Context_isTag = isTag;
/**
 * Returns an empty `Context`.
 *
 * @example
 * import { Context } from "effect"
 *
 * assert.strictEqual(Context.isContext(Context.empty()), true)
 *
 * @since 2.0.0
 * @category constructors
 */
const Context_empty = empty;
/**
 * Creates a new `Context` with a single service associated to the tag.
 *
 * @example
 * import { Context } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 *
 * const Services = Context.make(Port, { PORT: 8080 })
 *
 * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
 *
 * @since 2.0.0
 * @category constructors
 */
const Context_make = make;
/**
 * Adds a service to a given `Context`.
 *
 * @example
 * import { Context, pipe } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 * const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
 *
 * const someContext = Context.make(Port, { PORT: 8080 })
 *
 * const Services = pipe(
 *   someContext,
 *   Context.add(Timeout, { TIMEOUT: 5000 })
 * )
 *
 * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
 * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
 *
 * @since 2.0.0
 */
const Context_add = add;
/**
 * Get a service from the context that corresponds to the given tag.
 *
 * @param self - The `Context` to search for the service.
 * @param tag - The `Tag` of the service to retrieve.
 *
 * @example
 * import { pipe, Context } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 * const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
 *
 * const Services = pipe(
 *   Context.make(Port, { PORT: 8080 }),
 *   Context.add(Timeout, { TIMEOUT: 5000 })
 * )
 *
 * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
 *
 * @since 2.0.0
 * @category getters
 */
const Context_get = get;
/**
 * Get a service from the context that corresponds to the given tag.
 * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.
 *
 * For a safer version see {@link getOption}.
 *
 * @param self - The `Context` to search for the service.
 * @param tag - The `Tag` of the service to retrieve.
 *
 * @example
 * import { Context } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 * const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
 *
 * const Services = Context.make(Port, { PORT: 8080 })
 *
 * assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })
 * assert.throws(() => Context.unsafeGet(Services, Timeout))
 *
 * @since 2.0.0
 * @category unsafe
 */
const Context_unsafeGet = unsafeGet;
/**
 * Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not
 * found, the `Option` object will be `None`.
 *
 * @param self - The `Context` to search for the service.
 * @param tag - The `Tag` of the service to retrieve.
 *
 * @example
 * import { Context, Option } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 * const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
 *
 * const Services = Context.make(Port, { PORT: 8080 })
 *
 * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
 * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())
 *
 * @since 2.0.0
 * @category getters
 */
const Context_getOption = getOption;
/**
 * Merges two `Context`s, returning a new `Context` containing the services of both.
 *
 * @param self - The first `Context` to merge.
 * @param that - The second `Context` to merge.
 *
 * @example
 * import { Context } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 * const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
 *
 * const firstContext = Context.make(Port, { PORT: 8080 })
 * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })
 *
 * const Services = Context.merge(firstContext, secondContext)
 *
 * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
 * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
 *
 * @since 2.0.0
 */
const Context_merge = merge;
/**
 * Returns a new `Context` that contains only the specified services.
 *
 * @param self - The `Context` to prune services from.
 * @param tags - The list of `Tag`s to be included in the new `Context`.
 *
 * @example
 * import { pipe, Context, Option } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 * const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
 *
 * const someContext = pipe(
 *   Context.make(Port, { PORT: 8080 }),
 *   Context.add(Timeout, { TIMEOUT: 5000 })
 * )
 *
 * const Services = pipe(someContext, Context.pick(Port))
 *
 * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
 * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())
 *
 * @since 2.0.0
 */
const Context_pick = pick;
/**
 * @since 2.0.0
 */
const Context_omit = omit;
/**
 * @since 2.0.0
 * @category constructors
 */
const Context_Tag = Tag;
//# sourceMappingURL=Context.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Equivalence.js
/**
 * This module provides an implementation of the `Equivalence` type class, which defines a binary relation
 * that is reflexive, symmetric, and transitive. In other words, it defines a notion of equivalence between values of a certain type.
 * These properties are also known in mathematics as an "equivalence relation".
 *
 * @since 2.0.0
 */

/**
 * @category constructors
 * @since 2.0.0
 */
const Equivalence_make = isEquivalent => (self, that) => self === that || isEquivalent(self, that);
const isStrictEquivalent = (x, y) => x === y;
/**
 * Return an `Equivalence` that uses strict equality (===) to compare values.
 *
 * @since 2.0.0
 * @category constructors
 */
const strict = () => isStrictEquivalent;
/**
 * @category instances
 * @since 2.0.0
 */
const Equivalence_string = /*#__PURE__*/(/* unused pure expression or super */ null && (strict()));
/**
 * @category instances
 * @since 2.0.0
 */
const Equivalence_number = /*#__PURE__*/strict();
/**
 * @category instances
 * @since 2.0.0
 */
const Equivalence_boolean = /*#__PURE__*/strict();
/**
 * @category instances
 * @since 2.0.0
 */
const bigint = /*#__PURE__*/(/* unused pure expression or super */ null && (strict()));
/**
 * @category instances
 * @since 2.0.0
 */
const Equivalence_symbol = /*#__PURE__*/(/* unused pure expression or super */ null && (strict()));
/**
 * @category combining
 * @since 2.0.0
 */
const Equivalence_combine = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Equivalence_make((x, y) => self(x, y) && that(x, y)))));
/**
 * @category combining
 * @since 2.0.0
 */
const combineMany = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, collection) => Equivalence_make((x, y) => {
  if (!self(x, y)) {
    return false;
  }
  for (const equivalence of collection) {
    if (!equivalence(x, y)) {
      return false;
    }
  }
  return true;
}))));
const isAlwaysEquivalent = (_x, _y) => true;
/**
 * @category combining
 * @since 2.0.0
 */
const combineAll = collection => combineMany(isAlwaysEquivalent, collection);
/**
 * @category mapping
 * @since 2.0.0
 */
const Equivalence_mapInput = /*#__PURE__*/Function_dual(2, (self, f) => Equivalence_make((x, y) => self(f(x), f(y))));
/**
 * @category instances
 * @since 2.0.0
 */
const Equivalence_Date = /*#__PURE__*/(/* unused pure expression or super */ null && (Equivalence_mapInput(Equivalence_number, date => date.getTime())));
/**
 * @category combining
 * @since 2.0.0
 */
const Equivalence_product = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Equivalence_make(([xa, xb], [ya, yb]) => self(xa, ya) && that(xb, yb)))));
/**
 * @category combining
 * @since 2.0.0
 */
const Equivalence_all = collection => {
  return Equivalence_make((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const equivalence of collection) {
      if (collectionLength >= len) {
        break;
      }
      if (!equivalence(x[collectionLength], y[collectionLength])) {
        return false;
      }
      collectionLength++;
    }
    return true;
  });
};
/**
 * @category combining
 * @since 2.0.0
 */
const Equivalence_productMany = (self, collection) => {
  const equivalence = Equivalence_all(collection);
  return Equivalence_make((x, y) => !self(x[0], y[0]) ? false : equivalence(x.slice(1), y.slice(1)));
};
/**
 * Similar to `Promise.all` but operates on `Equivalence`s.
 *
 * ```
 * [Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>
 * ```
 *
 * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple
 * by applying each `Equivalence` to the corresponding element of the tuple.
 *
 * @category combinators
 * @since 2.0.0
 */
const Equivalence_tuple = (...elements) => Equivalence_all(elements);
/**
 * Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.
 *
 * @category combinators
 * @since 2.0.0
 */
const Equivalence_array = item => Equivalence_make((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});
/**
 * Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct
 * by applying each `Equivalence` to the corresponding property of the struct.
 *
 * @category combinators
 * @since 2.0.0
 */
const Equivalence_struct = fields => {
  const keys = Object.keys(fields);
  return Equivalence_make((self, that) => {
    for (const key of keys) {
      if (!fields[key](self[key], that[key])) {
        return false;
      }
    }
    return true;
  });
};
//# sourceMappingURL=Equivalence.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/array.js
/**
 * @since 2.0.0
 */
/** @internal */
const isNonEmptyArray = self => self.length > 0;
//# sourceMappingURL=array.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/either.js
/**
 * @since 2.0.0
 */







/**
 * @internal
 */
const either_TypeId = /*#__PURE__*/Symbol.for("effect/Either");
const either_CommonProto = {
  ...EffectPrototype,
  [either_TypeId]: {
    _R: _ => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
const RightProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(either_CommonProto), {
  _tag: "Right",
  _op: "Right",
  [Equal_symbol](that) {
    return isEither(that) && isRight(that) && equals(that.right, this.right);
  },
  [symbol]() {
    return combine(Hash_hash(this._tag))(Hash_hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
const LeftProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(either_CommonProto), {
  _tag: "Left",
  _op: "Left",
  [Equal_symbol](that) {
    return isEither(that) && isLeft(that) && equals(that.left, this.left);
  },
  [symbol]() {
    return combine(Hash_hash(this._tag))(Hash_hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
/** @internal */
const isEither = input => Predicate_hasProperty(input, either_TypeId);
/** @internal */
const isLeft = ma => ma._tag === "Left";
/** @internal */
const isRight = ma => ma._tag === "Right";
/** @internal */
const left = left => {
  const a = Object.create(LeftProto);
  a.left = left;
  return a;
};
/** @internal */
const right = right => {
  const a = Object.create(RightProto);
  a.right = right;
  return a;
};
/** @internal */
const getLeft = self => isRight(self) ? none : option_some(self.left);
/** @internal */
const getRight = self => isLeft(self) ? none : option_some(self.right);
/** @internal */
const fromOption = /*#__PURE__*/Function_dual(2, (self, onNone) => isNone(self) ? left(onNone()) : right(self.value));
//# sourceMappingURL=either.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Option.js








/**
 * @category symbols
 * @since 2.0.0
 */
const Option_TypeId = /*#__PURE__*/(/* unused pure expression or super */ null && (Symbol.for("effect/Option")));
/**
 * Creates a new `Option` that represents the absence of a value.
 *
 * @category constructors
 * @since 2.0.0
 */
const Option_none = () => none;
/**
 * Creates a new `Option` that wraps the given value.
 *
 * @param value - The value to wrap.
 *
 * @category constructors
 * @since 2.0.0
 */
const Option_some = option_some;
/**
 * Tests if a value is a `Option`.
 *
 * @param input - The value to check.
 *
 * @example
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.isOption(Option.some(1)), true)
 * assert.deepStrictEqual(Option.isOption(Option.none()), true)
 * assert.deepStrictEqual(Option.isOption({}), false)
 *
 * @category guards
 * @since 2.0.0
 */
const Option_isOption = isOption;
/**
 * Determine if a `Option` is a `None`.
 *
 * @param self - The `Option` to check.
 *
 * @example
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.isNone(Option.some(1)), false)
 * assert.deepStrictEqual(Option.isNone(Option.none()), true)
 *
 * @category guards
 * @since 2.0.0
 */
const Option_isNone = isNone;
/**
 * Determine if a `Option` is a `Some`.
 *
 * @param self - The `Option` to check.
 *
 * @example
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.isSome(Option.some(1)), true)
 * assert.deepStrictEqual(Option.isSome(Option.none()), false)
 *
 * @category guards
 * @since 2.0.0
 */
const Option_isSome = isSome;
/**
 * Matches the given `Option` and returns either the provided `onNone` value or the result of the provided `onSome`
 * function when passed the `Option`'s value.
 *
 * @param self - The `Option` to match
 * @param onNone - The value to be returned if the `Option` is `None`
 * @param onSome - The function to be called if the `Option` is `Some`, it will be passed the `Option`'s value and its result will be returned
 *
 * @example
 * import { pipe, Option } from "effect"
 *
 * assert.deepStrictEqual(
 *   pipe(Option.some(1), Option.match({ onNone: () => 'a none', onSome: (a) => `a some containing ${a}` })),
 *   'a some containing 1'
 * )
 *
 * assert.deepStrictEqual(
 *   pipe(Option.none(), Option.match({ onNone: () => 'a none', onSome: (a) => `a some containing ${a}` })),
 *   'a none'
 * )
 *
 * @category pattern matching
 * @since 2.0.0
 */
const match = /*#__PURE__*/Function_dual(2, (self, {
  onNone,
  onSome
}) => Option_isNone(self) ? onNone() : onSome(self.value));
/**
 * Returns a type guard from a `Option` returning function.
 * This function ensures that a type guard definition is type-safe.
 *
 * @example
 * import { Option } from "effect"
 *
 * const parsePositive = (n: number): Option.Option<number> =>
 *   n > 0 ? Option.some(n) : Option.none()
 *
 * const isPositive = Option.toRefinement(parsePositive)
 *
 * assert.deepStrictEqual(isPositive(1), true)
 * assert.deepStrictEqual(isPositive(-1), false)
 *
 * @category conversions
 * @since 2.0.0
 */
const toRefinement = f => a => Option_isSome(f(a));
/**
 * Converts an `Iterable` of values into an `Option`. Returns the first value of the `Iterable` wrapped in a `Some`
 * if the `Iterable` is not empty, otherwise returns `None`.
 *
 * @param collection - The `Iterable` to be converted to an `Option`.
 *
 * @example
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.fromIterable([1, 2, 3]), Option.some(1))
 * assert.deepStrictEqual(Option.fromIterable([]), Option.none())
 *
 * @category constructors
 * @since 2.0.0
 */
const fromIterable = collection => {
  for (const a of collection) {
    return Option_some(a);
  }
  return Option_none();
};
/**
 * Converts a `Either` to an `Option` discarding the error.
 *
 * Alias of {@link fromEither}.
 *
 * @example
 * import { Option, Either } from "effect"
 *
 * assert.deepStrictEqual(Option.getRight(Either.right('ok')), Option.some('ok'))
 * assert.deepStrictEqual(Option.getRight(Either.left('err')), Option.none())
 *
 * @category conversions
 * @since 2.0.0
 */
const Option_getRight = getRight;
/**
 * Converts a `Either` to an `Option` discarding the value.
 *
 * @example
 * import { Option, Either } from "effect"
 *
 * assert.deepStrictEqual(Option.getLeft(Either.right("ok")), Option.none())
 * assert.deepStrictEqual(Option.getLeft(Either.left("a")), Option.some("a"))
 *
 * @category conversions
 * @since 2.0.0
 */
const Option_getLeft = getLeft;
/**
 * Returns the value of the `Option` if it is `Some`, otherwise returns `onNone`
 *
 * @param self - The `Option` to get the value of.
 * @param onNone - Function that returns the default value to return if the `Option` is `None`.
 *
 * @example
 * import { pipe, Option } from "effect"
 *
 * assert.deepStrictEqual(pipe(Option.some(1), Option.getOrElse(() => 0)), 1)
 * assert.deepStrictEqual(pipe(Option.none(), Option.getOrElse(() => 0)), 0)
 *
 * @category getters
 * @since 2.0.0
 */
const getOrElse = /*#__PURE__*/Function_dual(2, (self, onNone) => Option_isNone(self) ? onNone() : self.value);
/**
 * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.
 *
 * @param self - The first `Option` to be checked.
 * @param that - The `Option` to return if `self` is `None`.
 *
 * @example
 * import { pipe, Option } from "effect"
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.none(),
 *     Option.orElse(() => Option.none())
 *   ),
 *   Option.none()
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.some('a'),
 *     Option.orElse(() => Option.none())
 *   ),
 *   Option.some('a')
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.none(),
 *     Option.orElse(() => Option.some('b'))
 *   ),
 *   Option.some('b')
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.some('a'),
 *     Option.orElse(() => Option.some('b'))
 *   ),
 *   Option.some('a')
 * )
 *
 * @category error handling
 * @since 2.0.0
 */
const orElse = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Option_isNone(self) ? that() : self)));
/**
 * Returns the provided default value as `Some` if `self` is `None`, otherwise returns `self`.
 *
 * @param self - The first `Option` to be checked.
 * @param onNone - Function that returns the default value to return if the `Option` is `None`.
 *
 * @example
 * import { pipe, Option } from "effect"
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.none(),
 *     Option.orElseSome(() => 'b')
 *   ),
 *   Option.some('b')
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.some('a'),
 *     Option.orElseSome(() => 'b')
 *   ),
 *   Option.some('a')
 * )
 *
 * @category error handling
 * @since 2.0.0
 */
const orElseSome = /*#__PURE__*/Function_dual(2, (self, onNone) => Option_isNone(self) ? Option_some(onNone()) : self);
/**
 * Similar to `orElse`, but instead of returning a simple union, it returns an `Either` object,
 * which contains information about which of the two `Option`s has been chosen.
 *
 * This is useful when it's important to know whether the value was retrieved from the first `Option` or the second option.
 *
 * @param self - The first `Option` to be checked.
 * @param that - The second `Option` to be considered if the first `Option` is `None`.
 *
 * @category error handling
 * @since 2.0.0
 */
const orElseEither = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Option_isNone(self) ? map(that(), either.right) : map(self, either.left))));
/**
 * Given an `Iterable` collection of `Option`s, returns the first `Some` found in the collection.
 *
 * @param collection - An iterable collection of `Option` to be searched.
 *
 * @example
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.firstSomeOf([Option.none(), Option.some(1), Option.some(2)]), Option.some(1))
 *
 * @category error handling
 * @since 2.0.0
 */
const firstSomeOf = collection => {
  let out = Option_none();
  for (out of collection) {
    if (Option_isSome(out)) {
      return out;
    }
  }
  return out;
};
/**
 * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise
 * returns the value wrapped in a `Some`.
 *
 * @param nullableValue - The nullable value to be converted to an `Option`.
 *
 * @example
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.fromNullable(undefined), Option.none())
 * assert.deepStrictEqual(Option.fromNullable(null), Option.none())
 * assert.deepStrictEqual(Option.fromNullable(1), Option.some(1))
 *
 * @category conversions
 * @since 2.0.0
 */
const fromNullable = nullableValue => nullableValue == null ? Option_none() : Option_some(nullableValue);
/**
 * This API is useful for lifting a function that returns `null` or `undefined` into the `Option` context.
 *
 * @example
 * import { Option } from "effect"
 *
 * const parse = (s: string): number | undefined => {
 *   const n = parseFloat(s)
 *   return isNaN(n) ? undefined : n
 * }
 *
 * const parseOption = Option.liftNullable(parse)
 *
 * assert.deepStrictEqual(parseOption('1'), Option.some(1))
 * assert.deepStrictEqual(parseOption('not a number'), Option.none())
 *
 * @category conversions
 * @since 2.0.0
 */
const liftNullable = f => (...a) => fromNullable(f(...a));
/**
 * Returns the value of the `Option` if it is a `Some`, otherwise returns `null`.
 *
 * @param self - The `Option` to extract the value from.
 *
 * @example
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.getOrNull(Option.some(1)), 1)
 * assert.deepStrictEqual(Option.getOrNull(Option.none()), null)
 *
 * @category getters
 * @since 2.0.0
 */
const getOrNull = /*#__PURE__*/(/* unused pure expression or super */ null && (getOrElse(constNull)));
/**
 * Returns the value of the `Option` if it is a `Some`, otherwise returns `undefined`.
 *
 * @param self - The `Option` to extract the value from.
 *
 * @example
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.getOrUndefined(Option.some(1)), 1)
 * assert.deepStrictEqual(Option.getOrUndefined(Option.none()), undefined)
 *
 * @category getters
 * @since 2.0.0
 */
const getOrUndefined = /*#__PURE__*/getOrElse(Function_constUndefined);
/**
 * A utility function that lifts a function that throws exceptions into a function that returns an `Option`.
 *
 * This function is useful for any function that might throw an exception, allowing the developer to handle
 * the exception in a more functional way.
 *
 * @param f - the function that can throw exceptions.
 *
 * @example
 * import { Option } from "effect"
 *
 * const parse = Option.liftThrowable(JSON.parse)
 *
 * assert.deepStrictEqual(parse("1"), Option.some(1))
 * assert.deepStrictEqual(parse(""), Option.none())
 *
 * @category conversions
 * @since 2.0.0
 */
const liftThrowable = f => (...a) => {
  try {
    return Option_some(f(...a));
  } catch (e) {
    return Option_none();
  }
};
/**
 * Extracts the value of an `Option` or throws if the `Option` is `None`.
 *
 * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.
 *
 * @param self - The `Option` to extract the value from.
 * @param onNone - A function that will be called if the `Option` is `None`. It returns the error to be thrown.
 *
 * @example
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(
 *   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),
 *   1
 * )
 * assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))
 *
 * @category conversions
 * @since 2.0.0
 */
const getOrThrowWith = /*#__PURE__*/Function_dual(2, (self, onNone) => {
  if (Option_isSome(self)) {
    return self.value;
  }
  throw onNone();
});
/**
 * Extracts the value of an `Option` or throws if the `Option` is `None`.
 *
 * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.
 *
 * @param self - The `Option` to extract the value from.
 * @throws `Error("getOrThrow called on a None")`
 *
 * @example
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)
 * assert.throws(() => Option.getOrThrow(Option.none()))
 *
 * @category conversions
 * @since 2.0.0
 */
const getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error("getOrThrow called on a None"));
/**
 * Maps the `Some` side of an `Option` value to a new `Option` value.
 *
 * @param self - An `Option` to map
 * @param f - The function to map over the value of the `Option`
 *
 * @category mapping
 * @since 2.0.0
 */
const map = /*#__PURE__*/Function_dual(2, (self, f) => Option_isNone(self) ? Option_none() : Option_some(f(self.value)));
/**
 * Maps the `Some` value of this `Option` to the specified constant value.
 *
 * @category mapping
 * @since 2.0.0
 */
const as = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, b) => map(self, () => b))));
/**
 * Maps the `Some` value of this `Option` to the `void` constant value.
 *
 * This is useful when the value of the `Option` is not needed, but the presence or absence of the value is important.
 *
 * @category mapping
 * @since 2.0.0
 */
const asVoid = /*#__PURE__*/(/* unused pure expression or super */ null && (as(undefined)));
const void_ = /*#__PURE__*/(/* unused pure expression or super */ null && (Option_some(undefined)));

/**
 * Applies a function to the value of an `Option` and flattens the result, if the input is `Some`.
 *
 * @category sequencing
 * @since 2.0.0
 */
const flatMap = /*#__PURE__*/Function_dual(2, (self, f) => Option_isNone(self) ? Option_none() : f(self.value));
/**
 * Executes a sequence of two `Option`s. The second `Option` can be dependent on the result of the first `Option`.
 *
 * @category sequencing
 * @since 2.0.0
 */
const andThen = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => flatMap(self, a => {
  const b = isFunction(f) ? f(a) : f;
  return Option_isOption(b) ? b : Option_some(b);
}))));
/**
 * This is `flatMap` + `fromNullable`, useful when working with optional values.
 *
 * @example
 * import { pipe, Option } from "effect"
 *
 * interface Employee {
 *   company?: {
 *     address?: {
 *       street?: {
 *         name?: string
 *       }
 *     }
 *   }
 * }
 *
 * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.some(employee1),
 *     Option.flatMapNullable(employee => employee.company?.address?.street?.name),
 *   ),
 *   Option.some('high street')
 * )
 *
 * const employee2: Employee = { company: { address: { street: {} } } }
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.some(employee2),
 *     Option.flatMapNullable(employee => employee.company?.address?.street?.name),
 *   ),
 *   Option.none()
 * )
 *
 * @category sequencing
 * @since 2.0.0
 */
const flatMapNullable = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => Option_isNone(self) ? Option_none() : fromNullable(f(self.value)))));
/**
 * @category sequencing
 * @since 2.0.0
 */
const flatten = /*#__PURE__*/(/* unused pure expression or super */ null && (flatMap(identity)));
/**
 * @category zipping
 * @since 2.0.0
 */
const zipRight = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => flatMap(self, () => that))));
/**
 * @category sequencing
 * @since 2.0.0
 */
const composeK = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (afb, bfc) => a => flatMap(afb(a), bfc))));
/**
 * Sequences the specified `that` `Option` but ignores its value.
 *
 * It is useful when we want to chain multiple operations, but only care about the result of `self`.
 *
 * @param that - The `Option` that will be ignored in the chain and discarded
 * @param self - The `Option` we care about
 *
 * @category zipping
 * @since 2.0.0
 */
const zipLeft = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => tap(self, () => that))));
/**
 * Applies the provided function `f` to the value of the `Option` if it is `Some` and returns the original `Option`
 * unless `f` returns `None`, in which case it returns `None`.
 *
 * This function is useful for performing additional computations on the value of the input `Option` without affecting its value.
 *
 * @param f - Function to apply to the value of the `Option` if it is `Some`
 * @param self - The `Option` to apply the function to
 *
 * @example
 * import { Option } from "effect"
 *
 * const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()
 *
 * assert.deepStrictEqual(Option.tap(Option.none(), getInteger), Option.none())
 * assert.deepStrictEqual(Option.tap(Option.some(1), getInteger), Option.some(1))
 * assert.deepStrictEqual(Option.tap(Option.some(1.14), getInteger), Option.none())
 *
 * @category sequencing
 * @since 2.0.0
 */
const tap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => flatMap(self, a => map(f(a), () => a)))));
/**
 * @category combining
 * @since 2.0.0
 */
const Option_product = (self, that) => Option_isSome(self) && Option_isSome(that) ? Option_some([self.value, that.value]) : Option_none();
/**
 * @category combining
 * @since 2.0.0
 */
const Option_productMany = (self, collection) => {
  if (Option_isNone(self)) {
    return Option_none();
  }
  const out = [self.value];
  for (const o of collection) {
    if (Option_isNone(o)) {
      return Option_none();
    }
    out.push(o.value);
  }
  return Option_some(out);
};
/**
 * Takes a structure of `Option`s and returns an `Option` of values with the same structure.
 *
 * - If a tuple is supplied, then the returned `Option` will contain a tuple with the same length.
 * - If a struct is supplied, then the returned `Option` will contain a struct with the same keys.
 * - If an iterable is supplied, then the returned `Option` will contain an array.
 *
 * @param fields - the struct of `Option`s to be sequenced.
 *
 * @example
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.all([Option.some(1), Option.some(2)]), Option.some([1, 2]))
 * assert.deepStrictEqual(Option.all({ a: Option.some(1), b: Option.some("hello") }), Option.some({ a: 1, b: "hello" }))
 * assert.deepStrictEqual(Option.all({ a: Option.some(1), b: Option.none() }), Option.none())
 *
 * @category combining
 * @since 2.0.0
 */
// @ts-expect-error
const Option_all = input => {
  if (Symbol.iterator in input) {
    const out = [];
    for (const o of input) {
      if (Option_isNone(o)) {
        return Option_none();
      }
      out.push(o.value);
    }
    return Option_some(out);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const o = input[key];
    if (Option_isNone(o)) {
      return Option_none();
    }
    out[key] = o.value;
  }
  return Option_some(out);
};
/**
 * Zips two `Option` values together using a provided function, returning a new `Option` of the result.
 *
 * @param self - The left-hand side of the zip operation
 * @param that - The right-hand side of the zip operation
 * @param f - The function used to combine the values of the two `Option`s
 *
 * @example
 * import { Option } from "effect"
 *
 * type Complex = [real: number, imaginary: number]
 *
 * const complex = (real: number, imaginary: number): Complex => [real, imaginary]
 *
 * assert.deepStrictEqual(Option.zipWith(Option.none(), Option.none(), complex), Option.none())
 * assert.deepStrictEqual(Option.zipWith(Option.some(1), Option.none(), complex), Option.none())
 * assert.deepStrictEqual(Option.zipWith(Option.none(), Option.some(1), complex), Option.none())
 * assert.deepStrictEqual(Option.zipWith(Option.some(1), Option.some(2), complex), Option.some([1, 2]))
 *
 * assert.deepStrictEqual(Option.zipWith(Option.some(1), complex)(Option.some(2)), Option.some([2, 1]))
 *
 * @category zipping
 * @since 2.0.0
 */
const zipWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, that, f) => map(Option_product(self, that), ([a, b]) => f(a, b)))));
/**
 * @category combining
 * @since 2.0.0
 */
const ap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => zipWith(self, that, (f, a) => f(a)))));
/**
 * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, elements that are `None` are ignored.
 *
 * @param self - The Iterable of `Option<A>` to be reduced.
 * @param b - The initial value of the accumulator.
 * @param f - The reducing function that takes the current accumulator value and the unwrapped value of an `Option<A>`.
 *
 * @example
 * import { pipe, Option } from "effect"
 *
 * const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]
 * assert.deepStrictEqual(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)), 3)
 *
 * @category folding
 * @since 2.0.0
 */
const reduceCompact = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, b, f) => {
  let out = b;
  for (const oa of self) {
    if (Option_isSome(oa)) {
      out = f(out, oa.value);
    }
  }
  return out;
})));
/**
 * Transforms an `Option` into an `Array`.
 * If the input is `None`, an empty array is returned.
 * If the input is `Some`, the value is wrapped in an array.
 *
 * @param self - The `Option` to convert to an array.
 *
 * @example
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.toArray(Option.some(1)), [1])
 * assert.deepStrictEqual(Option.toArray(Option.none()), [])
 *
 * @category conversions
 * @since 2.0.0
 */
const toArray = self => Option_isNone(self) ? [] : [self.value];
/**
 * @category filtering
 * @since 2.0.0
 */
const partitionMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  if (Option_isNone(self)) {
    return [Option_none(), Option_none()];
  }
  const e = f(self.value);
  return either.isLeft(e) ? [Option_some(e.left), Option_none()] : [Option_none(), Option_some(e.right)];
})));
/**
 * Maps over the value of an `Option` and filters out `None`s.
 *
 * Useful when in addition to filtering you also want to change the type of the `Option`.
 *
 * @param self - The `Option` to map over.
 * @param f - A function to apply to the value of the `Option`.
 *
 * @example
 * import { Option } from "effect"
 *
 * const evenNumber = (n: number) => n % 2 === 0 ? Option.some(n) : Option.none()
 *
 * assert.deepStrictEqual(Option.filterMap(Option.none(), evenNumber), Option.none())
 * assert.deepStrictEqual(Option.filterMap(Option.some(3), evenNumber), Option.none())
 * assert.deepStrictEqual(Option.filterMap(Option.some(2), evenNumber), Option.some(2))
 *
 * @category filtering
 * @since 2.0.0
 */
const filterMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => Option_isNone(self) ? Option_none() : f(self.value))));
/**
 * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.
 *
 * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.
 *
 * @param predicate - A predicate function to apply to the `Option` value.
 * @param fb - The `Option` to filter.
 *
 * @example
 * import { Option } from "effect"
 *
 * // predicate
 * const isEven = (n: number) => n % 2 === 0
 *
 * assert.deepStrictEqual(Option.filter(Option.none(), isEven), Option.none())
 * assert.deepStrictEqual(Option.filter(Option.some(3), isEven), Option.none())
 * assert.deepStrictEqual(Option.filter(Option.some(2), isEven), Option.some(2))
 *
 * // refinement
 * const isNumber = (v: unknown): v is number => typeof v === "number"
 *
 * assert.deepStrictEqual(Option.filter(Option.none(), isNumber), Option.none())
 * assert.deepStrictEqual(Option.filter(Option.some('hello'), isNumber), Option.none())
 * assert.deepStrictEqual(Option.filter(Option.some(2), isNumber), Option.some(2))
 *
 * @category filtering
 * @since 2.0.0
 */
const filter = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => filterMap(self, b => predicate(b) ? option.some(b) : option.none))));
/**
 * @example
 * import { Option, Number } from "effect"
 *
 * const isEquivalent = Option.getEquivalence(Number.Equivalence)
 * assert.deepStrictEqual(isEquivalent(Option.none(), Option.none()), true)
 * assert.deepStrictEqual(isEquivalent(Option.none(), Option.some(1)), false)
 * assert.deepStrictEqual(isEquivalent(Option.some(1), Option.none()), false)
 * assert.deepStrictEqual(isEquivalent(Option.some(1), Option.some(2)), false)
 * assert.deepStrictEqual(isEquivalent(Option.some(1), Option.some(1)), true)
 *
 * @category equivalence
 * @since 2.0.0
 */
const getEquivalence = isEquivalent => Equivalence.make((x, y) => x === y || (Option_isNone(x) ? Option_isNone(y) : Option_isNone(y) ? false : isEquivalent(x.value, y.value)));
/**
 * The `Order` instance allows `Option` values to be compared with
 * `compare`, whenever there is an `Order` instance for
 * the type the `Option` contains.
 *
 * `None` is considered to be less than any `Some` value.
 *
 * @example
 * import { pipe, Option, Number } from "effect"
 *
 * const O = Option.getOrder(Number.Order)
 * assert.deepStrictEqual(O(Option.none(), Option.none()), 0)
 * assert.deepStrictEqual(O(Option.none(), Option.some(1)), -1)
 * assert.deepStrictEqual(O(Option.some(1), Option.none()), 1)
 * assert.deepStrictEqual(O(Option.some(1), Option.some(2)), -1)
 * assert.deepStrictEqual(O(Option.some(1), Option.some(1)), 0)
 *
 * @category sorting
 * @since 2.0.0
 */
const getOrder = O => order.make((self, that) => Option_isSome(self) ? Option_isSome(that) ? O(self.value, that.value) : 1 : -1);
/**
 * Lifts a binary function into `Option`.
 *
 * @param f - The function to lift.
 *
 * @category lifting
 * @since 2.0.0
 */
const lift2 = f => dual(2, (self, that) => zipWith(self, that, f));
/**
 * Transforms a `Predicate` function into a `Some` of the input value if the predicate returns `true` or `None`
 * if the predicate returns `false`.
 *
 * @param predicate - A `Predicate` function that takes in a value of type `A` and returns a boolean.
 *
 * @example
 * import { Option } from "effect"
 *
 * const getOption = Option.liftPredicate((n: number) => n >= 0)
 *
 * assert.deepStrictEqual(getOption(-1), Option.none())
 * assert.deepStrictEqual(getOption(1), Option.some(1))
 *
 * @category lifting
 * @since 2.0.0
 */
const liftPredicate = predicate => b => predicate(b) ? Option_some(b) : Option_none();
/**
 * Returns a function that checks if a `Option` contains a given value using a provided `isEquivalent` function.
 *
 * @param equivalent - An `Equivalence` instance to compare values of the `Option`.
 * @param self - The `Option` to apply the comparison to.
 * @param a - The value to compare against the `Option`.
 *
 * @example
 * import { pipe, Option, Number } from "effect"
 *
 * assert.deepStrictEqual(pipe(Option.some(2), Option.containsWith(Number.Equivalence)(2)), true)
 * assert.deepStrictEqual(pipe(Option.some(1), Option.containsWith(Number.Equivalence)(2)), false)
 * assert.deepStrictEqual(pipe(Option.none(), Option.containsWith(Number.Equivalence)(2)), false)
 *
 * @category elements
 * @since 2.0.0
 */
const containsWith = isEquivalent => Function_dual(2, (self, a) => Option_isNone(self) ? false : isEquivalent(self.value, a));
const _equivalence = /*#__PURE__*/equivalence();
/**
 * Returns a function that checks if an `Option` contains a given value using the default `Equivalence`.
 *
 * @category elements
 * @since 2.0.0
 */
const contains = /*#__PURE__*/containsWith(_equivalence);
/**
 * Check if a value in an `Option` type meets a certain predicate.
 *
 * @param self - The `Option` to check.
 * @param predicate - The condition to check.
 *
 * @example
 * import { pipe, Option } from "effect"
 *
 * const isEven = (n: number) => n % 2 === 0
 *
 * assert.deepStrictEqual(pipe(Option.some(2), Option.exists(isEven)), true)
 * assert.deepStrictEqual(pipe(Option.some(1), Option.exists(isEven)), false)
 * assert.deepStrictEqual(pipe(Option.none(), Option.exists(isEven)), false)
 *
 * @since 2.0.0
 */
const exists = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, refinement) => Option_isNone(self) ? false : refinement(self.value))));
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * The "do simulation" in allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope
 *
 * @see {@link Do}
 * @see {@link bind}
 * @see {@link let_ let}
 *
 * @example
 * import { Option, pipe } from "effect"
 *
 * const result = pipe(
 *   Option.Do,
 *   Option.bind("x", () => Option.some(2)),
 *   Option.bind("y", () => Option.some(3)),
 *   Option.let("sum", ({ x, y }) => x + y),
 *   Option.filter(({ x, y }) => x * y > 5)
 * )
 * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
 *
 * @category do notation
 * @since 2.0.0
 */
const bindTo = /*#__PURE__*/(/* unused pure expression or super */ null && (doNotation.bindTo(map)));
const let_ = /*#__PURE__*/(/* unused pure expression or super */ null && (doNotation.let_(map)));

/**
 * The "do simulation" in allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope
 *
 * @see {@link Do}
 * @see {@link bindTo}
 * @see {@link let_ let}
 *
 * @example
 * import { Option, pipe } from "effect"
 *
 * const result = pipe(
 *   Option.Do,
 *   Option.bind("x", () => Option.some(2)),
 *   Option.bind("y", () => Option.some(3)),
 *   Option.let("sum", ({ x, y }) => x + y),
 *   Option.filter(({ x, y }) => x * y > 5)
 * )
 * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
 *
 * @category do notation
 * @since 2.0.0
 */
const bind = /*#__PURE__*/(/* unused pure expression or super */ null && (doNotation.bind(map, flatMap)));
/**
 * The "do simulation" in allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope
 *
 * @see {@link bindTo}
 * @see {@link bind}
 * @see {@link let_ let}
 *
 * @example
 * import { Option, pipe } from "effect"
 *
 * const result = pipe(
 *   Option.Do,
 *   Option.bind("x", () => Option.some(2)),
 *   Option.bind("y", () => Option.some(3)),
 *   Option.let("sum", ({ x, y }) => x + y),
 *   Option.filter(({ x, y }) => x * y > 5)
 * )
 * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
 *
 * @category do notation
 * @since 2.0.0
 */
const Do = /*#__PURE__*/Option_some({});
const Option_adapter = /*#__PURE__*/(/* unused pure expression or super */ null && (Gen.adapter()));
/**
 * @category generators
 * @since 2.0.0
 */
const gen = f => {
  const iterator = f(Option_adapter);
  let state = iterator.next();
  if (state.done) {
    return Option_some(state.value);
  } else {
    let current = state.value;
    if (Gen.isGenKind(current)) {
      current = current.value;
    } else {
      current = Gen.yieldWrapGet(current);
    }
    if (Option_isNone(current)) {
      return current;
    }
    while (!state.done) {
      state = iterator.next(current.value);
      if (!state.done) {
        current = state.value;
        if (Gen.isGenKind(current)) {
          current = current.value;
        } else {
          current = Gen.yieldWrapGet(current);
        }
        if (Option_isNone(current)) {
          return current;
        }
      }
    }
    return Option_some(state.value);
  }
};
//# sourceMappingURL=Option.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Iterable.js
/**
 * This module provides utility functions for working with Iterables in TypeScript.
 *
 * @since 2.0.0
 */






/**
 * Return a `Iterable` with element `i` initialized with `f(i)`.
 *
 * If the `length` is not specified, the `Iterable` will be infinite.
 *
 * **Note**. `length` is normalized to an integer >= 1.
 *
 * @example
 * import { makeBy } from "effect/Iterable"
 *
 * assert.deepStrictEqual(Array.from(makeBy(n => n * 2, { length: 5 })), [0, 2, 4, 6, 8])
 *
 * @category constructors
 * @since 2.0.0
 */
const makeBy = (f, options) => {
  const max = options?.length !== undefined ? Math.max(1, Math.floor(options.length)) : Infinity;
  return {
    [Symbol.iterator]() {
      let i = 0;
      return {
        next() {
          if (i < max) {
            return {
              value: f(i++),
              done: false
            };
          }
          return {
            done: true,
            value: undefined
          };
        }
      };
    }
  };
};
/**
 * Return a `Iterable` containing a range of integers, including both endpoints.
 *
 * If `end` is omitted, the range will not have an upper bound.
 *
 * @example
 * import { range } from "effect/Iterable"
 *
 * assert.deepStrictEqual(Array.from(range(1, 3)), [1, 2, 3])
 *
 * @category constructors
 * @since 2.0.0
 */
const range = (start, end) => {
  if (end === undefined) {
    return makeBy(i => start + i);
  }
  return makeBy(i => start + i, {
    length: start <= end ? end - start + 1 : 1
  });
};
/**
 * Return a `Iterable` containing a value repeated the specified number of times.
 *
 * **Note**. `n` is normalized to an integer >= 1.
 *
 * @example
 * import { replicate } from "effect/Iterable"
 *
 * assert.deepStrictEqual(Array.from(replicate("a", 3)), ["a", "a", "a"])
 *
 * @category constructors
 * @since 2.0.0
 */
const replicate = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (a, n) => makeBy(() => a, {
  length: n
}))));
/**
 * Takes a record and returns an Iterable of tuples containing its keys and values.
 *
 * @param self - The record to transform.
 *
 * @example
 * import { fromRecord } from "effect/Iterable"
 *
 * const x = { a: 1, b: 2, c: 3 }
 * assert.deepStrictEqual(Array.from(fromRecord(x)), [["a", 1], ["b", 2], ["c", 3]])
 *
 * @category conversions
 * @since 2.0.0
 */
const fromRecord = self => ({
  *[Symbol.iterator]() {
    for (const key in self) {
      if (Object.prototype.hasOwnProperty.call(self, key)) {
        yield [key, self[key]];
      }
    }
  }
});
/**
 * Prepend an element to the front of an `Iterable`, creating a new `Iterable`.
 *
 * @category concatenating
 * @since 2.0.0
 */
const prepend = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, head) => prependAll(self, [head]))));
/**
 * Prepends the specified prefix iterable to the beginning of the specified iterable.
 *
 * @example
 * import { Iterable } from "effect"
 *
 * assert.deepStrictEqual(
 *   Array.from(Iterable.prependAll([1, 2], ["a", "b"])),
 *   ["a", "b", 1, 2]
 * )
 *
 * @category concatenating
 * @since 2.0.0
 */
const prependAll = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => appendAll(that, self))));
/**
 * Append an element to the end of an `Iterable`, creating a new `Iterable`.
 *
 * @category concatenating
 * @since 2.0.0
 */
const append = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, last) => appendAll(self, [last]))));
/**
 * Concatenates two iterables, combining their elements.
 *
 * @category concatenating
 * @since 2.0.0
 */
const appendAll = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => ({
  [Symbol.iterator]() {
    const iterA = self[Symbol.iterator]();
    let doneA = false;
    let iterB;
    return {
      next() {
        if (!doneA) {
          const r = iterA.next();
          if (r.done) {
            doneA = true;
            iterB = that[Symbol.iterator]();
            return iterB.next();
          }
          return r;
        }
        return iterB.next();
      }
    };
  }
}))));
/**
 * Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.
 *
 * @category folding
 * @since 2.0.0
 */
const scan = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, b, f) => ({
  [Symbol.iterator]() {
    let acc = b;
    let iterator;
    function next() {
      if (iterator === undefined) {
        iterator = self[Symbol.iterator]();
        return {
          done: false,
          value: acc
        };
      }
      const result = iterator.next();
      if (result.done) {
        return result;
      }
      acc = f(acc, result.value);
      return {
        done: false,
        value: acc
      };
    }
    return {
      next
    };
  }
}))));
/**
 * Determine if an `Iterable` is empty
 *
 * @example
 * import { isEmpty } from "effect/Iterable"
 *
 * assert.deepStrictEqual(isEmpty([]), true);
 * assert.deepStrictEqual(isEmpty([1, 2, 3]), false);
 *
 * @category guards
 * @since 2.0.0
 */
const isEmpty = self => {
  const iterator = self[Symbol.iterator]();
  return iterator.next().done === true;
};
/**
 * Return the number of elements in a `Iterable`.
 *
 * @category getters
 * @since 2.0.0
 */
const size = self => {
  const iterator = self[Symbol.iterator]();
  let count = 0;
  while (!iterator.next().done) {
    count++;
  }
  return count;
};
/**
 * Get the first element of a `Iterable`, or `None` if the `Iterable` is empty.
 *
 * @category getters
 * @since 2.0.0
 */
const head = self => {
  const iterator = self[Symbol.iterator]();
  const result = iterator.next();
  return result.done ? O.none() : O.some(result.value);
};
/**
 * Keep only a max number of elements from the start of an `Iterable`, creating a new `Iterable`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @category getters
 * @since 2.0.0
 */
const Iterable_take = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => ({
  [Symbol.iterator]() {
    let i = 0;
    const iterator = self[Symbol.iterator]();
    return {
      next() {
        if (i < n) {
          i++;
          return iterator.next();
        }
        return {
          done: true,
          value: undefined
        };
      }
    };
  }
}))));
/**
 * Calculate the longest initial Iterable for which all element satisfy the specified predicate, creating a new `Iterable`.
 *
 * @category getters
 * @since 2.0.0
 */
const takeWhile = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done || !predicate(result.value, i++)) {
          return {
            done: true,
            value: undefined
          };
        }
        return result;
      }
    };
  }
}))));
/**
 * Drop a max number of elements from the start of an `Iterable`
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @category getters
 * @since 2.0.0
 */
const drop = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        while (i < n) {
          const result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: undefined
            };
          }
          i++;
        }
        return iterator.next();
      }
    };
  }
}))));
/**
 * Returns the first element that satisfies the specified
 * predicate, or `None` if no such element exists.
 *
 * @category elements
 * @since 2.0.0
 */
const findFirst = /*#__PURE__*/Function_dual(2, (self, f) => {
  let i = 0;
  for (const a of self) {
    const o = f(a, i);
    if (Predicate_isBoolean(o)) {
      if (o) {
        return Option_some(a);
      }
    } else {
      if (Option_isSome(o)) {
        return o;
      }
    }
    i++;
  }
  return Option_none();
});
/**
 * Find the last element for which a predicate holds.
 *
 * @category elements
 * @since 2.0.0
 */
const findLast = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  let i = 0;
  let last = O.none();
  for (const a of self) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        last = O.some(a);
      }
    } else {
      if (O.isSome(o)) {
        last = o;
      }
    }
    i++;
  }
  return last;
})));
/**
 * Takes two `Iterable`s and returns an `Iterable` of corresponding pairs.
 *
 * @category zipping
 * @since 2.0.0
 */
const zip = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Iterable_zipWith(self, that, Tuple.make))));
/**
 * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results. If one
 * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.
 *
 * @category zipping
 * @since 2.0.0
 */
const Iterable_zipWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, that, f) => ({
  [Symbol.iterator]() {
    const selfIterator = self[Symbol.iterator]();
    const thatIterator = that[Symbol.iterator]();
    return {
      next() {
        const selfResult = selfIterator.next();
        const thatResult = thatIterator.next();
        if (selfResult.done || thatResult.done) {
          return {
            done: true,
            value: undefined
          };
        }
        return {
          done: false,
          value: f(selfResult.value, thatResult.value)
        };
      }
    };
  }
}))));
/**
 * Places an element in between members of an `Iterable`.
 * If the input is a non-empty array, the result is also a non-empty array.
 *
 * @since 2.0.0
 */
const intersperse = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, middle) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let next = iterator.next();
    let emitted = false;
    return {
      next() {
        if (next.done) {
          return next;
        } else if (emitted) {
          emitted = false;
          return {
            done: false,
            value: middle
          };
        }
        emitted = true;
        const result = next;
        next = iterator.next();
        return result;
      }
    };
  }
}))));
/**
 * Returns a function that checks if an `Iterable` contains a given value using a provided `isEquivalent` function.
 *
 * @category elements
 * @since 2.0.0
 */
const Iterable_containsWith = isEquivalent => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
const Iterable_equivalence = /*#__PURE__*/(/* unused pure expression or super */ null && (Equal.equivalence()));
/**
 * Returns a function that checks if a `Iterable` contains a given value using the default `Equivalence`.
 *
 * @category elements
 * @since 2.0.0
 */
const Iterable_contains = /*#__PURE__*/(/* unused pure expression or super */ null && (Iterable_containsWith(Iterable_equivalence)));
/**
 * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
 * the `Iterable`.
 *
 * @category splitting
 * @since 2.0.0
 */
const chunksOf = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => {
  const safeN = Math.max(1, Math.floor(n));
  return {
    [Symbol.iterator]() {
      let iterator = self[Symbol.iterator]();
      return {
        next() {
          if (iterator === undefined) {
            return {
              done: true,
              value: undefined
            };
          }
          const chunk = [];
          for (let i = 0; i < safeN; i++) {
            const result = iterator.next();
            if (result.done) {
              iterator = undefined;
              return chunk.length === 0 ? {
                done: true,
                value: undefined
              } : {
                done: false,
                value: chunk
              };
            }
            chunk.push(result.value);
          }
          return {
            done: false,
            value: chunk
          };
        }
      };
    }
  };
})));
/**
 * Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s using the provided `isEquivalent` function.
 *
 * @category grouping
 * @since 2.0.0
 */
const groupWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, isEquivalent) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let nextResult;
    return {
      next() {
        let result;
        if (nextResult !== undefined) {
          if (nextResult.done) {
            return {
              done: true,
              value: undefined
            };
          }
          result = nextResult;
          nextResult = undefined;
        } else {
          result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: undefined
            };
          }
        }
        const chunk = [result.value];
        // eslint-disable-next-line no-constant-condition
        while (true) {
          const next = iterator.next();
          if (next.done || !isEquivalent(result.value, next.value)) {
            nextResult = next;
            return {
              done: false,
              value: chunk
            };
          }
          chunk.push(next.value);
        }
      }
    };
  }
}))));
/**
 * Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s.
 *
 * @category grouping
 * @since 2.0.0
 */
const group = /*#__PURE__*/(/* unused pure expression or super */ null && (groupWith( /*#__PURE__*/Equal.equivalence())));
/**
 * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
 * function on each element, and grouping the results according to values returned
 *
 * @category grouping
 * @since 2.0.0
 */
const groupBy = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const out = {};
  for (const a of self) {
    const k = f(a);
    if (Object.prototype.hasOwnProperty.call(out, k)) {
      out[k].push(a);
    } else {
      out[k] = [a];
    }
  }
  return out;
})));
const constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
const constEmptyIterator = {
  next() {
    return {
      done: true,
      value: undefined
    };
  }
};
/**
 * @category constructors
 * @since 2.0.0
 */
const Iterable_empty = () => constEmpty;
/**
 * Constructs a new `Iterable<A>` from the specified value.
 *
 * @category constructors
 * @since 2.0.0
 */
const of = a => [a];
/**
 * @category mapping
 * @since 2.0.0
 */
const Iterable_map = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: undefined
          };
        }
        return {
          done: false,
          value: f(result.value, i++)
        };
      }
    };
  }
}))));
/**
 * Applies a function to each element in an Iterable and returns a new Iterable containing the concatenated mapped elements.
 *
 * @category sequencing
 * @since 2.0.0
 */
const Iterable_flatMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => Iterable_flatten(Iterable_map(self, f)))));
/**
 * Flattens an Iterable of Iterables into a single Iterable
 *
 * @category sequencing
 * @since 2.0.0
 */
const Iterable_flatten = self => ({
  [Symbol.iterator]() {
    const outerIterator = self[Symbol.iterator]();
    let innerIterator;
    function next() {
      if (innerIterator === undefined) {
        const next = outerIterator.next();
        if (next.done) {
          return next;
        }
        innerIterator = next.value[Symbol.iterator]();
      }
      const result = innerIterator.next();
      if (result.done) {
        innerIterator = undefined;
        return next();
      }
      return result;
    }
    return {
      next
    };
  }
});
/**
 * @category filtering
 * @since 2.0.0
 */
const Iterable_filterMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        let result = iterator.next();
        while (!result.done) {
          const b = f(result.value, i++);
          if (O.isSome(b)) {
            return {
              done: false,
              value: b.value
            };
          }
          result = iterator.next();
        }
        return {
          done: true,
          value: undefined
        };
      }
    };
  }
}))));
/**
 * Transforms all elements of the `Iterable` for as long as the specified function returns some value
 *
 * @category filtering
 * @since 2.0.0
 */
const filterMapWhile = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: undefined
          };
        }
        const b = f(result.value, i++);
        if (O.isSome(b)) {
          return {
            done: false,
            value: b.value
          };
        }
        return {
          done: true,
          value: undefined
        };
      }
    };
  }
}))));
/**
 * Retrieves the `Some` values from an `Iterable` of `Option`s.
 *
 * @example
 * import { Iterable, Option } from "effect"
 *
 * assert.deepStrictEqual(
 *   Array.from(Iterable.getSomes([Option.some(1), Option.none(), Option.some(2)])),
 *   [1, 2]
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
const getSomes = /*#__PURE__*/(/* unused pure expression or super */ null && (Iterable_filterMap(identity)));
/**
 * Retrieves the `Left` values from an `Iterable` of `Either`s.
 *
 * @example
 * import { Iterable, Either } from "effect"
 *
 * assert.deepStrictEqual(
 *   Array.from(Iterable.getLefts([Either.right(1), Either.left("err"), Either.right(2)])),
 *   ["err"]
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
const getLefts = self => Iterable_filterMap(self, E.getLeft);
/**
 * Retrieves the `Right` values from an `Iterable` of `Either`s.
 *
 * @example
 * import { Iterable, Either } from "effect"
 *
 * assert.deepStrictEqual(
 *   Array.from(Iterable.getRights([Either.right(1), Either.left("err"), Either.right(2)])),
 *   [1, 2]
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
const getRights = self => Iterable_filterMap(self, E.getRight);
/**
 * @category filtering
 * @since 2.0.0
 */
const Iterable_filter = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        let result = iterator.next();
        while (!result.done) {
          if (predicate(result.value, i++)) {
            return {
              done: false,
              value: result.value
            };
          }
          result = iterator.next();
        }
        return {
          done: true,
          value: undefined
        };
      }
    };
  }
}))));
/**
 * @category sequencing
 * @since 2.0.0
 */
const Iterable_flatMapNullable = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => Iterable_filterMap(self, a => {
  const b = f(a);
  return b == null ? O.none() : O.some(b);
}))));
/**
 * Check if a predicate holds true for some `Iterable` element.
 *
 * @category elements
 * @since 2.0.0
 */
const Iterable_some = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i++)) {
      return true;
    }
  }
  return false;
})));
/**
 * @category constructors
 * @since 2.0.0
 */
const unfold = (b, f) => ({
  [Symbol.iterator]() {
    let next = b;
    return {
      next() {
        const o = f(next);
        if (O.isNone(o)) {
          return {
            done: true,
            value: undefined
          };
        }
        const [a, b] = o.value;
        next = b;
        return {
          done: false,
          value: a
        };
      }
    };
  }
});
/**
 * Iterate over the `Iterable` applying `f`.
 *
 * @since 2.0.0
 */
const forEach = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  let i = 0;
  for (const a of self) {
    f(a, i++);
  }
})));
/**
 * @category folding
 * @since 2.0.0
 */
const reduce = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, b, f) => {
  if (Array.isArray(self)) {
    return self.reduce(f, b);
  }
  let i = 0;
  let result = b;
  for (const n of self) {
    result = f(result, n, i++);
  }
  return result;
})));
/**
 * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.
 *
 * @since 2.0.0
 */
const dedupeAdjacentWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, isEquivalent) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let first = true;
    let last;
    function next() {
      const result = iterator.next();
      if (result.done) {
        return {
          done: true,
          value: undefined
        };
      }
      if (first) {
        first = false;
        last = result.value;
        return result;
      }
      const current = result.value;
      if (isEquivalent(last, current)) {
        return next();
      }
      last = current;
      return result;
    }
    return {
      next
    };
  }
}))));
/**
 * Deduplicates adjacent elements that are identical.
 *
 * @since 2.0.0
 */
const dedupeAdjacent = /*#__PURE__*/(/* unused pure expression or super */ null && (dedupeAdjacentWith( /*#__PURE__*/Equal.equivalence())));
/**
 * Zips this Iterable crosswise with the specified Iterable using the specified combiner.
 *
 * @since 2.0.0
 * @category elements
 */
const cartesianWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, that, f) => Iterable_flatMap(self, a => Iterable_map(that, b => f(a, b))))));
/**
 * Zips this Iterable crosswise with the specified Iterable.
 *
 * @since 2.0.0
 * @category elements
 */
const cartesian = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => cartesianWith(self, that, (a, b) => [a, b]))));
//# sourceMappingURL=Iterable.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Order.js
/**
 * This module provides an implementation of the `Order` type class which is used to define a total ordering on some type `A`.
 * An order is defined by a relation `<=`, which obeys the following laws:
 *
 * - either `x <= y` or `y <= x` (totality)
 * - if `x <= y` and `y <= x`, then `x == y` (antisymmetry)
 * - if `x <= y` and `y <= z`, then `x <= z` (transitivity)
 *
 * The truth table for compare is defined as follows:
 *
 * | `x <= y` | `x >= y` | Ordering |                       |
 * | -------- | -------- | -------- | --------------------- |
 * | `true`   | `true`   | `0`      | corresponds to x == y |
 * | `true`   | `false`  | `< 0`    | corresponds to x < y  |
 * | `false`  | `true`   | `> 0`    | corresponds to x > y  |
 *
 * @since 2.0.0
 */

/**
 * @category constructors
 * @since 2.0.0
 */
const Order_make = compare => (self, that) => self === that ? 0 : compare(self, that);
/**
 * @category instances
 * @since 2.0.0
 */
const Order_string = /*#__PURE__*/(/* unused pure expression or super */ null && (Order_make((self, that) => self < that ? -1 : 1)));
/**
 * @category instances
 * @since 2.0.0
 */
const Order_number = /*#__PURE__*/Order_make((self, that) => self < that ? -1 : 1);
/**
 * @category instances
 * @since 2.0.0
 */
const Order_boolean = /*#__PURE__*/Order_make((self, that) => self < that ? -1 : 1);
/**
 * @category instances
 * @since 2.0.0
 */
const Order_bigint = /*#__PURE__*/(/* unused pure expression or super */ null && (Order_make((self, that) => self < that ? -1 : 1)));
/**
 * @since 2.0.0
 */
const reverse = O => Order_make((self, that) => O(that, self));
/**
 * @category combining
 * @since 2.0.0
 */
const Order_combine = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Order_make((a1, a2) => {
  const out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  return that(a1, a2);
}))));
/**
 * @category combining
 * @since 2.0.0
 */
const Order_combineMany = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, collection) => Order_make((a1, a2) => {
  let out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  for (const O of collection) {
    out = O(a1, a2);
    if (out !== 0) {
      return out;
    }
  }
  return out;
}))));
/**
 * @since 2.0.0
 */
const Order_empty = () => Order_make(() => 0);
/**
 * @category combining
 * @since 2.0.0
 */
const Order_combineAll = collection => Order_combineMany(Order_empty(), collection);
/**
 * @category mapping
 * @since 2.0.0
 */
const Order_mapInput = /*#__PURE__*/Function_dual(2, (self, f) => Order_make((b1, b2) => self(f(b1), f(b2))));
/**
 * @category instances
 * @since 2.0.0
 */
const Order_Date = /*#__PURE__*/(/* unused pure expression or super */ null && (Order_mapInput(Order_number, date => date.getTime())));
/**
 * @category combining
 * @since 2.0.0
 */
const Order_product = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Order_make(([xa, xb], [ya, yb]) => {
  const o = self(xa, ya);
  return o !== 0 ? o : that(xb, yb);
}))));
/**
 * @category combining
 * @since 2.0.0
 */
const Order_all = collection => {
  return Order_make((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const O of collection) {
      if (collectionLength >= len) {
        break;
      }
      const o = O(x[collectionLength], y[collectionLength]);
      if (o !== 0) {
        return o;
      }
      collectionLength++;
    }
    return 0;
  });
};
/**
 * @category combining
 * @since 2.0.0
 */
const Order_productMany = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, collection) => {
  const O = Order_all(collection);
  return Order_make((x, y) => {
    const o = self(x[0], y[0]);
    return o !== 0 ? o : O(x.slice(1), y.slice(1));
  });
})));
/**
 * Similar to `Promise.all` but operates on `Order`s.
 *
 * ```
 * [Order<A>, Order<B>, ...] -> Order<[A, B, ...]>
 * ```
 *
 * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.
 * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.
 * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element
 * of the tuple.
 *
 * @category combinators
 * @since 2.0.0
 */
const Order_tuple = (...elements) => Order_all(elements);
/**
 * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.
 * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.
 * If all elements are equal, the arrays are then compared based on their length.
 * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.
 *
 * @category combinators
 * @since 2.0.0
 */
const Order_array = O => Order_make((self, that) => {
  const aLen = self.length;
  const bLen = that.length;
  const len = Math.min(aLen, bLen);
  for (let i = 0; i < len; i++) {
    const o = O(self[i], that[i]);
    if (o !== 0) {
      return o;
    }
  }
  return Order_number(aLen, bLen);
});
/**
 * This function creates and returns a new `Order` for a struct of values based on the given `Order`s
 * for each property in the struct.
 *
 * @category combinators
 * @since 2.0.0
 */
const Order_struct = fields => {
  const keys = Object.keys(fields);
  return Order_make((self, that) => {
    for (const key of keys) {
      const o = fields[key](self[key], that[key]);
      if (o !== 0) {
        return o;
      }
    }
    return 0;
  });
};
/**
 * Test whether one value is _strictly less than_ another.
 *
 * @since 2.0.0
 */
const lessThan = O => dual(2, (self, that) => O(self, that) === -1);
/**
 * Test whether one value is _strictly greater than_ another.
 *
 * @since 2.0.0
 */
const greaterThan = O => Function_dual(2, (self, that) => O(self, that) === 1);
/**
 * Test whether one value is _non-strictly less than_ another.
 *
 * @since 2.0.0
 */
const lessThanOrEqualTo = O => dual(2, (self, that) => O(self, that) !== 1);
/**
 * Test whether one value is _non-strictly greater than_ another.
 *
 * @since 2.0.0
 */
const greaterThanOrEqualTo = O => dual(2, (self, that) => O(self, that) !== -1);
/**
 * Take the minimum of two values. If they are considered equal, the first argument is chosen.
 *
 * @since 2.0.0
 */
const min = O => dual(2, (self, that) => self === that || O(self, that) < 1 ? self : that);
/**
 * Take the maximum of two values. If they are considered equal, the first argument is chosen.
 *
 * @since 2.0.0
 */
const max = O => dual(2, (self, that) => self === that || O(self, that) > -1 ? self : that);
/**
 * Clamp a value between a minimum and a maximum.
 *
 * @example
 * import { Order, Number } from "effect"
 *
 * const clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })
 *
 * assert.equal(clamp(3), 3)
 * assert.equal(clamp(0), 1)
 * assert.equal(clamp(6), 5)
 *
 * @since 2.0.0
 */
const clamp = O => dual(2, (self, options) => min(O)(options.maximum, max(O)(options.minimum, self)));
/**
 * Test whether a value is between a minimum and a maximum (inclusive).
 *
 * @since 2.0.0
 */
const between = O => dual(2, (self, options) => !lessThan(O)(self, options.minimum) && !greaterThan(O)(self, options.maximum));
//# sourceMappingURL=Order.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Record.js
/**
 * This module provides utility functions for working with records in TypeScript.
 *
 * @since 2.0.0
 */




/**
 * Creates a new, empty record.
 *
 * @category constructors
 * @since 2.0.0
 */
const Record_empty = () => ({});
/**
 * Determine if a record is empty.
 *
 * @param self - record to test for emptiness.
 *
 * @example
 * import { isEmptyRecord } from "effect/Record"
 *
 * assert.deepStrictEqual(isEmptyRecord({}), true);
 * assert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);
 *
 * @category guards
 * @since 2.0.0
 */
const isEmptyRecord = self => keys(self).length === 0;
/**
 * Determine if a record is empty.
 *
 * @param self - record to test for emptiness.
 *
 * @example
 * import { isEmptyReadonlyRecord } from "effect/Record"
 *
 * assert.deepStrictEqual(isEmptyReadonlyRecord({}), true);
 * assert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);
 *
 * @category guards
 * @since 2.0.0
 */
const isEmptyReadonlyRecord = (/* unused pure expression or super */ null && (isEmptyRecord));
/**
 * Takes an iterable and a projection function and returns a record.
 * The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.
 *
 * @param self - An iterable of values to be mapped to a record.
 * @param f - A projection function that maps values of the iterable to a tuple of a key and a value.
 *
 * @example
 * import { fromIterableWith } from "effect/Record"
 *
 * const input = [1, 2, 3, 4]
 *
 * assert.deepStrictEqual(
 *   fromIterableWith(input, a => [String(a), a * 2]),
 *   { '1': 2, '2': 4, '3': 6, '4': 8 }
 * )
 *
 * @category constructors
 * @since 2.0.0
 */
const fromIterableWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const out = Record_empty();
  for (const a of self) {
    const [k, b] = f(a);
    out[k] = b;
  }
  return out;
})));
/**
 * Creates a new record from an iterable, utilizing the provided function to determine the key for each element.
 *
 * @param items - An iterable containing elements.
 * @param f - A function that extracts the key for each element.
 *
 * @example
 * import { fromIterableBy } from "effect/Record"
 *
 * const users = [
 *   { id: "2", name: "name2" },
 *   { id: "1", name: "name1" }
 * ]
 *
 * assert.deepStrictEqual(
 *   fromIterableBy(users, user => user.id),
 *   {
 *     "2": { id: "2", name: "name2" },
 *     "1": { id: "1", name: "name1" }
 *   }
 * )
 *
 * @category constructors
 * @since 2.0.0
 */
const fromIterableBy = (items, f) => fromIterableWith(items, a => [f(a), a]);
/**
 * Builds a record from an iterable of key-value pairs.
 *
 * If there are conflicting keys when using `fromEntries`, the last occurrence of the key/value pair will overwrite the
 * previous ones. So the resulting record will only have the value of the last occurrence of each key.
 *
 * @param self - The iterable of key-value pairs.
 *
 * @example
 * import { fromEntries } from "effect/Record"
 *
 * const input: Array<[string, number]> = [["a", 1], ["b", 2]]
 *
 * assert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })
 *
 * @since 2.0.0
 * @category constructors
 */
const fromEntries = Object.fromEntries;
/**
 * Transforms the values of a record into an `Array` with a custom mapping function.
 *
 * @param self - The record to transform.
 * @param f - The custom mapping function to apply to each key/value of the record.
 *
 * @example
 * import { collect } from "effect/Record"
 *
 * const x = { a: 1, b: 2, c: 3 }
 * assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [["a", 1], ["b", 2], ["c", 3]])
 *
 * @category conversions
 * @since 2.0.0
 */
const collect = /*#__PURE__*/Function_dual(2, (self, f) => {
  const out = [];
  for (const key of keys(self)) {
    out.push(f(key, self[key]));
  }
  return out;
});
/**
 * Takes a record and returns an array of tuples containing its keys and values.
 *
 * @param self - The record to transform.
 *
 * @example
 * import { toEntries } from "effect/Record"
 *
 * const x = { a: 1, b: 2, c: 3 }
 * assert.deepStrictEqual(toEntries(x), [["a", 1], ["b", 2], ["c", 3]])
 *
 * @category conversions
 * @since 2.0.0
 */
const toEntries = /*#__PURE__*/collect((key, value) => [key, value]);
/**
 * Returns the number of key/value pairs in a record.
 *
 * @param self - A record to calculate the number of key/value pairs in.
 *
 * @example
 * import { size } from "effect/Record";
 *
 * assert.deepStrictEqual(size({ a: "a", b: 1, c: true }), 3);
 *
 * @since 2.0.0
 */
const Record_size = self => keys(self).length;
/**
 * Check if a given `key` exists in a record.
 *
 * @param self - the record to look in.
 * @param key - the key to look for in the record.
 *
 * @example
 * import { empty, has } from "effect/Record"
 *
 * assert.deepStrictEqual(has({ a: 1, b: 2 }, "a"), true);
 * assert.deepStrictEqual(has(empty<string>(), "c"), false);
 *
 * @since 2.0.0
 */
const has = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, key) => Object.prototype.hasOwnProperty.call(self, key))));
/**
 * Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.
 *
 * @param self - The record to retrieve value from.
 * @param key - Key to retrieve from record.
 *
 * @example
 * import { Record as R, Option } from "effect"
 *
 * const person: Record<string, unknown> = { name: "John Doe", age: 35 }
 *
 * assert.deepStrictEqual(R.get(person, "name"), Option.some("John Doe"))
 * assert.deepStrictEqual(R.get(person, "email"), Option.none())
 *
 * @since 2.0.0
 */
const Record_get = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, key) => has(self, key) ? Option.some(self[key]) : Option.none())));
/**
 * Apply a function to the element at the specified key, creating a new record.
 * If the key does not exist, the record is returned unchanged.
 *
 * @param self - The record to be updated.
 * @param key - The key of the element to modify.
 * @param f - The function to apply to the element.
 *
 * @example
 * import { Record as R } from "effect"
 *
 * const f = (x: number) => x * 2
 *
 * assert.deepStrictEqual(
 *  R.modify({ a: 3 }, 'a', f),
 *  { a: 6 }
 * )
 * assert.deepStrictEqual(
 *  R.modify({ a: 3 } as Record<string, number>, 'b', f),
 *  { a: 3 }
 * )
 *
 * @since 2.0.0
 */
const modify = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, key, f) => {
  if (!has(self, key)) {
    return {
      ...self
    };
  }
  return {
    ...self,
    [key]: f(self[key])
  };
})));
/**
 * Apply a function to the element at the specified key, creating a new record,
 * or return `None` if the key doesn't exist.
 *
 * @param self - The record to be updated.
 * @param key - The key of the element to modify.
 * @param f - The function to apply to the element.
 *
 * @example
 * import { Record as R, Option } from "effect"
 *
 * const f = (x: number) => x * 2
 *
 * assert.deepStrictEqual(
 *  R.modifyOption({ a: 3 }, 'a', f),
 *  Option.some({ a: 6 })
 * )
 * assert.deepStrictEqual(
 *  R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),
 *  Option.none()
 * )
 *
 * @since 2.0.0
 */
const modifyOption = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, key, f) => {
  if (!has(self, key)) {
    return Option.none();
  }
  return Option.some({
    ...self,
    [key]: f(self[key])
  });
})));
/**
 * Replaces a value in the record with the new value passed as parameter.
 *
 * @param self - The record to be updated.
 * @param key - The key to search for in the record.
 * @param b - The new value to replace the existing value with.
 *
 * @example
 * import { Record, Option } from "effect"
 *
 * assert.deepStrictEqual(
 *   Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),
 *   Option.some({ a: 10, b: 2, c: 3 })
 * )
 * assert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())
 *
 * @since 2.0.0
 */
const replaceOption = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, key, b) => modifyOption(self, key, () => b))));
/**
 * If the given key exists in the record, returns a new record with the key removed,
 * otherwise returns a copy of the original record.
 *
 * @param self - the record to remove the key from.
 * @param key - the key to remove from the record.
 *
 * @example
 * import { remove } from "effect/Record"
 *
 * assert.deepStrictEqual(remove({ a: 1, b: 2 }, "a"), { b: 2 })
 *
 * @since 2.0.0
 */
const remove = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, key) => {
  if (!has(self, key)) {
    return {
      ...self
    };
  }
  const out = {
    ...self
  };
  delete out[key];
  return out;
})));
/**
 * Retrieves the value of the property with the given `key` from a record and returns an `Option`
 * of a tuple with the value and the record with the removed property.
 * If the key is not present, returns `O.none`.
 *
 * @param self - The input record.
 * @param key - The key of the property to retrieve.
 *
 * @example
 * import { Record as R, Option } from "effect"
 *
 * assert.deepStrictEqual(R.pop({ a: 1, b: 2 }, "a"), Option.some([1, { b: 2 }]))
 * assert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, "c"), Option.none())
 *
 * @category record
 * @since 2.0.0
 */
const pop = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, key) => has(self, key) ? Option.some([self[key], remove(self, key)]) : Option.none())));
/**
 * Maps a record into another record by applying a transformation function to each of its values.
 *
 * @param self - The record to be mapped.
 * @param f - A transformation function that will be applied to each of the values in the record.
 *
 * @example
 * import { map } from "effect/Record"
 *
 * const f = (n: number) => `-${n}`
 *
 * assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: "-3", b: "-5" })
 *
 * const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`
 *
 * assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: "A-3", b: "B-5" })
 *
 * @category mapping
 * @since 2.0.0
 */
const Record_map = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const out = {
    ...self
  };
  for (const key of keys(self)) {
    out[key] = f(self[key], key);
  }
  return out;
})));
/**
 * Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.
 *
 * @example
 * import { mapKeys } from "effect/Record"
 *
 * assert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })
 *
 * @category mapping
 * @since 2.0.0
 */
const mapKeys = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const out = {};
  for (const key of keys(self)) {
    const a = self[key];
    out[f(key, a)] = a;
  }
  return out;
})));
/**
 * Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.
 *
 * @example
 * import { mapEntries } from "effect/Record"
 *
 * assert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })
 *
 * @category mapping
 * @since 2.0.0
 */
const mapEntries = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const out = {};
  for (const key of keys(self)) {
    const [k, b] = f(self[key], key);
    out[k] = b;
  }
  return out;
})));
/**
 * Transforms a record into a record by applying the function `f` to each key and value in the original record.
 * If the function returns `Some`, the key-value pair is included in the output record.
 *
 * @param self - The input record.
 * @param f - The transformation function.
 *
 * @example
 * import { Record, Option } from "effect"
 *
 * const x = { a: 1, b: 2, c: 3 }
 * const f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()
 * assert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })
 *
 * @since 2.0.0
 */
const Record_filterMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const out = Record_empty();
  for (const key of keys(self)) {
    const o = f(self[key], key);
    if (Option.isSome(o)) {
      out[key] = o.value;
    }
  }
  return out;
})));
/**
 * Selects properties from a record whose values match the given predicate.
 *
 * @param self - The record to filter.
 * @param predicate - A function that returns a `boolean` value to determine if the entry should be included in the new record.
 *
 * @example
 * import { filter } from "effect/Record"
 *
 * const x = { a: 1, b: 2, c: 3, d: 4 }
 * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })
 *
 * @category filtering
 * @since 2.0.0
 */
const Record_filter = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  const out = Record_empty();
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      out[key] = self[key];
    }
  }
  return out;
})));
/**
 * Given a record with `Option` values, returns a new record containing only the `Some` values, preserving the original keys.
 *
 * @param self - A record with `Option` values.
 *
 * @example
 * import { Record, Option } from "effect"
 *
 * assert.deepStrictEqual(
 *   Record.getSomes({ a: Option.some(1), b: Option.none(), c: Option.some(2) }),
 *   { a: 1, c: 2 }
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
const Record_getSomes = /*#__PURE__*/(/* unused pure expression or super */ null && (Record_filterMap(identity)));
/**
 * Given a record with `Either` values, returns a new record containing only the `Left` values, preserving the original keys.
 *
 * @example
 * import { Record, Either } from "effect"
 *
 * assert.deepStrictEqual(
 *   Record.getLefts({ a: Either.right(1), b: Either.left("err"), c: Either.right(2) }),
 *   { b: "err" }
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
const Record_getLefts = self => {
  const out = Record_empty();
  for (const key of keys(self)) {
    const value = self[key];
    if (E.isLeft(value)) {
      out[key] = value.left;
    }
  }
  return out;
};
/**
 * Given a record with `Either` values, returns a new record containing only the `Right` values, preserving the original keys.
 *
 * @example
 * import { Record, Either } from "effect"
 *
 * assert.deepStrictEqual(
 *   Record.getRights({ a: Either.right(1), b: Either.left("err"), c: Either.right(2) }),
 *   { a: 1, c: 2 }
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
const Record_getRights = self => {
  const out = Record_empty();
  for (const key of keys(self)) {
    const value = self[key];
    if (E.isRight(value)) {
      out[key] = value.right;
    }
  }
  return out;
};
/**
 * Partitions the elements of a record into two groups: those that match a predicate, and those that don't.
 *
 * @param self - The record to partition.
 * @param f - The predicate function to apply to each element.
 *
 * @example
 * import { Record, Either } from "effect"
 *
 * const x = { a: 1, b: 2, c: 3 }
 * const f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))
 * assert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])
 *
 * @category filtering
 * @since 2.0.0
 */
const Record_partitionMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const left = Record_empty();
  const right = Record_empty();
  for (const key of keys(self)) {
    const e = f(self[key], key);
    if (E.isLeft(e)) {
      left[key] = e.left;
    } else {
      right[key] = e.right;
    }
  }
  return [left, right];
})));
/**
 * Partitions a record of `Either` values into two separate records,
 * one with the `Left` values and one with the `Right` values.
 *
 * @param self - the record to partition.
 *
 * @example
 * import { Record, Either } from "effect"
 *
 * assert.deepStrictEqual(
 *   Record.separate({ a: Either.left("e"), b: Either.right(1) }),
 *   [{ a: "e" }, { b: 1 }]
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
const separate = /*#__PURE__*/(/* unused pure expression or super */ null && (Record_partitionMap(identity)));
/**
 * Partitions a record into two separate records based on the result of a predicate function.
 *
 * @param self - The input record to partition.
 * @param predicate - The partitioning function to determine the partitioning of each value of the record.
 *
 * @example
 * import { partition } from "effect/Record"
 *
 * assert.deepStrictEqual(
 *   partition({ a: 1, b: 3 }, (n) => n > 2),
 *   [{ a: 1 }, { b: 3 }]
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
const partition = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  const left = Record_empty();
  const right = Record_empty();
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      right[key] = self[key];
    } else {
      left[key] = self[key];
    }
  }
  return [left, right];
})));
/**
 * Retrieve the keys of a given record as an array.
 *
 * @param self - The object for which you want to get the keys.
 *
 * @since 2.0.0
 */
const keys = self => Object.keys(self);
/**
 * Retrieve the values of a given record as an array.
 *
 * @param self - The object for which you want to get the values.
 *
 * @since 2.0.0
 */
const values = self => collect(self, (_, a) => a);
/**
 * Add a new key-value pair or update an existing key's value in a record.
 *
 * @param self - The record to which you want to add or update a key-value pair.
 * @param key - The key you want to add or update.
 * @param values - The value you want to associate with the key.
 *
 * @example
 * import { set } from "effect/Record"
 *
 * assert.deepStrictEqual(set("a", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });
 * assert.deepStrictEqual(set("c", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });
 *
 * @since 2.0.0
 */
const set = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, key, value) => {
  return {
    ...self,
    [key]: value
  };
})));
/**
 * Replace a key's value in a record and return the updated record.
 * If the key does not exist in the record, a copy of the original record is returned.
 *
 * @param self - The original record.
 * @param key - The key to replace.
 * @param value - The new value to associate with the key.
 *
 * @example
 * import { Record } from "effect"
 *
 * assert.deepStrictEqual(Record.replace("a", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });
 * assert.deepStrictEqual(Record.replace("c", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });
 *
 * @since 2.0.0
 */
const replace = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, key, value) => {
  if (has(self, key)) {
    return {
      ...self,
      [key]: value
    };
  }
  return {
    ...self
  };
})));
/**
 * Check if all the keys and values in one record are also found in another record.
 *
 * @param self - The first record to check.
 * @param that - The second record to compare against.
 * @param equivalence - A function to compare values.
 *
 * @since 2.0.0
 */
const isSubrecordBy = equivalence => dual(2, (self, that) => {
  for (const key of keys(self)) {
    if (!has(that, key) || !equivalence(self[key], that[key])) {
      return false;
    }
  }
  return true;
});
/**
 * Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.
 * This comparison uses default equality checks (`Equal.equivalence()`).
 *
 * @param self - The first record to check.
 * @param that - The second record to compare against.
 *
 * @since 2.0.0
 */
const isSubrecord = /*#__PURE__*/(/* unused pure expression or super */ null && (isSubrecordBy( /*#__PURE__*/Equal.equivalence())));
/**
 * Reduce a record to a single value by combining its entries with a specified function.
 *
 * @param self - The record to reduce.
 * @param zero - The initial value of the accumulator.
 * @param f - The function to combine entries (accumulator, value, key).
 *
 * @category folding
 * @since 2.0.0
 */
const Record_reduce = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, zero, f) => {
  let out = zero;
  for (const key of keys(self)) {
    out = f(out, self[key], key);
  }
  return out;
})));
/**
 * Check if all entries in a record meet a specific condition.
 *
 * @param self - The record to check.
 * @param predicate - The condition to test entries (value, key).
 *
 * @since 2.0.0
 */
const Record_every = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, refinement) => {
  for (const key of keys(self)) {
    if (!refinement(self[key], key)) {
      return false;
    }
  }
  return true;
})));
/**
 * Check if any entry in a record meets a specific condition.
 *
 * @param self - The record to check.
 * @param predicate - The condition to test entries (value, key).
 *
 * @since 2.0.0
 */
const Record_some = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      return true;
    }
  }
  return false;
})));
/**
 * Merge two records, preserving entries that exist in either of the records.
 *
 * @param self - The first record.
 * @param that - The second record to combine with the first.
 * @param combine - A function to specify how to merge entries with the same key.
 *
 * @since 2.0.0
 */
const union = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, that, combine) => {
  if (isEmptyRecord(self)) {
    return {
      ...that
    };
  }
  if (isEmptyRecord(that)) {
    return {
      ...self
    };
  }
  const out = Record_empty();
  for (const key of keys(self)) {
    if (has(that, key)) {
      out[key] = combine(self[key], that[key]);
    } else {
      out[key] = self[key];
    }
  }
  for (const key of keys(that)) {
    if (!has(out, key)) {
      out[key] = that[key];
    }
  }
  return out;
})));
/**
 * Merge two records, retaining only the entries that exist in both records.
 *
 * @param self - The first record.
 * @param that - The second record to merge with the first.
 * @param combine - A function to specify how to merge entries with the same key.
 *
 * @since 2.0.0
 */
const intersection = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, that, combine) => {
  const out = Record_empty();
  if (isEmptyRecord(self) || isEmptyRecord(that)) {
    return out;
  }
  for (const key of keys(self)) {
    if (has(that, key)) {
      out[key] = combine(self[key], that[key]);
    }
  }
  return out;
})));
/**
 * Merge two records, preserving only the entries that are unique to each record.
 *
 * @param self - The first record.
 * @param that - The second record to compare with the first.
 *
 * @since 2.0.0
 */
const difference = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => {
  if (isEmptyRecord(self)) {
    return {
      ...that
    };
  }
  if (isEmptyRecord(that)) {
    return {
      ...self
    };
  }
  const out = {};
  for (const key of keys(self)) {
    if (!has(that, key)) {
      out[key] = self[key];
    }
  }
  for (const key of keys(that)) {
    if (!has(self, key)) {
      out[key] = that[key];
    }
  }
  return out;
})));
/**
 * Create an `Equivalence` for records using the provided `Equivalence` for values.
 *
 * @param equivalence - An `Equivalence` for the values contained in the records.
 *
 * @category instances
 * @since 2.0.0
 */
const Record_getEquivalence = equivalence => {
  const is = isSubrecordBy(equivalence);
  return (self, that) => is(self, that) && is(that, self);
};
/**
 * Create a non-empty record from a single element.
 *
 * @param key - The key for the element.
 * @param value - The value associated with the key.
 *
 * @category constructors
 * @since 2.0.0
 */
const singleton = (key, value) => ({
  [key]: value
});
//# sourceMappingURL=Record.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Tuple.js
/**
 * This module provides utility functions for working with tuples in TypeScript.
 *
 * @since 2.0.0
 */



/**
 * Constructs a new tuple from the provided values.
 *
 * @param elements - The list of elements to create the tuple from.
 *
 * @example
 * import { make } from "effect/Tuple"
 *
 * assert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])
 *
 * @category constructors
 * @since 2.0.0
 */
const Tuple_make = (...elements) => elements;
/**
 * Return the first element of a tuple.
 *
 * @param self - A tuple of length `2`.
 *
 * @example
 * import { getFirst } from "effect/Tuple"
 *
 * assert.deepStrictEqual(getFirst(["hello", 42]), "hello")
 *
 * @category getters
 * @since 2.0.0
 */
const getFirst = self => self[0];
/**
 * Return the second element of a tuple.
 *
 * @param self - A tuple of length `2`.
 *
 * @example
 * import { getSecond } from "effect/Tuple"
 *
 * assert.deepStrictEqual(getSecond(["hello", 42]), 42)
 *
 * @category getters
 * @since 2.0.0
 */
const getSecond = self => self[1];
/**
 * Transforms both elements of a tuple using the given functions.
 *
 * @param self - A tuple of length `2`.
 * @param f - The function to transform the first element of the tuple.
 * @param g - The function to transform the second element of the tuple.
 *
 * @example
 * import { mapBoth } from "effect/Tuple"
 *
 * assert.deepStrictEqual(
 *   mapBoth(["hello", 42], { onFirst: s => s.toUpperCase(), onSecond: n => n.toString() }),
 *   ["HELLO", "42"]
 * )
 *
 * @category mapping
 * @since 2.0.0
 */
const mapBoth = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, {
  onFirst,
  onSecond
}) => [onFirst(self[0]), onSecond(self[1])])));
/**
 * Transforms the first component of a tuple using a given function.
 *
 * @param self - A tuple of length `2`.
 * @param f - The function to transform the first element of the tuple.
 *
 * @example
 * import { mapFirst } from "effect/Tuple"
 *
 * assert.deepStrictEqual(
 *   mapFirst(["hello", 42], s => s.toUpperCase()),
 *   ["HELLO", 42]
 * )
 *
 * @category mapping
 * @since 2.0.0
 */
const mapFirst = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => [f(self[0]), self[1]])));
/**
 * Transforms the second component of a tuple using a given function.
 *
 * @param self - A tuple of length `2`.
 * @param f - The function to transform the second element of the tuple.
 *
 * @example
 * import { mapSecond } from "effect/Tuple"
 *
 * assert.deepStrictEqual(
 *   mapSecond(["hello", 42], n => n.toString()),
 *   ["hello", "42"]
 * )
 *
 * @category mapping
 * @since 2.0.0
 */
const mapSecond = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => [self[0], f(self[1])])));
/**
 * Swaps the two elements of a tuple.
 *
 * @param self - A tuple of length `2`.
 *
 * @example
 * import { swap } from "effect/Tuple"
 *
 * assert.deepStrictEqual(swap(["hello", 42]), [42, "hello"])
 *
 * @since 2.0.0
 */
const swap = self => [self[1], self[0]];
/**
 * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple
 * by applying each `Equivalence` to the corresponding element of the tuple.
 *
 * @category combinators
 * @since 2.0.0
 */
const Tuple_getEquivalence = Equivalence_tuple;
/**
 * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.
 * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.
 * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element
 * of the tuple.
 *
 * @category combinators
 * @since 2.0.0
 */
const Tuple_getOrder = Order_tuple;
/**
 * Appends an element to the end of a tuple.
 *
 * @category concatenating
 * @since 2.0.0
 */
const appendElement = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => [...self, that])));
/*

  TODO:

  - at
  - swap

*/
//# sourceMappingURL=Tuple.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Array.js
/**
 * This module provides utility functions for working with arrays in TypeScript.
 *
 * @since 2.0.0
 */











/**
 * Builds a `NonEmptyArray` from an non-empty collection of elements.
 *
 * @category constructors
 * @since 2.0.0
 */
const Array_make = (...elements) => elements;
/**
 * Creates a new `Array` of the specified length.
 *
 * @category constructors
 * @since 2.0.0
 */
const allocate = n => new Array(n);
/**
 * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.
 *
 * **Note**. `n` is normalized to an integer >= 1.
 *
 * @example
 * import { makeBy } from "effect/Array"
 *
 * assert.deepStrictEqual(makeBy(5, n => n * 2), [0, 2, 4, 6, 8])
 *
 * @category constructors
 * @since 2.0.0
 */
const Array_makeBy = (n, f) => {
  const max = Math.max(1, Math.floor(n));
  const out = new Array(max);
  for (let i = 0; i < max; i++) {
    out[i] = f(i);
  }
  return out;
};
/**
 * Return a `NonEmptyArray` containing a range of integers, including both endpoints.
 *
 * @example
 * import { range } from "effect/Array"
 *
 * assert.deepStrictEqual(range(1, 3), [1, 2, 3])
 *
 * @category constructors
 * @since 2.0.0
 */
const Array_range = (start, end) => start <= end ? Array_makeBy(end - start + 1, i => start + i) : [start];
/**
 * Return a `NonEmptyArray` containing a value repeated the specified number of times.
 *
 * **Note**. `n` is normalized to an integer >= 1.
 *
 * @example
 * import { replicate } from "effect/Array"
 *
 * assert.deepStrictEqual(replicate("a", 3), ["a", "a", "a"])
 *
 * @category constructors
 * @since 2.0.0
 */
const Array_replicate = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (a, n) => Array_makeBy(n, () => a))));
/**
 * Creates a new `Array` from an iterable collection of values.
 *
 * @category constructors
 * @since 2.0.0
 */
const Array_fromIterable = collection => Array.isArray(collection) ? collection : Array.from(collection);
/**
 * Takes a record and returns an array of tuples containing its keys and values.
 *
 * @param self - The record to transform.
 *
 * @example
 * import { fromRecord } from "effect/Array"
 *
 * const x = { a: 1, b: 2, c: 3 }
 * assert.deepStrictEqual(fromRecord(x), [["a", 1], ["b", 2], ["c", 3]])
 *
 * @category conversions
 * @since 2.0.0
 */
const Array_fromRecord = toEntries;
/**
 * @category conversions
 * @since 2.0.0
 */
const Array_fromOption = toArray;
/**
 * @category pattern matching
 * @since 2.0.0
 */
const Array_match = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty())));
/**
 * @category pattern matching
 * @since 2.0.0
 */
const matchLeft = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty())));
/**
 * @category pattern matching
 * @since 2.0.0
 */
const matchRight = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty())));
/**
 * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.
 *
 * @category concatenating
 * @since 2.0.0
 */
const Array_prepend = /*#__PURE__*/Function_dual(2, (self, head) => [head, ...self]);
/**
 * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).
 * If either array is non-empty, the result is also a non-empty array.
 *
 * @example
 * import { Array } from "effect"
 *
 * assert.deepStrictEqual(
 *   Array.prependAll([1, 2], ["a", "b"]),
 *   ["a", "b", 1, 2]
 * )
 *
 * @category concatenating
 * @since 2.0.0
 */
const Array_prependAll = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Array_fromIterable(that).concat(Array_fromIterable(self)))));
/**
 * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.
 *
 * @category concatenating
 * @since 2.0.0
 */
const Array_append = /*#__PURE__*/Function_dual(2, (self, last) => [...self, last]);
/**
 * Concatenates two arrays (or iterables), combining their elements.
 * If either array is non-empty, the result is also a non-empty array.
 *
 * @category concatenating
 * @since 2.0.0
 */
const Array_appendAll = /*#__PURE__*/Function_dual(2, (self, that) => Array_fromIterable(self).concat(Array_fromIterable(that)));
/**
 * Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.
 *
 * @category folding
 * @since 2.0.0
 */
const Array_scan = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, b, f) => {
  const out = [b];
  let i = 0;
  for (const a of self) {
    out[i + 1] = f(out[i], a);
    i++;
  }
  return out;
})));
/**
 * Reduce an `Iterable` from the right, keeping all intermediate results instead of only the final result.
 *
 * @category folding
 * @since 2.0.0
 */
const scanRight = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, b, f) => {
  const input = Array_fromIterable(self);
  const out = new Array(input.length + 1);
  out[input.length] = b;
  for (let i = input.length - 1; i >= 0; i--) {
    out[i] = f(out[i + 1], input[i]);
  }
  return out;
})));
/**
 * Determine if `unknown` is an Array.
 *
 * @param self - The value to check.
 *
 * @example
 * import { isArray } from "effect/Array"
 *
 * assert.deepStrictEqual(isArray(null), false);
 * assert.deepStrictEqual(isArray([1, 2, 3]), true);
 *
 * @category guards
 * @since 2.0.0
 */
const isArray = Array.isArray;
/**
 * Determine if an `Array` is empty narrowing down the type to `[]`.
 *
 * @param self - The `Array` to check.
 *
 * @example
 * import { isEmptyArray } from "effect/Array"
 *
 * assert.deepStrictEqual(isEmptyArray([]), true);
 * assert.deepStrictEqual(isEmptyArray([1, 2, 3]), false);
 *
 * @category guards
 * @since 2.0.0
 */
const isEmptyArray = self => self.length === 0;
/**
 * Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.
 *
 * @param self - The `ReadonlyArray` to check.
 *
 * @example
 * import { isEmptyReadonlyArray } from "effect/Array"
 *
 * assert.deepStrictEqual(isEmptyReadonlyArray([]), true);
 * assert.deepStrictEqual(isEmptyReadonlyArray([1, 2, 3]), false);
 *
 * @category guards
 * @since 2.0.0
 */
const isEmptyReadonlyArray = isEmptyArray;
/**
 * Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.
 *
 * An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.
 *
 * @param self - The `Array` to check.
 *
 * @example
 * import { isNonEmptyArray } from "effect/Array"
 *
 * assert.deepStrictEqual(isNonEmptyArray([]), false);
 * assert.deepStrictEqual(isNonEmptyArray([1, 2, 3]), true);
 *
 * @category guards
 * @since 2.0.0
 */
const Array_isNonEmptyArray = isNonEmptyArray;
/**
 * Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.
 *
 * A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.
 *
 * @param self - The `ReadonlyArray` to check.
 *
 * @example
 * import { isNonEmptyReadonlyArray } from "effect/Array"
 *
 * assert.deepStrictEqual(isNonEmptyReadonlyArray([]), false);
 * assert.deepStrictEqual(isNonEmptyReadonlyArray([1, 2, 3]), true);
 *
 * @category guards
 * @since 2.0.0
 */
const isNonEmptyReadonlyArray = isNonEmptyArray;
/**
 * Return the number of elements in a `ReadonlyArray`.
 *
 * @category getters
 * @since 2.0.0
 */
const Array_length = self => self.length;
const isOutOfBound = (i, as) => i < 0 || i >= as.length;
const Array_clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));
/**
 * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.
 *
 * @category getters
 * @since 2.0.0
 */
const Array_get = /*#__PURE__*/Function_dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBound(i, self) ? Option_none() : Option_some(self[i]);
});
/**
 * Gets an element unsafely, will throw on out of bounds.
 *
 * @since 2.0.0
 * @category unsafe
 */
const Array_unsafeGet = /*#__PURE__*/Function_dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBound(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
/**
 * Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.
 *
 * @category splitting
 * @since 2.0.0
 */
const unprepend = self => [headNonEmpty(self), tailNonEmpty(self)];
/**
 * Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.
 *
 * @category splitting
 * @since 2.0.0
 */
const unappend = self => [initNonEmpty(self), lastNonEmpty(self)];
/**
 * Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.
 *
 * @category getters
 * @since 2.0.0
 */
const Array_head = /*#__PURE__*/Array_get(0);
/**
 * @category getters
 * @since 2.0.0
 */
const headNonEmpty = /*#__PURE__*/Array_unsafeGet(0);
/**
 * Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.
 *
 * @category getters
 * @since 2.0.0
 */
const last = self => isNonEmptyReadonlyArray(self) ? Option_some(lastNonEmpty(self)) : Option_none();
/**
 * @category getters
 * @since 2.0.0
 */
const lastNonEmpty = self => self[self.length - 1];
/**
 * Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.
 *
 * @category getters
 * @since 2.0.0
 */
const tail = self => {
  const input = Array_fromIterable(self);
  return isNonEmptyReadonlyArray(input) ? O.some(tailNonEmpty(input)) : O.none();
};
/**
 * @category getters
 * @since 2.0.0
 */
const tailNonEmpty = self => self.slice(1);
/**
 * Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.
 *
 * @category getters
 * @since 2.0.0
 */
const init = self => {
  const input = Array_fromIterable(self);
  return isNonEmptyReadonlyArray(input) ? O.some(initNonEmpty(input)) : O.none();
};
/**
 * Get all but the last element of a non empty array, creating a new array.
 *
 * @category getters
 * @since 2.0.0
 */
const initNonEmpty = self => self.slice(0, -1);
/**
 * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @category getters
 * @since 2.0.0
 */
const Array_take = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => {
  const input = Array_fromIterable(self);
  return input.slice(0, Array_clamp(n, input));
})));
/**
 * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @category getters
 * @since 2.0.0
 */
const takeRight = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => {
  const input = Array_fromIterable(self);
  const i = Array_clamp(n, input);
  return i === 0 ? [] : input.slice(-i);
})));
/**
 * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.
 *
 * @category getters
 * @since 2.0.0
 */
const Array_takeWhile = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    out.push(a);
    i++;
  }
  return out;
})));
const spanIndex = (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
/**
 * Split an `Iterable` into two parts:
 *
 * 1. the longest initial subarray for which all elements satisfy the specified predicate
 * 2. the remaining elements
 *
 * @category splitting
 * @since 2.0.0
 */
const span = /*#__PURE__*/Function_dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
/**
 * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @category getters
 * @since 2.0.0
 */
const Array_drop = /*#__PURE__*/Function_dual(2, (self, n) => {
  const input = Array_fromIterable(self);
  return input.slice(Array_clamp(n, input), input.length);
});
/**
 * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @category getters
 * @since 2.0.0
 */
const dropRight = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => {
  const input = Array_fromIterable(self);
  return input.slice(0, input.length - Array_clamp(n, input));
})));
/**
 * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.
 *
 * @category getters
 * @since 2.0.0
 */
const dropWhile = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => Array_fromIterable(self).slice(spanIndex(self, predicate)))));
/**
 * Return the first index for which a predicate holds.
 *
 * @category elements
 * @since 2.0.0
 */
const findFirstIndex = /*#__PURE__*/Function_dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i)) {
      return Option_some(i);
    }
    i++;
  }
  return Option_none();
});
/**
 * Return the last index for which a predicate holds.
 *
 * @category elements
 * @since 2.0.0
 */
const findLastIndex = /*#__PURE__*/Function_dual(2, (self, predicate) => {
  const input = Array_fromIterable(self);
  for (let i = input.length - 1; i >= 0; i--) {
    if (predicate(input[i], i)) {
      return Option_some(i);
    }
  }
  return Option_none();
});
/**
 * Returns the first element that satisfies the specified
 * predicate, or `None` if no such element exists.
 *
 * @category elements
 * @since 2.0.0
 */
const Array_findFirst = findFirst;
/**
 * Find the last element for which a predicate holds.
 *
 * @category elements
 * @since 2.0.0
 */
const Array_findLast = /*#__PURE__*/Function_dual(2, (self, f) => {
  const input = Array_fromIterable(self);
  for (let i = input.length - 1; i >= 0; i--) {
    const a = input[i];
    const o = f(a, i);
    if (Predicate_isBoolean(o)) {
      if (o) {
        return Option_some(a);
      }
    } else {
      if (Option_isSome(o)) {
        return o;
      }
    }
  }
  return Option_none();
});
/**
 * Insert an element at the specified index, creating a new `NonEmptyArray`,
 * or return `None` if the index is out of bounds.
 *
 * @since 2.0.0
 */
const insertAt = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, i, b) => {
  const out = Array.from(self);
  //             v--- `= self.length` is ok, it means inserting in last position
  if (i < 0 || i > out.length) {
    return O.none();
  }
  out.splice(i, 0, b);
  return O.some(out);
})));
/**
 * Change the element at the specified index, creating a new `Array`,
 * or return a copy of the input if the index is out of bounds.
 *
 * @since 2.0.0
 */
const Array_replace = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, i, b) => Array_modify(self, i, () => b))));
/**
 * @since 2.0.0
 */
const Array_replaceOption = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, i, b) => Array_modifyOption(self, i, () => b))));
/**
 * Apply a function to the element at the specified index, creating a new `Array`,
 * or return a copy of the input if the index is out of bounds.
 *
 * @since 2.0.0
 */
const Array_modify = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, i, f) => O.getOrElse(Array_modifyOption(self, i, f), () => Array.from(self)))));
/**
 * Apply a function to the element at the specified index, creating a new `Array`,
 * or return `None` if the index is out of bounds.
 *
 * @since 2.0.0
 */
const Array_modifyOption = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, i, f) => {
  const out = Array.from(self);
  if (isOutOfBound(i, out)) {
    return O.none();
  }
  const next = f(out[i]);
  // @ts-expect-error
  out[i] = next;
  return O.some(out);
})));
/**
 * Delete the element at the specified index, creating a new `Array`,
 * or return a copy of the input if the index is out of bounds.
 *
 * @since 2.0.0
 */
const Array_remove = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, i) => {
  const out = Array.from(self);
  if (isOutOfBound(i, out)) {
    return out;
  }
  out.splice(i, 1);
  return out;
})));
/**
 * Reverse an `Iterable`, creating a new `Array`.
 *
 * @category elements
 * @since 2.0.0
 */
const Array_reverse = self => Array.from(self).reverse();
/**
 * Create a new array with elements sorted in increasing order based on the specified comparator.
 * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.
 *
 * @category sorting
 * @since 2.0.0
 */
const sort = /*#__PURE__*/Function_dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
/**
 * @since 2.0.0
 * @category elements
 */
const sortWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, f, order) => sort(self, Order.mapInput(order, f)))));
/**
 * Sort the elements of an `Iterable` in increasing order, where elements are compared
 * using first `orders[0]`, then `orders[1]`, etc...
 *
 * @category sorting
 * @since 2.0.0
 */
const sortBy = (...orders) => {
  const sortByAll = sort(Order.combineAll(orders));
  return self => {
    const input = Array_fromIterable(self);
    if (isNonEmptyReadonlyArray(input)) {
      return sortByAll(input);
    }
    return [];
  };
};
/**
 * Takes two `Iterable`s and returns an `Array` of corresponding pairs.
 * If one input `Iterable` is short, excess elements of the
 * longer `Iterable` are discarded.
 *
 * @category zipping
 * @since 2.0.0
 */
const Array_zip = /*#__PURE__*/Function_dual(2, (self, that) => Array_zipWith(self, that, Tuple_make));
/**
 * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one
 * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.
 *
 * @category zipping
 * @since 2.0.0
 */
const Array_zipWith = /*#__PURE__*/Function_dual(3, (self, that, f) => {
  const as = Array_fromIterable(self);
  const bs = Array_fromIterable(that);
  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as), headNonEmpty(bs))];
    const len = Math.min(as.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f(as[i], bs[i]);
    }
    return out;
  }
  return [];
});
/**
 * This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.
 *
 * @since 2.0.0
 */
const unzip = self => {
  const input = Array_fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const fa = [input[0][0]];
    const fb = [input[0][1]];
    for (let i = 1; i < input.length; i++) {
      fa[i] = input[i][0];
      fb[i] = input[i][1];
    }
    return [fa, fb];
  }
  return [[], []];
};
/**
 * Places an element in between members of an `Iterable`.
 * If the input is a non-empty array, the result is also a non-empty array.
 *
 * @since 2.0.0
 */
const Array_intersperse = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, middle) => {
  const input = Array_fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const tail = tailNonEmpty(input);
    for (let i = 0; i < tail.length; i++) {
      if (i < tail.length) {
        out.push(middle);
      }
      out.push(tail[i]);
    }
    return out;
  }
  return [];
})));
/**
 * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.
 *
 * @since 2.0.0
 */
const modifyNonEmptyHead = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => [f(headNonEmpty(self)), ...tailNonEmpty(self)])));
/**
 * Change the head, creating a new `NonEmptyReadonlyArray`.
 *
 * @since 2.0.0
 */
const setNonEmptyHead = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, b) => modifyNonEmptyHead(self, () => b))));
/**
 * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.
 *
 * @since 2.0.0
 */
const modifyNonEmptyLast = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => Array_append(initNonEmpty(self), f(lastNonEmpty(self))))));
/**
 * Change the last element, creating a new `NonEmptyReadonlyArray`.
 *
 * @since 2.0.0
 */
const setNonEmptyLast = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, b) => modifyNonEmptyLast(self, () => b))));
/**
 * Rotate an `Iterable` by `n` steps.
 * If the input is a non-empty array, the result is also a non-empty array.
 *
 * @since 2.0.0
 */
const rotate = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => {
  const input = Array_fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const len = input.length;
    const m = Math.round(n) % len;
    if (isOutOfBound(Math.abs(m), input) || m === 0) {
      return copy(input);
    }
    if (m < 0) {
      const [f, s] = splitNonEmptyAt(input, -m);
      return Array_appendAll(s, f);
    } else {
      return rotate(self, m - len);
    }
  }
  return [];
})));
/**
 * Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.
 *
 * @category elements
 * @since 2.0.0
 */
const Array_containsWith = isEquivalent => Function_dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
const Array_equivalence = /*#__PURE__*/equivalence();
/**
 * Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.
 *
 * @category elements
 * @since 2.0.0
 */
const Array_contains = /*#__PURE__*/Array_containsWith(Array_equivalence);
/**
 * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for "chopping" up the input
 * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a
 * value and the rest of the `Array`.
 *
 * @since 2.0.0
 */
const chop = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const input = Array_fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const [b, rest] = f(input);
    const out = [b];
    let next = rest;
    while (readonlyArray.isNonEmptyArray(next)) {
      const [b, rest] = f(next);
      out.push(b);
      next = rest;
    }
    return out;
  }
  return [];
})));
/**
 * Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.
 * The value of `n` can be `0`.
 *
 * @category splitting
 * @since 2.0.0
 */
const splitAt = /*#__PURE__*/Function_dual(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
/**
 * Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.
 * The value of `n` must be `>= 1`.
 *
 * @category splitting
 * @since 2.0.0
 */
const splitNonEmptyAt = /*#__PURE__*/Function_dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy(self), []] : [Array_prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
});
/**
 * Splits this iterable into `n` equally sized arrays.
 *
 * @since 2.0.0
 * @category splitting
 */
const split = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => {
  const input = Array_fromIterable(self);
  return Array_chunksOf(input, Math.ceil(input.length / Math.floor(n)));
})));
/**
 * Splits this iterable on the first element that matches this predicate.
 * Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.
 *
 * @category splitting
 * @since 2.0.0
 */
const splitWhere = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => span(self, (a, i) => !predicate(a, i)))));
/**
 * @since 2.0.0
 */
const copy = self => self.slice();
/**
 * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
 * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive
 * definition of `chunksOf`; it satisfies the property that
 *
 * ```ts
 * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))
 * ```
 *
 * whenever `n` evenly divides the length of `self`.
 *
 * @category splitting
 * @since 2.0.0
 */
const Array_chunksOf = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => {
  const input = Array_fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    return chop(input, splitNonEmptyAt(n));
  }
  return [];
})));
/**
 * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.
 *
 * @category grouping
 * @since 2.0.0
 */
const Array_groupWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, isEquivalent) => chop(self, as => {
  const h = headNonEmpty(as);
  const out = [h];
  let i = 1;
  for (; i < as.length; i++) {
    const a = as[i];
    if (isEquivalent(a, h)) {
      out.push(a);
    } else {
      break;
    }
  }
  return [out, as.slice(i)];
}))));
/**
 * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.
 *
 * @category grouping
 * @since 2.0.0
 */
const Array_group = /*#__PURE__*/(/* unused pure expression or super */ null && (Array_groupWith( /*#__PURE__*/Equal.equivalence())));
/**
 * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
 * function on each element, and grouping the results according to values returned
 *
 * @category grouping
 * @since 2.0.0
 */
const Array_groupBy = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const out = {};
  for (const a of self) {
    const k = f(a);
    if (Object.prototype.hasOwnProperty.call(out, k)) {
      out[k].push(a);
    } else {
      out[k] = [a];
    }
  }
  return out;
})));
/**
 * @since 2.0.0
 */
const unionWith = /*#__PURE__*/Function_dual(3, (self, that, isEquivalent) => {
  const a = Array_fromIterable(self);
  const b = Array_fromIterable(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe = dedupeWith(isEquivalent);
      return dedupe(Array_appendAll(a, b));
    }
    return a;
  }
  return b;
});
/**
 * @since 2.0.0
 */
const Array_union = /*#__PURE__*/Function_dual(2, (self, that) => unionWith(self, that, Array_equivalence));
/**
 * Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.
 * The order and references of result values are determined by the first `Iterable`.
 *
 * @since 2.0.0
 */
const intersectionWith = isEquivalent => {
  const has = Array_containsWith(isEquivalent);
  return dual(2, (self, that) => Array_fromIterable(self).filter(a => has(that, a)));
};
/**
 * Creates an `Array` of unique values that are included in all given `Iterable`s.
 * The order and references of result values are determined by the first `Iterable`.
 *
 * @since 2.0.0
 */
const Array_intersection = /*#__PURE__*/(/* unused pure expression or super */ null && (intersectionWith(Array_equivalence)));
/**
 * Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.
 * The order and references of result values are determined by the first `Iterable`.
 *
 * @since 2.0.0
 */
const differenceWith = isEquivalent => {
  const has = Array_containsWith(isEquivalent);
  return dual(2, (self, that) => Array_fromIterable(self).filter(a => !has(that, a)));
};
/**
 * Creates a `Array` of values not included in the other given `Iterable`.
 * The order and references of result values are determined by the first `Iterable`.
 *
 * @since 2.0.0
 */
const Array_difference = /*#__PURE__*/(/* unused pure expression or super */ null && (differenceWith(Array_equivalence)));
/**
 * @category constructors
 * @since 2.0.0
 */
const Array_empty = () => [];
/**
 * Constructs a new `NonEmptyArray<A>` from the specified value.
 *
 * @category constructors
 * @since 2.0.0
 */
const Array_of = a => [a];
/**
 * @category mapping
 * @since 2.0.0
 */
const Array_map = /*#__PURE__*/Function_dual(2, (self, f) => self.map(f));
/**
 * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.
 *
 * @category sequencing
 * @since 2.0.0
 */
const Array_flatMap = /*#__PURE__*/Function_dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
/**
 * Flattens an array of arrays into a single array by concatenating all arrays.
 *
 * @category sequencing
 * @since 2.0.0
 */
const Array_flatten = /*#__PURE__*/Array_flatMap(Function_identity);
/**
 * @category filtering
 * @since 2.0.0
 */
const Array_filterMap = /*#__PURE__*/Function_dual(2, (self, f) => {
  const as = Array_fromIterable(self);
  const out = [];
  for (let i = 0; i < as.length; i++) {
    const o = f(as[i], i);
    if (Option_isSome(o)) {
      out.push(o.value);
    }
  }
  return out;
});
/**
 * Transforms all elements of the `readonlyArray` for as long as the specified function returns some value
 *
 * @category filtering
 * @since 2.0.0
 */
const Array_filterMapWhile = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    const b = f(a, i);
    if (O.isSome(b)) {
      out.push(b.value);
    } else {
      break;
    }
    i++;
  }
  return out;
})));
/**
 * @category filtering
 * @since 2.0.0
 */
const Array_partitionMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const left = [];
  const right = [];
  const as = Array_fromIterable(self);
  for (let i = 0; i < as.length; i++) {
    const e = f(as[i], i);
    if (E.isLeft(e)) {
      left.push(e.left);
    } else {
      right.push(e.right);
    }
  }
  return [left, right];
})));
/**
 * Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.
 *
 * @example
 * import { Array, Option } from "effect"
 *
 * assert.deepStrictEqual(
 *   Array.getSomes([Option.some(1), Option.none(), Option.some(2)]),
 *   [1, 2]
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
const Array_getSomes = /*#__PURE__*/Array_filterMap(Function_identity);
/**
 * Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.
 *
 * @example
 * import { Array, Either } from "effect"
 *
 * assert.deepStrictEqual(
 *   Array.getLefts([Either.right(1), Either.left("err"), Either.right(2)]),
 *   ["err"]
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
const Array_getLefts = self => {
  const out = [];
  for (const a of self) {
    if (E.isLeft(a)) {
      out.push(a.left);
    }
  }
  return out;
};
/**
 * Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.
 *
 * @example
 * import { Array, Either } from "effect"
 *
 * assert.deepStrictEqual(
 *   Array.getRights([Either.right(1), Either.left("err"), Either.right(2)]),
 *   [1, 2]
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
const Array_getRights = self => {
  const out = [];
  for (const a of self) {
    if (E.isRight(a)) {
      out.push(a.right);
    }
  }
  return out;
};
/**
 * @category filtering
 * @since 2.0.0
 */
const Array_filter = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  const as = Array_fromIterable(self);
  const out = [];
  for (let i = 0; i < as.length; i++) {
    if (predicate(as[i], i)) {
      out.push(as[i]);
    }
  }
  return out;
})));
/**
 * Separate elements based on a predicate that also exposes the index of the element.
 *
 * @category filtering
 * @since 2.0.0
 */
const Array_partition = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  const left = [];
  const right = [];
  const as = Array_fromIterable(self);
  for (let i = 0; i < as.length; i++) {
    if (predicate(as[i], i)) {
      right.push(as[i]);
    } else {
      left.push(as[i]);
    }
  }
  return [left, right];
})));
/**
 * @category filtering
 * @since 2.0.0
 */
const Array_separate = /*#__PURE__*/(/* unused pure expression or super */ null && (Array_partitionMap(identity)));
/**
 * @category folding
 * @since 2.0.0
 */
const Array_reduce = /*#__PURE__*/Function_dual(3, (self, b, f) => Array_fromIterable(self).reduce((b, a, i) => f(b, a, i), b));
/**
 * @category folding
 * @since 2.0.0
 */
const reduceRight = /*#__PURE__*/Function_dual(3, (self, b, f) => Array_fromIterable(self).reduceRight((b, a, i) => f(b, a, i), b));
/**
 * @category lifting
 * @since 2.0.0
 */
const Array_liftPredicate = predicate => b => predicate(b) ? [b] : [];
/**
 * @category lifting
 * @since 2.0.0
 */
const liftOption = f => (...a) => Array_fromOption(f(...a));
/**
 * @category conversions
 * @since 2.0.0
 */
const Array_fromNullable = a => a == null ? Array_empty() : [a];
/**
 * @category lifting
 * @since 2.0.0
 */
const Array_liftNullable = f => (...a) => Array_fromNullable(f(...a));
/**
 * @category sequencing
 * @since 2.0.0
 */
const Array_flatMapNullable = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => isNonEmptyReadonlyArray(self) ? Array_fromNullable(f(headNonEmpty(self))) : Array_empty())));
/**
 * @category lifting
 * @since 2.0.0
 */
const liftEither = f => (...a) => {
  const e = f(...a);
  return E.isLeft(e) ? [] : [e.right];
};
/**
 * Check if a predicate holds true for every `ReadonlyArray` element.
 *
 * @category elements
 * @since 2.0.0
 */
const Array_every = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, refinement) => self.every(refinement))));
/**
 * Check if a predicate holds true for some `ReadonlyArray` element.
 *
 * @category elements
 * @since 2.0.0
 */
const Array_some = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => self.some(predicate))));
/**
 * @since 2.0.0
 */
const extend = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => self.map((_, i, as) => f(as.slice(i))))));
/**
 * @since 2.0.0
 */
const Array_min = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, O) => self.reduce(Order.min(O)))));
/**
 * @since 2.0.0
 */
const Array_max = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, O) => self.reduce(Order.max(O)))));
/**
 * @category constructors
 * @since 2.0.0
 */
const Array_unfold = (b, f) => {
  const out = [];
  let next = b;
  let o;
  while (Option_isSome(o = f(next))) {
    const [a, b] = o.value;
    out.push(a);
    next = b;
  }
  return out;
};
/**
 * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.
 * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.
 * If all elements are equal, the arrays are then compared based on their length.
 * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.
 *
 * @category instances
 * @since 2.0.0
 */
const Array_getOrder = Order_array;
/**
 * @category instances
 * @since 2.0.0
 */
const Array_getEquivalence = Equivalence_array;
/**
 * Iterate over the `Iterable` applying `f`.
 *
 * @since 2.0.0
 */
const Array_forEach = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => Array_fromIterable(self).forEach((a, i) => f(a, i)))));
/**
 * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,
 * preserving the order of the first occurrence of each element.
 *
 * @since 2.0.0
 */
const dedupeWith = /*#__PURE__*/Function_dual(2, (self, isEquivalent) => {
  const input = Array_fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every(a => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
/**
 * Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.
 * The equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.
 *
 * @since 2.0.0
 */
const dedupe = self => dedupeWith(self, equivalence());
/**
 * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.
 *
 * @since 2.0.0
 */
const Array_dedupeAdjacentWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, isEquivalent) => {
  const out = [];
  let lastA = O.none();
  for (const a of self) {
    if (O.isNone(lastA) || !isEquivalent(a, lastA.value)) {
      out.push(a);
      lastA = O.some(a);
    }
  }
  return out;
})));
/**
 * Deduplicates adjacent elements that are identical.
 *
 * @since 2.0.0
 */
const Array_dedupeAdjacent = /*#__PURE__*/(/* unused pure expression or super */ null && (Array_dedupeAdjacentWith( /*#__PURE__*/Equal.equivalence())));
/**
 * Joins the elements together with "sep" in the middle.
 *
 * @since 2.0.0
 * @category folding
 */
const Array_join = /*#__PURE__*/Function_dual(2, (self, sep) => Array_fromIterable(self).join(sep));
/**
 * Statefully maps over the chunk, producing new elements of type `B`.
 *
 * @since 2.0.0
 * @category folding
 */
const mapAccum = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, s, f) => {
  let i = 0;
  let s1 = s;
  const out = [];
  for (const a of self) {
    const r = f(s1, a, i);
    s1 = r[0];
    out.push(r[1]);
    i++;
  }
  return [s1, out];
})));
/**
 * Zips this chunk crosswise with the specified chunk using the specified combiner.
 *
 * @since 2.0.0
 * @category elements
 */
const Array_cartesianWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, that, f) => Array_flatMap(self, a => Array_map(that, b => f(a, b))))));
/**
 * Zips this chunk crosswise with the specified chunk.
 *
 * @since 2.0.0
 * @category elements
 */
const Array_cartesian = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Array_cartesianWith(self, that, (a, b) => [a, b]))));
//# sourceMappingURL=Array.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Chunk.js
/**
 * @since 2.0.0
 */










const Chunk_TypeId = /*#__PURE__*/Symbol.for("effect/Chunk");
function Chunk_copy(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
const emptyArray = [];
/**
 * Compares the two chunks of equal length using the specified function
 *
 * @category equivalence
 * @since 2.0.0
 */
const Chunk_getEquivalence = isEquivalent => Equivalence_make((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, Chunk_unsafeGet(that, i))));
const Chunk_equivalence = /*#__PURE__*/Chunk_getEquivalence(equals);
const ChunkProto = {
  [Chunk_TypeId]: {
    _A: _ => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [Equal_symbol](that) {
    return isChunk(that) && Chunk_equivalence(this, that);
  },
  [symbol]() {
    return cached(this, array(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray":
        {
          return this.backing.array[Symbol.iterator]();
        }
      case "IEmpty":
        {
          return emptyArray[Symbol.iterator]();
        }
      default:
        {
          return toReadonlyArray(this)[Symbol.iterator]();
        }
    }
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
const makeChunk = backing => {
  const chunk = Object.create(ChunkProto);
  chunk.backing = backing;
  switch (backing._tag) {
    case "IEmpty":
      {
        chunk.length = 0;
        chunk.depth = 0;
        chunk.left = chunk;
        chunk.right = chunk;
        break;
      }
    case "IConcat":
      {
        chunk.length = backing.left.length + backing.right.length;
        chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
        chunk.left = backing.left;
        chunk.right = backing.right;
        break;
      }
    case "IArray":
      {
        chunk.length = backing.array.length;
        chunk.depth = 0;
        chunk.left = Chunk_empty;
        chunk.right = Chunk_empty;
        break;
      }
    case "ISingleton":
      {
        chunk.length = 1;
        chunk.depth = 0;
        chunk.left = Chunk_empty;
        chunk.right = Chunk_empty;
        break;
      }
    case "ISlice":
      {
        chunk.length = backing.length;
        chunk.depth = backing.chunk.depth + 1;
        chunk.left = Chunk_empty;
        chunk.right = Chunk_empty;
        break;
      }
  }
  return chunk;
};
/**
 * Checks if `u` is a `Chunk<unknown>`
 *
 * @category constructors
 * @since 2.0.0
 */
const isChunk = u => Predicate_hasProperty(u, Chunk_TypeId);
const Chunk_empty = /*#__PURE__*/makeChunk({
  _tag: "IEmpty"
});
/**
 * @category constructors
 * @since 2.0.0
 */
const esm_Chunk_empty = () => Chunk_empty;
/**
 * Builds a `NonEmptyChunk` from an non-empty collection of elements.
 *
 * @category constructors
 * @since 2.0.0
 */
const Chunk_make = (...as) => as.length === 1 ? Chunk_of(as[0]) : unsafeFromNonEmptyArray(as);
/**
 * Builds a `NonEmptyChunk` from a single element.
 *
 * @category constructors
 * @since 2.0.0
 */
const Chunk_of = a => makeChunk({
  _tag: "ISingleton",
  a
});
/**
 * Creates a new `Chunk` from an iterable collection of values.
 *
 * @category constructors
 * @since 2.0.0
 */
const Chunk_fromIterable = self => isChunk(self) ? self : makeChunk({
  _tag: "IArray",
  array: Array_fromIterable(self)
});
const copyToArray = (self, array, initial) => {
  switch (self.backing._tag) {
    case "IArray":
      {
        Chunk_copy(self.backing.array, 0, array, initial, self.length);
        break;
      }
    case "IConcat":
      {
        copyToArray(self.left, array, initial);
        copyToArray(self.right, array, initial + self.left.length);
        break;
      }
    case "ISingleton":
      {
        array[initial] = self.backing.a;
        break;
      }
    case "ISlice":
      {
        let i = 0;
        let j = initial;
        while (i < self.length) {
          array[j] = Chunk_unsafeGet(self, i);
          i += 1;
          j += 1;
        }
        break;
      }
  }
};
/**
 * Converts the specified `Chunk` to a `Array`.
 *
 * @category conversions
 * @since 2.0.0
 */
const Chunk_toArray = self => toReadonlyArray(self).slice();
/**
 * Converts the specified `Chunk` to a `ReadonlyArray`.
 *
 * @category conversions
 * @since 2.0.0
 */
const toReadonlyArray = self => {
  switch (self.backing._tag) {
    case "IEmpty":
      {
        return emptyArray;
      }
    case "IArray":
      {
        return self.backing.array;
      }
    default:
      {
        const arr = new Array(self.length);
        copyToArray(self, arr, 0);
        self.backing = {
          _tag: "IArray",
          array: arr
        };
        self.left = Chunk_empty;
        self.right = Chunk_empty;
        self.depth = 0;
        return arr;
      }
  }
};
/**
 * @since 2.0.0
 * @category elements
 */
const Chunk_reverse = self => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray":
      {
        return makeChunk({
          _tag: "IArray",
          array: Array_reverse(self.backing.array)
        });
      }
    case "IConcat":
      {
        return makeChunk({
          _tag: "IConcat",
          left: Chunk_reverse(self.backing.right),
          right: Chunk_reverse(self.backing.left)
        });
      }
    case "ISlice":
      return unsafeFromArray(Array_reverse(toReadonlyArray(self)));
  }
};
/**
 * This function provides a safe way to read a value at a particular index from a `Chunk`.
 *
 * @category elements
 * @since 2.0.0
 */
const Chunk_get = /*#__PURE__*/Function_dual(2, (self, index) => index < 0 || index >= self.length ? Option_none() : Option_some(Chunk_unsafeGet(self, index)));
/**
 * Wraps an array into a chunk without copying, unsafe on mutable arrays
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeFromArray = self => makeChunk({
  _tag: "IArray",
  array: self
});
/**
 * Wraps an array into a chunk without copying, unsafe on mutable arrays
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeFromNonEmptyArray = self => unsafeFromArray(self);
/**
 * Gets an element unsafely, will throw on out of bounds
 *
 * @since 2.0.0
 * @category unsafe
 */
const Chunk_unsafeGet = /*#__PURE__*/Function_dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty":
      {
        throw new Error(`Index out of bounds`);
      }
    case "ISingleton":
      {
        if (index !== 0) {
          throw new Error(`Index out of bounds`);
        }
        return self.backing.a;
      }
    case "IArray":
      {
        if (index >= self.length || index < 0) {
          throw new Error(`Index out of bounds`);
        }
        return self.backing.array[index];
      }
    case "IConcat":
      {
        return index < self.left.length ? Chunk_unsafeGet(self.left, index) : Chunk_unsafeGet(self.right, index - self.left.length);
      }
    case "ISlice":
      {
        return Chunk_unsafeGet(self.backing.chunk, index + self.backing.offset);
      }
  }
});
/**
 * Appends the specified element to the end of the `Chunk`.
 *
 * @category concatenating
 * @since 2.0.0
 */
const Chunk_append = /*#__PURE__*/Function_dual(2, (self, a) => Chunk_appendAll(self, Chunk_of(a)));
/**
 * Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.
 *
 * @category concatenating
 * @since 2.0.0
 */
const Chunk_prepend = /*#__PURE__*/Function_dual(2, (self, elem) => Chunk_appendAll(Chunk_of(elem), self));
/**
 * Takes the first up to `n` elements from the chunk
 *
 * @since 2.0.0
 */
const Chunk_take = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => {
  if (n <= 0) {
    return Chunk_empty;
  } else if (n >= self.length) {
    return self;
  } else {
    switch (self.backing._tag) {
      case "ISlice":
        {
          return makeChunk({
            _tag: "ISlice",
            chunk: self.backing.chunk,
            length: n,
            offset: self.backing.offset
          });
        }
      case "IConcat":
        {
          if (n > self.left.length) {
            return makeChunk({
              _tag: "IConcat",
              left: self.left,
              right: Chunk_take(self.right, n - self.left.length)
            });
          }
          return Chunk_take(self.left, n);
        }
      default:
        {
          return makeChunk({
            _tag: "ISlice",
            chunk: self,
            offset: 0,
            length: n
          });
        }
    }
  }
})));
/**
 * Drops the first up to `n` elements from the chunk
 *
 * @since 2.0.0
 */
const Chunk_drop = /*#__PURE__*/Function_dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return Chunk_empty;
  } else {
    switch (self.backing._tag) {
      case "ISlice":
        {
          return makeChunk({
            _tag: "ISlice",
            chunk: self.backing.chunk,
            offset: self.backing.offset + n,
            length: self.backing.length - n
          });
        }
      case "IConcat":
        {
          if (n > self.left.length) {
            return Chunk_drop(self.right, n - self.left.length);
          }
          return makeChunk({
            _tag: "IConcat",
            left: Chunk_drop(self.left, n),
            right: self.right
          });
        }
      default:
        {
          return makeChunk({
            _tag: "ISlice",
            chunk: self,
            offset: n,
            length: self.length - n
          });
        }
    }
  }
});
/**
 * Drops the last `n` elements.
 *
 * @since 2.0.0
 */
const Chunk_dropRight = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => Chunk_take(self, Math.max(0, self.length - n)))));
/**
 * Drops all elements so long as the predicate returns true.
 *
 * @since 2.0.0
 */
const Chunk_dropWhile = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  const arr = toReadonlyArray(self);
  const len = arr.length;
  let i = 0;
  while (i < len && predicate(arr[i])) {
    i++;
  }
  return Chunk_drop(self, i);
})));
/**
 * Prepends the specified prefix chunk to the beginning of the specified chunk.
 * If either chunk is non-empty, the result is also a non-empty chunk.
 *
 * @example
 * import { Chunk } from "effect"
 *
 * assert.deepStrictEqual(
 *   Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make("a", "b")), Chunk.toArray),
 *   ["a", "b", 1, 2]
 * )
 *
 * @category concatenating
 * @since 2.0.0
 */
const Chunk_prependAll = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Chunk_appendAll(that, self))));
/**
 * Concatenates two chunks, combining their elements.
 * If either chunk is non-empty, the result is also a non-empty chunk.
 *
 * @example
 * import { Chunk } from "effect"
 *
 * assert.deepStrictEqual(
 *   Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make("a", "b")), Chunk.toArray),
 *   [1, 2, "a", "b"]
 * )
 *
 * @category concatenating
 * @since 2.0.0
 */
const Chunk_appendAll = /*#__PURE__*/Function_dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff = that.depth - self.depth;
  if (Math.abs(diff) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = Chunk_appendAll(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = Chunk_appendAll(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = Chunk_appendAll(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = Chunk_appendAll(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
/**
 * Returns a filtered and mapped subset of the elements.
 *
 * @since 2.0.0
 * @category filtering
 */
const Chunk_filterMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => unsafeFromArray(RA.filterMap(self, f)))));
/**
 * Returns a filtered and mapped subset of the elements.
 *
 * @since 2.0.0
 * @category filtering
 */
const Chunk_filter = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => unsafeFromArray(RA.filter(self, predicate)))));
/**
 * Transforms all elements of the chunk for as long as the specified function returns some value
 *
 * @since 2.0.0
 * @category filtering
 */
const Chunk_filterMapWhile = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => unsafeFromArray(RA.filterMapWhile(self, f)))));
/**
 * Filter out optional values
 *
 * @since 2.0.0
 * @category filtering
 */
const compact = self => Chunk_filterMap(self, identity);
/**
 * Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.
 *
 * @since 2.0.0
 * @category sequencing
 */
const Chunk_flatMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  if (self.backing._tag === "ISingleton") {
    return f(self.backing.a, 0);
  }
  let out = Chunk_empty;
  let i = 0;
  for (const k of self) {
    out = Chunk_appendAll(out, f(k, i++));
  }
  return out;
})));
/**
 * Applies the specified function to each element of the `List`.
 *
 * @since 2.0.0
 * @category combinators
 */
const Chunk_forEach = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => toReadonlyArray(self).forEach(f))));
/**
 * Flattens a chunk of chunks into a single chunk by concatenating all chunks.
 *
 * @since 2.0.0
 * @category sequencing
 */
const Chunk_flatten = /*#__PURE__*/(/* unused pure expression or super */ null && (Chunk_flatMap(identity)));
/**
 * Groups elements in chunks of up to `n` elements.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_chunksOf = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => {
  const gr = [];
  let current = [];
  toReadonlyArray(self).forEach(a => {
    current.push(a);
    if (current.length >= n) {
      gr.push(unsafeFromArray(current));
      current = [];
    }
  });
  if (current.length > 0) {
    gr.push(unsafeFromArray(current));
  }
  return unsafeFromArray(gr);
})));
/**
 * Creates a Chunk of unique values that are included in all given Chunks.
 *
 * The order and references of result values are determined by the Chunk.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_intersection = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => unsafeFromArray(RA.intersection(toReadonlyArray(self), toReadonlyArray(that))))));
/**
 * Determines if the chunk is empty.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_isEmpty = self => self.length === 0;
/**
 * Determines if the chunk is not empty.
 *
 * @since 2.0.0
 * @category elements
 */
const isNonEmpty = self => self.length > 0;
/**
 * Returns the first element of this chunk if it exists.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_head = /*#__PURE__*/Chunk_get(0);
/**
 * Returns the first element of this chunk.
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeHead = self => Chunk_unsafeGet(self, 0);
/**
 * Returns the first element of this non empty chunk.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_headNonEmpty = unsafeHead;
/**
 * Returns the last element of this chunk if it exists.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_last = self => Chunk_get(self, self.length - 1);
/**
 * Returns the last element of this chunk.
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeLast = self => Chunk_unsafeGet(self, self.length - 1);
/**
 * Transforms the elements of a chunk using the specified mapping function.
 * If the input chunk is non-empty, the resulting chunk will also be non-empty.
 *
 * @example
 * import { Chunk } from "effect"
 *
 * assert.deepStrictEqual(
 *   Chunk.map(Chunk.make(1, 2), (n) => n + 1),
 *   Chunk.make(2, 3)
 * )
 *
 * @since 2.0.0
 * @category mapping
 */
const Chunk_map = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => self.backing._tag === "ISingleton" ? Chunk_of(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), RA.map((a, i) => f(a, i)))))));
/**
 * Statefully maps over the chunk, producing new elements of type `B`.
 *
 * @since 2.0.0
 * @category folding
 */
const Chunk_mapAccum = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, s, f) => {
  const [s1, as] = RA.mapAccum(self, s, f);
  return [s1, unsafeFromArray(as)];
})));
/**
 * Separate elements based on a predicate that also exposes the index of the element.
 *
 * @category filtering
 * @since 2.0.0
 */
const Chunk_partition = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => pipe(RA.partition(toReadonlyArray(self), predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]))));
/**
 * Partitions the elements of this chunk into two chunks using f.
 *
 * @category filtering
 * @since 2.0.0
 */
const Chunk_partitionMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => pipe(RA.partitionMap(toReadonlyArray(self), f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]))));
/**
 * Partitions the elements of this chunk into two chunks.
 *
 * @category filtering
 * @since 2.0.0
 */
const Chunk_separate = self => pipe(RA.separate(toReadonlyArray(self)), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]);
/**
 * Retireves the size of the chunk
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_size = self => self.length;
/**
 * Sort the elements of a Chunk in increasing order, creating a new Chunk.
 *
 * @since 2.0.0
 * @category sorting
 */
const Chunk_sort = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, O) => unsafeFromArray(RA.sort(toReadonlyArray(self), O)))));
/**
 * @since 2.0.0
 * @category sorting
 */
const Chunk_sortWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, f, order) => Chunk_sort(self, Order.mapInput(order, f)))));
/**
 *  Returns two splits of this chunk at the specified index.
 *
 * @since 2.0.0
 * @category splitting
 */
const Chunk_splitAt = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => [Chunk_take(self, n), Chunk_drop(self, n)])));
/**
 * Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.
 * The value of `n` must be `>= 1`.
 *
 * @category splitting
 * @since 2.0.0
 */
const Chunk_splitNonEmptyAt = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [self, esm_Chunk_empty()] : [Chunk_take(self, _n), Chunk_drop(self, _n)];
})));
/**
 * Splits this chunk into `n` equally sized chunks.
 *
 * @since 2.0.0
 * @category splitting
 */
const Chunk_split = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => Chunk_chunksOf(self, Math.ceil(self.length / Math.floor(n))))));
/**
 * Splits this chunk on the first element that matches this predicate.
 * Returns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.
 *
 * @category splitting
 * @since 2.0.0
 */
const Chunk_splitWhere = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  let i = 0;
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      break;
    } else {
      i++;
    }
  }
  return Chunk_splitAt(self, i);
})));
/**
 * Returns every elements after the first.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_tail = self => self.length > 0 ? O.some(Chunk_drop(self, 1)) : O.none();
/**
 * Returns every elements after the first.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_tailNonEmpty = self => Chunk_drop(self, 1);
/**
 * Takes the last `n` elements.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_takeRight = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => Chunk_drop(self, self.length - n))));
/**
 * Takes all elements so long as the predicate returns true.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_takeWhile = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  const out = [];
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      out.push(a);
    } else {
      break;
    }
  }
  return unsafeFromArray(out);
})));
/**
 * Creates a Chunks of unique values, in order, from all given Chunks.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_union = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => unsafeFromArray(RA.union(toReadonlyArray(self), toReadonlyArray(that))))));
/**
 * Remove duplicates from an array, keeping the first occurrence of an element.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_dedupe = self => unsafeFromArray(RA.dedupe(toReadonlyArray(self)));
/**
 * Deduplicates adjacent elements that are identical.
 *
 * @since 2.0.0
 * @category filtering
 */
const Chunk_dedupeAdjacent = self => unsafeFromArray(RA.dedupeAdjacent(self));
/**
 * Takes a `Chunk` of pairs and return two corresponding `Chunk`s.
 *
 * Note: The function is reverse of `zip`.
 *
 * @since 2.0.0
 * @category elements
 */
const Chunk_unzip = self => {
  const [left, right] = RA.unzip(self);
  return [unsafeFromArray(left), unsafeFromArray(right)];
};
/**
 * Zips this chunk pointwise with the specified chunk using the specified combiner.
 *
 * @since 2.0.0
 * @category zipping
 */
const Chunk_zipWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, that, f) => unsafeFromArray(RA.zipWith(self, that, f)))));
/**
 * Zips this chunk pointwise with the specified chunk.
 *
 * @since 2.0.0
 * @category zipping
 */
const Chunk_zip = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Chunk_zipWith(self, that, (a, b) => [a, b]))));
/**
 * Delete the element at the specified index, creating a new `Chunk`,
 * or returning the input if the index is out of bounds.
 *
 * @since 2.0.0
 */
const Chunk_remove = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, i) => unsafeFromArray(RA.remove(toReadonlyArray(self), i)))));
/**
 * @since 2.0.0
 */
const Chunk_modifyOption = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, i, f) => O.map(RA.modifyOption(toReadonlyArray(self), i, f), unsafeFromArray))));
/**
 * Apply a function to the element at the specified index, creating a new `Chunk`,
 * or returning the input if the index is out of bounds.
 *
 * @since 2.0.0
 */
const Chunk_modify = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, i, f) => O.getOrElse(Chunk_modifyOption(self, i, f), () => self))));
/**
 * Change the element at the specified index, creating a new `Chunk`,
 * or returning the input if the index is out of bounds.
 *
 * @since 2.0.0
 */
const Chunk_replace = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, i, b) => Chunk_modify(self, i, () => b))));
/**
 * @since 2.0.0
 */
const Chunk_replaceOption = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, i, b) => Chunk_modifyOption(self, i, () => b))));
/**
 * Return a Chunk of length n with element i initialized with f(i).
 *
 * **Note**. `n` is normalized to an integer >= 1.
 *
 * @category constructors
 * @since 2.0.0
 */
const Chunk_makeBy = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (n, f) => Chunk_fromIterable(RA.makeBy(n, f)))));
/**
 * Create a non empty `Chunk` containing a range of integers, including both endpoints.
 *
 * @category constructors
 * @since 2.0.0
 */
const Chunk_range = (start, end) => start <= end ? Chunk_makeBy(end - start + 1, i => start + i) : Chunk_of(start);
// -------------------------------------------------------------------------------------
// re-exports from ReadonlyArray
// -------------------------------------------------------------------------------------
/**
 * Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.
 *
 * @category elements
 * @since 2.0.0
 */
const Chunk_contains = Array_contains;
/**
 * Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.
 *
 * @category elements
 * @since 2.0.0
 */
const Chunk_containsWith = Array_containsWith;
/**
 * Returns the first element that satisfies the specified
 * predicate, or `None` if no such element exists.
 *
 * @category elements
 * @since 2.0.0
 */
const Chunk_findFirst = Array_findFirst;
/**
 * Return the first index for which a predicate holds.
 *
 * @category elements
 * @since 2.0.0
 */
const Chunk_findFirstIndex = findFirstIndex;
/**
 * Find the last element for which a predicate holds.
 *
 * @category elements
 * @since 2.0.0
 */
const Chunk_findLast = Array_findLast;
/**
 * Return the last index for which a predicate holds.
 *
 * @category elements
 * @since 2.0.0
 */
const Chunk_findLastIndex = findLastIndex;
/**
 * Check if a predicate holds true for every `Chunk` element.
 *
 * @category elements
 * @since 2.0.0
 */
const Chunk_every = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, refinement) => RA.fromIterable(self).every(refinement))));
/**
 * Check if a predicate holds true for some `Chunk` element.
 *
 * @category elements
 * @since 2.0.0
 */
const Chunk_some = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => RA.fromIterable(self).some(predicate))));
/**
 * Joins the elements together with "sep" in the middle.
 *
 * @category folding
 * @since 2.0.0
 */
const Chunk_join = Array_join;
/**
 * @category folding
 * @since 2.0.0
 */
const Chunk_reduce = Array_reduce;
/**
 * @category folding
 * @since 2.0.0
 */
const Chunk_reduceRight = reduceRight;
//# sourceMappingURL=Chunk.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Either.js
/**
 * @since 2.0.0
 */






/**
 * @category symbols
 * @since 2.0.0
 */
const Either_TypeId = either_TypeId;
/**
 * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias
 * of this structure.
 *
 * @category constructors
 * @since 2.0.0
 */
const Either_right = right;
/**
 * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this
 * structure.
 *
 * @category constructors
 * @since 2.0.0
 */
const Either_left = left;
/**
 * Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use
 * the provided default as a `Left`.
 *
 * @example
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))
 * assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))
 *
 * @category constructors
 * @since 2.0.0
 */
const Either_fromNullable = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, onNullable) => self == null ? Either_left(onNullable(self)) : Either_right(self))));
/**
 * @example
 * import { Either, Option } from "effect"
 *
 * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))
 * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))
 *
 * @category constructors
 * @since 2.0.0
 */
const Either_fromOption = fromOption;
const try_ = evaluate => {
  if (isFunction(evaluate)) {
    try {
      return Either_right(evaluate());
    } catch (e) {
      return Either_left(e);
    }
  } else {
    try {
      return Either_right(evaluate.try());
    } catch (e) {
      return Either_left(evaluate.catch(e));
    }
  }
};

/**
 * Tests if a value is a `Either`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(Either.isEither(Either.right(1)), true)
 * assert.deepStrictEqual(Either.isEither(Either.left("a")), true)
 * assert.deepStrictEqual(Either.isEither({ right: 1 }), false)
 *
 * @category guards
 * @since 2.0.0
 */
const Either_isEither = isEither;
/**
 * Determine if a `Either` is a `Left`.
 *
 * @param self - The `Either` to check.
 *
 * @example
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)
 * assert.deepStrictEqual(Either.isLeft(Either.left("a")), true)
 *
 * @category guards
 * @since 2.0.0
 */
const Either_isLeft = isLeft;
/**
 * Determine if a `Either` is a `Right`.
 *
 * @param self - The `Either` to check.
 *
 * @example
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(Either.isRight(Either.right(1)), true)
 * assert.deepStrictEqual(Either.isRight(Either.left("a")), false)
 *
 * @category guards
 * @since 2.0.0
 */
const Either_isRight = isRight;
/**
 * Converts a `Either` to an `Option` discarding the `Left`.
 *
 * Alias of {@link toOption}.
 *
 * @example
 * import { Either, Option } from "effect"
 *
 * assert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))
 * assert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())
 *
 * @category getters
 * @since 2.0.0
 */
const Either_getRight = getRight;
/**
 * Converts a `Either` to an `Option` discarding the value.
 *
 * @example
 * import { Either, Option } from "effect"
 *
 * assert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())
 * assert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))
 *
 * @category getters
 * @since 2.0.0
 */
const Either_getLeft = getLeft;
/**
 * @category equivalence
 * @since 2.0.0
 */
const Either_getEquivalence = ({
  left,
  right
}) => Equivalence.make((x, y) => x === y || (Either_isLeft(x) ? Either_isLeft(y) && left(x.left, y.left) : Either_isRight(y) && right(x.right, y.right)));
/**
 * @category mapping
 * @since 2.0.0
 */
const Either_mapBoth = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, {
  onLeft,
  onRight
}) => Either_isLeft(self) ? Either_left(onLeft(self.left)) : Either_right(onRight(self.right)))));
/**
 * Maps the `Left` side of an `Either` value to a new `Either` value.
 *
 * @param self - The input `Either` value to map.
 * @param f - A transformation function to apply to the `Left` value of the input `Either`.
 *
 * @category mapping
 * @since 2.0.0
 */
const mapLeft = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => Either_isLeft(self) ? Either_left(f(self.left)) : Either_right(self.right))));
/**
 * Maps the `Right` side of an `Either` value to a new `Either` value.
 *
 * @param self - An `Either` to map
 * @param f - The function to map over the value of the `Either`
 *
 * @category mapping
 * @since 2.0.0
 */
const Either_map = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => Either_isRight(self) ? Either_right(f(self.right)) : Either_left(self.left))));
/**
 * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,
 * if the value is a `Right` the inner value is applied to the `onRight` function.
 *
 * @example
 * import { pipe, Either } from "effect"
 *
 * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`
 *
 * const onRight = (value: number): string => `Ok: ${value}`
 *
 * assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')
 * assert.deepStrictEqual(
 *   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),
 *   'strings: string 1, string 2'
 * )
 *
 * @category pattern matching
 * @since 2.0.0
 */
const Either_match = /*#__PURE__*/Function_dual(2, (self, {
  onLeft,
  onRight
}) => Either_isLeft(self) ? onLeft(self.left) : onRight(self.right));
/**
 * Filter the right value with the provided function.
 * If the predicate fails, set the left value with the result of the provided function.
 *
 * @example
 * import { pipe, Either } from "effect"
 *
 * const isPositive = (n: number): boolean => n > 0
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     Either.right(1),
 *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)
 *   ),
 *   Either.right(1)
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     Either.right(0),
 *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)
 *   ),
 *   Either.left("0 is not positive")
 * )
 *
 * @since 2.0.0
 * @category filtering & conditionals
 */
const filterOrLeft = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, predicate, orLeftWith) => Either_flatMap(self, r => predicate(r) ? Either_right(r) : Either_left(orLeftWith(r))))));
/**
 * @category getters
 * @since 2.0.0
 */
const Either_merge = /*#__PURE__*/Either_match({
  onLeft: Function_identity,
  onRight: Function_identity
});
/**
 * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.
 *
 * @example
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + "!"), 1)
 * assert.deepStrictEqual(Either.getOrElse(Either.left("not a number"), (error) => error + "!"), "not a number!")
 *
 * @category getters
 * @since 2.0.0
 */
const Either_getOrElse = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, onLeft) => Either_isLeft(self) ? onLeft(self.left) : self.right)));
/**
 * @example
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(Either.getOrNull(Either.right(1)), 1)
 * assert.deepStrictEqual(Either.getOrNull(Either.left("a")), null)
 *
 * @category getters
 * @since 2.0.0
 */
const Either_getOrNull = /*#__PURE__*/(/* unused pure expression or super */ null && (Either_getOrElse(constNull)));
/**
 * @example
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(Either.getOrUndefined(Either.right(1)), 1)
 * assert.deepStrictEqual(Either.getOrUndefined(Either.left("a")), undefined)
 *
 * @category getters
 * @since 2.0.0
 */
const Either_getOrUndefined = /*#__PURE__*/(/* unused pure expression or super */ null && (Either_getOrElse(constUndefined)));
/**
 * Extracts the value of an `Either` or throws if the `Either` is `Left`.
 *
 * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.
 *
 * @param self - The `Either` to extract the value from.
 * @param onLeft - A function that will be called if the `Either` is `Left`. It returns the error to be thrown.
 *
 * @example
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(
 *   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),
 *   1
 * )
 * assert.throws(() => Either.getOrThrowWith(Either.left("error"), () => new Error('Unexpected Left')))
 *
 * @category getters
 * @since 2.0.0
 */
const Either_getOrThrowWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, onLeft) => {
  if (Either_isRight(self)) {
    return self.right;
  }
  throw onLeft(self.left);
})));
/**
 * Extracts the value of an `Either` or throws if the `Either` is `Left`.
 *
 * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.
 *
 * @param self - The `Either` to extract the value from.
 * @throws `Error("getOrThrow called on a Left")`
 *
 * @example
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)
 * assert.throws(() => Either.getOrThrow(Either.left("error")))
 *
 * @category getters
 * @since 2.0.0
 */
const Either_getOrThrow = /*#__PURE__*/(/* unused pure expression or super */ null && (Either_getOrThrowWith(() => new Error("getOrThrow called on a Left"))));
/**
 * Returns `self` if it is a `Right` or `that` otherwise.
 *
 * @param self - The input `Either` value to check and potentially return.
 * @param that - A function that takes the error value from `self` (if it's a `Left`) and returns a new `Either` value.
 *
 * @category error handling
 * @since 2.0.0
 */
const Either_orElse = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Either_isLeft(self) ? that(self.left) : Either_right(self.right))));
/**
 * @category sequencing
 * @since 2.0.0
 */
const Either_flatMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => Either_isLeft(self) ? Either_left(self.left) : f(self.right))));
/**
 * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.
 *
 * @category sequencing
 * @since 2.0.0
 */
const Either_andThen = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => Either_flatMap(self, a => {
  const b = isFunction(f) ? f(a) : f;
  return Either_isEither(b) ? b : Either_right(b);
}))));
/**
 * @category zipping
 * @since 2.0.0
 */
const Either_zipWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, that, f) => Either_flatMap(self, r => Either_map(that, r2 => f(r, r2))))));
/**
 * @category combining
 * @since 2.0.0
 */
const Either_ap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Either_zipWith(self, that, (f, a) => f(a)))));
/**
 * Takes a structure of `Either`s and returns an `Either` of values with the same structure.
 *
 * - If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.
 * - If a struct is supplied, then the returned `Either` will contain a struct with the same keys.
 * - If an iterable is supplied, then the returned `Either` will contain an array.
 *
 * @param fields - the struct of `Either`s to be sequenced.
 *
 * @example
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))
 * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right("hello") }), Either.right({ right: 1, b: "hello" }))
 * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left("error") }), Either.left("error"))
 *
 * @category combining
 * @since 2.0.0
 */
// @ts-expect-error
const Either_all = input => {
  if (Symbol.iterator in input) {
    const out = [];
    for (const e of input) {
      if (Either_isLeft(e)) {
        return e;
      }
      out.push(e.right);
    }
    return Either_right(out);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const e = input[key];
    if (Either_isLeft(e)) {
      return e;
    }
    out[key] = e.right;
  }
  return Either_right(out);
};
/**
 * Returns an `Either` that swaps the error/success cases. This allows you to
 * use all methods on the error channel, possibly before flipping back.
 *
 * @since 2.0.0
 * @category mapping
 */
const Either_flip = self => Either_isLeft(self) ? Either_right(self.left) : Either_left(self.right);
const Either_adapter = /*#__PURE__*/(/* unused pure expression or super */ null && (Gen.adapter()));
/**
 * @category generators
 * @since 2.0.0
 */
const Either_gen = f => {
  const iterator = f(Either_adapter);
  let state = iterator.next();
  if (state.done) {
    return Either_right(state.value);
  } else {
    let current = state.value;
    if (Gen.isGenKind(current)) {
      current = current.value;
    } else {
      current = Gen.yieldWrapGet(current);
    }
    if (Either_isLeft(current)) {
      return current;
    }
    while (!state.done) {
      state = iterator.next(current.right);
      if (!state.done) {
        current = state.value;
        if (Gen.isGenKind(current)) {
          current = current.value;
        } else {
          current = Gen.yieldWrapGet(current);
        }
        if (Either_isLeft(current)) {
          return current;
        }
      }
    }
    return Either_right(state.value);
  }
};
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * The "do simulation" in allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 *
 * @see {@link bind}
 * @see {@link bindTo}
 * @see {@link let_ let}
 *
 * @example
 * import { Either, pipe } from "effect"
 *
 * const result = pipe(
 *   Either.Do,
 *   Either.bind("x", () => Either.right(2)),
 *   Either.bind("y", () => Either.right(3)),
 *   Either.let("sum", ({ x, y }) => x + y)
 * )
 * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
 *
 * @category do notation
 * @since 2.0.0
 */
const Either_Do = /*#__PURE__*/Either_right({});
/**
 * The "do simulation" in allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 *
 * @see {@link Do}
 * @see {@link bindTo}
 * @see {@link let_ let}
 *
 * @example
 * import { Either, pipe } from "effect"
 *
 * const result = pipe(
 *   Either.Do,
 *   Either.bind("x", () => Either.right(2)),
 *   Either.bind("y", () => Either.right(3)),
 *   Either.let("sum", ({ x, y }) => x + y)
 * )
 * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
 *
 * @category do notation
 * @since 2.0.0
 */
const Either_bind = /*#__PURE__*/(/* unused pure expression or super */ null && (doNotation.bind(Either_map, Either_flatMap)));
/**
 * The "do simulation" in allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 *
 * @see {@link Do}
 * @see {@link bind}
 * @see {@link let_ let}
 *
 * @example
 * import { Either, pipe } from "effect"
 *
 * const result = pipe(
 *   Either.Do,
 *   Either.bind("x", () => Either.right(2)),
 *   Either.bind("y", () => Either.right(3)),
 *   Either.let("sum", ({ x, y }) => x + y)
 * )
 * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
 *
 * @category do notation
 * @since 2.0.0
 */
const Either_bindTo = /*#__PURE__*/(/* unused pure expression or super */ null && (doNotation.bindTo(Either_map)));
const Either_let_ = /*#__PURE__*/(/* unused pure expression or super */ null && (doNotation.let_(Either_map)));

//# sourceMappingURL=Either.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/hashMap/config.js
/** @internal */
const SIZE = 5;
/** @internal */
const BUCKET_SIZE = /*#__PURE__*/Math.pow(2, SIZE);
/** @internal */
const MASK = BUCKET_SIZE - 1;
/** @internal */
const MAX_INDEX_NODE = BUCKET_SIZE / 2;
/** @internal */
const MIN_ARRAY_NODE = BUCKET_SIZE / 4;
//# sourceMappingURL=config.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/hashMap/bitwise.js

/**
 * Hamming weight.
 *
 * Taken from: http://jsperf.com/hamming-weight
 *
 * @internal
 */
function popcount(x) {
  x -= x >> 1 & 0x55555555;
  x = (x & 0x33333333) + (x >> 2 & 0x33333333);
  x = x + (x >> 4) & 0x0f0f0f0f;
  x += x >> 8;
  x += x >> 16;
  return x & 0x7f;
}
/** @internal */
function hashFragment(shift, h) {
  return h >>> shift & MASK;
}
/** @internal */
function toBitmap(x) {
  return 1 << x;
}
/** @internal */
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}
//# sourceMappingURL=bitwise.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/stack.js
const stack_make = (value, previous) => ({
  value,
  previous
});
//# sourceMappingURL=stack.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/hashMap/array.js
/** @internal */
function arrayUpdate(mutate, at, v, arr) {
  let out = arr;
  if (!mutate) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
/** @internal */
function arraySpliceOut(mutate, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at) out[g++] = arr[i++];
  }
  ;
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate) {
    out.length = newLen;
  }
  return out;
}
/** @internal */
function arraySpliceIn(mutate, at, v, arr) {
  const len = arr.length;
  if (mutate) {
    let i = len;
    while (i >= at) arr[i--] = arr[i];
    arr[at] = v;
    return arr;
  }
  let i = 0,
    g = 0;
  const out = new Array(len + 1);
  while (i < at) out[g++] = arr[i++];
  out[at] = v;
  while (i < len) out[++g] = arr[i++];
  return out;
}
//# sourceMappingURL=array.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/hashMap/node.js







/** @internal */
class EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash, key, size) {
    const v = f(Option_none());
    if (Option_isNone(v)) return new EmptyNode();
    ++size.value;
    return new LeafNode(edit, hash, key, v);
  }
}
/** @internal */
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
/** @internal */
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
/** @internal */
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
/** @internal */
class LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash, key, value) {
    this.edit = edit;
    this.hash = hash;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift, f, hash, key, size) {
    if (equals(key, this.key)) {
      const v = f(this.value);
      if (v === this.value) return this;else if (Option_isNone(v)) {
        ;
        --size.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v;
        return this;
      }
      return new LeafNode(edit, hash, key, v);
    }
    const v = f(Option_none());
    if (Option_isNone(v)) return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));
  }
}
/** @internal */
class CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash, children) {
    this.edit = edit;
    this.hash = hash;
    this.children = children;
  }
  modify(edit, shift, f, hash, key, size) {
    if (hash === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);
      if (list === this.children) return this;
      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0]; // collapse single element collision list
    }
    const v = f(Option_none());
    if (Option_isNone(v)) return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));
  }
  updateCollisionList(mutate, edit, hash, list, f, key, size) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value = child.value;
        const newValue = f(value);
        if (newValue === value) return list;
        if (Option_isNone(newValue)) {
          ;
          --size.value;
          return arraySpliceOut(mutate, i, list);
        }
        return arrayUpdate(mutate, i, new LeafNode(edit, hash, key, newValue), list);
      }
    }
    const newValue = f(Option_none());
    if (Option_isNone(newValue)) return list;
    ++size.value;
    return arrayUpdate(mutate, len, new LeafNode(edit, hash, key, newValue), list);
  }
}
/** @internal */
class IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
  }
  modify(edit, shift, f, hash, key, size) {
    const mask = this.mask;
    const children = this.children;
    const frag = hashFragment(shift, hash);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists) {
      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash, key, size);
      if (!_newChild) return this;
      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
    }
    const current = children[indx];
    const child = current.modify(edit, shift + SIZE, f, hash, key, size);
    if (current === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      // remove
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
        return children[indx ^ 1]; // collapse
      }
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else {
      // modify
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new IndexedNode(edit, bitmap, newChildren);
  }
}
/** @internal */
class ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size, children) {
    this.edit = edit;
    this.size = size;
    this.children = children;
  }
  modify(edit, shift, f, hash, key, size) {
    let count = this.size;
    const children = this.children;
    const frag = hashFragment(shift, hash);
    const child = children[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift + SIZE, f, hash, key, size);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      // add
      ;
      ++count;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      // remove
      ;
      --count;
      if (count <= MIN_ARRAY_NODE) {
        return pack(edit, count, frag, children);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children);
    } else {
      // modify
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new ArrayNode(edit, count, newChildren);
  }
}
function pack(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift, h1);
  const subH2 = hashFragment(shift, h2);
  if (subH1 === subH2) {
    return child => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
  }
}
function mergeLeaves(edit, shift, h1, n1, h2, n2) {
  let stack = undefined;
  let currentShift = shift;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = stack_make(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}
//# sourceMappingURL=node.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/hashMap.js











const HashMapSymbolKey = "effect/HashMap";
/** @internal */
const HashMapTypeId = /*#__PURE__*/Symbol.for(HashMapSymbolKey);
const HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash = Hash_hash(HashMapSymbolKey);
    for (const item of this) {
      hash ^= Function_pipe(Hash_hash(item[0]), combine(Hash_hash(item[1])));
    }
    return cached(this, hash);
  },
  [Equal_symbol](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = Function_pipe(that, getHash(item[0], Hash_hash(item[0])));
        if (Option_isNone(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
const makeImpl = (editable, edit, root, size) => {
  const map = Object.create(HashMapProto);
  map._editable = editable;
  map._edit = edit;
  map._root = root;
  map._size = size;
  return map;
};
class HashMapIterator {
  map;
  f;
  v;
  constructor(map, f) {
    this.map = map;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, undefined);
  }
  next() {
    if (Option_isNone(this.v)) {
      return {
        done: true,
        value: undefined
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this.map, this.f);
  }
}
const applyCont = cont => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : Option_none();
const visitLazy = (node, f, cont = undefined) => {
  switch (node._tag) {
    case "LeafNode":
      {
        if (Option_isSome(node.value)) {
          return Option_some({
            value: f(node.key, node.value.value),
            cont
          });
        }
        return applyCont(cont);
      }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode":
      {
        const children = node.children;
        return visitLazyChildren(children.length, children, 0, f, cont);
      }
    default:
      {
        return applyCont(cont);
      }
  }
};
const visitLazyChildren = (len, children, i, f, cont) => {
  while (i < len) {
    const child = children[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont(cont);
};
const hashMap_empty = /*#__PURE__*/makeImpl(false, 0, /*#__PURE__*/new EmptyNode(), 0);
/** @internal */
const internal_hashMap_empty = () => hashMap_empty;
/** @internal */
const hashMap_make = (...entries) => hashMap_fromIterable(entries);
/** @internal */
const hashMap_fromIterable = entries => {
  const map = beginMutation(internal_hashMap_empty());
  for (const entry of entries) {
    hashMap_set(map, entry[0], entry[1]);
  }
  return endMutation(map);
};
/** @internal */
const isHashMap = u => Predicate_hasProperty(u, HashMapTypeId);
/** @internal */
const hashMap_isEmpty = self => self && isEmptyNode(self._root);
/** @internal */
const hashMap_get = /*#__PURE__*/Function_dual(2, (self, key) => getHash(self, key, Hash_hash(key)));
/** @internal */
const getHash = /*#__PURE__*/Function_dual(3, (self, key, hash) => {
  let node = self._root;
  let shift = 0;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    switch (node._tag) {
      case "LeafNode":
        {
          return equals(key, node.key) ? node.value : Option_none();
        }
      case "CollisionNode":
        {
          if (hash === node.hash) {
            const children = node.children;
            for (let i = 0, len = children.length; i < len; ++i) {
              const child = children[i];
              if ("key" in child && equals(key, child.key)) {
                return child.value;
              }
            }
          }
          return Option_none();
        }
      case "IndexedNode":
        {
          const frag = hashFragment(shift, hash);
          const bit = toBitmap(frag);
          if (node.mask & bit) {
            node = node.children[fromBitmap(node.mask, bit)];
            shift += SIZE;
            break;
          }
          return Option_none();
        }
      case "ArrayNode":
        {
          node = node.children[hashFragment(shift, hash)];
          if (node) {
            shift += SIZE;
            break;
          }
          return Option_none();
        }
      default:
        return Option_none();
    }
  }
});
/** @internal */
const hashMap_unsafeGet = /*#__PURE__*/Function_dual(2, (self, key) => {
  const element = getHash(self, key, Hash_hash(key));
  if (Option_isNone(element)) {
    throw new Error("Expected map to contain key");
  }
  return element.value;
});
/** @internal */
const hashMap_has = /*#__PURE__*/Function_dual(2, (self, key) => Option_isSome(getHash(self, key, Hash_hash(key))));
/** @internal */
const hasHash = /*#__PURE__*/Function_dual(3, (self, key, hash) => Option_isSome(getHash(self, key, hash)));
/** @internal */
const hashMap_set = /*#__PURE__*/Function_dual(3, (self, key, value) => modifyAt(self, key, () => Option_some(value)));
/** @internal */
const setTree = /*#__PURE__*/Function_dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    ;
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
/** @internal */
const hashMap_keys = self => new HashMapIterator(self, key => key);
/** @internal */
const hashMap_values = self => new HashMapIterator(self, (_, value) => value);
/** @internal */
const entries = self => new HashMapIterator(self, (key, value) => [key, value]);
/** @internal */
const hashMap_size = self => self._size;
/** @internal */
const beginMutation = self => makeImpl(true, self._edit + 1, self._root, self._size);
/** @internal */
const endMutation = self => {
  ;
  self._editable = false;
  return self;
};
/** @internal */
const mutate = /*#__PURE__*/Function_dual(2, (self, f) => {
  const transient = beginMutation(self);
  f(transient);
  return endMutation(transient);
});
/** @internal */
const modifyAt = /*#__PURE__*/Function_dual(3, (self, key, f) => modifyHash(self, key, Hash_hash(key), f));
/** @internal */
const modifyHash = /*#__PURE__*/Function_dual(4, (self, key, hash, f) => {
  const size = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash, key, size);
  return Function_pipe(self, setTree(newRoot, size.value));
});
/** @internal */
const hashMap_modify = /*#__PURE__*/Function_dual(3, (self, key, f) => modifyAt(self, key, map(f)));
/** @internal */
const hashMap_union = /*#__PURE__*/Function_dual(2, (self, that) => {
  const result = beginMutation(self);
  hashMap_forEach(that, (v, k) => hashMap_set(result, k, v));
  return endMutation(result);
});
/** @internal */
const hashMap_remove = /*#__PURE__*/Function_dual(2, (self, key) => modifyAt(self, key, Option_none));
/** @internal */
const removeMany = /*#__PURE__*/Function_dual(2, (self, keys) => mutate(self, map => {
  for (const key of keys) {
    hashMap_remove(key)(map);
  }
}));
/**
 * Maps over the entries of the `HashMap` using the specified function.
 *
 * @since 2.0.0
 * @category mapping
 */
const hashMap_map = /*#__PURE__*/Function_dual(2, (self, f) => hashMap_reduce(self, internal_hashMap_empty(), (map, value, key) => hashMap_set(map, key, f(value, key))));
/** @internal */
const hashMap_flatMap = /*#__PURE__*/Function_dual(2, (self, f) => hashMap_reduce(self, internal_hashMap_empty(), (zero, value, key) => mutate(zero, map => hashMap_forEach(f(value, key), (value, key) => hashMap_set(map, key, value)))));
/** @internal */
const hashMap_forEach = /*#__PURE__*/Function_dual(2, (self, f) => hashMap_reduce(self, void 0, (_, value, key) => f(value, key)));
/** @internal */
const hashMap_reduce = /*#__PURE__*/Function_dual(3, (self, zero, f) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return Option_isSome(root.value) ? f(zero, root.value.value, root.key) : zero;
  }
  if (root._tag === "EmptyNode") {
    return zero;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i = 0, len = children.length; i < len;) {
      const child = children[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (Option_isSome(child.value)) {
            zero = f(zero, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero;
});
/** @internal */
const hashMap_filter = /*#__PURE__*/Function_dual(2, (self, f) => mutate(internal_hashMap_empty(), map => {
  for (const [k, a] of self) {
    if (f(a, k)) {
      hashMap_set(map, k, a);
    }
  }
}));
/** @internal */
const hashMap_compact = self => hashMap_filterMap(self, Function_identity);
/** @internal */
const hashMap_filterMap = /*#__PURE__*/Function_dual(2, (self, f) => mutate(internal_hashMap_empty(), map => {
  for (const [k, a] of self) {
    const option = f(a, k);
    if (Option_isSome(option)) {
      hashMap_set(map, k, option.value);
    }
  }
}));
/** @internal */
const hashMap_findFirst = /*#__PURE__*/Function_dual(2, (self, predicate) => {
  for (const ka of self) {
    if (predicate(ka[1], ka[0])) {
      return Option_some(ka);
    }
  }
  return Option_none();
});
//# sourceMappingURL=hashMap.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/hashSet.js







const HashSetSymbolKey = "effect/HashSet";
/** @internal */
const HashSetTypeId = /*#__PURE__*/Symbol.for(HashSetSymbolKey);
const HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return hashMap_keys(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(Hash_hash(this._keyMap))(Hash_hash(HashSetSymbolKey)));
  },
  [Equal_symbol](that) {
    if (isHashSet(that)) {
      return hashMap_size(this._keyMap) === hashMap_size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const hashSet_makeImpl = keyMap => {
  const set = Object.create(HashSetProto);
  set._keyMap = keyMap;
  return set;
};
/** @internal */
const isHashSet = u => Predicate_hasProperty(u, HashSetTypeId);
const hashSet_empty = /*#__PURE__*/hashSet_makeImpl( /*#__PURE__*/internal_hashMap_empty());
/** @internal */
const internal_hashSet_empty = () => hashSet_empty;
/** @internal */
const hashSet_fromIterable = elements => {
  const set = hashSet_beginMutation(internal_hashSet_empty());
  for (const value of elements) {
    hashSet_add(set, value);
  }
  return hashSet_endMutation(set);
};
/** @internal */
const hashSet_make = (...elements) => {
  const set = hashSet_beginMutation(internal_hashSet_empty());
  for (const value of elements) {
    hashSet_add(set, value);
  }
  return hashSet_endMutation(set);
};
/** @internal */
const hashSet_has = /*#__PURE__*/Function_dual(2, (self, value) => hashMap_has(self._keyMap, value));
/** @internal */
const hashSet_some = /*#__PURE__*/Function_dual(2, (self, f) => {
  let found = false;
  for (const value of self) {
    found = f(value);
    if (found) {
      break;
    }
  }
  return found;
});
/** @internal */
const hashSet_every = /*#__PURE__*/Function_dual(2, (self, refinement) => !hashSet_some(self, a => !refinement(a)));
/** @internal */
const isSubset = /*#__PURE__*/Function_dual(2, (self, that) => hashSet_every(self, value => hashSet_has(that, value)));
/** @internal */
const hashSet_values = self => hashMap_keys(self._keyMap);
/** @internal */
const hashSet_size = self => hashMap_size(self._keyMap);
/** @internal */
const hashSet_beginMutation = self => hashSet_makeImpl(beginMutation(self._keyMap));
/** @internal */
const hashSet_endMutation = self => {
  ;
  self._keyMap._editable = false;
  return self;
};
/** @internal */
const hashSet_mutate = /*#__PURE__*/Function_dual(2, (self, f) => {
  const transient = hashSet_beginMutation(self);
  f(transient);
  return hashSet_endMutation(transient);
});
/** @internal */
const hashSet_add = /*#__PURE__*/Function_dual(2, (self, value) => self._keyMap._editable ? (hashMap_set(value, true)(self._keyMap), self) : hashSet_makeImpl(hashMap_set(value, true)(self._keyMap)));
/** @internal */
const hashSet_remove = /*#__PURE__*/Function_dual(2, (self, value) => self._keyMap._editable ? (hashMap_remove(value)(self._keyMap), self) : hashSet_makeImpl(hashMap_remove(value)(self._keyMap)));
/** @internal */
const hashSet_difference = /*#__PURE__*/Function_dual(2, (self, that) => hashSet_mutate(self, set => {
  for (const value of that) {
    hashSet_remove(set, value);
  }
}));
/** @internal */
const hashSet_intersection = /*#__PURE__*/Function_dual(2, (self, that) => hashSet_mutate(internal_hashSet_empty(), set => {
  for (const value of that) {
    if (hashSet_has(value)(self)) {
      hashSet_add(value)(set);
    }
  }
}));
/** @internal */
const hashSet_union = /*#__PURE__*/Function_dual(2, (self, that) => hashSet_mutate(internal_hashSet_empty(), set => {
  hashSet_forEach(self, value => hashSet_add(set, value));
  for (const value of that) {
    hashSet_add(set, value);
  }
}));
/** @internal */
const toggle = /*#__PURE__*/Function_dual(2, (self, value) => hashSet_has(self, value) ? hashSet_remove(self, value) : hashSet_add(self, value));
/** @internal */
const hashSet_map = /*#__PURE__*/Function_dual(2, (self, f) => hashSet_mutate(internal_hashSet_empty(), set => {
  hashSet_forEach(self, a => {
    const b = f(a);
    if (!hashSet_has(set, b)) {
      hashSet_add(set, b);
    }
  });
}));
/** @internal */
const hashSet_flatMap = /*#__PURE__*/Function_dual(2, (self, f) => hashSet_mutate(internal_hashSet_empty(), set => {
  hashSet_forEach(self, a => {
    for (const b of f(a)) {
      if (!hashSet_has(set, b)) {
        hashSet_add(set, b);
      }
    }
  });
}));
/** @internal */
const hashSet_forEach = /*#__PURE__*/Function_dual(2, (self, f) => hashMap_forEach(self._keyMap, (_, k) => f(k)));
/** @internal */
const hashSet_reduce = /*#__PURE__*/Function_dual(3, (self, zero, f) => hashMap_reduce(self._keyMap, zero, (z, _, a) => f(z, a)));
/** @internal */
const hashSet_filter = /*#__PURE__*/Function_dual(2, (self, f) => {
  return hashSet_mutate(internal_hashSet_empty(), set => {
    const iterator = hashSet_values(self);
    let next;
    while (!(next = iterator.next()).done) {
      const value = next.value;
      if (f(value)) {
        hashSet_add(set, value);
      }
    }
  });
});
/** @internal */
const hashSet_partition = /*#__PURE__*/Function_dual(2, (self, predicate) => {
  const iterator = hashSet_values(self);
  let next;
  const right = hashSet_beginMutation(internal_hashSet_empty());
  const left = hashSet_beginMutation(internal_hashSet_empty());
  while (!(next = iterator.next()).done) {
    const value = next.value;
    if (predicate(value)) {
      hashSet_add(right, value);
    } else {
      hashSet_add(left, value);
    }
  }
  return [hashSet_endMutation(left), hashSet_endMutation(right)];
});
//# sourceMappingURL=hashSet.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/HashSet.js
/**
 * @since 2.0.0
 */

const HashSet_TypeId = HashSetTypeId;
/**
 * @since 2.0.0
 * @category refinements
 */
const HashSet_isHashSet = isHashSet;
/**
 * Creates an empty `HashSet`.
 *
 * @since 2.0.0
 * @category constructors
 */
const HashSet_empty = internal_hashSet_empty;
/**
 * Creates a new `HashSet` from an iterable collection of values.
 *
 * @since 2.0.0
 * @category constructors
 */
const HashSet_fromIterable = hashSet_fromIterable;
/**
 * Construct a new `HashSet` from a variable number of values.
 *
 * @since 2.0.0
 * @category constructors
 */
const HashSet_make = hashSet_make;
/**
 * Checks if the specified value exists in the `HashSet`.
 *
 * @since 2.0.0
 * @category elements
 */
const HashSet_has = hashSet_has;
/**
 * Check if a predicate holds true for some `HashSet` element.
 *
 * @since 2.0.0
 * @category elements
 */
const HashSet_some = hashSet_some;
/**
 * Check if a predicate holds true for every `HashSet` element.
 *
 * @since 2.0.0
 * @category elements
 */
const HashSet_every = hashSet_every;
/**
 * Returns `true` if and only if every element in the this `HashSet` is an
 * element of the second set,
 *
 * **NOTE**: the hash and equal of both sets must be the same.
 *
 * @since 2.0.0
 * @category elements
 */
const HashSet_isSubset = isSubset;
/**
 * Returns an `IterableIterator` of the values in the `HashSet`.
 *
 * @since 2.0.0
 * @category getters
 */
const HashSet_values = hashSet_values;
/**
 * Calculates the number of values in the `HashSet`.
 *
 * @since 2.0.0
 * @category getters
 */
const HashSet_size = hashSet_size;
/**
 * Marks the `HashSet` as mutable.
 *
 * @since 2.0.0
 */
const HashSet_beginMutation = hashSet_beginMutation;
/**
 * Marks the `HashSet` as immutable.
 *
 * @since 2.0.0
 */
const HashSet_endMutation = hashSet_endMutation;
/**
 * Mutates the `HashSet` within the context of the provided function.
 *
 * @since 2.0.0
 */
const HashSet_mutate = hashSet_mutate;
/**
 * Adds a value to the `HashSet`.
 *
 * @since 2.0.0
 */
const HashSet_add = hashSet_add;
/**
 * Removes a value from the `HashSet`.
 *
 * @since 2.0.0
 */
const HashSet_remove = hashSet_remove;
/**
 * Computes the set difference between this `HashSet` and the specified
 * `Iterable<A>`.
 *
 * **NOTE**: the hash and equal of the values in both the set and the iterable
 * must be the same.
 *
 * @since 2.0.0
 */
const HashSet_difference = hashSet_difference;
/**
 * Returns a `HashSet` of values which are present in both this set and that
 * `Iterable<A>`.
 *
 * **NOTE**: the hash and equal of the values in both the set and the iterable
 * must be the same.
 *
 * @since 2.0.0
 */
const HashSet_intersection = hashSet_intersection;
/**
 * Computes the set union `(`self` + `that`)` between this `HashSet` and the
 * specified `Iterable<A>`.
 *
 * **NOTE**: the hash and equal of the values in both the set and the iterable
 * must be the same.
 *
 * @since 2.0.0
 */
const HashSet_union = hashSet_union;
/**
 * Checks if a value is present in the `HashSet`. If it is present, the value
 * will be removed from the `HashSet`, otherwise the value will be added to the
 * `HashSet`.
 *
 * @since 2.0.0
 */
const HashSet_toggle = toggle;
/**
 * Maps over the values of the `HashSet` using the specified function.
 *
 * @since 2.0.0
 * @category mapping
 */
const HashSet_map = hashSet_map;
/**
 * Chains over the values of the `HashSet` using the specified function.
 *
 * @since 2.0.0
 * @category sequencing
 */
const HashSet_flatMap = hashSet_flatMap;
/**
 * Applies the specified function to the values of the `HashSet`.
 *
 * @since 2.0.0
 * @category traversing
 */
const HashSet_forEach = hashSet_forEach;
/**
 * Reduces the specified state over the values of the `HashSet`.
 *
 * @since 2.0.0
 * @category folding
 */
const HashSet_reduce = hashSet_reduce;
/**
 * Filters values out of a `HashSet` using the specified predicate.
 *
 * @since 2.0.0
 * @category filtering
 */
const HashSet_filter = hashSet_filter;
/**
 * Partition the values of a `HashSet` using the specified predicate.
 *
 * If a value matches the predicate, it will be placed into the `HashSet` on the
 * right side of the resulting `Tuple`, otherwise the value will be placed into
 * the left side.
 *
 * @since 2.0.0
 * @category partitioning
 */
const HashSet_partition = hashSet_partition;
//# sourceMappingURL=HashSet.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/MutableRef.js
/**
 * @since 2.0.0
 */




const MutableRef_TypeId = /*#__PURE__*/Symbol.for("effect/MutableRef");
const MutableRefProto = {
  [MutableRef_TypeId]: MutableRef_TypeId,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/**
 * @since 2.0.0
 * @category constructors
 */
const MutableRef_make = value => {
  const ref = Object.create(MutableRefProto);
  ref.current = value;
  return ref;
};
/**
 * @since 2.0.0
 * @category general
 */
const compareAndSet = /*#__PURE__*/Function_dual(3, (self, oldValue, newValue) => {
  if (equals(oldValue, self.current)) {
    self.current = newValue;
    return true;
  }
  return false;
});
/**
 * @since 2.0.0
 * @category numeric
 */
const decrement = self => update(self, n => n - 1);
/**
 * @since 2.0.0
 * @category numeric
 */
const decrementAndGet = self => updateAndGet(self, n => n - 1);
/**
 * @since 2.0.0
 * @category general
 */
const MutableRef_get = self => self.current;
/**
 * @since 2.0.0
 * @category numeric
 */
const getAndDecrement = self => getAndUpdate(self, n => n - 1);
/**
 * @since 2.0.0
 * @category numeric
 */
const getAndIncrement = self => getAndUpdate(self, n => n + 1);
/**
 * @since 2.0.0
 * @category general
 */
const getAndSet = /*#__PURE__*/(/* unused pure expression or super */ null && (Dual.dual(2, (self, value) => {
  const ret = self.current;
  self.current = value;
  return ret;
})));
/**
 * @since 2.0.0
 * @category general
 */
const getAndUpdate = /*#__PURE__*/(/* unused pure expression or super */ null && (Dual.dual(2, (self, f) => getAndSet(self, f(MutableRef_get(self))))));
/**
 * @since 2.0.0
 * @category numeric
 */
const increment = self => update(self, n => n + 1);
/**
 * @since 2.0.0
 * @category numeric
 */
const incrementAndGet = self => updateAndGet(self, n => n + 1);
/**
 * @since 2.0.0
 * @category general
 */
const MutableRef_set = /*#__PURE__*/Function_dual(2, (self, value) => {
  self.current = value;
  return self;
});
/**
 * @since 2.0.0
 * @category general
 */
const setAndGet = /*#__PURE__*/(/* unused pure expression or super */ null && (Dual.dual(2, (self, value) => {
  self.current = value;
  return self.current;
})));
/**
 * @since 2.0.0
 * @category general
 */
const update = /*#__PURE__*/(/* unused pure expression or super */ null && (Dual.dual(2, (self, f) => MutableRef_set(self, f(MutableRef_get(self))))));
/**
 * @since 2.0.0
 * @category general
 */
const updateAndGet = /*#__PURE__*/(/* unused pure expression or super */ null && (Dual.dual(2, (self, f) => setAndGet(self, f(MutableRef_get(self))))));
/**
 * @since 2.0.0
 * @category boolean
 */
const MutableRef_toggle = self => update(self, _ => !_);
//# sourceMappingURL=MutableRef.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/fiberId.js









/** @internal */
const FiberIdSymbolKey = "effect/FiberId";
/** @internal */
const FiberIdTypeId = /*#__PURE__*/Symbol.for(FiberIdSymbolKey);
/** @internal */
const OP_NONE = "None";
/** @internal */
const OP_RUNTIME = "Runtime";
/** @internal */
const OP_COMPOSITE = "Composite";
const emptyHash = /*#__PURE__*/string(`${FiberIdSymbolKey}-${OP_NONE}`);
/** @internal */
class None {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol]() {
    return emptyHash;
  }
  [Equal_symbol](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
/** @internal */
class Runtime {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id, startTimeMillis) {
    this.id = id;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol]() {
    return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [Equal_symbol](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
/** @internal */
class Composite {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
  _hash;
  [symbol]() {
    return Function_pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(Hash_hash(this.left)), combine(Hash_hash(this.right)), cached(this));
  }
  [Equal_symbol](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
/** @internal */
const fiberId_none = /*#__PURE__*/new None();
/** @internal */
const fiberId_runtime = (id, startTimeMillis) => {
  return new Runtime(id, startTimeMillis);
};
/** @internal */
const composite = (left, right) => {
  return new Composite(left, right);
};
/** @internal */
const isFiberId = self => Predicate_hasProperty(self, FiberIdTypeId);
/** @internal */
const fiberId_isNone = self => {
  return self._tag === OP_NONE || Function_pipe(toSet(self), HashSet_every(id => fiberId_isNone(id)));
};
/** @internal */
const isRuntime = self => {
  return self._tag === OP_RUNTIME;
};
/** @internal */
const isComposite = self => {
  return self._tag === OP_COMPOSITE;
};
/** @internal */
const fiberId_combine = /*#__PURE__*/Function_dual(2, (self, that) => {
  if (self._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self;
  }
  return new Composite(self, that);
});
/** @internal */
const fiberId_combineAll = fiberIds => {
  return Function_pipe(fiberIds, HashSet_reduce(fiberId_none, (a, b) => fiberId_combine(b)(a)));
};
/** @internal */
const fiberId_getOrElse = /*#__PURE__*/Function_dual(2, (self, that) => fiberId_isNone(self) ? that : self);
/** @internal */
const ids = self => {
  switch (self._tag) {
    case OP_NONE:
      {
        return HashSet_empty();
      }
    case OP_RUNTIME:
      {
        return HashSet_make(self.id);
      }
    case OP_COMPOSITE:
      {
        return Function_pipe(ids(self.left), HashSet_union(ids(self.right)));
      }
  }
};
const _fiberCounter = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/Fiber/Id/_fiberCounter"), () => MutableRef_make(0));
/** @internal */
const fiberId_make = (id, startTimeSeconds) => {
  return new Runtime(id, startTimeSeconds);
};
/** @internal */
const threadName = self => {
  const identifiers = Array.from(ids(self)).map(n => `#${n}`).join(",");
  return identifiers;
};
/** @internal */
const toOption = self => {
  const fiberIds = toSet(self);
  if (HashSet_size(fiberIds) === 0) {
    return Option_none();
  }
  let first = true;
  let acc;
  for (const fiberId of fiberIds) {
    if (first) {
      acc = fiberId;
      first = false;
    } else {
      // @ts-expect-error
      acc = Function_pipe(acc, fiberId_combine(fiberId));
    }
  }
  // @ts-expect-error
  return Option_some(acc);
};
/** @internal */
const toSet = self => {
  switch (self._tag) {
    case OP_NONE:
      {
        return HashSet_empty();
      }
    case OP_RUNTIME:
      {
        return HashSet_make(self);
      }
    case OP_COMPOSITE:
      {
        return Function_pipe(toSet(self.left), HashSet_union(toSet(self.right)));
      }
  }
};
/** @internal */
const fiberId_unsafeMake = () => {
  const id = MutableRef_get(_fiberCounter);
  Function_pipe(_fiberCounter, MutableRef_set(id + 1));
  return new Runtime(id, Date.now());
};
//# sourceMappingURL=fiberId.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/FiberId.js

/**
 * @since 2.0.0
 * @category symbols
 */
const FiberId_FiberIdTypeId = FiberIdTypeId;
/**
 * @since 2.0.0
 * @category constructors
 */
const FiberId_none = fiberId_none;
/**
 * @since 2.0.0
 * @category constructors
 */
const FiberId_runtime = fiberId_runtime;
/**
 * @since 2.0.0
 * @category constructors
 */
const FiberId_composite = composite;
/**
 * Returns `true` if the specified unknown value is a `FiberId`, `false`
 * otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const FiberId_isFiberId = isFiberId;
/**
 * Returns `true` if the `FiberId` is a `None`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const FiberId_isNone = fiberId_isNone;
/**
 * Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const FiberId_isRuntime = isRuntime;
/**
 * Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const FiberId_isComposite = isComposite;
/**
 * Combine two `FiberId`s.
 *
 * @since 2.0.0
 * @category constructors
 */
const FiberId_combine = fiberId_combine;
/**
 * Combines a set of `FiberId`s into a single `FiberId`.
 *
 * @since 2.0.0
 * @category constructors
 */
const FiberId_combineAll = fiberId_combineAll;
/**
 * Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.
 *
 * @since 2.0.0
 * @category utils
 */
const FiberId_getOrElse = fiberId_getOrElse;
/**
 * Get the set of identifiers for this `FiberId`.
 *
 * @since 2.0.0
 * @category destructors
 */
const FiberId_ids = ids;
/**
 * Creates a new `FiberId`.
 *
 * @since 2.0.0
 * @category constructors
 */
const FiberId_make = fiberId_make;
/**
 * Creates a string representing the name of the current thread of execution
 * represented by the specified `FiberId`.
 *
 * @since 2.0.0
 * @category destructors
 */
const FiberId_threadName = threadName;
/**
 * Convert a `FiberId` into an `Option<FiberId>`.
 *
 * @since 2.0.0
 * @category destructors
 */
const FiberId_toOption = toOption;
/**
 * Convert a `FiberId` into a `HashSet<FiberId>`.
 *
 * @since 2.0.0
 * @category destructors
 */
const FiberId_toSet = toSet;
/**
 * Unsafely creates a new `FiberId`.
 *
 * @since 2.0.0
 * @category unsafe
 */
const FiberId_unsafeMake = fiberId_unsafeMake;
//# sourceMappingURL=FiberId.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/hashMap/keySet.js

/** @internal */
function keySet(self) {
  return hashSet_makeImpl(self);
}
//# sourceMappingURL=keySet.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/HashMap.js
/**
 * @since 2.0.0
 */


const HashMap_TypeId = HashMapTypeId;
/**
 * @since 2.0.0
 * @category refinements
 */
const HashMap_isHashMap = isHashMap;
/**
 * Creates a new `HashMap`.
 *
 * @since 2.0.0
 * @category constructors
 */
const HashMap_empty = internal_hashMap_empty;
/**
 * Constructs a new `HashMap` from an array of key/value pairs.
 *
 * @since 2.0.0
 * @category constructors
 */
const HashMap_make = hashMap_make;
/**
 * Creates a new `HashMap` from an iterable collection of key/value pairs.
 *
 * @since 2.0.0
 * @category constructors
 */
const HashMap_fromIterable = hashMap_fromIterable;
/**
 * Checks if the `HashMap` contains any entries.
 *
 * @since 2.0.0
 * @category elements
 */
const HashMap_isEmpty = hashMap_isEmpty;
/**
 * Safely lookup the value for the specified key in the `HashMap` using the
 * internal hashing function.
 *
 * @since 2.0.0
 * @category elements
 */
const HashMap_get = hashMap_get;
/**
 * Lookup the value for the specified key in the `HashMap` using a custom hash.
 *
 * @since 2.0.0
 * @category elements
 */
const HashMap_getHash = getHash;
/**
 * Unsafely lookup the value for the specified key in the `HashMap` using the
 * internal hashing function.
 *
 * @since 2.0.0
 * @category unsafe
 */
const HashMap_unsafeGet = hashMap_unsafeGet;
/**
 * Checks if the specified key has an entry in the `HashMap`.
 *
 * @since 2.0.0
 * @category elements
 */
const HashMap_has = hashMap_has;
/**
 * Checks if the specified key has an entry in the `HashMap` using a custom
 * hash.
 *
 * @since 2.0.0
 * @category elements
 */
const HashMap_hasHash = hasHash;
/**
 * Sets the specified key to the specified value using the internal hashing
 * function.
 *
 * @since 2.0.0
 */
const HashMap_set = hashMap_set;
/**
 * Returns an `IterableIterator` of the keys within the `HashMap`.
 *
 * @since 2.0.0
 * @category getters
 */
const HashMap_keys = hashMap_keys;
/**
 * Returns a `HashSet` of keys within the `HashMap`.
 *
 * @since 2.0.0
 * @category getter
 */
const HashMap_keySet = keySet;
/**
 * Returns an `IterableIterator` of the values within the `HashMap`.
 *
 * @since 2.0.0
 * @category getters
 */
const HashMap_values = hashMap_values;
/**
 * Returns an `IterableIterator` of the entries within the `HashMap`.
 *
 * @since 2.0.0
 * @category getters
 */
const HashMap_entries = entries;
/**
 * Returns an `Array<[K, V]>` of the entries within the `HashMap`.
 *
 * @since 2.0.0
 * @category getters
 */
const HashMap_toEntries = self => Array.from(HashMap_entries(self));
/**
 * Returns the number of entries within the `HashMap`.
 *
 * @since 2.0.0
 * @category getters
 */
const HashMap_size = hashMap_size;
/**
 * Marks the `HashMap` as mutable.
 *
 * @since 2.0.0
 */
const HashMap_beginMutation = beginMutation;
/**
 * Marks the `HashMap` as immutable.
 *
 * @since 2.0.0
 */
const HashMap_endMutation = endMutation;
/**
 * Mutates the `HashMap` within the context of the provided function.
 *
 * @since 2.0.0
 */
const HashMap_mutate = mutate;
/**
 * Set or remove the specified key in the `HashMap` using the specified
 * update function. The value of the specified key will be computed using the
 * provided hash.
 *
 * The update function will be invoked with the current value of the key if it
 * exists, or `None` if no such value exists.
 *
 * @since 2.0.0
 */
const HashMap_modifyAt = modifyAt;
/**
 * Alter the value of the specified key in the `HashMap` using the specified
 * update function. The value of the specified key will be computed using the
 * provided hash.
 *
 * The update function will be invoked with the current value of the key if it
 * exists, or `None` if no such value exists.
 *
 * This function will always either update or insert a value into the `HashMap`.
 *
 * @since 2.0.0
 */
const HashMap_modifyHash = modifyHash;
/**
 * Updates the value of the specified key within the `HashMap` if it exists.
 *
 * @since 2.0.0
 */
const HashMap_modify = hashMap_modify;
/**
 * Performs a union of this `HashMap` and that `HashMap`.
 *
 * @since 2.0.0
 */
const HashMap_union = hashMap_union;
/**
 * Remove the entry for the specified key in the `HashMap` using the internal
 * hashing function.
 *
 * @since 2.0.0
 */
const HashMap_remove = hashMap_remove;
/**
 * Removes all entries in the `HashMap` which have the specified keys.
 *
 * @since 2.0.0
 */
const HashMap_removeMany = removeMany;
/**
 * Maps over the entries of the `HashMap` using the specified function.
 *
 * @since 2.0.0
 * @category mapping
 */
const HashMap_map = hashMap_map;
/**
 * Chains over the entries of the `HashMap` using the specified function.
 *
 * **NOTE**: the hash and equal of both maps have to be the same.
 *
 * @since 2.0.0
 * @category sequencing
 */
const HashMap_flatMap = hashMap_flatMap;
/**
 * Applies the specified function to the entries of the `HashMap`.
 *
 * @since 2.0.0
 * @category traversing
 */
const HashMap_forEach = hashMap_forEach;
/**
 * Reduces the specified state over the entries of the `HashMap`.
 *
 * @since 2.0.0
 * @category folding
 */
const HashMap_reduce = hashMap_reduce;
/**
 * Filters entries out of a `HashMap` using the specified predicate.
 *
 * @since 2.0.0
 * @category filtering
 */
const HashMap_filter = hashMap_filter;
/**
 * Filters out `None` values from a `HashMap` of `Options`s.
 *
 * @since 2.0.0
 * @category filtering
 */
const HashMap_compact = hashMap_compact;
/**
 * Maps over the entries of the `HashMap` using the specified partial function
 * and filters out `None` values.
 *
 * @since 2.0.0
 * @category filtering
 */
const HashMap_filterMap = hashMap_filterMap;
/**
 * Returns the first element that satisfies the specified
 * predicate, or `None` if no such element exists.
 *
 * @category elements
 * @since 2.0.0
 */
const HashMap_findFirst = hashMap_findFirst;
//# sourceMappingURL=HashMap.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/List.js
/**
 * A data type for immutable linked lists representing ordered collections of elements of type `A`.
 *
 * This data type is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.
 *
 * **Performance**
 *
 * - Time: `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list. This includes the index-based lookup of elements, `length`, `append` and `reverse`.
 * - Space: `List` implements structural sharing of the tail list. This means that many operations are either zero- or constant-memory cost.
 *
 * @since 2.0.0
 */
/**
 * This file is ported from
 *
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 */











/**
 * @since 2.0.0
 * @category symbol
 */
const List_TypeId = /*#__PURE__*/Symbol.for("effect/List");
/**
 * Converts the specified `List` to an `Array`.
 *
 * @category conversions
 * @since 2.0.0
 */
const List_toArray = self => Array_fromIterable(self);
/**
 * @category equivalence
 * @since 2.0.0
 */
const List_getEquivalence = isEquivalent => Equivalence_mapInput(Array_getEquivalence(isEquivalent), List_toArray);
const List_equivalence = /*#__PURE__*/List_getEquivalence(equals);
const ConsProto = {
  [List_TypeId]: List_TypeId,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: List_toArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [Equal_symbol](that) {
    return isList(that) && this._tag === that._tag && List_equivalence(this, that);
  },
  [symbol]() {
    return cached(this, array(List_toArray(this)));
  },
  [Symbol.iterator]() {
    let done = false;
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let self = this;
    return {
      next() {
        if (done) {
          return this.return();
        }
        if (self._tag === "Nil") {
          done = true;
          return this.return();
        }
        const value = self.head;
        self = self.tail;
        return {
          done,
          value
        };
      },
      return(value) {
        if (!done) {
          done = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
const makeCons = (head, tail) => {
  const cons = Object.create(ConsProto);
  cons.head = head;
  cons.tail = tail;
  return cons;
};
const NilHash = /*#__PURE__*/string("Nil");
const NilProto = {
  [List_TypeId]: List_TypeId,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [Equal_symbol](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: undefined
        };
      }
    };
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
const _Nil = /*#__PURE__*/Object.create(NilProto);
/**
 * Returns `true` if the specified value is a `List`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const isList = u => Predicate_hasProperty(u, List_TypeId);
/**
 * Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const isNil = self => self._tag === "Nil";
/**
 * Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const isCons = self => self._tag === "Cons";
/**
 * Returns the number of elements contained in the specified `List`
 *
 * @since 2.0.0
 * @category getters
 */
const List_size = self => {
  let these = self;
  let len = 0;
  while (!isNil(these)) {
    len += 1;
    these = these.tail;
  }
  return len;
};
/**
 * Constructs a new empty `List<A>`.
 *
 * @since 2.0.0
 * @category constructors
 */
const nil = () => _Nil;
/**
 * Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.
 *
 * @since 2.0.0
 * @category constructors
 */
const cons = (head, tail) => makeCons(head, tail);
/**
 * Constructs a new empty `List<A>`.
 *
 * Alias of {@link nil}.
 *
 * @since 2.0.0
 * @category constructors
 */
const List_empty = nil;
/**
 * Constructs a new `List<A>` from the specified value.
 *
 * @since 2.0.0
 * @category constructors
 */
const List_of = value => makeCons(value, _Nil);
/**
 * Creates a new `List` from an iterable collection of values.
 *
 * @since 2.0.0
 * @category constructors
 */
const List_fromIterable = prefix => {
  const iterator = prefix[Symbol.iterator]();
  let next;
  if ((next = iterator.next()) && !next.done) {
    const result = makeCons(next.value, _Nil);
    let curr = result;
    while ((next = iterator.next()) && !next.done) {
      const temp = makeCons(next.value, _Nil);
      curr.tail = temp;
      curr = temp;
    }
    return result;
  } else {
    return _Nil;
  }
};
/**
 * Constructs a new `List<A>` from the specified values.
 *
 * @since 2.0.0
 * @category constructors
 */
const List_make = (...elements) => List_fromIterable(elements);
/**
 * Appends the specified element to the end of the `List`, creating a new `Cons`.
 *
 * @category concatenating
 * @since 2.0.0
 */
const List_append = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, element) => List_appendAll(self, List_of(element)))));
/**
 * Concatenates two lists, combining their elements.
 * If either list is non-empty, the result is also a non-empty list.
 *
 * @example
 * import { List } from "effect"
 *
 * assert.deepStrictEqual(
 *   List.make(1, 2).pipe(List.appendAll(List.make("a", "b")), List.toArray),
 *   [1, 2, "a", "b"]
 * )
 *
 * @category concatenating
 * @since 2.0.0
 */
const List_appendAll = /*#__PURE__*/Function_dual(2, (self, that) => List_prependAll(that, self));
/**
 * Prepends the specified element to the beginning of the list.
 *
 * @category concatenating
 * @since 2.0.0
 */
const List_prepend = /*#__PURE__*/Function_dual(2, (self, element) => cons(element, self));
/**
 * Prepends the specified prefix list to the beginning of the specified list.
 * If either list is non-empty, the result is also a non-empty list.
 *
 * @example
 * import { List } from "effect"
 *
 * assert.deepStrictEqual(
 *   List.make(1, 2).pipe(List.prependAll(List.make("a", "b")), List.toArray),
 *   ["a", "b", 1, 2]
 * )
 *
 * @category concatenating
 * @since 2.0.0
 */
const List_prependAll = /*#__PURE__*/Function_dual(2, (self, prefix) => {
  if (isNil(self)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self;
  } else {
    const result = makeCons(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
/**
 * Prepends the specified prefix list (in reverse order) to the beginning of the
 * specified list.
 *
 * @category concatenating
 * @since 2.0.0
 */
const prependAllReversed = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, prefix) => {
  let out = self;
  let pres = prefix;
  while (isCons(pres)) {
    out = makeCons(pres.head, out);
    pres = pres.tail;
  }
  return out;
})));
/**
 * Drops the first `n` elements from the specified list.
 *
 * @since 2.0.0
 * @category combinators
 */
const List_drop = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  }
  if (n >= List_size(self)) {
    return _Nil;
  }
  let these = self;
  let i = 0;
  while (!isNil(these) && i < n) {
    these = these.tail;
    i += 1;
  }
  return these;
})));
/**
 * Check if a predicate holds true for every `List` element.
 *
 * @since 2.0.0
 * @category elements
 */
const List_every = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, refinement) => {
  for (const a of self) {
    if (!refinement(a)) {
      return false;
    }
  }
  return true;
})));
/**
 * Check if a predicate holds true for some `List` element.
 *
 * @since 2.0.0
 * @category elements
 */
const List_some = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  let these = self;
  while (!isNil(these)) {
    if (predicate(these.head)) {
      return true;
    }
    these = these.tail;
  }
  return false;
})));
/**
 * Filters a list using the specified predicate.
 *
 * @since 2.0.0
 * @category combinators
 */
const List_filter = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => noneIn(self, predicate, false))));
// everything seen so far is not included
const noneIn = (self, predicate, isFlipped) => {
  /* eslint-disable no-constant-condition */
  while (true) {
    if (isNil(self)) {
      return _Nil;
    } else {
      if (predicate(self.head) !== isFlipped) {
        return allIn(self, self.tail, predicate, isFlipped);
      } else {
        self = self.tail;
      }
    }
  }
};
// everything from 'start' is included, if everything from this point is in we can return the origin
// start otherwise if we discover an element that is out we must create a new partial list.
const allIn = (start, remaining, predicate, isFlipped) => {
  /* eslint-disable no-constant-condition */
  while (true) {
    if (isNil(remaining)) {
      return start;
    } else {
      if (predicate(remaining.head) !== isFlipped) {
        remaining = remaining.tail;
      } else {
        return partialFill(start, remaining, predicate, isFlipped);
      }
    }
  }
};
// we have seen elements that should be included then one that should be excluded, start building
const partialFill = (origStart, firstMiss, predicate, isFlipped) => {
  const newHead = makeCons(List_unsafeHead(origStart), _Nil);
  let toProcess = unsafeTail(origStart);
  let currentLast = newHead;
  // we know that all elements are :: until at least firstMiss.tail
  while (!(toProcess === firstMiss)) {
    const newElem = makeCons(List_unsafeHead(toProcess), _Nil);
    currentLast.tail = newElem;
    currentLast = unsafeCoerce(newElem);
    toProcess = unsafeCoerce(toProcess.tail);
  }
  // at this point newHead points to a list which is a duplicate of all the 'in' elements up to the first miss.
  // currentLast is the last element in that list.
  // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.
  let next = firstMiss.tail;
  let nextToCopy = unsafeCoerce(next); // the next element we would need to copy to our list if we cant share.
  while (!isNil(next)) {
    // generally recommended is next.isNonEmpty but this incurs an extra method call.
    const head = List_unsafeHead(next);
    if (predicate(head) !== isFlipped) {
      next = next.tail;
    } else {
      // its not a match - do we have outstanding elements?
      while (!(nextToCopy === next)) {
        const newElem = makeCons(List_unsafeHead(nextToCopy), _Nil);
        currentLast.tail = newElem;
        currentLast = newElem;
        nextToCopy = unsafeCoerce(nextToCopy.tail);
      }
      nextToCopy = unsafeCoerce(next.tail);
      next = next.tail;
    }
  }
  // we have remaining elements - they are unchanged attach them to the end
  if (!isNil(nextToCopy)) {
    currentLast.tail = nextToCopy;
  }
  return newHead;
};
/**
 * Filters and maps a list using the specified partial function. The resulting
 * list may be smaller than the input list due to the possibility of the partial
 * function not being defined for some elements.
 *
 * @since 2.0.0
 * @category combinators
 */
const List_filterMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const bs = [];
  for (const a of self) {
    const oa = f(a);
    if (Option.isSome(oa)) {
      bs.push(oa.value);
    }
  }
  return List_fromIterable(bs);
})));
/**
 * Removes all `None` values from the specified list.
 *
 * @since 2.0.0
 * @category combinators
 */
const List_compact = self => List_filterMap(self, identity);
/**
 * Returns the first element that satisfies the specified
 * predicate, or `None` if no such element exists.
 *
 * @category elements
 * @since 2.0.0
 */
const List_findFirst = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  let these = self;
  while (!isNil(these)) {
    if (predicate(these.head)) {
      return Option.some(these.head);
    }
    these = these.tail;
  }
  return Option.none();
})));
/**
 * Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.
 *
 * @since 2.0.0
 * @category sequencing
 */
const List_flatMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  let rest = self;
  let head = undefined;
  let tail = undefined;
  while (!isNil(rest)) {
    let bs = f(rest.head);
    while (!isNil(bs)) {
      const next = makeCons(bs.head, _Nil);
      if (tail === undefined) {
        head = next;
      } else {
        tail.tail = next;
      }
      tail = next;
      bs = bs.tail;
    }
    rest = rest.tail;
  }
  if (head === undefined) {
    return _Nil;
  }
  return head;
})));
/**
 * Applies the specified function to each element of the `List`.
 *
 * @since 2.0.0
 * @category combinators
 */
const List_forEach = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  let these = self;
  while (!isNil(these)) {
    f(these.head);
    these = these.tail;
  }
})));
/**
 * Returns the first element of the specified list, or `None` if the list is
 * empty.
 *
 * @since 2.0.0
 * @category getters
 */
const List_head = self => isNil(self) ? Option.none() : Option.some(self.head);
/**
 * Returns the last element of the specified list, or `None` if the list is
 * empty.
 *
 * @since 2.0.0
 * @category getters
 */
const List_last = self => isNil(self) ? Option.none() : Option.some(List_unsafeLast(self));
/**
 * Applies the specified mapping function to each element of the list.
 *
 * @since 2.0.0
 * @category mapping
 */
const List_map = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  if (isNil(self)) {
    return self;
  } else {
    let i = 0;
    const head = makeCons(f(self.head, i++), _Nil);
    let nextHead = head;
    let rest = self.tail;
    while (!isNil(rest)) {
      const next = makeCons(f(rest.head, i++), _Nil);
      nextHead.tail = next;
      nextHead = next;
      rest = rest.tail;
    }
    return head;
  }
})));
/**
 * Partition a list into two lists, where the first list contains all elements
 * that did not satisfy the specified predicate, and the second list contains
 * all elements that did satisfy the specified predicate.
 *
 * @since 2.0.0
 * @category combinators
 */
const List_partition = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => {
  const left = [];
  const right = [];
  for (const a of self) {
    if (predicate(a)) {
      right.push(a);
    } else {
      left.push(a);
    }
  }
  return [List_fromIterable(left), List_fromIterable(right)];
})));
/**
 * Partition a list into two lists, where the first list contains all elements
 * for which the specified function returned a `Left`, and the second list
 * contains all elements for which the specified function returned a `Right`.
 *
 * @since 2.0.0
 * @category combinators
 */
const List_partitionMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const left = [];
  const right = [];
  for (const a of self) {
    const e = f(a);
    if (Either.isLeft(e)) {
      left.push(e.left);
    } else {
      right.push(e.right);
    }
  }
  return [List_fromIterable(left), List_fromIterable(right)];
})));
/**
 * Folds over the elements of the list using the specified function, using the
 * specified initial value.
 *
 * @since 2.0.0
 * @category folding
 */
const List_reduce = /*#__PURE__*/Function_dual(3, (self, zero, f) => {
  let acc = zero;
  let these = self;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
/**
 * Folds over the elements of the list using the specified function, beginning
 * with the last element of the list, using the specified initial value.
 *
 * @since 2.0.0
 * @category folding
 */
const List_reduceRight = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, zero, f) => {
  let acc = zero;
  let these = List_reverse(self);
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
})));
/**
 * Returns a new list with the elements of the specified list in reverse order.
 *
 * @since 2.0.0
 * @category elements
 */
const List_reverse = self => {
  let result = List_empty();
  let these = self;
  while (!isNil(these)) {
    result = List_prepend(result, these.head);
    these = these.tail;
  }
  return result;
};
/**
 * Splits the specified list into two lists at the specified index.
 *
 * @since 2.0.0
 * @category combinators
 */
const List_splitAt = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => [List_take(self, n), List_drop(self, n)])));
/**
 * Returns the tail of the specified list, or `None` if the list is empty.
 *
 * @since 2.0.0
 * @category getters
 */
const List_tail = self => isNil(self) ? Option.none() : Option.some(self.tail);
/**
 * Takes the specified number of elements from the beginning of the specified
 * list.
 *
 * @since 2.0.0
 * @category combinators
 */
const List_take = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, n) => {
  if (n <= 0) {
    return _Nil;
  }
  if (n >= List_size(self)) {
    return self;
  }
  let these = List_make(List_unsafeHead(self));
  let current = unsafeTail(self);
  for (let i = 1; i < n; i++) {
    these = makeCons(List_unsafeHead(current), these);
    current = unsafeTail(current);
  }
  return List_reverse(these);
})));
/**
 * Converts the specified `List` to a `Chunk`.
 *
 * @since 2.0.0
 * @category conversions
 */
const toChunk = self => Chunk.fromIterable(self);
const getExpectedListToBeNonEmptyErrorMessage = "Expected List to be non-empty";
/**
 * Unsafely returns the first element of the specified `List`.
 *
 * @since 2.0.0
 * @category unsafe
 */
const List_unsafeHead = self => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  return self.head;
};
/**
 * Unsafely returns the last element of the specified `List`.
 *
 * @since 2.0.0
 * @category unsafe
 */
const List_unsafeLast = self => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  let these = self;
  let scout = self.tail;
  while (!isNil(scout)) {
    these = scout;
    scout = scout.tail;
  }
  return these.head;
};
/**
 * Unsafely returns the tail of the specified `List`.
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeTail = self => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  return self.tail;
};
//# sourceMappingURL=List.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/data.js



/** @internal */
const ArrayProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array(this));
  },
  [Equal_symbol](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
/** @internal */
const Structural = /*#__PURE__*/function () {
  function Structural(args) {
    if (args) {
      Object.assign(this, args);
    }
  }
  Structural.prototype = StructuralPrototype;
  return Structural;
}();
/** @internal */
const data_struct = as => Object.assign(Object.create(StructuralPrototype), as);
//# sourceMappingURL=data.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/differ/chunkPatch.js





/** @internal */
const ChunkPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferChunkPatch");
function variance(a) {
  return a;
}
const PatchProto = {
  ...Structural.prototype,
  [ChunkPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};
const EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {
  _tag: "Empty"
});
const chunkPatch_empty = /*#__PURE__*/Object.create(EmptyProto);
/**
 * @internal
 */
const differ_chunkPatch_empty = () => chunkPatch_empty;
const AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {
  _tag: "AndThen"
});
const makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
const AppendProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {
  _tag: "Append"
});
const makeAppend = values => {
  const o = Object.create(AppendProto);
  o.values = values;
  return o;
};
const SliceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {
  _tag: "Slice"
});
const makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
const UpdateProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {
  _tag: "Update"
});
const makeUpdate = (index, patch) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch;
  return o;
};
/** @internal */
const diff = options => {
  let i = 0;
  let patch = differ_chunkPatch_empty();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = Chunk_unsafeGet(i)(options.oldValue);
    const newElement = Chunk_unsafeGet(i)(options.newValue);
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch = Function_pipe(patch, chunkPatch_combine(makeUpdate(i, valuePatch)));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch = Function_pipe(patch, chunkPatch_combine(makeSlice(0, i)));
  }
  if (i < options.newValue.length) {
    patch = Function_pipe(patch, chunkPatch_combine(makeAppend(Chunk_drop(i)(options.newValue))));
  }
  return patch;
};
/** @internal */
const chunkPatch_combine = /*#__PURE__*/Function_dual(2, (self, that) => makeAndThen(self, that));
/** @internal */
const chunkPatch_patch = /*#__PURE__*/Function_dual(3, (self, oldValue, differ) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let chunk = oldValue;
  let patches = Chunk_of(self);
  while (isNonEmpty(patches)) {
    const head = Chunk_headNonEmpty(patches);
    const tail = Chunk_tailNonEmpty(patches);
    switch (head._tag) {
      case "Empty":
        {
          patches = tail;
          break;
        }
      case "AndThen":
        {
          patches = Chunk_prepend(head.first)(Chunk_prepend(head.second)(tail));
          break;
        }
      case "Append":
        {
          chunk = Chunk_appendAll(head.values)(chunk);
          patches = tail;
          break;
        }
      case "Slice":
        {
          const array = toReadonlyArray(chunk);
          chunk = unsafeFromArray(array.slice(head.from, head.until));
          patches = tail;
          break;
        }
      case "Update":
        {
          const array = toReadonlyArray(chunk);
          array[head.index] = differ.patch(head.patch, array[head.index]);
          chunk = unsafeFromArray(array);
          patches = tail;
          break;
        }
    }
  }
  return chunk;
});
//# sourceMappingURL=chunkPatch.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/differ/contextPatch.js





/** @internal */
const ContextPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferContextPatch");
function contextPatch_variance(a) {
  return a;
}
/** @internal */
const contextPatch_PatchProto = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: contextPatch_variance,
    _Patch: contextPatch_variance
  }
};
const contextPatch_EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(contextPatch_PatchProto), {
  _tag: "Empty"
});
const contextPatch_empty = /*#__PURE__*/Object.create(contextPatch_EmptyProto);
/**
 * @internal
 */
const differ_contextPatch_empty = () => contextPatch_empty;
const contextPatch_AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(contextPatch_PatchProto), {
  _tag: "AndThen"
});
const contextPatch_makeAndThen = (first, second) => {
  const o = Object.create(contextPatch_AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
const AddServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(contextPatch_PatchProto), {
  _tag: "AddService"
});
const makeAddService = (key, service) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service;
  return o;
};
const RemoveServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(contextPatch_PatchProto), {
  _tag: "RemoveService"
});
const makeRemoveService = key => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
const UpdateServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(contextPatch_PatchProto), {
  _tag: "UpdateService"
});
const makeUpdateService = (key, update) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update;
  return o;
};
/** @internal */
const contextPatch_diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch = differ_contextPatch_empty();
  for (const [tag, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag)) {
      const old = missingServices.get(tag);
      missingServices.delete(tag);
      if (!equals(old, newService)) {
        patch = contextPatch_combine(makeUpdateService(tag, () => newService))(patch);
      }
    } else {
      missingServices.delete(tag);
      patch = contextPatch_combine(makeAddService(tag, newService))(patch);
    }
  }
  for (const [tag] of missingServices.entries()) {
    patch = contextPatch_combine(makeRemoveService(tag))(patch);
  }
  return patch;
};
/** @internal */
const contextPatch_combine = /*#__PURE__*/Function_dual(2, (self, that) => contextPatch_makeAndThen(self, that));
/** @internal */
const contextPatch_patch = /*#__PURE__*/Function_dual(2, (self, context) => {
  if (self._tag === "Empty") {
    return context;
  }
  let wasServiceUpdated = false;
  let patches = Chunk_of(self);
  const updatedContext = new Map(context.unsafeMap);
  while (isNonEmpty(patches)) {
    const head = Chunk_headNonEmpty(patches);
    const tail = Chunk_tailNonEmpty(patches);
    switch (head._tag) {
      case "Empty":
        {
          patches = tail;
          break;
        }
      case "AddService":
        {
          updatedContext.set(head.key, head.service);
          patches = tail;
          break;
        }
      case "AndThen":
        {
          patches = Chunk_prepend(Chunk_prepend(tail, head.second), head.first);
          break;
        }
      case "RemoveService":
        {
          updatedContext.delete(head.key);
          patches = tail;
          break;
        }
      case "UpdateService":
        {
          updatedContext.set(head.key, head.update(updatedContext.get(head.key)));
          wasServiceUpdated = true;
          patches = tail;
          break;
        }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map = new Map();
  for (const [tag] of context.unsafeMap) {
    if (updatedContext.has(tag)) {
      map.set(tag, updatedContext.get(tag));
      updatedContext.delete(tag);
    }
  }
  for (const [tag, s] of updatedContext) {
    map.set(tag, s);
  }
  return makeContext(map);
});
//# sourceMappingURL=contextPatch.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/differ/hashMapPatch.js





/** @internal */
const HashMapPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferHashMapPatch");
function hashMapPatch_variance(a) {
  return a;
}
/** @internal */
const hashMapPatch_PatchProto = {
  ...Structural.prototype,
  [HashMapPatchTypeId]: {
    _Value: hashMapPatch_variance,
    _Key: hashMapPatch_variance,
    _Patch: hashMapPatch_variance
  }
};
const hashMapPatch_EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(hashMapPatch_PatchProto), {
  _tag: "Empty"
});
const hashMapPatch_empty = /*#__PURE__*/Object.create(hashMapPatch_EmptyProto);
/** @internal */
const differ_hashMapPatch_empty = () => hashMapPatch_empty;
const hashMapPatch_AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(hashMapPatch_PatchProto), {
  _tag: "AndThen"
});
const hashMapPatch_makeAndThen = (first, second) => {
  const o = Object.create(hashMapPatch_AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
const AddProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(hashMapPatch_PatchProto), {
  _tag: "Add"
});
const makeAdd = (key, value) => {
  const o = Object.create(AddProto);
  o.key = key;
  o.value = value;
  return o;
};
const RemoveProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(hashMapPatch_PatchProto), {
  _tag: "Remove"
});
const makeRemove = key => {
  const o = Object.create(RemoveProto);
  o.key = key;
  return o;
};
const hashMapPatch_UpdateProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(hashMapPatch_PatchProto), {
  _tag: "Update"
});
const hashMapPatch_makeUpdate = (key, patch) => {
  const o = Object.create(hashMapPatch_UpdateProto);
  o.key = key;
  o.patch = patch;
  return o;
};
/** @internal */
const hashMapPatch_diff = options => {
  const [removed, patch] = HashMap_reduce([options.oldValue, differ_hashMapPatch_empty()], ([map, patch], newValue, key) => {
    const option = HashMap_get(key)(map);
    switch (option._tag) {
      case "Some":
        {
          const valuePatch = options.differ.diff(option.value, newValue);
          if (equals(valuePatch, options.differ.empty)) {
            return [HashMap_remove(key)(map), patch];
          }
          return [HashMap_remove(key)(map), hashMapPatch_combine(hashMapPatch_makeUpdate(key, valuePatch))(patch)];
        }
      case "None":
        {
          return [map, hashMapPatch_combine(makeAdd(key, newValue))(patch)];
        }
    }
  })(options.newValue);
  return HashMap_reduce(patch, (patch, _, key) => hashMapPatch_combine(makeRemove(key))(patch))(removed);
};
/** @internal */
const hashMapPatch_combine = /*#__PURE__*/Function_dual(2, (self, that) => hashMapPatch_makeAndThen(self, that));
/** @internal */
const hashMapPatch_patch = /*#__PURE__*/Function_dual(3, (self, oldValue, differ) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let map = oldValue;
  let patches = Chunk_of(self);
  while (isNonEmpty(patches)) {
    const head = Chunk_headNonEmpty(patches);
    const tail = Chunk_tailNonEmpty(patches);
    switch (head._tag) {
      case "Empty":
        {
          patches = tail;
          break;
        }
      case "AndThen":
        {
          patches = Chunk_prepend(head.first)(Chunk_prepend(head.second)(tail));
          break;
        }
      case "Add":
        {
          map = HashMap_set(head.key, head.value)(map);
          patches = tail;
          break;
        }
      case "Remove":
        {
          map = HashMap_remove(head.key)(map);
          patches = tail;
          break;
        }
      case "Update":
        {
          const option = HashMap_get(head.key)(map);
          if (option._tag === "Some") {
            map = HashMap_set(head.key, differ.patch(head.patch, option.value))(map);
          }
          patches = tail;
          break;
        }
    }
  }
  return map;
});
//# sourceMappingURL=hashMapPatch.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/differ/hashSetPatch.js




/** @internal */
const HashSetPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferHashSetPatch");
function hashSetPatch_variance(a) {
  return a;
}
/** @internal */
const hashSetPatch_PatchProto = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: hashSetPatch_variance,
    _Key: hashSetPatch_variance,
    _Patch: hashSetPatch_variance
  }
};
const hashSetPatch_EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(hashSetPatch_PatchProto), {
  _tag: "Empty"
});
const hashSetPatch_empty = /*#__PURE__*/Object.create(hashSetPatch_EmptyProto);
/** @internal */
const differ_hashSetPatch_empty = () => hashSetPatch_empty;
const hashSetPatch_AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(hashSetPatch_PatchProto), {
  _tag: "AndThen"
});
/** @internal */
const hashSetPatch_makeAndThen = (first, second) => {
  const o = Object.create(hashSetPatch_AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
const hashSetPatch_AddProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(hashSetPatch_PatchProto), {
  _tag: "Add"
});
/** @internal */
const hashSetPatch_makeAdd = value => {
  const o = Object.create(hashSetPatch_AddProto);
  o.value = value;
  return o;
};
const hashSetPatch_RemoveProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(hashSetPatch_PatchProto), {
  _tag: "Remove"
});
/** @internal */
const hashSetPatch_makeRemove = value => {
  const o = Object.create(hashSetPatch_RemoveProto);
  o.value = value;
  return o;
};
/** @internal */
const hashSetPatch_diff = (oldValue, newValue) => {
  const [removed, patch] = HashSet_reduce([oldValue, differ_hashSetPatch_empty()], ([set, patch], value) => {
    if (HashSet_has(value)(set)) {
      return [HashSet_remove(value)(set), patch];
    }
    return [set, hashSetPatch_combine(hashSetPatch_makeAdd(value))(patch)];
  })(newValue);
  return HashSet_reduce(patch, (patch, value) => hashSetPatch_combine(hashSetPatch_makeRemove(value))(patch))(removed);
};
/** @internal */
const hashSetPatch_combine = /*#__PURE__*/Function_dual(2, (self, that) => hashSetPatch_makeAndThen(self, that));
/** @internal */
const hashSetPatch_patch = /*#__PURE__*/Function_dual(2, (self, oldValue) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let set = oldValue;
  let patches = Chunk_of(self);
  while (isNonEmpty(patches)) {
    const head = Chunk_headNonEmpty(patches);
    const tail = Chunk_tailNonEmpty(patches);
    switch (head._tag) {
      case "Empty":
        {
          patches = tail;
          break;
        }
      case "AndThen":
        {
          patches = Chunk_prepend(head.first)(Chunk_prepend(head.second)(tail));
          break;
        }
      case "Add":
        {
          set = HashSet_add(head.value)(set);
          patches = tail;
          break;
        }
      case "Remove":
        {
          set = HashSet_remove(head.value)(set);
          patches = tail;
        }
    }
  }
  return set;
});
//# sourceMappingURL=hashSetPatch.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/differ/orPatch.js





/** @internal */
const OrPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferOrPatch");
function orPatch_variance(a) {
  return a;
}
/** @internal */
const orPatch_PatchProto = {
  ...Structural.prototype,
  [OrPatchTypeId]: {
    _Value: orPatch_variance,
    _Key: orPatch_variance,
    _Patch: orPatch_variance
  }
};
const orPatch_EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(orPatch_PatchProto), {
  _tag: "Empty"
});
const orPatch_empty = /*#__PURE__*/Object.create(orPatch_EmptyProto);
/** @internal */
const differ_orPatch_empty = () => orPatch_empty;
const orPatch_AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(orPatch_PatchProto), {
  _tag: "AndThen"
});
/** @internal */
const orPatch_makeAndThen = (first, second) => {
  const o = Object.create(orPatch_AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
const SetLeftProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(orPatch_PatchProto), {
  _tag: "SetLeft"
});
/** @internal */
const makeSetLeft = value => {
  const o = Object.create(SetLeftProto);
  o.value = value;
  return o;
};
const SetRightProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(orPatch_PatchProto), {
  _tag: "SetRight"
});
/** @internal */
const makeSetRight = value => {
  const o = Object.create(SetRightProto);
  o.value = value;
  return o;
};
const UpdateLeftProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(orPatch_PatchProto), {
  _tag: "UpdateLeft"
});
/** @internal */
const makeUpdateLeft = patch => {
  const o = Object.create(UpdateLeftProto);
  o.patch = patch;
  return o;
};
const UpdateRightProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(orPatch_PatchProto), {
  _tag: "UpdateRight"
});
/** @internal */
const makeUpdateRight = patch => {
  const o = Object.create(UpdateRightProto);
  o.patch = patch;
  return o;
};
/** @internal */
const orPatch_diff = options => {
  switch (options.oldValue._tag) {
    case "Left":
      {
        switch (options.newValue._tag) {
          case "Left":
            {
              const valuePatch = options.left.diff(options.oldValue.left, options.newValue.left);
              if (equals(valuePatch, options.left.empty)) {
                return differ_orPatch_empty();
              }
              return makeUpdateLeft(valuePatch);
            }
          case "Right":
            {
              return makeSetRight(options.newValue.right);
            }
        }
      }
    case "Right":
      {
        switch (options.newValue._tag) {
          case "Left":
            {
              return makeSetLeft(options.newValue.left);
            }
          case "Right":
            {
              const valuePatch = options.right.diff(options.oldValue.right, options.newValue.right);
              if (equals(valuePatch, options.right.empty)) {
                return differ_orPatch_empty();
              }
              return makeUpdateRight(valuePatch);
            }
        }
      }
  }
};
/** @internal */
const orPatch_combine = /*#__PURE__*/Function_dual(2, (self, that) => orPatch_makeAndThen(self, that));
/** @internal */
const orPatch_patch = /*#__PURE__*/Function_dual(2, (self, {
  left,
  oldValue,
  right
}) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let patches = Chunk_of(self);
  let result = oldValue;
  while (isNonEmpty(patches)) {
    const head = Chunk_headNonEmpty(patches);
    const tail = Chunk_tailNonEmpty(patches);
    switch (head._tag) {
      case "Empty":
        {
          patches = tail;
          break;
        }
      case "AndThen":
        {
          patches = Chunk_prepend(head.first)(Chunk_prepend(head.second)(tail));
          break;
        }
      case "UpdateLeft":
        {
          if (result._tag === "Left") {
            result = Either_left(left.patch(head.patch, result.left));
          }
          patches = tail;
          break;
        }
      case "UpdateRight":
        {
          if (result._tag === "Right") {
            result = Either_right(right.patch(head.patch, result.right));
          }
          patches = tail;
          break;
        }
      case "SetLeft":
        {
          result = Either_left(head.value);
          patches = tail;
          break;
        }
      case "SetRight":
        {
          result = Either_right(head.value);
          patches = tail;
          break;
        }
    }
  }
  return result;
});
//# sourceMappingURL=orPatch.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js




/** @internal */
const ReadonlyArrayPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferReadonlyArrayPatch");
function readonlyArrayPatch_variance(a) {
  return a;
}
const readonlyArrayPatch_PatchProto = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: readonlyArrayPatch_variance,
    _Patch: readonlyArrayPatch_variance
  }
};
const readonlyArrayPatch_EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(readonlyArrayPatch_PatchProto), {
  _tag: "Empty"
});
const readonlyArrayPatch_empty = /*#__PURE__*/Object.create(readonlyArrayPatch_EmptyProto);
/**
 * @internal
 */
const differ_readonlyArrayPatch_empty = () => readonlyArrayPatch_empty;
const readonlyArrayPatch_AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(readonlyArrayPatch_PatchProto), {
  _tag: "AndThen"
});
const readonlyArrayPatch_makeAndThen = (first, second) => {
  const o = Object.create(readonlyArrayPatch_AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
const readonlyArrayPatch_AppendProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(readonlyArrayPatch_PatchProto), {
  _tag: "Append"
});
const readonlyArrayPatch_makeAppend = values => {
  const o = Object.create(readonlyArrayPatch_AppendProto);
  o.values = values;
  return o;
};
const readonlyArrayPatch_SliceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(readonlyArrayPatch_PatchProto), {
  _tag: "Slice"
});
const readonlyArrayPatch_makeSlice = (from, until) => {
  const o = Object.create(readonlyArrayPatch_SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
const readonlyArrayPatch_UpdateProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(readonlyArrayPatch_PatchProto), {
  _tag: "Update"
});
const readonlyArrayPatch_makeUpdate = (index, patch) => {
  const o = Object.create(readonlyArrayPatch_UpdateProto);
  o.index = index;
  o.patch = patch;
  return o;
};
/** @internal */
const readonlyArrayPatch_diff = options => {
  let i = 0;
  let patch = differ_readonlyArrayPatch_empty();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch = readonlyArrayPatch_combine(patch, readonlyArrayPatch_makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch = readonlyArrayPatch_combine(patch, readonlyArrayPatch_makeSlice(0, i));
  }
  if (i < options.newValue.length) {
    patch = readonlyArrayPatch_combine(patch, readonlyArrayPatch_makeAppend(Array_drop(i)(options.newValue)));
  }
  return patch;
};
/** @internal */
const readonlyArrayPatch_combine = /*#__PURE__*/Function_dual(2, (self, that) => readonlyArrayPatch_makeAndThen(self, that));
/** @internal */
const readonlyArrayPatch_patch = /*#__PURE__*/Function_dual(3, (self, oldValue, differ) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray = oldValue.slice();
  let patches = Array_of(self);
  while (Array_isNonEmptyArray(patches)) {
    const head = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head._tag) {
      case "Empty":
        {
          patches = tail;
          break;
        }
      case "AndThen":
        {
          tail.unshift(head.first, head.second);
          patches = tail;
          break;
        }
      case "Append":
        {
          for (const value of head.values) {
            readonlyArray.push(value);
          }
          patches = tail;
          break;
        }
      case "Slice":
        {
          readonlyArray = readonlyArray.slice(head.from, head.until);
          patches = tail;
          break;
        }
      case "Update":
        {
          readonlyArray[head.index] = differ.patch(head.patch, readonlyArray[head.index]);
          patches = tail;
          break;
        }
    }
  }
  return readonlyArray;
});
//# sourceMappingURL=readonlyArrayPatch.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/differ.js









/** @internal */
const DifferTypeId = /*#__PURE__*/Symbol.for("effect/Differ");
/** @internal */
const DifferProto = {
  [DifferTypeId]: {
    _P: Function_identity,
    _V: Function_identity
  }
};
/** @internal */
const differ_make = params => {
  const differ = Object.create(DifferProto);
  differ.empty = params.empty;
  differ.diff = params.diff;
  differ.combine = params.combine;
  differ.patch = params.patch;
  return differ;
};
/** @internal */
const environment = () => differ_make({
  empty: differ_contextPatch_empty(),
  combine: (first, second) => contextPatch_combine(second)(first),
  diff: (oldValue, newValue) => contextPatch_diff(oldValue, newValue),
  patch: (patch, oldValue) => contextPatch_patch(oldValue)(patch)
});
/** @internal */
const chunk = differ => differ_make({
  empty: differ_chunkPatch_empty(),
  combine: (first, second) => chunkPatch_combine(second)(first),
  diff: (oldValue, newValue) => diff({
    oldValue,
    newValue,
    differ
  }),
  patch: (patch, oldValue) => chunkPatch_patch(oldValue, differ)(patch)
});
/** @internal */
const hashMap = differ => differ_make({
  empty: differ_hashMapPatch_empty(),
  combine: (first, second) => hashMapPatch_combine(second)(first),
  diff: (oldValue, newValue) => hashMapPatch_diff({
    oldValue,
    newValue,
    differ
  }),
  patch: (patch, oldValue) => hashMapPatch_patch(oldValue, differ)(patch)
});
/** @internal */
const hashSet = () => differ_make({
  empty: differ_hashSetPatch_empty(),
  combine: (first, second) => hashSetPatch_combine(second)(first),
  diff: (oldValue, newValue) => hashSetPatch_diff(oldValue, newValue),
  patch: (patch, oldValue) => hashSetPatch_patch(oldValue)(patch)
});
/** @internal */
const differ_orElseEither = /*#__PURE__*/Function_dual(2, (self, that) => differ_make({
  empty: differ_orPatch_empty(),
  combine: (first, second) => orPatch_combine(first, second),
  diff: (oldValue, newValue) => orPatch_diff({
    oldValue,
    newValue,
    left: self,
    right: that
  }),
  patch: (patch, oldValue) => orPatch_patch(patch, {
    oldValue,
    left: self,
    right: that
  })
}));
/** @internal */
const differ_readonlyArray = differ => differ_make({
  empty: differ_readonlyArrayPatch_empty(),
  combine: (first, second) => readonlyArrayPatch_combine(first, second),
  diff: (oldValue, newValue) => readonlyArrayPatch_diff({
    oldValue,
    newValue,
    differ
  }),
  patch: (patch, oldValue) => readonlyArrayPatch_patch(patch, oldValue, differ)
});
/** @internal */
const transform = /*#__PURE__*/Function_dual(2, (self, {
  toNew,
  toOld
}) => differ_make({
  empty: self.empty,
  combine: (first, second) => self.combine(first, second),
  diff: (oldValue, newValue) => self.diff(toOld(oldValue), toOld(newValue)),
  patch: (patch, oldValue) => toNew(self.patch(patch, toOld(oldValue)))
}));
/** @internal */
const differ_update = () => updateWith((_, a) => a);
/** @internal */
const updateWith = f => differ_make({
  empty: Function_identity,
  combine: (first, second) => {
    if (first === Function_identity) {
      return second;
    }
    if (second === Function_identity) {
      return first;
    }
    return a => second(first(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return Function_identity;
    }
    return constant(newValue);
  },
  patch: (patch, oldValue) => f(oldValue, patch(oldValue))
});
/** @internal */
const differ_zip = /*#__PURE__*/Function_dual(2, (self, that) => differ_make({
  empty: [self.empty, that.empty],
  combine: (first, second) => [self.combine(first[0], second[0]), that.combine(first[1], second[1])],
  diff: (oldValue, newValue) => [self.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],
  patch: (patch, oldValue) => [self.patch(patch[0], oldValue[0]), that.patch(patch[1], oldValue[1])]
}));
//# sourceMappingURL=differ.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js

/** @internal */
const BIT_MASK = 0xff;
/** @internal */
const BIT_SHIFT = 0x08;
/** @internal */
const active = patch => patch & BIT_MASK;
/** @internal */
const enabled = patch => patch >> BIT_SHIFT & BIT_MASK;
/** @internal */
const runtimeFlagsPatch_make = (active, enabled) => (active & BIT_MASK) + ((enabled & active & BIT_MASK) << BIT_SHIFT);
/** @internal */
const runtimeFlagsPatch_empty = /*#__PURE__*/runtimeFlagsPatch_make(0, 0);
/** @internal */
const enable = flag => runtimeFlagsPatch_make(flag, flag);
/** @internal */
const disable = flag => runtimeFlagsPatch_make(flag, 0);
/** @internal */
const runtimeFlagsPatch_isEmpty = patch => patch === 0;
/** @internal */
const isActive = /*#__PURE__*/Function_dual(2, (self, flag) => (active(self) & flag) !== 0);
/** @internal */
const isEnabled = /*#__PURE__*/Function_dual(2, (self, flag) => (enabled(self) & flag) !== 0);
/** @internal */
const isDisabled = /*#__PURE__*/Function_dual(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);
/** @internal */
const exclude = /*#__PURE__*/Function_dual(2, (self, flag) => runtimeFlagsPatch_make(active(self) & ~flag, enabled(self)));
/** @internal */
const both = /*#__PURE__*/Function_dual(2, (self, that) => runtimeFlagsPatch_make(active(self) | active(that), enabled(self) & enabled(that)));
/** @internal */
const runtimeFlagsPatch_either = /*#__PURE__*/Function_dual(2, (self, that) => runtimeFlagsPatch_make(active(self) | active(that), enabled(self) | enabled(that)));
/** @internal */
const runtimeFlagsPatch_andThen = /*#__PURE__*/Function_dual(2, (self, that) => self | that);
/** @internal */
const inverse = patch => runtimeFlagsPatch_make(enabled(patch), invert(active(patch)));
/** @internal */
const invert = n => ~n >>> 0 & BIT_MASK;
//# sourceMappingURL=runtimeFlagsPatch.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/runtimeFlags.js



/** @internal */
const runtimeFlags_None = 0;
/** @internal */
const Interruption = 1 << 0;
/** @internal */
const OpSupervision = 1 << 1;
/** @internal */
const RuntimeMetrics = 1 << 2;
/** @internal */
const WindDown = 1 << 4;
/** @internal */
const CooperativeYielding = 1 << 5;
/** @internal */
const allFlags = [runtimeFlags_None, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding];
const print = flag => {
  switch (flag) {
    case CooperativeYielding:
      {
        return "CooperativeYielding";
      }
    case WindDown:
      {
        return "WindDown";
      }
    case RuntimeMetrics:
      {
        return "RuntimeMetrics";
      }
    case OpSupervision:
      {
        return "OpSupervision";
      }
    case Interruption:
      {
        return "Interruption";
      }
    case runtimeFlags_None:
      {
        return "None";
      }
  }
};
/** @internal */
const cooperativeYielding = self => runtimeFlags_isEnabled(self, CooperativeYielding);
/** @internal */
const runtimeFlags_disable = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, flag) => self & ~flag)));
/** @internal */
const disableAll = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, flags) => self & ~flags)));
/** @internal */
const runtimeFlags_enable = /*#__PURE__*/Function_dual(2, (self, flag) => self | flag);
/** @internal */
const enableAll = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, flags) => self | flags)));
/** @internal */
const interruptible = self => interruption(self) && !windDown(self);
/** @internal */
const interruption = self => runtimeFlags_isEnabled(self, Interruption);
/** @internal */
const runtimeFlags_isDisabled = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, flag) => !runtimeFlags_isEnabled(self, flag))));
/** @internal */
const runtimeFlags_isEnabled = /*#__PURE__*/Function_dual(2, (self, flag) => (self & flag) !== 0);
/** @internal */
const runtimeFlags_make = (...flags) => flags.reduce((a, b) => a | b, 0);
/** @internal */
const runtimeFlags_none = /*#__PURE__*/runtimeFlags_make(runtimeFlags_None);
/** @internal */
const opSupervision = self => runtimeFlags_isEnabled(self, OpSupervision);
/** @internal */
const render = self => {
  const active = [];
  allFlags.forEach(flag => {
    if (runtimeFlags_isEnabled(self, flag)) {
      active.push(`${print(flag)}`);
    }
  });
  return `RuntimeFlags(${active.join(", ")})`;
};
/** @internal */
const runtimeMetrics = self => runtimeFlags_isEnabled(self, RuntimeMetrics);
/** @internal */
const runtimeFlags_toSet = self => new Set(allFlags.filter(flag => runtimeFlags_isEnabled(self, flag)));
const windDown = self => runtimeFlags_isEnabled(self, WindDown);
// circular with RuntimeFlagsPatch
/** @internal */
const enabledSet = self => runtimeFlags_toSet(active(self) & enabled(self));
/** @internal */
const disabledSet = self => runtimeFlags_toSet(active(self) & ~enabled(self));
/** @internal */
const runtimeFlags_diff = /*#__PURE__*/Function_dual(2, (self, that) => runtimeFlagsPatch_make(self ^ that, that));
/** @internal */
const runtimeFlags_patch = /*#__PURE__*/Function_dual(2, (self, patch) => self & (invert(active(patch)) | enabled(patch)) | active(patch) & enabled(patch));
/** @internal */
const renderPatch = self => {
  const enabled = Array.from(enabledSet(self)).map(flag => print(flag)).join(", ");
  const disabled = Array.from(disabledSet(self)).map(flag => print(flag)).join(", ");
  return `RuntimeFlagsPatch(enabled = (${enabled}), disabled = (${disabled}))`;
};
/** @internal */
const differ = /*#__PURE__*/differ_make({
  empty: runtimeFlagsPatch_empty,
  diff: (oldValue, newValue) => runtimeFlags_diff(oldValue, newValue),
  combine: (first, second) => runtimeFlagsPatch_andThen(second)(first),
  patch: (_patch, oldValue) => runtimeFlags_patch(oldValue, _patch)
});
//# sourceMappingURL=runtimeFlags.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/RuntimeFlagsPatch.js
/**
 * @since 2.0.0
 */


/**
 * The empty `RuntimeFlagsPatch`.
 *
 * @since 2.0.0
 * @category constructors
 */
const RuntimeFlagsPatch_empty = runtimeFlagsPatch_empty;
/**
 * @since 2.0.0
 * @category constructors
 */
const RuntimeFlagsPatch_make = runtimeFlagsPatch_make;
/**
 * Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.
 *
 * @since 2.0.0
 * @category constructors
 */
const RuntimeFlagsPatch_enable = enable;
/**
 * Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.
 *
 * @since 2.0.0
 * @category constructors
 */
const RuntimeFlagsPatch_disable = disable;
/**
 * Returns `true` if the specified `RuntimeFlagsPatch` is empty.
 *
 * @since 2.0.0
 * @category getters
 */
const RuntimeFlagsPatch_isEmpty = runtimeFlagsPatch_isEmpty;
/**
 * Returns `true` if the `RuntimeFlagsPatch` describes the specified
 * `RuntimeFlag` as active.
 *
 * @since 2.0.0
 * @category elements
 */
const RuntimeFlagsPatch_isActive = isActive;
/**
 * Returns `true` if the `RuntimeFlagsPatch` describes the specified
 * `RuntimeFlag` as enabled.
 *
 * @since 2.0.0
 * @category elements
 */
const RuntimeFlagsPatch_isEnabled = isEnabled;
/**
 * Returns `true` if the `RuntimeFlagsPatch` describes the specified
 * `RuntimeFlag` as disabled.
 *
 * @since 2.0.0
 * @category elements
 */
const RuntimeFlagsPatch_isDisabled = isDisabled;
/**
 * Returns `true` if the `RuntimeFlagsPatch` includes the specified
 * `RuntimeFlag`, `false` otherwise.
 *
 * @since 2.0.0
 * @category elements
 */
const includes = isActive;
/**
 * Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,
 * followed by `that` patch.
 *
 * @since 2.0.0
 * @category utils
 */
const RuntimeFlagsPatch_andThen = runtimeFlagsPatch_andThen;
/**
 * Creates a `RuntimeFlagsPatch` describing application of both the `self` patch
 * and `that` patch.
 *
 * @since 2.0.0
 * @category utils
 */
const RuntimeFlagsPatch_both = both;
/**
 * Creates a `RuntimeFlagsPatch` describing application of either the `self`
 * patch or `that` patch.
 *
 * @since 2.0.0
 * @category utils
 */
const RuntimeFlagsPatch_either = runtimeFlagsPatch_either;
/**
 * Creates a `RuntimeFlagsPatch` which describes exclusion of the specified
 * `RuntimeFlag` from the set of `RuntimeFlags`.
 *
 * @category utils
 * @since 2.0.0
 */
const RuntimeFlagsPatch_exclude = exclude;
/**
 * Creates a `RuntimeFlagsPatch` which describes the inverse of the patch
 * specified by the provided `RuntimeFlagsPatch`.
 *
 * @since 2.0.0
 * @category utils
 */
const RuntimeFlagsPatch_inverse = inverse;
/**
 * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as
 * enabled by the specified `RuntimeFlagsPatch`.
 *
 * @since 2.0.0
 * @category destructors
 */
const RuntimeFlagsPatch_enabledSet = enabledSet;
/**
 * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as
 * disabled by the specified `RuntimeFlagsPatch`.
 *
 * @since 2.0.0
 * @category destructors
 */
const RuntimeFlagsPatch_disabledSet = disabledSet;
/**
 * Renders the provided `RuntimeFlagsPatch` to a string.
 *
 * @since 2.0.0
 * @category destructors
 */
const RuntimeFlagsPatch_render = renderPatch;
//# sourceMappingURL=RuntimeFlagsPatch.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/opCodes/cause.js
/** @internal */
const OP_DIE = "Die";
/** @internal */
const OP_EMPTY = "Empty";
/** @internal */
const OP_FAIL = "Fail";
/** @internal */
const OP_INTERRUPT = "Interrupt";
/** @internal */
const OP_PARALLEL = "Parallel";
/** @internal */
const OP_SEQUENTIAL = "Sequential";
//# sourceMappingURL=cause.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/cause.js













// -----------------------------------------------------------------------------
// Models
// -----------------------------------------------------------------------------
/** @internal */
const CauseSymbolKey = "effect/Cause";
/** @internal */
const CauseTypeId = /*#__PURE__*/Symbol.for(CauseSymbolKey);
const cause_variance = {
  /* c8 ignore next */
  _E: _ => _
};
/** @internal */
const proto = {
  [CauseTypeId]: cause_variance,
  [symbol]() {
    return Function_pipe(Hash_hash(CauseSymbolKey), combine(Hash_hash(flattenCause(this))), cached(this));
  },
  [Equal_symbol](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
// -----------------------------------------------------------------------------
// Constructors
// -----------------------------------------------------------------------------
/** @internal */
const cause_empty = /*#__PURE__*/(() => {
  const o = /*#__PURE__*/Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
/** @internal */
const fail = error => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error;
  return o;
};
/** @internal */
const die = defect => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
/** @internal */
const interrupt = fiberId => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId;
  return o;
};
/** @internal */
const parallel = (left, right) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left;
  o.right = right;
  return o;
};
/** @internal */
const sequential = (left, right) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left;
  o.right = right;
  return o;
};
// -----------------------------------------------------------------------------
// Refinements
// -----------------------------------------------------------------------------
/** @internal */
const isCause = u => Predicate_hasProperty(u, CauseTypeId);
/** @internal */
const isEmptyType = self => self._tag === OpCodes.OP_EMPTY;
/** @internal */
const isFailType = self => self._tag === OpCodes.OP_FAIL;
/** @internal */
const isDieType = self => self._tag === OP_DIE;
/** @internal */
const isInterruptType = self => self._tag === OpCodes.OP_INTERRUPT;
/** @internal */
const isSequentialType = self => self._tag === OpCodes.OP_SEQUENTIAL;
/** @internal */
const isParallelType = self => self._tag === OpCodes.OP_PARALLEL;
// -----------------------------------------------------------------------------
// Getters
// -----------------------------------------------------------------------------
/** @internal */
const cause_size = self => reduceWithContext(self, void 0, SizeCauseReducer);
/** @internal */
const cause_isEmpty = self => {
  if (self._tag === OP_EMPTY) {
    return true;
  }
  return cause_reduce(self, true, (acc, cause) => {
    switch (cause._tag) {
      case OP_EMPTY:
        {
          return Option_some(acc);
        }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT:
        {
          return Option_some(false);
        }
      default:
        {
          return Option_none();
        }
    }
  });
};
/** @internal */
const isFailure = self => Option.isSome(failureOption(self));
/** @internal */
const isDie = self => Option.isSome(dieOption(self));
/** @internal */
const isInterrupted = self => Option_isSome(interruptOption(self));
/** @internal */
const isInterruptedOnly = self => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self);
/** @internal */
const cause_failures = self => Chunk_reverse(cause_reduce(self, esm_Chunk_empty(), (list, cause) => cause._tag === OP_FAIL ? Option_some(Function_pipe(list, Chunk_prepend(cause.error))) : Option_none()));
/** @internal */
const cause_defects = self => Chunk_reverse(cause_reduce(self, esm_Chunk_empty(), (list, cause) => cause._tag === OP_DIE ? Option_some(Function_pipe(list, Chunk_prepend(cause.defect))) : Option_none()));
/** @internal */
const interruptors = self => cause_reduce(self, HashSet_empty(), (set, cause) => cause._tag === OP_INTERRUPT ? Option_some(Function_pipe(set, HashSet_add(cause.fiberId))) : Option_none());
/** @internal */
const failureOption = self => find(self, cause => cause._tag === OP_FAIL ? Option_some(cause.error) : Option_none());
/** @internal */
const failureOrCause = self => {
  const option = failureOption(self);
  switch (option._tag) {
    case "None":
      {
        // no `E` inside this `Cause`, so it can be safely cast to `never`
        return Either_right(self);
      }
    case "Some":
      {
        return Either_left(option.value);
      }
  }
};
/** @internal */
const dieOption = self => find(self, cause => cause._tag === OpCodes.OP_DIE ? Option.some(cause.defect) : Option.none());
/** @internal */
const flipCauseOption = self => cause_match(self, {
  onEmpty: Option.some(cause_empty),
  onFail: failureOption => pipe(failureOption, Option.map(fail)),
  onDie: defect => Option.some(die(defect)),
  onInterrupt: fiberId => Option.some(interrupt(fiberId)),
  onSequential: (left, right) => {
    if (Option.isSome(left) && Option.isSome(right)) {
      return Option.some(sequential(left.value, right.value));
    }
    if (Option.isNone(left) && Option.isSome(right)) {
      return Option.some(right.value);
    }
    if (Option.isSome(left) && Option.isNone(right)) {
      return Option.some(left.value);
    }
    return Option.none();
  },
  onParallel: (left, right) => {
    if (Option.isSome(left) && Option.isSome(right)) {
      return Option.some(parallel(left.value, right.value));
    }
    if (Option.isNone(left) && Option.isSome(right)) {
      return Option.some(right.value);
    }
    if (Option.isSome(left) && Option.isNone(right)) {
      return Option.some(left.value);
    }
    return Option.none();
  }
});
/** @internal */
const interruptOption = self => find(self, cause => cause._tag === OP_INTERRUPT ? Option_some(cause.fiberId) : Option_none());
/** @internal */
const keepDefects = self => cause_match(self, {
  onEmpty: Option_none(),
  onFail: () => Option_none(),
  onDie: defect => Option_some(die(defect)),
  onInterrupt: () => Option_none(),
  onSequential: (left, right) => {
    if (Option_isSome(left) && Option_isSome(right)) {
      return Option_some(sequential(left.value, right.value));
    }
    if (Option_isSome(left) && Option_isNone(right)) {
      return Option_some(left.value);
    }
    if (Option_isNone(left) && Option_isSome(right)) {
      return Option_some(right.value);
    }
    return Option_none();
  },
  onParallel: (left, right) => {
    if (Option_isSome(left) && Option_isSome(right)) {
      return Option_some(parallel(left.value, right.value));
    }
    if (Option_isSome(left) && Option_isNone(right)) {
      return Option_some(left.value);
    }
    if (Option_isNone(left) && Option_isSome(right)) {
      return Option_some(right.value);
    }
    return Option_none();
  }
});
/** @internal */
const keepDefectsAndElectFailures = self => cause_match(self, {
  onEmpty: Option_none(),
  onFail: failure => Option_some(die(failure)),
  onDie: defect => Option_some(die(defect)),
  onInterrupt: () => Option_none(),
  onSequential: (left, right) => {
    if (Option_isSome(left) && Option_isSome(right)) {
      return Option_some(sequential(left.value, right.value));
    }
    if (Option_isSome(left) && Option_isNone(right)) {
      return Option_some(left.value);
    }
    if (Option_isNone(left) && Option_isSome(right)) {
      return Option_some(right.value);
    }
    return Option_none();
  },
  onParallel: (left, right) => {
    if (Option_isSome(left) && Option_isSome(right)) {
      return Option_some(parallel(left.value, right.value));
    }
    if (Option_isSome(left) && Option_isNone(right)) {
      return Option_some(left.value);
    }
    if (Option_isNone(left) && Option_isSome(right)) {
      return Option_some(right.value);
    }
    return Option_none();
  }
});
/** @internal */
const linearize = self => cause_match(self, {
  onEmpty: HashSet.empty(),
  onFail: error => HashSet.make(fail(error)),
  onDie: defect => HashSet.make(die(defect)),
  onInterrupt: fiberId => HashSet.make(interrupt(fiberId)),
  onSequential: (leftSet, rightSet) => pipe(leftSet, HashSet.flatMap(leftCause => pipe(rightSet, HashSet.map(rightCause => sequential(leftCause, rightCause))))),
  onParallel: (leftSet, rightSet) => pipe(leftSet, HashSet.flatMap(leftCause => pipe(rightSet, HashSet.map(rightCause => parallel(leftCause, rightCause)))))
});
/** @internal */
const stripFailures = self => cause_match(self, {
  onEmpty: cause_empty,
  onFail: () => cause_empty,
  onDie: defect => die(defect),
  onInterrupt: fiberId => interrupt(fiberId),
  onSequential: sequential,
  onParallel: parallel
});
/** @internal */
const electFailures = self => cause_match(self, {
  onEmpty: cause_empty,
  onFail: failure => die(failure),
  onDie: defect => die(defect),
  onInterrupt: fiberId => interrupt(fiberId),
  onSequential: (left, right) => sequential(left, right),
  onParallel: (left, right) => parallel(left, right)
});
/** @internal */
const stripSomeDefects = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, pf) => cause_match(self, {
  onEmpty: Option.some(cause_empty),
  onFail: error => Option.some(fail(error)),
  onDie: defect => {
    const option = pf(defect);
    return Option.isSome(option) ? Option.none() : Option.some(die(defect));
  },
  onInterrupt: fiberId => Option.some(interrupt(fiberId)),
  onSequential: (left, right) => {
    if (Option.isSome(left) && Option.isSome(right)) {
      return Option.some(sequential(left.value, right.value));
    }
    if (Option.isSome(left) && Option.isNone(right)) {
      return Option.some(left.value);
    }
    if (Option.isNone(left) && Option.isSome(right)) {
      return Option.some(right.value);
    }
    return Option.none();
  },
  onParallel: (left, right) => {
    if (Option.isSome(left) && Option.isSome(right)) {
      return Option.some(parallel(left.value, right.value));
    }
    if (Option.isSome(left) && Option.isNone(right)) {
      return Option.some(left.value);
    }
    if (Option.isNone(left) && Option.isSome(right)) {
      return Option.some(right.value);
    }
    return Option.none();
  }
}))));
// -----------------------------------------------------------------------------
// Mapping
// -----------------------------------------------------------------------------
/** @internal */
const cause_as = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, error) => cause_map(self, () => error))));
/** @internal */
const cause_map = /*#__PURE__*/Function_dual(2, (self, f) => cause_flatMap(self, e => fail(f(e))));
// -----------------------------------------------------------------------------
// Sequencing
// -----------------------------------------------------------------------------
/** @internal */
const cause_flatMap = /*#__PURE__*/Function_dual(2, (self, f) => cause_match(self, {
  onEmpty: cause_empty,
  onFail: error => f(error),
  onDie: defect => die(defect),
  onInterrupt: fiberId => interrupt(fiberId),
  onSequential: (left, right) => sequential(left, right),
  onParallel: (left, right) => parallel(left, right)
}));
/** @internal */
const cause_flatten = self => cause_flatMap(self, Function_identity);
/** @internal */
const cause_andThen = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => isFunction(f) ? cause_flatMap(self, f) : cause_flatMap(self, () => f))));
// -----------------------------------------------------------------------------
// Equality
// -----------------------------------------------------------------------------
/** @internal */
const cause_contains = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => {
  if (that._tag === OpCodes.OP_EMPTY || self === that) {
    return true;
  }
  return cause_reduce(self, false, (accumulator, cause) => {
    return Option.some(accumulator || causeEquals(cause, that));
  });
})));
/** @internal */
const causeEquals = (left, right) => {
  let leftStack = Chunk_of(left);
  let rightStack = Chunk_of(right);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = Function_pipe(Chunk_headNonEmpty(leftStack), cause_reduce([HashSet_empty(), esm_Chunk_empty()], ([parallel, sequential], cause) => {
      const [par, seq] = evaluateCause(cause);
      return Option_some([Function_pipe(parallel, HashSet_union(par)), Function_pipe(sequential, Chunk_appendAll(seq))]);
    }));
    const [rightParallel, rightSequential] = Function_pipe(Chunk_headNonEmpty(rightStack), cause_reduce([HashSet_empty(), esm_Chunk_empty()], ([parallel, sequential], cause) => {
      const [par, seq] = evaluateCause(cause);
      return Option_some([Function_pipe(parallel, HashSet_union(par)), Function_pipe(sequential, Chunk_appendAll(seq))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
// -----------------------------------------------------------------------------
// Flattening
// -----------------------------------------------------------------------------
/**
 * Flattens a cause to a sequence of sets of causes, where each set represents
 * causes that fail in parallel and sequential sets represent causes that fail
 * after each other.
 *
 * @internal
 */
const flattenCause = cause => {
  return flattenCauseLoop(Chunk_of(cause), esm_Chunk_empty());
};
/** @internal */
const flattenCauseLoop = (causes, flattened) => {
  // eslint-disable-next-line no-constant-condition
  while (1) {
    const [parallel, sequential] = Function_pipe(causes, Array_reduce([HashSet_empty(), esm_Chunk_empty()], ([parallel, sequential], cause) => {
      const [par, seq] = evaluateCause(cause);
      return [Function_pipe(parallel, HashSet_union(par)), Function_pipe(sequential, Chunk_appendAll(seq))];
    }));
    const updated = HashSet_size(parallel) > 0 ? Function_pipe(flattened, Chunk_prepend(parallel)) : flattened;
    if (Chunk_isEmpty(sequential)) {
      return Chunk_reverse(updated);
    }
    causes = sequential;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
// -----------------------------------------------------------------------------
// Finding
// -----------------------------------------------------------------------------
/** @internal */
const find = /*#__PURE__*/Function_dual(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option = pf(item);
    switch (option._tag) {
      case "None":
        {
          switch (item._tag) {
            case OP_SEQUENTIAL:
            case OP_PARALLEL:
              {
                stack.push(item.right);
                stack.push(item.left);
                break;
              }
          }
          break;
        }
      case "Some":
        {
          return option;
        }
    }
  }
  return Option_none();
});
// -----------------------------------------------------------------------------
// Filtering
// -----------------------------------------------------------------------------
/** @internal */
const cause_filter = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, predicate) => reduceWithContext(self, void 0, FilterCauseReducer(predicate)))));
// -----------------------------------------------------------------------------
// Evaluation
// -----------------------------------------------------------------------------
/**
 * Takes one step in evaluating a cause, returning a set of causes that fail
 * in parallel and a list of causes that fail sequentially after those causes.
 *
 * @internal
 */
const evaluateCause = self => {
  let cause = self;
  const stack = [];
  let _parallel = HashSet_empty();
  let _sequential = esm_Chunk_empty();
  while (cause !== undefined) {
    switch (cause._tag) {
      case OP_EMPTY:
        {
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
      case OP_FAIL:
        {
          _parallel = HashSet_add(_parallel, Chunk_make(cause._tag, cause.error));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
      case OP_DIE:
        {
          _parallel = HashSet_add(_parallel, Chunk_make(cause._tag, cause.defect));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
      case OP_INTERRUPT:
        {
          _parallel = HashSet_add(_parallel, Chunk_make(cause._tag, cause.fiberId));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
      case OP_SEQUENTIAL:
        {
          switch (cause.left._tag) {
            case OP_EMPTY:
              {
                cause = cause.right;
                break;
              }
            case OP_SEQUENTIAL:
              {
                cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
                break;
              }
            case OP_PARALLEL:
              {
                cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
                break;
              }
            default:
              {
                _sequential = Chunk_prepend(_sequential, cause.right);
                cause = cause.left;
                break;
              }
          }
          break;
        }
      case OP_PARALLEL:
        {
          stack.push(cause.right);
          cause = cause.left;
          break;
        }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
// -----------------------------------------------------------------------------
// Reducing
// -----------------------------------------------------------------------------
/** @internal */
const SizeCauseReducer = {
  emptyCase: () => 0,
  failCase: () => 1,
  dieCase: () => 1,
  interruptCase: () => 1,
  sequentialCase: (_, left, right) => left + right,
  parallelCase: (_, left, right) => left + right
};
/** @internal */
const IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left, right) => left && right,
  parallelCase: (_, left, right) => left && right
};
/** @internal */
const FilterCauseReducer = predicate => ({
  emptyCase: () => cause_empty,
  failCase: (_, error) => fail(error),
  dieCase: (_, defect) => die(defect),
  interruptCase: (_, fiberId) => interrupt(fiberId),
  sequentialCase: (_, left, right) => {
    if (predicate(left)) {
      if (predicate(right)) {
        return sequential(left, right);
      }
      return left;
    }
    if (predicate(right)) {
      return right;
    }
    return cause_empty;
  },
  parallelCase: (_, left, right) => {
    if (predicate(left)) {
      if (predicate(right)) {
        return parallel(left, right);
      }
      return left;
    }
    if (predicate(right)) {
      return right;
    }
    return cause_empty;
  }
});
const OP_SEQUENTIAL_CASE = "SequentialCase";
const OP_PARALLEL_CASE = "ParallelCase";
/** @internal */
const cause_match = /*#__PURE__*/Function_dual(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self, void 0, {
    emptyCase: () => onEmpty,
    failCase: (_, error) => onFail(error),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId) => onInterrupt(fiberId),
    sequentialCase: (_, left, right) => onSequential(left, right),
    parallelCase: (_, left, right) => onParallel(left, right)
  });
});
/** @internal */
const cause_reduce = /*#__PURE__*/Function_dual(3, (self, zero, pf) => {
  let accumulator = zero;
  let cause = self;
  const causes = [];
  while (cause !== undefined) {
    const option = pf(accumulator, cause);
    accumulator = Option_isSome(option) ? option.value : accumulator;
    switch (cause._tag) {
      case OP_SEQUENTIAL:
        {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
      case OP_PARALLEL:
        {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
      default:
        {
          cause = undefined;
          break;
        }
    }
    if (cause === undefined && causes.length > 0) {
      cause = causes.pop();
    }
  }
  return accumulator;
});
/** @internal */
const reduceWithContext = /*#__PURE__*/Function_dual(3, (self, context, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause = input.pop();
    switch (cause._tag) {
      case OP_EMPTY:
        {
          output.push(Either_right(reducer.emptyCase(context)));
          break;
        }
      case OP_FAIL:
        {
          output.push(Either_right(reducer.failCase(context, cause.error)));
          break;
        }
      case OP_DIE:
        {
          output.push(Either_right(reducer.dieCase(context, cause.defect)));
          break;
        }
      case OP_INTERRUPT:
        {
          output.push(Either_right(reducer.interruptCase(context, cause.fiberId)));
          break;
        }
      case OP_SEQUENTIAL:
        {
          input.push(cause.right);
          input.push(cause.left);
          output.push(Either_left({
            _tag: OP_SEQUENTIAL_CASE
          }));
          break;
        }
      case OP_PARALLEL:
        {
          input.push(cause.right);
          input.push(cause.left);
          output.push(Either_left({
            _tag: OP_PARALLEL_CASE
          }));
          break;
        }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either = output.pop();
    switch (either._tag) {
      case "Left":
        {
          switch (either.left._tag) {
            case OP_SEQUENTIAL_CASE:
              {
                const left = accumulator.pop();
                const right = accumulator.pop();
                const value = reducer.sequentialCase(context, left, right);
                accumulator.push(value);
                break;
              }
            case OP_PARALLEL_CASE:
              {
                const left = accumulator.pop();
                const right = accumulator.pop();
                const value = reducer.parallelCase(context, left, right);
                accumulator.push(value);
                break;
              }
          }
          break;
        }
      case "Right":
        {
          accumulator.push(either.right);
          break;
        }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
// -----------------------------------------------------------------------------
// Pretty Printing
// -----------------------------------------------------------------------------
const filterStack = stack => {
  const lines = stack.split("\n");
  const out = [];
  for (let i = 0; i < lines.length; i++) {
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1"));
    if (lines[i].includes("effect_instruction_i")) {
      return out.join("\n");
    }
  }
  return out.join("\n");
};
/** @internal */
const pretty = cause => {
  if (isInterruptedOnly(cause)) {
    return "All fibers interrupted without errors.";
  }
  const final = cause_prettyErrors(cause).map(e => {
    let message = e.message;
    if (e.stack) {
      message += `\r\n${filterStack(e.stack)}`;
    }
    if (e.span) {
      let current = e.span;
      let i = 0;
      while (current && current._tag === "Span" && i < 10) {
        message += `\r\n    at ${current.name}`;
        current = getOrUndefined(current.parent);
        i++;
      }
    }
    return message;
  }).join("\r\n");
  return final;
};
class PrettyError {
  message;
  stack;
  span;
  constructor(message, stack, span) {
    this.message = message;
    this.stack = stack;
    this.span = span;
  }
  toJSON() {
    const out = {
      message: this.message
    };
    if (this.stack) {
      out.stack = this.stack;
    }
    if (this.span) {
      out.span = this.span;
    }
    return out;
  }
}
/**
 * A utility function for generating human-readable error messages from a generic error of type `unknown`.
 *
 * Rules:
 *
 * 1) If the input `u` is already a string, it's considered a message, and "Error" is added as a prefix.
 * 2) If `u` has a user-defined `toString()` method, it uses that method and adds "Error" as a prefix.
 * 3) If `u` is an object and its only (optional) properties are "name", "message", or "_tag", it constructs
 *    an error message based on those properties.
 * 4) Otherwise, it uses `JSON.stringify` to produce a string representation and uses it as the error message,
 *   with "Error" added as a prefix.
 *
 * @internal
 */
const prettyErrorMessage = u => {
  // 1)
  if (typeof u === "string") {
    return `Error: ${u}`;
  }
  // 2)
  try {
    if (Predicate_hasProperty(u, "toString") && Predicate_isFunction(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
    // something's off, rollback to json
  }
  // 3)
  return `Error: ${JSON.stringify(u)}`;
};
const spanSymbol = /*#__PURE__*/Symbol.for("effect/SpanAnnotation");
const defaultRenderError = error => {
  const span = Predicate_hasProperty(error, spanSymbol) && error[spanSymbol];
  if (error instanceof Error) {
    return new PrettyError(prettyErrorMessage(error), error.stack?.split("\n").filter(_ => _.match(/at (.*)/)).join("\n"), span);
  }
  return new PrettyError(prettyErrorMessage(error), void 0, span);
};
/** @internal */
const cause_prettyErrors = cause => reduceWithContext(cause, void 0, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [defaultRenderError(unknownError)];
  },
  failCase: (_, error) => {
    return [defaultRenderError(error)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});
//# sourceMappingURL=cause.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/opCodes/deferred.js
/** @internal */
const OP_STATE_PENDING = "Pending";
/** @internal */
const OP_STATE_DONE = "Done";
//# sourceMappingURL=deferred.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/deferred.js

/** @internal */
const DeferredSymbolKey = "effect/Deferred";
/** @internal */
const DeferredTypeId = /*#__PURE__*/Symbol.for(DeferredSymbolKey);
/** @internal */
const deferredVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
const pending = joiners => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
/** @internal */
const done = effect => {
  return {
    _tag: OP_STATE_DONE,
    effect
  };
};
//# sourceMappingURL=deferred.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/singleShotGen.js
/** @internal */
class singleShotGen_SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new singleShotGen_SingleShotGen(this.self);
  }
}
//# sourceMappingURL=singleShotGen.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/tracer.js
/**
 * @since 2.0.0
 */

/** @internal */
const TracerTypeId = /*#__PURE__*/Symbol.for("effect/Tracer");
/** @internal */
const tracer_make = options => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
/** @internal */
const tracerTag = /*#__PURE__*/GenericTag("effect/Tracer");
/** @internal */
const spanTag = /*#__PURE__*/GenericTag("effect/ParentSpan");
const randomHexString = /*#__PURE__*/function () {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function (length) {
    let result = "";
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();
/** @internal */
class NativeSpan {
  name;
  parent;
  context;
  links;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  constructor(name, parent, context, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context;
    this.links = links;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
  }
  end(endTime, exit) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit,
      startTime: this.status.startTime
    };
  }
  attribute(key, value) {
    this.attributes.set(key, value);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
}
/** @internal */
const nativeTracer = /*#__PURE__*/tracer_make({
  span: (name, parent, context, links, startTime, kind) => new NativeSpan(name, parent, context, links, startTime, kind),
  context: f => f()
});
/** @internal */
const externalSpan = options => ({
  _tag: "ExternalSpan",
  spanId: options.spanId,
  traceId: options.traceId,
  sampled: options.sampled ?? true,
  context: options.context ?? Context_empty()
});
//# sourceMappingURL=tracer.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/core.js





























// -----------------------------------------------------------------------------
// Effect
// -----------------------------------------------------------------------------
/** @internal */
const EffectErrorSymbolKey = "effect/EffectError";
/** @internal */
const EffectErrorTypeId = /*#__PURE__*/Symbol.for(EffectErrorSymbolKey);
/** @internal */
const isEffectError = u => Predicate_hasProperty(u, EffectErrorTypeId);
/** @internal */
const makeEffectError = cause => ({
  [EffectErrorTypeId]: EffectErrorTypeId,
  _tag: "EffectError",
  cause
});
/**
 * @internal
 */
const blocked = (blockedRequests, _continue) => {
  const effect = new EffectPrimitive("Blocked");
  effect.effect_instruction_i0 = blockedRequests;
  effect.effect_instruction_i1 = _continue;
  return effect;
};
/**
 * @internal
 */
const runRequestBlock = blockedRequests => {
  const effect = new EffectPrimitive("RunBlocked");
  effect.effect_instruction_i0 = blockedRequests;
  return effect;
};
/** @internal */
const core_EffectTypeId = /*#__PURE__*/Symbol.for("effect/Effect");
/** @internal */
class RevertFlags {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch, op) {
    this.patch = patch;
    this.op = op;
  }
}
/** @internal */
class EffectPrimitive {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [core_EffectTypeId] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [Equal_symbol](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new singleShotGen_SingleShotGen(new YieldWrap(this));
  }
}
/** @internal */
class EffectPrimitiveFailure {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [core_EffectTypeId] = effectVariance;
  constructor(_op) {
    this._op = _op;
    // @ts-expect-error
    this._tag = _op;
  }
  [Equal_symbol](that) {
    return exitIsExit(that) && that._op === "Failure" &&
    // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return Function_pipe(
    // @ts-expect-error
    string(this._tag),
    // @ts-expect-error
    combine(Hash_hash(this.effect_instruction_i0)), cached(this));
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new singleShotGen_SingleShotGen(new YieldWrap(this));
  }
}
/** @internal */
class EffectPrimitiveSuccess {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [core_EffectTypeId] = effectVariance;
  constructor(_op) {
    this._op = _op;
    // @ts-expect-error
    this._tag = _op;
  }
  [Equal_symbol](that) {
    return exitIsExit(that) && that._op === "Success" &&
    // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return Function_pipe(
    // @ts-expect-error
    string(this._tag),
    // @ts-expect-error
    combine(Hash_hash(this.effect_instruction_i0)), cached(this));
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new singleShotGen_SingleShotGen(new YieldWrap(this));
  }
}
/** @internal */
const isEffect = u => Predicate_hasProperty(u, core_EffectTypeId);
/* @internal */
const withFiberRuntime = withRuntime => {
  const effect = new EffectPrimitive(OP_WITH_RUNTIME);
  effect.effect_instruction_i0 = withRuntime;
  return effect;
};
/* @internal */
const acquireUseRelease = /*#__PURE__*/Function_dual(3, (acquire, use, release) => uninterruptibleMask(restore => core_flatMap(acquire, a => core_flatMap(core_exit(suspend(() => restore(use(a)))), exit => {
  return suspend(() => release(a, exit)).pipe(matchCauseEffect({
    onFailure: cause => {
      switch (exit._tag) {
        case OP_FAILURE:
          return failCause(parallel(exit.effect_instruction_i0, cause));
        case OP_SUCCESS:
          return failCause(cause);
      }
    },
    onSuccess: () => exit
  }));
}))));
/* @internal */
const core_as = /*#__PURE__*/Function_dual(2, (self, value) => core_flatMap(self, () => succeed(value)));
/* @internal */
const core_asVoid = self => core_as(self, void 0);
/* @internal */
const custom = function () {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2:
      {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.commit = arguments[1];
        break;
      }
    case 3:
      {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.effect_instruction_i1 = arguments[1];
        wrapper.commit = arguments[2];
        break;
      }
    case 4:
      {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.effect_instruction_i1 = arguments[1];
        wrapper.effect_instruction_i2 = arguments[2];
        wrapper.commit = arguments[3];
        break;
      }
    default:
      {
        throw new Error(getBugErrorMessage("you're not supposed to end up here"));
      }
  }
  return wrapper;
};
/* @internal */
const core_async = (register, blockingOn = FiberId_none) => {
  return custom(register, function () {
    let backingResume = undefined;
    let pendingEffect = undefined;
    function proxyResume(effect) {
      if (backingResume) {
        backingResume(effect);
      } else if (pendingEffect === undefined) {
        pendingEffect = effect;
      }
    }
    const effect = new EffectPrimitive(OP_ASYNC);
    effect.effect_instruction_i0 = resume => {
      backingResume = resume;
      if (pendingEffect) {
        resume(pendingEffect);
      }
    };
    effect.effect_instruction_i1 = blockingOn;
    let cancelerRef = undefined;
    let controllerRef = undefined;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = this.effect_instruction_i0(proxyResume, controllerRef.signal);
    } else {
      cancelerRef = this.effect_instruction_i0(proxyResume);
    }
    return cancelerRef || controllerRef ? onInterrupt(effect, _ => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? core_void_;
    }) : effect;
  });
};
/* @internal */
const catchAllCause = /*#__PURE__*/Function_dual(2, (self, f) => {
  const effect = new EffectPrimitive(OP_ON_FAILURE);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = f;
  return effect;
});
/* @internal */
const catchAll = /*#__PURE__*/Function_dual(2, (self, f) => matchEffect(self, {
  onFailure: f,
  onSuccess: succeed
}));
/* @internal */
const catchIf = /*#__PURE__*/Function_dual(3, (self, predicate, f) => catchAllCause(self, cause => {
  const either = failureOrCause(cause);
  switch (either._tag) {
    case "Left":
      return predicate(either.left) ? f(either.left) : failCause(cause);
    case "Right":
      return failCause(either.right);
  }
}));
/* @internal */
const catchSome = /*#__PURE__*/Function_dual(2, (self, pf) => catchAllCause(self, cause => {
  const either = failureOrCause(cause);
  switch (either._tag) {
    case "Left":
      return Function_pipe(pf(either.left), getOrElse(() => failCause(cause)));
    case "Right":
      return failCause(either.right);
  }
}));
/* @internal */
const checkInterruptible = f => withFiberRuntime((_, status) => f(interruption(status.runtimeFlags)));
const core_spanSymbol = /*#__PURE__*/Symbol.for("effect/SpanAnnotation");
const originalSymbol = /*#__PURE__*/Symbol.for("effect/OriginalAnnotation");
/* @internal */
const originalInstance = obj => {
  if (hasProperty(obj, originalSymbol)) {
    // @ts-expect-error
    return obj[originalSymbol];
  }
  return obj;
};
/* @internal */
const capture = (obj, span) => {
  if (Option_isSome(span)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === core_spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === core_spanSymbol) {
          return span.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        // @ts-expect-error
        return target[p];
      }
    });
  }
  return obj;
};
/* @internal */
const core_die = defect => Predicate_isObject(defect) && !(core_spanSymbol in defect) ? withFiberRuntime(fiber => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
/* @internal */
const dieMessage = message => failCauseSync(() => die(new RuntimeException(message)));
/* @internal */
const dieSync = evaluate => core_flatMap(sync(evaluate), core_die);
/* @internal */
const core_either = self => matchEffect(self, {
  onFailure: e => succeed(Either_left(e)),
  onSuccess: a => succeed(Either_right(a))
});
/* @internal */
const core_exit = self => matchCause(self, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
/* @internal */
const core_fail = error => Predicate_isObject(error) && !(core_spanSymbol in error) ? withFiberRuntime(fiber => failCause(fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(fail(error));
/* @internal */
const failSync = evaluate => core_flatMap(sync(evaluate), core_fail);
/* @internal */
const failCause = cause => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
/* @internal */
const failCauseSync = evaluate => core_flatMap(sync(evaluate), failCause);
/* @internal */
const fiberId = /*#__PURE__*/withFiberRuntime(state => succeed(state.id()));
/* @internal */
const fiberIdWith = f => withFiberRuntime(state => f(state.id()));
/* @internal */
const core_flatMap = /*#__PURE__*/Function_dual(2, (self, f) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = f;
  return effect;
});
/* @internal */
const core_andThen = /*#__PURE__*/Function_dual(2, (self, f) => core_flatMap(self, a => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return core_async(resume => {
      b.then(a => resume(succeed(a)), e => resume(core_fail(new UnknownException(e))));
    });
  }
  return succeed(b);
}));
/* @internal */
const step = self => {
  const effect = new EffectPrimitive("OnStep");
  effect.effect_instruction_i0 = self;
  return effect;
};
/* @internal */
const core_flatten = self => core_flatMap(self, Function_identity);
/* @internal */
const core_flip = self => matchEffect(self, {
  onFailure: succeed,
  onSuccess: core_fail
});
/* @internal */
const matchCause = /*#__PURE__*/Function_dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: cause => succeed(options.onFailure(cause)),
  onSuccess: a => succeed(options.onSuccess(a))
}));
/* @internal */
const matchCauseEffect = /*#__PURE__*/Function_dual(2, (self, options) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = options.onFailure;
  effect.effect_instruction_i2 = options.onSuccess;
  return effect;
});
/* @internal */
const matchEffect = /*#__PURE__*/Function_dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: cause => {
    const defects = cause_defects(cause);
    if (defects.length > 0) {
      return failCause(electFailures(cause));
    }
    const failures = cause_failures(cause);
    if (failures.length > 0) {
      return options.onFailure(unsafeHead(failures));
    }
    return failCause(cause);
  },
  onSuccess: options.onSuccess
}));
/* @internal */
const forEachSequential = /*#__PURE__*/Function_dual(2, (self, f) => suspend(() => {
  const arr = Array_fromIterable(self);
  const ret = allocate(arr.length);
  let i = 0;
  return core_as(whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: b => {
      ret[i++] = b;
    }
  }), ret);
}));
/* @internal */
const forEachSequentialDiscard = /*#__PURE__*/Function_dual(2, (self, f) => suspend(() => {
  const arr = Array_fromIterable(self);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
/* @internal */
const if_ = /*#__PURE__*/Function_dual(args => typeof args[0] === "boolean" || isEffect(args[0]), (self, options) => isEffect(self) ? core_flatMap(self, b => b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
/* @internal */
const core_interrupt = /*#__PURE__*/core_flatMap(fiberId, fiberId => interruptWith(fiberId));
/* @internal */
const interruptWith = fiberId => failCause(interrupt(fiberId));
/* @internal */
const core_interruptible = self => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = RuntimeFlagsPatch_enable(Interruption);
  effect.effect_instruction_i1 = () => self;
  return effect;
};
/* @internal */
const interruptibleMask = f => custom(f, function () {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = RuntimeFlagsPatch_enable(Interruption);
  effect.effect_instruction_i1 = oldFlags => interruption(oldFlags) ? this.effect_instruction_i0(core_interruptible) : this.effect_instruction_i0(uninterruptible);
  return effect;
});
/* @internal */
const intoDeferred = /*#__PURE__*/Function_dual(2, (self, deferred) => uninterruptibleMask(restore => core_flatMap(core_exit(restore(self)), exit => deferredDone(deferred, exit))));
/* @internal */
const core_map = /*#__PURE__*/Function_dual(2, (self, f) => core_flatMap(self, a => sync(() => f(a))));
/* @internal */
const core_mapBoth = /*#__PURE__*/Function_dual(2, (self, options) => matchEffect(self, {
  onFailure: e => failSync(() => options.onFailure(e)),
  onSuccess: a => sync(() => options.onSuccess(a))
}));
/* @internal */
const mapError = /*#__PURE__*/Function_dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: cause => {
    const either = failureOrCause(cause);
    switch (either._tag) {
      case "Left":
        {
          return failSync(() => f(either.left));
        }
      case "Right":
        {
          return failCause(either.right);
        }
    }
  },
  onSuccess: succeed
}));
/* @internal */
const onError = /*#__PURE__*/Function_dual(2, (self, cleanup) => onExit(self, exit => exitIsSuccess(exit) ? core_void_ : cleanup(exit.effect_instruction_i0)));
/* @internal */
const onExit = /*#__PURE__*/Function_dual(2, (self, cleanup) => uninterruptibleMask(restore => matchCauseEffect(restore(self), {
  onFailure: cause1 => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: cause2 => exitFailCause(sequential(cause1, cause2)),
      onSuccess: () => result
    });
  },
  onSuccess: success => {
    const result = exitSucceed(success);
    return core_zipRight(cleanup(result), result);
  }
})));
/* @internal */
const onInterrupt = /*#__PURE__*/Function_dual(2, (self, cleanup) => onExit(self, exitMatch({
  onFailure: cause => isInterruptedOnly(cause) ? core_asVoid(cleanup(interruptors(cause))) : core_void_,
  onSuccess: () => core_void_
})));
/* @internal */
const core_orElse = /*#__PURE__*/Function_dual(2, (self, that) => attemptOrElse(self, that, succeed));
/* @internal */
const orDie = self => orDieWith(self, Function_identity);
/* @internal */
const orDieWith = /*#__PURE__*/Function_dual(2, (self, f) => matchEffect(self, {
  onFailure: e => core_die(f(e)),
  onSuccess: succeed
}));
/* @internal */
const core_partitionMap = (elements, f) => Array_fromIterable(elements).reduceRight(([lefts, rights], current) => {
  const either = f(current);
  switch (either._tag) {
    case "Left":
      {
        return [[either.left, ...lefts], rights];
      }
    case "Right":
      {
        return [lefts, [either.right, ...rights]];
      }
  }
}, [Array_empty(), Array_empty()]);
/* @internal */
const core_runtimeFlags = /*#__PURE__*/withFiberRuntime((_, status) => succeed(status.runtimeFlags));
/* @internal */
const succeed = value => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
/* @internal */
const suspend = effect => core_flatMap(sync(effect), Function_identity);
/* @internal */
const sync = evaluate => {
  const effect = new EffectPrimitive(OP_SYNC);
  effect.effect_instruction_i0 = evaluate;
  return effect;
};
/* @internal */
const core_tap = /*#__PURE__*/Function_dual(2, (self, f) => core_flatMap(self, a => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return core_as(b, a);
  } else if (isPromiseLike(b)) {
    return core_async(resume => {
      b.then(_ => resume(succeed(a)), e => resume(core_fail(new UnknownException(e))));
    });
  }
  return succeed(a);
}));
/* @internal */
const transplant = f => withFiberRuntime(state => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope = Function_pipe(scopeOverride, getOrElse(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, Option_some(scope)));
});
/* @internal */
const attemptOrElse = /*#__PURE__*/Function_dual(3, (self, that, onSuccess) => matchCauseEffect(self, {
  onFailure: cause => {
    const defects = cause_defects(cause);
    if (defects.length > 0) {
      return failCause(getOrThrow(keepDefectsAndElectFailures(cause)));
    }
    return that();
  },
  onSuccess
}));
/* @internal */
const uninterruptible = self => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = RuntimeFlagsPatch_disable(Interruption);
  effect.effect_instruction_i1 = () => self;
  return effect;
};
/* @internal */
const uninterruptibleMask = f => custom(f, function () {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = RuntimeFlagsPatch_disable(Interruption);
  effect.effect_instruction_i1 = oldFlags => interruption(oldFlags) ? this.effect_instruction_i0(core_interruptible) : this.effect_instruction_i0(uninterruptible);
  return effect;
});
const core_void_ = /*#__PURE__*/succeed(void 0);

/* @internal */
const updateRuntimeFlags = patch => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = patch;
  effect.effect_instruction_i1 = void 0;
  return effect;
};
/* @internal */
const whenEffect = /*#__PURE__*/Function_dual(2, (self, condition) => core_flatMap(condition, b => {
  if (b) {
    return Function_pipe(self, core_map(Option_some));
  }
  return succeed(Option_none());
}));
/* @internal */
const whileLoop = options => {
  const effect = new EffectPrimitive(OP_WHILE);
  effect.effect_instruction_i0 = options.while;
  effect.effect_instruction_i1 = options.body;
  effect.effect_instruction_i2 = options.step;
  return effect;
};
/* @internal */
const withConcurrency = /*#__PURE__*/Function_dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));
/* @internal */
const withRequestBatching = /*#__PURE__*/Function_dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));
/* @internal */
const withRuntimeFlags = /*#__PURE__*/Function_dual(2, (self, update) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = update;
  effect.effect_instruction_i1 = () => self;
  return effect;
});
/** @internal */
const withTracerEnabled = /*#__PURE__*/Function_dual(2, (effect, enabled) => fiberRefLocally(effect, currentTracerEnabled, enabled));
/** @internal */
const withTracerTiming = /*#__PURE__*/Function_dual(2, (effect, enabled) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled));
/* @internal */
const yieldNow = options => {
  const effect = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
};
/* @internal */
const core_zip = /*#__PURE__*/Function_dual(2, (self, that) => core_flatMap(self, a => core_map(that, b => [a, b])));
/* @internal */
const zipFlatten = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => core_flatMap(self, a => core_map(that, b => [...a, b])))));
/* @internal */
const core_zipLeft = /*#__PURE__*/Function_dual(2, (self, that) => core_flatMap(self, a => core_as(that, a)));
/* @internal */
const core_zipRight = /*#__PURE__*/Function_dual(2, (self, that) => core_flatMap(self, () => that));
/* @internal */
const core_zipWith = /*#__PURE__*/Function_dual(3, (self, that, f) => core_flatMap(self, a => core_map(that, b => f(a, b))));
/* @internal */
const never = /*#__PURE__*/core_async(() => {
  const interval = setInterval(() => {
    //
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
// -----------------------------------------------------------------------------
// Fiber
// -----------------------------------------------------------------------------
/* @internal */
const interruptFiber = self => core_flatMap(fiberId, fiberId => Function_pipe(self, interruptAsFiber(fiberId)));
/* @internal */
const interruptAsFiber = /*#__PURE__*/Function_dual(2, (self, fiberId) => core_flatMap(self.interruptAsFork(fiberId), () => self.await));
// -----------------------------------------------------------------------------
// LogLevel
// -----------------------------------------------------------------------------
/** @internal */
const logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 50000,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 40000,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 30000,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 20000,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 10000,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];
// -----------------------------------------------------------------------------
// FiberRef
// -----------------------------------------------------------------------------
/** @internal */
const FiberRefSymbolKey = "effect/FiberRef";
/** @internal */
const FiberRefTypeId = /*#__PURE__*/Symbol.for(FiberRefSymbolKey);
const fiberRefVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/* @internal */
const fiberRefGet = self => fiberRefModify(self, a => [a, a]);
/* @internal */
const fiberRefGetAndSet = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, value) => fiberRefModify(self, v => [v, value]))));
/* @internal */
const fiberRefGetAndUpdate = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => fiberRefModify(self, v => [v, f(v)]))));
/* @internal */
const fiberRefGetAndUpdateSome = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, pf) => fiberRefModify(self, v => [v, Option.getOrElse(pf(v), () => v)]))));
/* @internal */
const fiberRefGetWith = /*#__PURE__*/Function_dual(2, (self, f) => core_flatMap(fiberRefGet(self), f));
/* @internal */
const fiberRefSet = /*#__PURE__*/Function_dual(2, (self, value) => fiberRefModify(self, () => [void 0, value]));
/* @internal */
const fiberRefDelete = self => withFiberRuntime(state => {
  state.unsafeDeleteFiberRef(self);
  return core_void_;
});
/* @internal */
const fiberRefReset = self => fiberRefSet(self, self.initial);
/* @internal */
const fiberRefModify = /*#__PURE__*/Function_dual(2, (self, f) => withFiberRuntime(state => {
  const [b, a] = f(state.getFiberRef(self));
  state.setFiberRef(self, a);
  return succeed(b);
}));
/* @internal */
const fiberRefModifySome = (self, def, f) => fiberRefModify(self, v => Option.getOrElse(f(v), () => [def, v]));
/* @internal */
const fiberRefUpdate = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => fiberRefModify(self, v => [void 0, f(v)]))));
/* @internal */
const fiberRefUpdateSome = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, pf) => fiberRefModify(self, v => [void 0, Option.getOrElse(pf(v), () => v)]))));
/* @internal */
const fiberRefUpdateAndGet = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => fiberRefModify(self, v => {
  const result = f(v);
  return [result, result];
}))));
/* @internal */
const fiberRefUpdateSomeAndGet = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, pf) => fiberRefModify(self, v => {
  const result = Option.getOrElse(pf(v), () => v);
  return [result, result];
}))));
// circular
/** @internal */
const RequestResolverSymbolKey = "effect/RequestResolver";
/** @internal */
const RequestResolverTypeId = /*#__PURE__*/Symbol.for(RequestResolverSymbolKey);
const requestResolverVariance = {
  /* c8 ignore next */
  _A: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
/** @internal */
class RequestResolverImpl {
  runAll;
  target;
  [RequestResolverTypeId] = requestResolverVariance;
  constructor(runAll, target) {
    this.runAll = runAll;
    this.target = target;
    this.runAll = runAll;
  }
  [symbol]() {
    return cached(this, this.target ? Hash_hash(this.target) : random(this));
  }
  [Equal_symbol](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
  }
  identified(...ids) {
    return new RequestResolverImpl(this.runAll, Chunk_fromIterable(ids));
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
const isRequestResolver = u => Predicate_hasProperty(u, RequestResolverTypeId);
// end
/** @internal */
const resolverLocally = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (use, self, value) => new RequestResolverImpl(requests => fiberRefLocally(use.runAll(requests), self, value), Chunk.make("Locally", use, self, value)))));
/** @internal */
const requestBlockLocally = (self, ref, value) => _blockedRequests.reduce(self, LocallyReducer(ref, value));
const LocallyReducer = (ref, value) => ({
  emptyCase: () => _blockedRequests.empty,
  parCase: (left, right) => _blockedRequests.par(left, right),
  seqCase: (left, right) => _blockedRequests.seq(left, right),
  singleCase: (dataSource, blockedRequest) => _blockedRequests.single(resolverLocally(dataSource, ref, value), blockedRequest)
});
/* @internal */
const fiberRefLocally = /*#__PURE__*/Function_dual(3, (use, self, value) => acquireUseRelease(core_zipLeft(fiberRefGet(self), fiberRefSet(self, value)), () => use, oldValue => fiberRefSet(self, oldValue)));
/* @internal */
const fiberRefLocallyWith = /*#__PURE__*/Function_dual(3, (use, self, f) => fiberRefGetWith(self, a => fiberRefLocally(use, self, f(a))));
/** @internal */
const fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: differ_update(),
  fork: options?.fork ?? Function_identity,
  join: options?.join
});
/** @internal */
const fiberRefUnsafeMakeHashSet = initial => {
  const differ = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ,
    fork: differ.empty
  });
};
/** @internal */
const fiberRefUnsafeMakeReadonlyArray = initial => {
  const differ = differ_readonlyArray(differ_update());
  return fiberRefUnsafeMakePatch(initial, {
    differ,
    fork: differ.empty
  });
};
/** @internal */
const fiberRefUnsafeMakeContext = initial => {
  const differ = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ,
    fork: differ.empty
  });
};
/** @internal */
const fiberRefUnsafeMakePatch = (initial, options) => ({
  [FiberRefTypeId]: fiberRefVariance,
  initial,
  diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
  combine: (first, second) => options.differ.combine(first, second),
  patch: patch => oldValue => options.differ.patch(patch, oldValue),
  fork: options.fork,
  join: options.join ?? ((_, n) => n),
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
});
/** @internal */
const fiberRefUnsafeMakeRuntimeFlags = initial => fiberRefUnsafeMakePatch(initial, {
  differ: differ,
  fork: differ.empty
});
/** @internal */
const currentContext = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(Context_empty()));
/** @internal */
const currentSchedulingPriority = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
/** @internal */
const currentMaxOpsBeforeYield = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
/** @internal */
const currentLogAnnotations = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(HashMap_empty()));
/** @internal */
const currentLogLevel = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
/** @internal */
const currentLogSpan = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(List_empty()));
/** @internal */
const withSchedulingPriority = /*#__PURE__*/Function_dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));
/** @internal */
const withMaxOpsBeforeYield = /*#__PURE__*/Function_dual(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler));
/** @internal */
const currentConcurrency = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
/**
 * @internal
 */
const currentRequestBatching = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentUnhandledErrorLogLevel = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(Option_some(logLevelDebug)));
/** @internal */
const withUnhandledErrorLogLevel = /*#__PURE__*/Function_dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
/** @internal */
const currentMetricLabels = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(Array_empty()));
/* @internal */
const metricLabels = /*#__PURE__*/fiberRefGet(currentMetricLabels);
/** @internal */
const currentForkScopeOverride = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(Option_none(), {
  fork: () => Option_none(),
  join: (parent, _) => parent
}));
/** @internal */
const currentInterruptedCause = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(cause_empty, {
  fork: () => cause_empty,
  join: (parent, _) => parent
}));
/** @internal */
const currentTracerEnabled = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentTracerTimingEnabled = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentTracerSpanAnnotations = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(HashMap_empty()));
/** @internal */
const currentTracerSpanLinks = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(esm_Chunk_empty()));
// -----------------------------------------------------------------------------
// Scope
// -----------------------------------------------------------------------------
/** @internal */
const ScopeTypeId = /*#__PURE__*/Symbol.for("effect/Scope");
/** @internal */
const CloseableScopeTypeId = /*#__PURE__*/Symbol.for("effect/CloseableScope");
/* @internal */
const scopeAddFinalizer = (self, finalizer) => self.addFinalizer(() => core_asVoid(finalizer));
/* @internal */
const scopeAddFinalizerExit = (self, finalizer) => self.addFinalizer(finalizer);
/* @internal */
const scopeClose = (self, exit) => self.close(exit);
/* @internal */
const scopeFork = (self, strategy) => self.fork(strategy);
// -----------------------------------------------------------------------------
// Cause
// -----------------------------------------------------------------------------
/** @internal */
const causeSquash = self => {
  return causeSquashWith(identity)(self);
};
/** @internal */
const causeSquashWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const option = pipe(self, internalCause.failureOption, Option.map(f));
  switch (option._tag) {
    case "None":
      {
        return pipe(internalCause.defects(self), Chunk.head, Option.match({
          onNone: () => {
            const interrupts = Arr.fromIterable(internalCause.interruptors(self)).flatMap(fiberId => Arr.fromIterable(FiberId.ids(fiberId)).map(id => `#${id}`));
            return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
          },
          onSome: identity
        }));
      }
    case "Some":
      {
        return option.value;
      }
  }
})));
// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------
/** @internal */
const YieldableError = /*#__PURE__*/function () {
  class YieldableError extends globalThis.Error {
    commit() {
      return core_fail(this);
    }
    toString() {
      return this.message ? `${this.name}: ${this.message}` : this.name;
    }
    toJSON() {
      return {
        ...this
      };
    }
    [NodeInspectSymbol]() {
      const stack = this.stack;
      if (stack) {
        return `${this.toString()}\n${stack.split("\n").slice(1).join("\n")}`;
      }
      return this.toString();
    }
  }
  Object.assign(YieldableError.prototype, StructuralCommitPrototype);
  return YieldableError;
}();
const makeException = (proto, tag) => {
  class Base extends YieldableError {
    _tag = tag;
  }
  Object.assign(Base.prototype, proto);
  Base.prototype.name = tag;
  return Base;
};
/** @internal */
const RuntimeExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/RuntimeException");
/** @internal */
const RuntimeException = /*#__PURE__*/makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
/** @internal */
const isRuntimeException = u => hasProperty(u, RuntimeExceptionTypeId);
/** @internal */
const InterruptedExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/InterruptedException");
/** @internal */
const InterruptedException = /*#__PURE__*/makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
/** @internal */
const isInterruptedException = u => Predicate_hasProperty(u, InterruptedExceptionTypeId);
/** @internal */
const IllegalArgumentExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/IllegalArgument");
/** @internal */
const IllegalArgumentException = /*#__PURE__*/makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
/** @internal */
const isIllegalArgumentException = u => hasProperty(u, IllegalArgumentExceptionTypeId);
/** @internal */
const NoSuchElementExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/NoSuchElement");
/** @internal */
const NoSuchElementException = /*#__PURE__*/makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
/** @internal */
const isNoSuchElementException = u => Predicate_hasProperty(u, NoSuchElementExceptionTypeId);
/** @internal */
const InvalidPubSubCapacityExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
/** @internal */
const InvalidPubSubCapacityException = /*#__PURE__*/makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
/** @internal */
const isInvalidCapacityError = u => hasProperty(u, InvalidPubSubCapacityExceptionTypeId);
/** @internal */
const TimeoutExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/Timeout");
/** @internal */
const TimeoutException = /*#__PURE__*/makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
/** @internal */
const isTimeoutException = u => hasProperty(u, TimeoutExceptionTypeId);
/** @internal */
const UnknownExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/UnknownException");
/** @internal */
const UnknownException = /*#__PURE__*/function () {
  class UnknownException extends YieldableError {
    error;
    _tag = "UnknownException";
    constructor(error, message) {
      super(message ?? (Predicate_hasProperty(error, "message") && isString(error.message) ? error.message : void 0));
      this.error = error;
    }
  }
  Object.assign(UnknownException.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException;
}();
/** @internal */
const isUnknownException = u => hasProperty(u, UnknownExceptionTypeId);
// -----------------------------------------------------------------------------
// Exit
// -----------------------------------------------------------------------------
/** @internal */
const exitIsExit = u => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
/** @internal */
const exitIsFailure = self => self._tag === "Failure";
/** @internal */
const exitIsSuccess = self => self._tag === "Success";
/** @internal */
const exitIsInterrupted = self => {
  switch (self._tag) {
    case OP_FAILURE:
      return isInterrupted(self.effect_instruction_i0);
    case OP_SUCCESS:
      return false;
  }
};
/** @internal */
const exitAs = /*#__PURE__*/Function_dual(2, (self, value) => {
  switch (self._tag) {
    case OP_FAILURE:
      {
        return exitFailCause(self.effect_instruction_i0);
      }
    case OP_SUCCESS:
      {
        return exitSucceed(value);
      }
  }
});
/** @internal */
const exitAsVoid = self => exitAs(self, void 0);
/** @internal */
const exitCauseOption = self => {
  switch (self._tag) {
    case OP_FAILURE:
      return Option_some(self.effect_instruction_i0);
    case OP_SUCCESS:
      return Option_none();
  }
};
/** @internal */
const exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);
/** @internal */
const exitDie = defect => exitFailCause(die(defect));
/** @internal */
const exitExists = /*#__PURE__*/Function_dual(2, (self, refinement) => {
  switch (self._tag) {
    case OP_FAILURE:
      return false;
    case OP_SUCCESS:
      return refinement(self.effect_instruction_i0);
  }
});
/** @internal */
const exitFail = error => exitFailCause(fail(error));
/** @internal */
const exitFailCause = cause => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
/** @internal */
const exitFlatMap = /*#__PURE__*/Function_dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      {
        return exitFailCause(self.effect_instruction_i0);
      }
    case OP_SUCCESS:
      {
        return f(self.effect_instruction_i0);
      }
  }
});
/** @internal */
const exitFlatMapEffect = /*#__PURE__*/Function_dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      {
        return succeed(exitFailCause(self.effect_instruction_i0));
      }
    case OP_SUCCESS:
      {
        return f(self.effect_instruction_i0);
      }
  }
});
/** @internal */
const exitFlatten = self => Function_pipe(self, exitFlatMap(Function_identity));
/** @internal */
const exitForEachEffect = /*#__PURE__*/Function_dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      {
        return succeed(exitFailCause(self.effect_instruction_i0));
      }
    case OP_SUCCESS:
      {
        return core_exit(f(self.effect_instruction_i0));
      }
  }
});
/** @internal */
const exitFromEither = either => {
  switch (either._tag) {
    case "Left":
      return exitFail(either.left);
    case "Right":
      return exitSucceed(either.right);
  }
};
/** @internal */
const exitFromOption = option => {
  switch (option._tag) {
    case "None":
      return exitFail(void 0);
    case "Some":
      return exitSucceed(option.value);
  }
};
/** @internal */
const exitGetOrElse = /*#__PURE__*/Function_dual(2, (self, orElse) => {
  switch (self._tag) {
    case OP_FAILURE:
      return orElse(self.effect_instruction_i0);
    case OP_SUCCESS:
      return self.effect_instruction_i0;
  }
});
/** @internal */
const exitInterrupt = fiberId => exitFailCause(interrupt(fiberId));
/** @internal */
const exitMap = /*#__PURE__*/Function_dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(self.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self.effect_instruction_i0));
  }
});
/** @internal */
const exitMapBoth = /*#__PURE__*/Function_dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(Function_pipe(self.effect_instruction_i0, cause_map(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self.effect_instruction_i0));
  }
});
/** @internal */
const exitMapError = /*#__PURE__*/Function_dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(Function_pipe(self.effect_instruction_i0, cause_map(f)));
    case OP_SUCCESS:
      return exitSucceed(self.effect_instruction_i0);
  }
});
/** @internal */
const exitMapErrorCause = /*#__PURE__*/Function_dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(f(self.effect_instruction_i0));
    case OP_SUCCESS:
      return exitSucceed(self.effect_instruction_i0);
  }
});
/** @internal */
const exitMatch = /*#__PURE__*/Function_dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
/** @internal */
const exitMatchEffect = /*#__PURE__*/Function_dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
/** @internal */
const exitSucceed = value => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
/** @internal */
const exitVoid = /*#__PURE__*/exitSucceed(void 0);
/** @internal */
const exitZip = /*#__PURE__*/Function_dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: sequential
}));
/** @internal */
const exitZipLeft = /*#__PURE__*/Function_dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, _) => a,
  onFailure: sequential
}));
/** @internal */
const exitZipRight = /*#__PURE__*/Function_dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: sequential
}));
/** @internal */
const exitZipPar = /*#__PURE__*/Function_dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: parallel
}));
/** @internal */
const exitZipParLeft = /*#__PURE__*/Function_dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, _) => a,
  onFailure: parallel
}));
/** @internal */
const exitZipParRight = /*#__PURE__*/Function_dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: parallel
}));
/** @internal */
const exitZipWith = /*#__PURE__*/Function_dual(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      {
        switch (that._tag) {
          case OP_SUCCESS:
            return exitFailCause(self.effect_instruction_i0);
          case OP_FAILURE:
            {
              return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
            }
        }
      }
    case OP_SUCCESS:
      {
        switch (that._tag) {
          case OP_SUCCESS:
            return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
          case OP_FAILURE:
            return exitFailCause(that.effect_instruction_i0);
        }
      }
  }
});
const exitCollectAllInternal = (exits, combineCauses) => {
  const list = Chunk_fromIterable(exits);
  if (!isNonEmpty(list)) {
    return Option_none();
  }
  return Function_pipe(Chunk_tailNonEmpty(list), Array_reduce(Function_pipe(Chunk_headNonEmpty(list), exitMap(Chunk_of)), (accumulator, current) => Function_pipe(accumulator, exitZipWith(current, {
    onSuccess: (list, value) => Function_pipe(list, Chunk_prepend(value)),
    onFailure: combineCauses
  }))), exitMap(Chunk_reverse), exitMap(chunk => toReadonlyArray(chunk)), Option_some);
};
// -----------------------------------------------------------------------------
// Deferred
// -----------------------------------------------------------------------------
/** @internal */
const deferredUnsafeMake = fiberId => ({
  [DeferredTypeId]: deferredVariance,
  state: MutableRef_make(pending([])),
  blockingOn: fiberId,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
});
/* @internal */
const deferredMake = () => core_flatMap(fiberId, id => deferredMakeAs(id));
/* @internal */
const deferredMakeAs = fiberId => sync(() => deferredUnsafeMake(fiberId));
/* @internal */
const deferredAwait = self => core_async(resume => {
  const state = MutableRef_get(self.state);
  switch (state._tag) {
    case OP_STATE_DONE:
      {
        return resume(state.effect);
      }
    case OP_STATE_PENDING:
      {
        // we can push here as the internal state is mutable
        state.joiners.push(resume);
        return deferredInterruptJoiner(self, resume);
      }
  }
}, self.blockingOn);
/* @internal */
const deferredComplete = /*#__PURE__*/Function_dual(2, (self, effect) => intoDeferred(effect, self));
/* @internal */
const deferredCompleteWith = /*#__PURE__*/Function_dual(2, (self, effect) => sync(() => {
  const state = MutableRef_get(self.state);
  switch (state._tag) {
    case OP_STATE_DONE:
      {
        return false;
      }
    case OP_STATE_PENDING:
      {
        MutableRef_set(self.state, done(effect));
        for (let i = 0, len = state.joiners.length; i < len; i++) {
          state.joiners[i](effect);
        }
        return true;
      }
  }
}));
/* @internal */
const deferredDone = /*#__PURE__*/Function_dual(2, (self, exit) => deferredCompleteWith(self, exit));
/* @internal */
const deferredFail = /*#__PURE__*/Function_dual(2, (self, error) => deferredCompleteWith(self, core_fail(error)));
/* @internal */
const deferredFailSync = /*#__PURE__*/Function_dual(2, (self, evaluate) => deferredCompleteWith(self, failSync(evaluate)));
/* @internal */
const deferredFailCause = /*#__PURE__*/Function_dual(2, (self, cause) => deferredCompleteWith(self, failCause(cause)));
/* @internal */
const deferredFailCauseSync = /*#__PURE__*/Function_dual(2, (self, evaluate) => deferredCompleteWith(self, failCauseSync(evaluate)));
/* @internal */
const deferredDie = /*#__PURE__*/Function_dual(2, (self, defect) => deferredCompleteWith(self, core_die(defect)));
/* @internal */
const deferredDieSync = /*#__PURE__*/Function_dual(2, (self, evaluate) => deferredCompleteWith(self, dieSync(evaluate)));
/* @internal */
const deferredInterrupt = self => core_flatMap(fiberId, fiberId => deferredCompleteWith(self, interruptWith(fiberId)));
/* @internal */
const deferredInterruptWith = /*#__PURE__*/Function_dual(2, (self, fiberId) => deferredCompleteWith(self, interruptWith(fiberId)));
/* @internal */
const deferredIsDone = self => sync(() => MutableRef_get(self.state)._tag === OP_STATE_DONE);
/* @internal */
const deferredPoll = self => sync(() => {
  const state = MutableRef_get(self.state);
  switch (state._tag) {
    case OP_STATE_DONE:
      {
        return Option_some(state.effect);
      }
    case OP_STATE_PENDING:
      {
        return Option_none();
      }
  }
});
/* @internal */
const deferredSucceed = /*#__PURE__*/Function_dual(2, (self, value) => deferredCompleteWith(self, succeed(value)));
/* @internal */
const deferredSync = /*#__PURE__*/Function_dual(2, (self, evaluate) => deferredCompleteWith(self, sync(evaluate)));
/** @internal */
const deferredUnsafeDone = (self, effect) => {
  const state = MutableRef_get(self.state);
  if (state._tag === OP_STATE_PENDING) {
    MutableRef_set(self.state, done(effect));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect);
    }
  }
};
const deferredInterruptJoiner = (self, joiner) => sync(() => {
  const state = MutableRef_get(self.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      // we can splice here as the internal state is mutable
      state.joiners.splice(index, 1);
    }
  }
});
// -----------------------------------------------------------------------------
// Context
// -----------------------------------------------------------------------------
const constContext = /*#__PURE__*/fiberRefGet(currentContext);
/* @internal */
const context = () => constContext;
/* @internal */
const contextWith = f => core_map(context(), f);
/* @internal */
const contextWithEffect = f => core_flatMap(context(), f);
/* @internal */
const provideContext = /*#__PURE__*/Function_dual(2, (self, context) => fiberRefLocally(currentContext, context)(self));
/* @internal */
const provideSomeContext = /*#__PURE__*/Function_dual(2, (self, context) => fiberRefLocallyWith(currentContext, parent => Context_merge(parent, context))(self));
/* @internal */
const mapInputContext = /*#__PURE__*/Function_dual(2, (self, f) => contextWithEffect(context => provideContext(self, f(context))));
// -----------------------------------------------------------------------------
// Tracing
// -----------------------------------------------------------------------------
/** @internal */
const currentSpanFromFiber = fiber => {
  const span = fiber.getFiberRef(currentContext).unsafeMap.get(spanTag.key);
  return span !== undefined && span._tag === "Span" ? Option_some(span) : Option_none();
};
const NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  name: "noop",
  sampled: false,
  parent: /*#__PURE__*/Option_none(),
  context: /*#__PURE__*/Context_empty(),
  status: {
    _tag: "Ended",
    startTime: /*#__PURE__*/BigInt(0),
    endTime: /*#__PURE__*/BigInt(0),
    exit: exitVoid
  },
  attributes: /*#__PURE__*/new Map(),
  links: [],
  kind: "internal",
  attribute() {},
  event() {},
  end() {}
};
/** @internal */
const noopSpan = name => {
  const span = Object.create(NoopSpanProto);
  span.name = name;
  return span;
};
//# sourceMappingURL=core.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Duration.js
/**
 * @since 2.0.0
 */








const Duration_TypeId = /*#__PURE__*/Symbol.for("effect/Duration");
const bigint0 = /*#__PURE__*/BigInt(0);
const bigint24 = /*#__PURE__*/BigInt(24);
const bigint60 = /*#__PURE__*/BigInt(60);
const bigint1e3 = /*#__PURE__*/BigInt(1_000);
const bigint1e6 = /*#__PURE__*/BigInt(1_000_000);
const bigint1e9 = /*#__PURE__*/BigInt(1_000_000_000);
const DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
/**
 * @since 2.0.0
 */
const decode = input => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return Duration_millis(input);
  } else if (isBigInt(input)) {
    return Duration_nanos(input);
  } else if (Array.isArray(input)) {
    if (input.length === 2 && isNumber(input[0]) && isNumber(input[1])) {
      return Duration_nanos(BigInt(input[0]) * bigint1e9 + BigInt(input[1]));
    }
  } else if (isString(input)) {
    DURATION_REGEX.lastIndex = 0; // Reset the lastIndex before each use
    const match = DURATION_REGEX.exec(input);
    if (match) {
      const [_, valueStr, unit] = match;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return Duration_nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return Duration_millis(value);
        case "second":
        case "seconds":
          return seconds(value);
        case "minute":
        case "minutes":
          return minutes(value);
        case "hour":
        case "hours":
          return hours(value);
        case "day":
        case "days":
          return days(value);
        case "week":
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
/**
 * @since 2.5.0
 */
const decodeUnknown = /*#__PURE__*/(/* unused pure expression or super */ null && (Option.liftThrowable(decode)));
const zeroValue = {
  _tag: "Millis",
  millis: 0
};
const infinityValue = {
  _tag: "Infinity"
};
const DurationProto = {
  [Duration_TypeId]: Duration_TypeId,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [Equal_symbol](that) {
    return isDuration(that) && Duration_equals(this, that);
  },
  toString() {
    return `Duration(${Duration_format(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
const Duration_make = input => {
  const duration = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1_000_000))
      };
    } else {
      duration.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint0) {
    duration.value = zeroValue;
  } else {
    duration.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration;
};
/**
 * @since 2.0.0
 * @category guards
 */
const isDuration = u => Predicate_hasProperty(u, Duration_TypeId);
/**
 * @since 2.0.0
 * @category guards
 */
const Duration_isFinite = self => self.value._tag !== "Infinity";
/**
 * @since 2.0.0
 * @category constructors
 */
const zero = /*#__PURE__*/Duration_make(0);
/**
 * @since 2.0.0
 * @category constructors
 */
const infinity = /*#__PURE__*/(/* unused pure expression or super */ null && (Duration_make(Infinity)));
/**
 * @since 2.0.0
 * @category constructors
 */
const Duration_nanos = nanos => Duration_make(nanos);
/**
 * @since 2.0.0
 * @category constructors
 */
const micros = micros => Duration_make(micros * bigint1e3);
/**
 * @since 2.0.0
 * @category constructors
 */
const Duration_millis = millis => Duration_make(millis);
/**
 * @since 2.0.0
 * @category constructors
 */
const seconds = seconds => Duration_make(seconds * 1000);
/**
 * @since 2.0.0
 * @category constructors
 */
const minutes = minutes => Duration_make(minutes * 60_000);
/**
 * @since 2.0.0
 * @category constructors
 */
const hours = hours => Duration_make(hours * 3_600_000);
/**
 * @since 2.0.0
 * @category constructors
 */
const days = days => Duration_make(days * 86_400_000);
/**
 * @since 2.0.0
 * @category constructors
 */
const weeks = weeks => Duration_make(weeks * 604_800_000);
/**
 * @since 2.0.0
 * @category getters
 */
const toMillis = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return Infinity;
    case "Nanos":
      return Number(_self.value.nanos) / 1_000_000;
    case "Millis":
      return _self.value.millis;
  }
};
/**
 * @since 2.0.0
 * @category getters
 */
const toSeconds = self => toMillis(self) / 1_000;
/**
 * Get the duration in nanoseconds as a bigint.
 *
 * If the duration is infinite, returns `Option.none()`
 *
 * @since 2.0.0
 * @category getters
 */
const toNanos = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return Option.none();
    case "Nanos":
      return Option.some(_self.value.nanos);
    case "Millis":
      return Option.some(BigInt(Math.round(_self.value.millis * 1_000_000)));
  }
};
/**
 * Get the duration in nanoseconds as a bigint.
 *
 * If the duration is infinite, it throws an error.
 *
 * @since 2.0.0
 * @category getters
 */
const unsafeToNanos = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1_000_000));
  }
};
/**
 * @since 2.0.0
 * @category getters
 */
const toHrTime = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1_000_000)];
  }
};
/**
 * @since 2.0.0
 * @category pattern matching
 */
const Duration_match = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, options) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
})));
/**
 * @since 2.0.0
 * @category pattern matching
 */
const matchWith = /*#__PURE__*/Function_dual(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1_000_000));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1_000_000));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
/**
 * @category instances
 * @since 2.0.0
 */
const Duration_Order = /*#__PURE__*/(/* unused pure expression or super */ null && (order.make((self, that) => matchWith(self, that, {
  onMillis: (self, that) => self < that ? -1 : self > that ? 1 : 0,
  onNanos: (self, that) => self < that ? -1 : self > that ? 1 : 0
}))));
/**
 * Checks if a `Duration` is between a `minimum` and `maximum` value.
 *
 * @category predicates
 * @since 2.0.0
 */
const Duration_between = /*#__PURE__*/(/* unused pure expression or super */ null && (order.between( /*#__PURE__*/order.mapInput(Duration_Order, decode))));
/**
 * @category instances
 * @since 2.0.0
 */
const Duration_Equivalence = (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self === that,
  onNanos: (self, that) => self === that
});
const _min = /*#__PURE__*/(/* unused pure expression or super */ null && (order.min(Duration_Order)));
/**
 * @since 2.0.0
 */
const Duration_min = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => _min(decode(self), decode(that)))));
const _max = /*#__PURE__*/(/* unused pure expression or super */ null && (order.max(Duration_Order)));
/**
 * @since 2.0.0
 */
const Duration_max = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => _max(decode(self), decode(that)))));
const _clamp = /*#__PURE__*/(/* unused pure expression or super */ null && (order.clamp(Duration_Order)));
/**
 * @since 2.0.0
 */
const Duration_clamp = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, options) => _clamp(decode(self), {
  minimum: decode(options.minimum),
  maximum: decode(options.maximum)
}))));
/**
 * @since 2.4.19
 * @category math
 */
const divide = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, by) => Duration_match(self, {
  onMillis: millis => {
    if (by === 0 || isNaN(by) || !Number.isFinite(by)) {
      return Option.none();
    }
    return Option.some(Duration_make(millis / by));
  },
  onNanos: nanos => {
    if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {
      return Option.none();
    }
    try {
      return Option.some(Duration_make(nanos / BigInt(by)));
    } catch (e) {
      return Option.none();
    }
  }
}))));
/**
 * @since 2.4.19
 * @category math
 */
const unsafeDivide = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, by) => Duration_match(self, {
  onMillis: millis => Duration_make(millis / by),
  onNanos: nanos => {
    if (isNaN(by) || by < 0 || Object.is(by, -0)) {
      return zero;
    } else if (Object.is(by, 0) || !Number.isFinite(by)) {
      return infinity;
    }
    return Duration_make(nanos / BigInt(by));
  }
}))));
/**
 * @since 2.0.0
 * @category math
 */
const times = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, times) => Duration_match(self, {
  onMillis: millis => Duration_make(millis * times),
  onNanos: nanos => Duration_make(nanos * BigInt(times))
}))));
/**
 * @since 2.0.0
 * @category math
 */
const subtract = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => Duration_make(self - that),
  onNanos: (self, that) => Duration_make(self - that)
}))));
/**
 * @since 2.0.0
 * @category math
 */
const sum = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => Duration_make(self + that),
  onNanos: (self, that) => Duration_make(self + that)
}))));
/**
 * @since 2.0.0
 * @category predicates
 */
const Duration_lessThan = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self < that,
  onNanos: (self, that) => self < that
}))));
/**
 * @since 2.0.0
 * @category predicates
 */
const Duration_lessThanOrEqualTo = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self <= that,
  onNanos: (self, that) => self <= that
}))));
/**
 * @since 2.0.0
 * @category predicates
 */
const Duration_greaterThan = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self > that,
  onNanos: (self, that) => self > that
}))));
/**
 * @since 2.0.0
 * @category predicates
 */
const Duration_greaterThanOrEqualTo = /*#__PURE__*/Function_dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self >= that,
  onNanos: (self, that) => self >= that
}));
/**
 * @since 2.0.0
 * @category predicates
 */
const Duration_equals = /*#__PURE__*/Function_dual(2, (self, that) => Duration_Equivalence(decode(self), decode(that)));
/**
 * Converts a `Duration` to a human readable string.
 * @since 2.0.0
 *
 * @example
 * import { Duration } from "effect"
 *
 * Duration.format(Duration.millis(1000)) // "1s"
 * Duration.format(Duration.millis(1001)) // "1s 1ms"
 */
const Duration_format = self => {
  const duration = decode(self);
  const parts = [];
  if (duration.value._tag === "Infinity") {
    return "Infinity";
  }
  const nanos = unsafeToNanos(duration);
  if (nanos % bigint1e6) {
    parts.push(`${nanos % bigint1e6}ns`);
  }
  const ms = nanos / bigint1e6;
  if (ms % bigint1e3 !== bigint0) {
    parts.push(`${ms % bigint1e3}ms`);
  }
  const sec = ms / bigint1e3;
  if (sec % bigint60 !== bigint0) {
    parts.push(`${sec % bigint60}s`);
  }
  const min = sec / bigint60;
  if (min % bigint60 !== bigint0) {
    parts.push(`${min % bigint60}m`);
  }
  const hr = min / bigint60;
  if (hr % bigint24 !== bigint0) {
    parts.push(`${hr % bigint24}h`);
  }
  const days = hr / bigint24;
  if (days !== bigint0) {
    parts.push(`${days}d`);
  }
  return parts.reverse().join(" ");
};
//# sourceMappingURL=Duration.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/clock.js




/** @internal */
const ClockSymbolKey = "effect/Clock";
/** @internal */
const ClockTypeId = /*#__PURE__*/Symbol.for(ClockSymbolKey);
/** @internal */
const clockTag = /*#__PURE__*/GenericTag("effect/Clock");
/** @internal */
const MAX_TIMER_MILLIS = 2 ** 31 - 1;
/** @internal */
const globalClockScheduler = {
  unsafeSchedule(task, duration) {
    const millis = toMillis(duration);
    // If the duration is greater than the value allowable by the JS timer
    // functions, treat the value as an infinite duration
    if (millis > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
const performanceNowNanos = /*#__PURE__*/function () {
  const bigint1e6 = /*#__PURE__*/BigInt(1_000_000);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e6;
  }
  const origin = "timeOrigin" in performance && typeof performance.timeOrigin === "number" ? /*#__PURE__*/BigInt( /*#__PURE__*/Math.round(performance.timeOrigin * 1_000_000)) : /*#__PURE__*/BigInt( /*#__PURE__*/Date.now()) * bigint1e6 - /*#__PURE__*/BigInt( /*#__PURE__*/Math.round( /*#__PURE__*/performance.now() * 1_000_000));
  return () => origin + BigInt(Math.round(performance.now() * 1_000_000));
}();
const processOrPerformanceNow = /*#__PURE__*/function () {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : undefined;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /*#__PURE__*/performanceNowNanos() - /*#__PURE__*/processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();
/** @internal */
class ClockImpl {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration) {
    return core_async(resume => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume(core_void_), duration);
      return core_asVoid(sync(canceler));
    });
  }
}
/** @internal */
const clock_make = () => new ClockImpl();
//# sourceMappingURL=clock.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Number.js
/**
 * This module provides utility functions and type class instances for working with the `number` type in TypeScript.
 * It includes functions for basic arithmetic operations, as well as type class instances for
 * `Equivalence` and `Order`.
 *
 * @since 2.0.0
 */





/**
 * Tests if a value is a `number`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isNumber } from "effect/Number"
 *
 * assert.deepStrictEqual(isNumber(2), true)
 * assert.deepStrictEqual(isNumber("2"), false)
 *
 * @category guards
 * @since 2.0.0
 */
const Number_isNumber = isNumber;
/**
 * Provides an addition operation on `number`s.
 *
 * @param self - The first operand.
 * @param that - The second operand.
 *
 * @example
 * import { sum } from "effect/Number"
 *
 * assert.deepStrictEqual(sum(2, 3), 5)
 *
 * @category math
 * @since 2.0.0
 */
const Number_sum = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => self + that)));
/**
 * Provides a multiplication operation on `number`s.
 *
 * @param self - The first operand.
 * @param that - The second operand.
 *
 * @example
 * import { multiply } from "effect/Number"
 *
 * assert.deepStrictEqual(multiply(2, 3), 6)
 *
 * @category math
 * @since 2.0.0
 */
const multiply = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => self * that)));
/**
 * Provides a subtraction operation on `number`s.
 *
 * @param self - The first operand.
 * @param that - The second operand.
 *
 * @example
 * import { subtract } from "effect/Number"
 *
 * assert.deepStrictEqual(subtract(2, 3), -1)
 *
 * @category math
 * @since 2.0.0
 */
const Number_subtract = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => self - that)));
/**
 * Provides a division operation on `number`s.
 *
 * @param self - The dividend operand.
 * @param that - The divisor operand.
 *
 * @example
 * import { Number, Option } from "effect"
 *
 * assert.deepStrictEqual(Number.divide(6, 3), Option.some(2))
 * assert.deepStrictEqual(Number.divide(6, 0), Option.none())
 *
 * @category math
 * @since 2.0.0
 */
const Number_divide = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => that === 0 ? option.none : option.some(self / that))));
/**
 * Provides a division operation on `number`s.
 *
 * Throws a `RangeError` if the divisor is `0`.
 *
 * @param self - The dividend operand.
 * @param that - The divisor operand.
 *
 * @example
 * import { unsafeDivide } from "effect/Number"
 *
 * assert.deepStrictEqual(unsafeDivide(6, 3), 2)
 *
 * @category math
 * @since 2.0.0
 */
const Number_unsafeDivide = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => self / that)));
/**
 * Returns the result of adding `1` to a given number.
 *
 * @param n - A `number` to be incremented.
 *
 * @example
 * import { increment } from "effect/Number"
 *
 * assert.deepStrictEqual(increment(2), 3)
 *
 * @category math
 * @since 2.0.0
 */
const Number_increment = n => n + 1;
/**
 * Decrements a number by `1`.
 *
 * @param n - A `number` to be decremented.
 *
 * @example
 * import { decrement } from "effect/Number"
 *
 * assert.deepStrictEqual(decrement(3), 2)
 *
 * @category math
 * @since 2.0.0
 */
const Number_decrement = n => n - 1;
/**
 * @category instances
 * @since 2.0.0
 */
const Number_Equivalence = Equivalence_number;
/**
 * @category instances
 * @since 2.0.0
 */
const Number_Order = Order_number;
/**
 * Returns `true` if the first argument is less than the second, otherwise `false`.
 *
 * @param self - The first argument.
 * @param that - The second argument.
 *
 * @example
 * import { lessThan } from "effect/Number"
 *
 * assert.deepStrictEqual(lessThan(2, 3), true)
 * assert.deepStrictEqual(lessThan(3, 3), false)
 * assert.deepStrictEqual(lessThan(4, 3), false)
 *
 * @category predicates
 * @since 2.0.0
 */
const Number_lessThan = /*#__PURE__*/(/* unused pure expression or super */ null && (order.lessThan(Number_Order)));
/**
 * Returns a function that checks if a given `number` is less than or equal to the provided one.
 *
 * @param self - The first `number` to compare with.
 * @param that - The second `number` to compare with.
 *
 * @example
 * import { lessThanOrEqualTo } from "effect/Number"
 *
 * assert.deepStrictEqual(lessThanOrEqualTo(2, 3), true)
 * assert.deepStrictEqual(lessThanOrEqualTo(3, 3), true)
 * assert.deepStrictEqual(lessThanOrEqualTo(4, 3), false)
 *
 * @category predicates
 * @since 2.0.0
 */
const Number_lessThanOrEqualTo = /*#__PURE__*/(/* unused pure expression or super */ null && (order.lessThanOrEqualTo(Number_Order)));
/**
 * Returns `true` if the first argument is greater than the second, otherwise `false`.
 *
 * @param self - The first argument.
 * @param that - The second argument.
 *
 * @example
 * import { greaterThan } from "effect/Number"
 *
 * assert.deepStrictEqual(greaterThan(2, 3), false)
 * assert.deepStrictEqual(greaterThan(3, 3), false)
 * assert.deepStrictEqual(greaterThan(4, 3), true)
 *
 * @category predicates
 * @since 2.0.0
 */
const Number_greaterThan = /*#__PURE__*/(/* unused pure expression or super */ null && (order.greaterThan(Number_Order)));
/**
 * Returns a function that checks if a given `number` is greater than or equal to the provided one.
 *
 * @param self - The first `number` to compare with.
 * @param that - The second `number` to compare with.
 *
 * @example
 * import { greaterThanOrEqualTo } from "effect/Number"
 *
 * assert.deepStrictEqual(greaterThanOrEqualTo(2, 3), false)
 * assert.deepStrictEqual(greaterThanOrEqualTo(3, 3), true)
 * assert.deepStrictEqual(greaterThanOrEqualTo(4, 3), true)
 *
 * @category predicates
 * @since 2.0.0
 */
const Number_greaterThanOrEqualTo = /*#__PURE__*/(/* unused pure expression or super */ null && (order.greaterThanOrEqualTo(Number_Order)));
/**
 * Checks if a `number` is between a `minimum` and `maximum` value (inclusive).
 *
 * @param self - The `number` to check.
 * @param minimum - The `minimum` value to check.
 * @param maximum - The `maximum` value to check.
 *
 * @example
 * import { Number } from "effect"
 *
 * const between = Number.between({ minimum: 0, maximum: 5 })
 *
 * assert.deepStrictEqual(between(3), true)
 * assert.deepStrictEqual(between(-1), false)
 * assert.deepStrictEqual(between(6), false)
 *
 * @category predicates
 * @since 2.0.0
 */
const Number_between = /*#__PURE__*/(/* unused pure expression or super */ null && (order.between(Number_Order)));
/**
 * Restricts the given `number` to be within the range specified by the `minimum` and `maximum` values.
 *
 * - If the `number` is less than the `minimum` value, the function returns the `minimum` value.
 * - If the `number` is greater than the `maximum` value, the function returns the `maximum` value.
 * - Otherwise, it returns the original `number`.
 *
 * @param self - The `number` to be clamped.
 * @param minimum - The lower end of the range.
 * @param maximum - The upper end of the range.
 *
 * @example
 * import { Number } from "effect"
 *
 * const clamp = Number.clamp({ minimum: 1, maximum: 5 })
 *
 * assert.equal(clamp(3), 3)
 * assert.equal(clamp(0), 1)
 * assert.equal(clamp(6), 5)
 *
 * @since 2.0.0
 */
const Number_clamp = /*#__PURE__*/(/* unused pure expression or super */ null && (order.clamp(Number_Order)));
/**
 * Returns the minimum between two `number`s.
 *
 * @param self - The first `number`.
 * @param that - The second `number`.
 *
 * @example
 * import { min } from "effect/Number"
 *
 * assert.deepStrictEqual(min(2, 3), 2)
 *
 * @since 2.0.0
 */
const Number_min = /*#__PURE__*/(/* unused pure expression or super */ null && (order.min(Number_Order)));
/**
 * Returns the maximum between two `number`s.
 *
 * @param self - The first `number`.
 * @param that - The second `number`.
 *
 * @example
 * import { max } from "effect/Number"
 *
 * assert.deepStrictEqual(max(2, 3), 3)
 *
 * @since 2.0.0
 */
const Number_max = /*#__PURE__*/(/* unused pure expression or super */ null && (order.max(Number_Order)));
/**
 * Determines the sign of a given `number`.
 *
 * @param n - The `number` to determine the sign of.
 *
 * @example
 * import { sign } from "effect/Number"
 *
 * assert.deepStrictEqual(sign(-5), -1)
 * assert.deepStrictEqual(sign(0), 0)
 * assert.deepStrictEqual(sign(5), 1)
 *
 * @category math
 * @since 2.0.0
 */
const sign = n => Number_Order(n, 0);
/**
 * Takes an `Iterable` of `number`s and returns their sum as a single `number`.
 *
 * @param collection - The collection of `number`s to sum.
 *
 * @example
 * import { sumAll } from "effect/Number"
 *
 * assert.deepStrictEqual(sumAll([2, 3, 4]), 9)
 *
 * @category math
 * @since 2.0.0
 */
const sumAll = collection => {
  let out = 0;
  for (const n of collection) {
    out += n;
  }
  return out;
};
/**
 * Takes an `Iterable` of `number`s and returns their multiplication as a single `number`.
 *
 * @param collection - The collection of `number`s to multiply.
 *
 * @example
 * import { multiplyAll } from "effect/Number"
 *
 * assert.deepStrictEqual(multiplyAll([2, 3, 4]), 24)
 *
 * @category math
 * @since 2.0.0
 */
const multiplyAll = collection => {
  let out = 1;
  for (const n of collection) {
    if (n === 0) {
      return 0;
    }
    out *= n;
  }
  return out;
};
/**
 * Returns the remainder left over when one operand is divided by a second operand.
 *
 * It always takes the sign of the dividend.
 *
 * @param self - The dividend.
 * @param divisor - The divisor.
 *
 * @example
 * import { remainder } from "effect/Number"
 *
 * assert.deepStrictEqual(remainder(2, 2), 0)
 * assert.deepStrictEqual(remainder(3, 2), 1)
 * assert.deepStrictEqual(remainder(-4, 2), -0)
 *
 * @category math
 * @since 2.0.0
 */
const remainder = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, divisor) => {
  // https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
  const selfDecCount = (self.toString().split(".")[1] || "").length;
  const divisorDecCount = (divisor.toString().split(".")[1] || "").length;
  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;
  const selfInt = parseInt(self.toFixed(decCount).replace(".", ""));
  const divisorInt = parseInt(divisor.toFixed(decCount).replace(".", ""));
  return selfInt % divisorInt / Math.pow(10, decCount);
})));
/**
 * Returns the next power of 2 from the given number.
 *
 * @param self - The number to find the next power of 2 from.
 *
 * @example
 * import { nextPow2 } from "effect/Number"
 *
 * assert.deepStrictEqual(nextPow2(5), 8)
 * assert.deepStrictEqual(nextPow2(17), 32)
 *
 * @category math
 * @since 2.0.0
 */
const nextPow2 = n => {
  const nextPow = Math.ceil(Math.log(n) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
};
/**
 * Tries to parse a `number` from a `string` using the `Number()` function.
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category constructors
 * @since 2.0.0
 */
const parse = s => {
  if (s === "NaN") {
    return option.some(NaN);
  }
  if (s === "Infinity") {
    return option.some(Infinity);
  }
  if (s === "-Infinity") {
    return option.some(-Infinity);
  }
  if (s.trim() === "") {
    return option.none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? option.none : option.some(n);
};
//# sourceMappingURL=Number.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/RegExp.js
/**
 * This module provides utility functions for working with RegExp in TypeScript.
 *
 * @since 2.0.0
 */
/**
 * Escapes special characters in a regular expression pattern.
 *
 * @example
 * import { RegExp } from "effect"
 *
 * assert.deepStrictEqual(RegExp.escape("a*b"), "a\\*b")
 *
 * @since 2.0.0
 */
const RegExp_escape = string => string.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");
//# sourceMappingURL=RegExp.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/opCodes/configError.js
/** @internal */
const OP_AND = "And";
/** @internal */
const OP_OR = "Or";
/** @internal */
const OP_INVALID_DATA = "InvalidData";
/** @internal */
const OP_MISSING_DATA = "MissingData";
/** @internal */
const OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
/** @internal */
const OP_UNSUPPORTED = "Unsupported";
//# sourceMappingURL=configError.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/configError.js





/** @internal */
const ConfigErrorSymbolKey = "effect/ConfigError";
/** @internal */
const ConfigErrorTypeId = /*#__PURE__*/Symbol.for(ConfigErrorSymbolKey);
/** @internal */
const configError_proto = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
/** @internal */
const And = (self, that) => {
  const error = Object.create(configError_proto);
  error._op = OP_AND;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  return error;
};
/** @internal */
const Or = (self, that) => {
  const error = Object.create(configError_proto);
  error._op = OP_OR;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  return error;
};
/** @internal */
const InvalidData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(configError_proto);
  error._op = OP_INVALID_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path = Function_pipe(this.path, Array_join(options.pathDelim));
      return `(Invalid data at ${path}: "${this.message}")`;
    }
  });
  return error;
};
/** @internal */
const MissingData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(configError_proto);
  error._op = OP_MISSING_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path = Function_pipe(this.path, Array_join(options.pathDelim));
      return `(Missing data at ${path}: "${this.message}")`;
    }
  });
  return error;
};
/** @internal */
const SourceUnavailable = (path, message, cause, options = {
  pathDelim: "."
}) => {
  const error = Object.create(configError_proto);
  error._op = OP_SOURCE_UNAVAILABLE;
  error.path = path;
  error.message = message;
  error.cause = cause;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path = Function_pipe(this.path, Array_join(options.pathDelim));
      return `(Source unavailable at ${path}: "${this.message}")`;
    }
  });
  return error;
};
/** @internal */
const Unsupported = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(configError_proto);
  error._op = OP_UNSUPPORTED;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path = Function_pipe(this.path, Array_join(options.pathDelim));
      return `(Unsupported operation at ${path}: "${this.message}")`;
    }
  });
  return error;
};
/** @internal */
const isConfigError = u => hasProperty(u, ConfigErrorTypeId);
/** @internal */
const isAnd = self => self._op === OpCodes.OP_AND;
/** @internal */
const isOr = self => self._op === OpCodes.OP_OR;
/** @internal */
const isInvalidData = self => self._op === OpCodes.OP_INVALID_DATA;
/** @internal */
const isMissingData = self => self._op === OpCodes.OP_MISSING_DATA;
/** @internal */
const isSourceUnavailable = self => self._op === OpCodes.OP_SOURCE_UNAVAILABLE;
/** @internal */
const isUnsupported = self => self._op === OpCodes.OP_UNSUPPORTED;
/** @internal */
const prefixed = /*#__PURE__*/Function_dual(2, (self, prefix) => {
  switch (self._op) {
    case OP_AND:
      {
        return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
      }
    case OP_OR:
      {
        return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
      }
    case OP_INVALID_DATA:
      {
        return InvalidData([...prefix, ...self.path], self.message);
      }
    case OP_MISSING_DATA:
      {
        return MissingData([...prefix, ...self.path], self.message);
      }
    case OP_SOURCE_UNAVAILABLE:
      {
        return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
      }
    case OP_UNSUPPORTED:
      {
        return Unsupported([...prefix, ...self.path], self.message);
      }
  }
});
/** @internal */
const IsMissingDataOnlyReducer = {
  andCase: (_, left, right) => left && right,
  orCase: (_, left, right) => left && right,
  invalidDataCase: constFalse,
  missingDataCase: constTrue,
  sourceUnavailableCase: constFalse,
  unsupportedCase: constFalse
};
/** @internal */
const configError_reduceWithContext = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, context, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const error = input.pop();
    switch (error._op) {
      case OpCodes.OP_AND:
        {
          input.push(error.right);
          input.push(error.left);
          output.push(Either.left({
            _op: "AndCase"
          }));
          break;
        }
      case OpCodes.OP_OR:
        {
          input.push(error.right);
          input.push(error.left);
          output.push(Either.left({
            _op: "OrCase"
          }));
          break;
        }
      case OpCodes.OP_INVALID_DATA:
        {
          output.push(Either.right(reducer.invalidDataCase(context, error.path, error.message)));
          break;
        }
      case OpCodes.OP_MISSING_DATA:
        {
          output.push(Either.right(reducer.missingDataCase(context, error.path, error.message)));
          break;
        }
      case OpCodes.OP_SOURCE_UNAVAILABLE:
        {
          output.push(Either.right(reducer.sourceUnavailableCase(context, error.path, error.message, error.cause)));
          break;
        }
      case OpCodes.OP_UNSUPPORTED:
        {
          output.push(Either.right(reducer.unsupportedCase(context, error.path, error.message)));
          break;
        }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either = output.pop();
    switch (either._op) {
      case "Left":
        {
          switch (either.left._op) {
            case "AndCase":
              {
                const left = accumulator.pop();
                const right = accumulator.pop();
                const value = reducer.andCase(context, left, right);
                accumulator.push(value);
                break;
              }
            case "OrCase":
              {
                const left = accumulator.pop();
                const right = accumulator.pop();
                const value = reducer.orCase(context, left, right);
                accumulator.push(value);
                break;
              }
          }
          break;
        }
      case "Right":
        {
          accumulator.push(either.right);
          break;
        }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
})));
/** @internal */
const isMissingDataOnly = self => configError_reduceWithContext(self, void 0, IsMissingDataOnlyReducer);
//# sourceMappingURL=configError.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/configProvider/pathPatch.js






/** @internal */
const pathPatch_empty = {
  _tag: "Empty"
};
/** @internal */
const pathPatch_andThen = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => ({
  _tag: "AndThen",
  first: self,
  second: that
}))));
/** @internal */
const mapName = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => pathPatch_andThen(self, {
  _tag: "MapName",
  f
}))));
/** @internal */
const nested = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, name) => pathPatch_andThen(self, {
  _tag: "Nested",
  name
}))));
/** @internal */
const unnested = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, name) => pathPatch_andThen(self, {
  _tag: "Unnested",
  name
}))));
/** @internal */
const patch = /*#__PURE__*/Function_dual(2, (path, patch) => {
  let input = List_of(patch);
  let output = path;
  while (isCons(input)) {
    const patch = input.head;
    switch (patch._tag) {
      case "Empty":
        {
          input = input.tail;
          break;
        }
      case "AndThen":
        {
          input = cons(patch.first, cons(patch.second, input.tail));
          break;
        }
      case "MapName":
        {
          output = Array_map(output, patch.f);
          input = input.tail;
          break;
        }
      case "Nested":
        {
          output = Array_prepend(output, patch.name);
          input = input.tail;
          break;
        }
      case "Unnested":
        {
          const containsName = Function_pipe(Array_head(output), contains(patch.name));
          if (containsName) {
            output = tailNonEmpty(output);
            input = input.tail;
          } else {
            return Either_left(MissingData(output, `Expected ${patch.name} to be in path in ConfigProvider#unnested`));
          }
          break;
        }
    }
  }
  return Either_right(output);
});
//# sourceMappingURL=pathPatch.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/opCodes/config.js
/** @internal */
const OP_CONSTANT = "Constant";
/** @internal */
const config_OP_FAIL = "Fail";
/** @internal */
const OP_FALLBACK = "Fallback";
/** @internal */
const OP_DESCRIBED = "Described";
/** @internal */
const OP_LAZY = "Lazy";
/** @internal */
const OP_MAP_OR_FAIL = "MapOrFail";
/** @internal */
const OP_NESTED = "Nested";
/** @internal */
const OP_PRIMITIVE = "Primitive";
/** @internal */
const OP_SEQUENCE = "Sequence";
/** @internal */
const OP_HASHMAP = "HashMap";
/** @internal */
const OP_ZIP_WITH = "ZipWith";
//# sourceMappingURL=config.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/configProvider.js















const concat = (l, r) => [...l, ...r];
/** @internal */
const ConfigProviderSymbolKey = "effect/ConfigProvider";
/** @internal */
const ConfigProviderTypeId = /*#__PURE__*/Symbol.for(ConfigProviderSymbolKey);
/** @internal */
const configProviderTag = /*#__PURE__*/GenericTag("effect/ConfigProvider");
/** @internal */
const FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
/** @internal */
const FlatConfigProviderTypeId = /*#__PURE__*/Symbol.for(FlatConfigProviderSymbolKey);
/** @internal */
const configProvider_make = options => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  },
  ...options
});
/** @internal */
const makeFlat = options => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config, split = true) => options.load(path, config, split),
  enumerateChildren: options.enumerateChildren
});
/** @internal */
const fromFlat = flat => configProvider_make({
  load: config => core_flatMap(fromFlatLoop(flat, Array_empty(), config, false), chunk => match(Array_head(chunk), {
    onNone: () => core_fail(MissingData(Array_empty(), `Expected a single value having structure: ${config}`)),
    onSome: succeed
  })),
  flattened: flat
});
/** @internal */
const fromEnv = config => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, config);
  const makePathString = path => Function_pipe(path, Array_join(pathDelim));
  const unmakePathString = pathString => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive, split = true) => {
    const pathString = makePathString(path);
    const current = getEnv();
    const valueOpt = pathString in current ? Option_some(current[pathString]) : Option_none();
    return Function_pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), core_flatMap(value => parsePrimitive(value, path, primitive, seqDelim, split)));
  };
  const enumerateChildren = path => sync(() => {
    const current = getEnv();
    const keys = Object.keys(current);
    const keyPaths = keys.map(value => unmakePathString(value.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter(keyPath => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = Function_pipe(path, Array_unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === undefined || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));
    return HashSet_fromIterable(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: pathPatch_empty
  }));
};
/** @internal */
const fromMap = (map, config) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({
    seqDelim: ",",
    pathDelim: "."
  }, config);
  const makePathString = path => pipe(path, Arr.join(pathDelim));
  const unmakePathString = pathString => pathString.split(pathDelim);
  const mapWithIndexSplit = splitIndexInKeys(map, str => unmakePathString(str), makePathString);
  const load = (path, primitive, split = true) => {
    const pathString = makePathString(path);
    const valueOpt = mapWithIndexSplit.has(pathString) ? Option.some(mapWithIndexSplit.get(pathString)) : Option.none();
    return pipe(valueOpt, core.mapError(() => configError.MissingData(path, `Expected ${pathString} to exist in the provided map`)), core.flatMap(value => parsePrimitive(value, path, primitive, seqDelim, split)));
  };
  const enumerateChildren = path => core.sync(() => {
    const keyPaths = Arr.fromIterable(mapWithIndexSplit.keys()).map(unmakePathString);
    const filteredKeyPaths = keyPaths.filter(keyPath => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, Arr.unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === undefined || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));
    return HashSet.fromIterable(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: pathPatch.empty
  }));
};
const configProvider_extend = (leftDef, rightDef, left, right) => {
  const leftPad = Array_unfold(left.length, index => index >= right.length ? Option_none() : Option_some([leftDef(index), index + 1]));
  const rightPad = Array_unfold(right.length, index => index >= left.length ? Option_none() : Option_some([rightDef(index), index + 1]));
  const leftExtension = concat(left, leftPad);
  const rightExtension = concat(right, rightPad);
  return [leftExtension, rightExtension];
};
const appendConfigPath = (path, config) => {
  let op = config;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
};
const fromFlatLoop = (flat, prefix, config, split) => {
  const op = config;
  switch (op._tag) {
    case OP_CONSTANT:
      {
        return succeed(Array_of(op.value));
      }
    case OP_DESCRIBED:
      {
        return suspend(() => fromFlatLoop(flat, prefix, op.config, split));
      }
    case config_OP_FAIL:
      {
        return core_fail(MissingData(prefix, op.message));
      }
    case OP_FALLBACK:
      {
        return Function_pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll(error1 => {
          if (op.condition(error1)) {
            return Function_pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll(error2 => core_fail(Or(error1, error2))));
          }
          return core_fail(error1);
        }));
      }
    case OP_LAZY:
      {
        return suspend(() => fromFlatLoop(flat, prefix, op.config(), split));
      }
    case OP_MAP_OR_FAIL:
      {
        return suspend(() => Function_pipe(fromFlatLoop(flat, prefix, op.original, split), core_flatMap(forEachSequential(a => Function_pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
      }
    case OP_NESTED:
      {
        return suspend(() => fromFlatLoop(flat, concat(prefix, Array_of(op.name)), op.config, split));
      }
    case OP_PRIMITIVE:
      {
        return Function_pipe(patch(prefix, flat.patch), core_flatMap(prefix => Function_pipe(flat.load(prefix, op, split), core_flatMap(values => {
          if (values.length === 0) {
            const name = Function_pipe(last(prefix), getOrElse(() => "<n/a>"));
            return core_fail(MissingData([], `Expected ${op.description} with name ${name}`));
          }
          return succeed(values);
        }))));
      }
    case OP_SEQUENCE:
      {
        return Function_pipe(patch(prefix, flat.patch), core_flatMap(patchedPrefix => Function_pipe(flat.enumerateChildren(patchedPrefix), core_flatMap(indicesFrom), core_flatMap(indices => {
          if (indices.length === 0) {
            return suspend(() => core_map(fromFlatLoop(flat, patchedPrefix, op.config, true), Array_of));
          }
          return Function_pipe(forEachSequential(indices, index => fromFlatLoop(flat, Array_append(prefix, `[${index}]`), op.config, true)), core_map(chunkChunk => {
            const flattened = Array_flatten(chunkChunk);
            if (flattened.length === 0) {
              return Array_of(Array_empty());
            }
            return Array_of(flattened);
          }));
        }))));
      }
    case OP_HASHMAP:
      {
        return suspend(() => Function_pipe(patch(prefix, flat.patch), core_flatMap(prefix => Function_pipe(flat.enumerateChildren(prefix), core_flatMap(keys => {
          return Function_pipe(keys, forEachSequential(key => fromFlatLoop(flat, concat(prefix, Array_of(key)), op.valueConfig, split)), core_map(matrix => {
            if (matrix.length === 0) {
              return Array_of(HashMap_empty());
            }
            return Function_pipe(transpose(matrix), Array_map(values => HashMap_fromIterable(Array_zip(Array_fromIterable(keys), values))));
          }));
        })))));
      }
    case OP_ZIP_WITH:
      {
        return suspend(() => Function_pipe(fromFlatLoop(flat, prefix, op.left, split), core_either, core_flatMap(left => Function_pipe(fromFlatLoop(flat, prefix, op.right, split), core_either, core_flatMap(right => {
          if (Either_isLeft(left) && Either_isLeft(right)) {
            return core_fail(And(left.left, right.left));
          }
          if (Either_isLeft(left) && Either_isRight(right)) {
            return core_fail(left.left);
          }
          if (Either_isRight(left) && Either_isLeft(right)) {
            return core_fail(right.left);
          }
          if (Either_isRight(left) && Either_isRight(right)) {
            const path = Function_pipe(prefix, Array_join("."));
            const fail = fromFlatLoopFail(prefix, path);
            const [lefts, rights] = configProvider_extend(fail, fail, Function_pipe(left.right, Array_map(Either_right)), Function_pipe(right.right, Array_map(Either_right)));
            return Function_pipe(lefts, Array_zip(rights), forEachSequential(([left, right]) => Function_pipe(core_zip(left, right), core_map(([left, right]) => op.zip(left, right)))));
          }
          throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
        })))));
      }
  }
};
const fromFlatLoopFail = (prefix, path) => index => Either_left(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
/** @internal */
const mapInputPath = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => fromFlat(mapInputPathFlat(self.flattened, f)))));
const mapInputPathFlat = (self, f) => makeFlat({
  load: (path, config, split = true) => self.load(path, config, split),
  enumerateChildren: path => self.enumerateChildren(path),
  patch: pathPatch.mapName(self.patch, f)
});
/** @internal */
const configProvider_nested = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, name) => fromFlat(makeFlat({
  load: (path, config) => self.flattened.load(path, config, true),
  enumerateChildren: path => self.flattened.enumerateChildren(path),
  patch: pathPatch.nested(self.flattened.patch, name)
})))));
/** @internal */
const configProvider_unnested = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, name) => fromFlat(makeFlat({
  load: (path, config) => self.flattened.load(path, config, true),
  enumerateChildren: path => self.flattened.enumerateChildren(path),
  patch: pathPatch.unnested(self.flattened.patch, name)
})))));
/** @internal */
const configProvider_orElse = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => fromFlat(orElseFlat(self.flattened, () => that().flattened)))));
const orElseFlat = (self, that) => makeFlat({
  load: (path, config, split) => pipe(pathPatch.patch(path, self.patch), core.flatMap(patch => self.load(patch, config, split)), core.catchAll(error1 => pipe(core.sync(that), core.flatMap(that => pipe(pathPatch.patch(path, that.patch), core.flatMap(patch => that.load(patch, config, split)), core.catchAll(error2 => core.fail(configError.Or(error1, error2)))))))),
  enumerateChildren: path => pipe(pathPatch.patch(path, self.patch), core.flatMap(patch => self.enumerateChildren(patch)), core.either, core.flatMap(left => pipe(core.sync(that), core.flatMap(that => pipe(pathPatch.patch(path, that.patch), core.flatMap(patch => that.enumerateChildren(patch)), core.either, core.flatMap(right => {
    if (Either.isLeft(left) && Either.isLeft(right)) {
      return core.fail(configError.And(left.left, right.left));
    }
    if (Either.isLeft(left) && Either.isRight(right)) {
      return core.succeed(right.right);
    }
    if (Either.isRight(left) && Either.isLeft(right)) {
      return core.succeed(left.right);
    }
    if (Either.isRight(left) && Either.isRight(right)) {
      return core.succeed(pipe(left.right, HashSet.union(right.right)));
    }
    throw new Error("BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/effect/issues");
  })))))),
  patch: pathPatch.empty
});
/** @internal */
const constantCase = self => mapInputPath(self, StringUtils.constantCase);
/** @internal */
const kebabCase = self => mapInputPath(self, StringUtils.kebabCase);
/** @internal */
const lowerCase = self => mapInputPath(self, StringUtils.lowerCase);
/** @internal */
const snakeCase = self => mapInputPath(self, StringUtils.snakeCase);
/** @internal */
const upperCase = self => mapInputPath(self, StringUtils.upperCase);
/** @internal */
const within = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, path, f) => {
  const unnest = Arr.reduce(path, self, (provider, name) => configProvider_unnested(provider, name));
  const nest = Arr.reduceRight(path, f(unnest), (provider, name) => configProvider_nested(provider, name));
  return configProvider_orElse(nest, () => self);
})));
const splitPathString = (text, delim) => {
  const split = text.split(new RegExp(`\\s*${RegExp_escape(delim)}\\s*`));
  return split;
};
const parsePrimitive = (text, path, primitive, delimiter, split) => {
  if (!split) {
    return Function_pipe(primitive.parse(text), core_mapBoth({
      onFailure: prefixed(path),
      onSuccess: Array_of
    }));
  }
  return Function_pipe(splitPathString(text, delimiter), forEachSequential(char => primitive.parse(char.trim())), mapError(prefixed(path)));
};
const transpose = array => {
  return Object.keys(array[0]).map(column => array.map(row => row[column]));
};
const indicesFrom = quotedIndices => Function_pipe(forEachSequential(quotedIndices, parseQuotedIndex), core_mapBoth({
  onFailure: () => Array_empty(),
  onSuccess: sort(Number_Order)
}), core_either, core_map(Either_merge));
const STR_INDEX_REGEX = /(^.+)(\[(\d+)\])$/;
const QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
const parseQuotedIndex = str => {
  const match = str.match(QUOTED_INDEX_REGEX);
  if (match !== null) {
    const matchedIndex = match[2];
    return Function_pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? Option_some(matchedIndex) : Option_none(), flatMap(parseInteger));
  }
  return Option_none();
};
const splitIndexInKeys = (map, unmakePathString, makePathString) => {
  const newMap = new Map();
  for (const [pathString, value] of map) {
    const keyWithIndex = pipe(unmakePathString(pathString), Arr.flatMap(key => Option.match(splitIndexFrom(key), {
      onNone: () => Arr.of(key),
      onSome: ([key, index]) => Arr.make(key, `[${index}]`)
    })));
    newMap.set(makePathString(keyWithIndex), value);
  }
  return newMap;
};
const splitIndexFrom = key => {
  const match = key.match(STR_INDEX_REGEX);
  if (match !== null) {
    const matchedString = match[1];
    const matchedIndex = match[3];
    const optionalString = matchedString !== undefined && matchedString.length > 0 ? Option.some(matchedString) : Option.none();
    const optionalIndex = pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? Option.some(matchedIndex) : Option.none(), Option.flatMap(parseInteger));
    return Option.all([optionalString, optionalIndex]);
  }
  return Option.none();
};
const parseInteger = str => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? Option_none() : Option_some(parsedIndex);
};
const keyName = name => ({
  _tag: "KeyName",
  name
});
const keyIndex = index => ({
  _tag: "KeyIndex",
  index
});
/** @internal */
const fromJson = json => {
  const hiddenDelimiter = "\ufeff";
  const indexedEntries = Arr.map(getIndexedEntries(json), ([key, value]) => [configPathToString(key).join(hiddenDelimiter), value]);
  return fromMap(new Map(indexedEntries), {
    pathDelim: hiddenDelimiter,
    seqDelim: hiddenDelimiter
  });
};
const configPathToString = path => {
  const output = [];
  let i = 0;
  while (i < path.length) {
    const component = path[i];
    if (component._tag === "KeyName") {
      if (i + 1 < path.length) {
        const nextComponent = path[i + 1];
        if (nextComponent._tag === "KeyIndex") {
          output.push(`${component.name}[${nextComponent.index}]`);
          i += 2;
        } else {
          output.push(component.name);
          i += 1;
        }
      } else {
        output.push(component.name);
        i += 1;
      }
    }
  }
  return output;
};
const getIndexedEntries = config => {
  const loopAny = (path, value) => {
    if (typeof value === "string") {
      return Arr.make([path, value]);
    }
    if (typeof value === "number" || typeof value === "boolean") {
      return Arr.make([path, String(value)]);
    }
    if (Arr.isArray(value)) {
      return loopArray(path, value);
    }
    if (typeof value === "object" && value !== null) {
      return loopObject(path, value);
    }
    return Arr.empty();
  };
  const loopArray = (path, values) => Arr.match(values, {
    onEmpty: () => Arr.make([path, "<nil>"]),
    onNonEmpty: Arr.flatMap((value, index) => loopAny(Arr.append(path, keyIndex(index)), value))
  });
  const loopObject = (path, value) => Object.entries(value).flatMap(([key, value]) => {
    const newPath = Arr.append(path, keyName(key));
    const result = loopAny(newPath, value);
    if (Arr.isEmptyReadonlyArray(result)) {
      return Arr.make([newPath, ""]);
    }
    return result;
  });
  return loopObject(Arr.empty(), config);
};
//# sourceMappingURL=configProvider.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/defaultServices/console.js


/** @internal */
const console_TypeId = /*#__PURE__*/Symbol.for("effect/Console");
/** @internal */
const console_consoleTag = /*#__PURE__*/GenericTag("effect/Console");
/** @internal */
const console_defaultConsole = {
  [console_TypeId]: console_TypeId,
  assert(condition, ...args) {
    return sync(() => {
      console.assert(condition, ...args);
    });
  },
  clear: /*#__PURE__*/sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args) {
    return sync(() => {
      console.debug(...args);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args) {
    return sync(() => {
      console.dirxml(...args);
    });
  },
  error(...args) {
    return sync(() => {
      console.error(...args);
    });
  },
  group(options) {
    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
  },
  groupEnd: /*#__PURE__*/sync(() => {
    console.groupEnd();
  }),
  info(...args) {
    return sync(() => {
      console.info(...args);
    });
  },
  log(...args) {
    return sync(() => {
      console.log(...args);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args) {
    return sync(() => {
      console.timeLog(label, ...args);
    });
  },
  trace(...args) {
    return sync(() => {
      console.trace(...args);
    });
  },
  warn(...args) {
    return sync(() => {
      console.warn(...args);
    });
  },
  unsafe: console
};
//# sourceMappingURL=console.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/random.js





/** @internal */
const RandomSymbolKey = "effect/Random";
/** @internal */
const RandomTypeId = /*#__PURE__*/Symbol.for(RandomSymbolKey);
/** @internal */
const randomTag = /*#__PURE__*/GenericTag("effect/Random");
/** @internal */
class RandomImpl {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return core_map(this.next, n => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min, max) {
    return core_map(this.next, n => (max - min) * n + min);
  }
  nextIntBetween(min, max) {
    return sync(() => this.PRNG.integer(max - min) + min);
  }
  shuffle(elements) {
    return shuffleWith(elements, n => this.nextIntBetween(0, n));
  }
}
const shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => Function_pipe(sync(() => Array.from(elements)), core_flatMap(buffer => {
    const numbers = [];
    for (let i = buffer.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return Function_pipe(numbers, forEachSequentialDiscard(n => Function_pipe(nextIntBounded(n), core_map(k => random_swap(buffer, n - 1, k)))), core_as(Chunk_fromIterable(buffer)));
  })));
};
const random_swap = (buffer, index1, index2) => {
  const tmp = buffer[index1];
  buffer[index1] = buffer[index2];
  buffer[index2] = tmp;
  return buffer;
};
const random_make = seed => new RandomImpl(seed);
//# sourceMappingURL=random.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/defaultServices.js










/** @internal */
const liveServices = /*#__PURE__*/Function_pipe( /*#__PURE__*/Context_empty(), /*#__PURE__*/Context_add(clockTag, /*#__PURE__*/clock_make()), /*#__PURE__*/Context_add(console_consoleTag, console_defaultConsole), /*#__PURE__*/Context_add(randomTag, /*#__PURE__*/random_make( /*#__PURE__*/Math.random() * 4294967296 >>> 0)), /*#__PURE__*/Context_add(configProviderTag, /*#__PURE__*/fromEnv()), /*#__PURE__*/Context_add(tracerTag, nativeTracer));
/**
 * The `FiberRef` holding the default `Effect` services.
 *
 * @since 2.0.0
 * @category fiberRefs
 */
const currentServices = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
// circular with Clock
/** @internal */
const sleep = duration => {
  const decodedDuration = decode(duration);
  return clockWith(clock => clock.sleep(decodedDuration));
};
/** @internal */
const clockWith = f => fiberRefGetWith(currentServices, services => f(Context_get(services, clockTag)));
/** @internal */
const currentTimeMillis = /*#__PURE__*/clockWith(clock => clock.currentTimeMillis);
/** @internal */
const currentTimeNanos = /*#__PURE__*/clockWith(clock => clock.currentTimeNanos);
/** @internal */
const withClock = /*#__PURE__*/Function_dual(2, (effect, value) => fiberRefLocallyWith(currentServices, Context_add(clockTag, value))(effect));
// circular with ConfigProvider
/** @internal */
const withConfigProvider = /*#__PURE__*/Function_dual(2, (effect, value) => fiberRefLocallyWith(currentServices, Context_add(configProviderTag, value))(effect));
/** @internal */
const configProviderWith = f => fiberRefGetWith(currentServices, services => f(Context_get(services, configProviderTag)));
/** @internal */
const config = config => configProviderWith(_ => _.load(config));
/** @internal */
const configOrDie = config => core.orDie(configProviderWith(_ => _.load(config)));
// circular with Random
/** @internal */
const randomWith = f => fiberRefGetWith(currentServices, services => f(Context_get(services, randomTag)));
/** @internal */
const withRandom = /*#__PURE__*/Function_dual(2, (effect, value) => fiberRefLocallyWith(currentServices, Context_add(randomTag, value))(effect));
/** @internal */
const next = /*#__PURE__*/(/* unused pure expression or super */ null && (randomWith(random => random.next)));
/** @internal */
const nextInt = /*#__PURE__*/(/* unused pure expression or super */ null && (randomWith(random => random.nextInt)));
/** @internal */
const nextBoolean = /*#__PURE__*/(/* unused pure expression or super */ null && (randomWith(random => random.nextBoolean)));
/** @internal */
const nextRange = (min, max) => randomWith(random => random.nextRange(min, max));
/** @internal */
const nextIntBetween = (min, max) => randomWith(random => random.nextIntBetween(min, max));
/** @internal */
const shuffle = elements => randomWith(random => random.shuffle(elements));
// circular with Tracer
/** @internal */
const tracerWith = f => fiberRefGetWith(currentServices, services => f(Context_get(services, tracerTag)));
/** @internal */
const withTracer = /*#__PURE__*/Function_dual(2, (effect, value) => fiberRefLocallyWith(currentServices, Context_add(tracerTag, value))(effect));
//# sourceMappingURL=defaultServices.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Boolean.js
/**
 * This module provides utility functions and type class instances for working with the `boolean` type in TypeScript.
 * It includes functions for basic boolean operations, as well as type class instances for
 * `Equivalence` and `Order`.
 *
 * @since 2.0.0
 */




/**
 * Tests if a value is a `boolean`.
 *
 * @param input - The value to test.
 *
 * @example
 * import { isBoolean } from "effect/Boolean"
 *
 * assert.deepStrictEqual(isBoolean(true), true)
 * assert.deepStrictEqual(isBoolean("true"), false)
 *
 * @category guards
 * @since 2.0.0
 */
const Boolean_isBoolean = Predicate_isBoolean;
/**
 * This function returns the result of either of the given functions depending on the value of the boolean parameter.
 * It is useful when you have to run one of two functions depending on the boolean value.
 *
 * @param value - the boolean value that decides which function will be executed.
 * @param onFalse - a lazy evaluation function that will be executed when the `value` is `false`.
 * @param onTrue - a lazy evaluation function that will be executed when the `value` is `true`.
 *
 * @example
 * import { Boolean } from "effect"
 *
 * assert.deepStrictEqual(Boolean.match(true, { onFalse: () => "It's false!", onTrue: () => "It's true!" }), "It's true!")
 *
 * @category pattern matching
 * @since 2.0.0
 */
const Boolean_match = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (value, options) => value ? options.onTrue() : options.onFalse())));
/**
 * @category instances
 * @since 2.0.0
 */
const Boolean_Equivalence = Equivalence_boolean;
/**
 * @category instances
 * @since 2.0.0
 */
const Boolean_Order = Order_boolean;
/**
 * Negates the given boolean: `!self`
 *
 * @example
 * import { not } from "effect/Boolean"
 *
 * assert.deepStrictEqual(not(true), false)
 * assert.deepStrictEqual(not(false), true)
 *
 * @category combinators
 * @since 2.0.0
 */
const Boolean_not = self => !self;
/**
 * Combines two boolean using AND: `self && that`.
 *
 * @example
 * import { and } from "effect/Boolean"
 *
 * assert.deepStrictEqual(and(true, true), true)
 * assert.deepStrictEqual(and(true, false), false)
 * assert.deepStrictEqual(and(false, true), false)
 * assert.deepStrictEqual(and(false, false), false)
 *
 * @category combinators
 * @since 2.0.0
 */
const Boolean_and = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => self && that)));
/**
 * Combines two boolean using NAND: `!(self && that)`.
 *
 * @example
 * import { nand } from "effect/Boolean"
 *
 * assert.deepStrictEqual(nand(true, true), false)
 * assert.deepStrictEqual(nand(true, false), true)
 * assert.deepStrictEqual(nand(false, true), true)
 * assert.deepStrictEqual(nand(false, false), true)
 *
 * @category combinators
 * @since 2.0.0
 */
const Boolean_nand = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => !(self && that))));
/**
 * Combines two boolean using OR: `self || that`.
 *
 * @example
 * import { or } from "effect/Boolean"
 *
 * assert.deepStrictEqual(or(true, true), true)
 * assert.deepStrictEqual(or(true, false), true)
 * assert.deepStrictEqual(or(false, true), true)
 * assert.deepStrictEqual(or(false, false), false)
 *
 * @category combinators
 * @since 2.0.0
 */
const Boolean_or = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => self || that)));
/**
 * Combines two booleans using NOR: `!(self || that)`.
 *
 * @example
 * import { nor } from "effect/Boolean"
 *
 * assert.deepStrictEqual(nor(true, true), false)
 * assert.deepStrictEqual(nor(true, false), false)
 * assert.deepStrictEqual(nor(false, true), false)
 * assert.deepStrictEqual(nor(false, false), true)
 *
 * @category combinators
 * @since 2.0.0
 */
const Boolean_nor = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => !(self || that))));
/**
 * Combines two booleans using XOR: `(!self && that) || (self && !that)`.
 *
 * @example
 * import { xor } from "effect/Boolean"
 *
 * assert.deepStrictEqual(xor(true, true), false)
 * assert.deepStrictEqual(xor(true, false), true)
 * assert.deepStrictEqual(xor(false, true), true)
 * assert.deepStrictEqual(xor(false, false), false)
 *
 * @category combinators
 * @since 2.0.0
 */
const Boolean_xor = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => !self && that || self && !that)));
/**
 * Combines two booleans using EQV (aka XNOR): `!xor(self, that)`.
 *
 * @example
 * import { eqv } from "effect/Boolean"
 *
 * assert.deepStrictEqual(eqv(true, true), true)
 * assert.deepStrictEqual(eqv(true, false), false)
 * assert.deepStrictEqual(eqv(false, true), false)
 * assert.deepStrictEqual(eqv(false, false), true)
 *
 * @category combinators
 * @since 2.0.0
 */
const Boolean_eqv = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => !Boolean_xor(self, that))));
/**
 * Combines two booleans using an implication: `(!self || that)`.
 *
 * @example
 * import { implies } from "effect/Boolean"
 *
 * assert.deepStrictEqual(implies(true, true), true)
 * assert.deepStrictEqual(implies(true, false), false)
 * assert.deepStrictEqual(implies(false, true), true)
 * assert.deepStrictEqual(implies(false, false), true)
 *
 * @category combinators
 * @since 2.0.0
 */
const Boolean_implies = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => self ? that : true)));
/**
 * This utility function is used to check if all the elements in a collection of boolean values are `true`.
 *
 * @param collection - An iterable collection of booleans.
 *
 * @example
 * import { every } from "effect/Boolean"
 *
 * assert.deepStrictEqual(every([true, true, true]), true)
 * assert.deepStrictEqual(every([true, false, true]), false)
 *
 * @since 2.0.0
 */
const Boolean_every = collection => {
  for (const b of collection) {
    if (!b) {
      return false;
    }
  }
  return true;
};
/**
 * This utility function is used to check if at least one of the elements in a collection of boolean values is `true`.
 *
 * @param collection - An iterable collection of booleans.
 *
 * @example
 * import { some } from "effect/Boolean"
 *
 * assert.deepStrictEqual(some([true, false, true]), true)
 * assert.deepStrictEqual(some([false, false, false]), false)
 *
 * @since 2.0.0
 */
const Boolean_some = collection => {
  for (const b of collection) {
    if (b) {
      return true;
    }
  }
  return false;
};
//# sourceMappingURL=Boolean.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Deferred.js


/**
 * @since 2.0.0
 * @category symbols
 */
const Deferred_DeferredTypeId = DeferredTypeId;
/**
 * Creates a new `Deferred`.
 *
 * @since 2.0.0
 * @category constructors
 */
const Deferred_make = deferredMake;
/**
 * Creates a new `Deferred` from the specified `FiberId`.
 *
 * @since 2.0.0
 * @category constructors
 */
const makeAs = deferredMakeAs;
const _await = deferredAwait;

/**
 * Completes the deferred with the result of the specified effect. If the
 * deferred has already been completed, the method will produce false.
 *
 * Note that `Deferred.completeWith` will be much faster, so consider using
 * that if you do not need to memoize the result of the specified effect.
 *
 * @since 2.0.0
 * @category utils
 */
const complete = deferredComplete;
/**
 * Completes the deferred with the result of the specified effect. If the
 * deferred has already been completed, the method will produce false.
 *
 * @since 2.0.0
 * @category utils
 */
const completeWith = deferredCompleteWith;
/**
 * Exits the `Deferred` with the specified `Exit` value, which will be
 * propagated to all fibers waiting on the value of the `Deferred`.
 *
 * @since 2.0.0
 * @category utils
 */
const Deferred_done = deferredDone;
/**
 * Fails the `Deferred` with the specified error, which will be propagated to
 * all fibers waiting on the value of the `Deferred`.
 *
 * @since 2.0.0
 * @category utils
 */
const Deferred_fail = deferredFail;
/**
 * Fails the `Deferred` with the specified error, which will be propagated to
 * all fibers waiting on the value of the `Deferred`.
 *
 * @since 2.0.0
 * @category utils
 */
const Deferred_failSync = deferredFailSync;
/**
 * Fails the `Deferred` with the specified `Cause`, which will be propagated to
 * all fibers waiting on the value of the `Deferred`.
 *
 * @since 2.0.0
 * @category utils
 */
const Deferred_failCause = deferredFailCause;
/**
 * Fails the `Deferred` with the specified `Cause`, which will be propagated to
 * all fibers waiting on the value of the `Deferred`.
 *
 * @since 2.0.0
 * @category utils
 */
const Deferred_failCauseSync = deferredFailCauseSync;
/**
 * Kills the `Deferred` with the specified defect, which will be propagated to
 * all fibers waiting on the value of the `Deferred`.
 *
 * @since 2.0.0
 * @category utils
 */
const Deferred_die = deferredDie;
/**
 * Kills the `Deferred` with the specified defect, which will be propagated to
 * all fibers waiting on the value of the `Deferred`.
 *
 * @since 2.0.0
 * @category utils
 */
const Deferred_dieSync = deferredDieSync;
/**
 * Completes the `Deferred` with interruption. This will interrupt all fibers
 * waiting on the value of the `Deferred` with the `FiberId` of the fiber
 * calling this method.
 *
 * @since 2.0.0
 * @category utils
 */
const Deferred_interrupt = deferredInterrupt;
/**
 * Completes the `Deferred` with interruption. This will interrupt all fibers
 * waiting on the value of the `Deferred` with the specified `FiberId`.
 *
 * @since 2.0.0
 * @category utils
 */
const Deferred_interruptWith = deferredInterruptWith;
/**
 * Returns `true` if this `Deferred` has already been completed with a value or
 * an error, `false` otherwise.
 *
 * @since 2.0.0
 * @category getters
 */
const isDone = deferredIsDone;
/**
 * Returns a `Some<Effect<A, E, R>>` from the `Deferred` if this `Deferred` has
 * already been completed, `None` otherwise.
 *
 * @since 2.0.0
 * @category getters
 */
const poll = deferredPoll;
/**
 * Completes the `Deferred` with the specified value.
 *
 * @since 2.0.0
 * @category utils
 */
const Deferred_succeed = deferredSucceed;
/**
 * Completes the `Deferred` with the specified lazily evaluated value.
 *
 * @since 2.0.0
 * @category utils
 */
const Deferred_sync = deferredSync;
/**
 * Unsafely creates a new `Deferred` from the specified `FiberId`.
 *
 * @since 2.0.0
 * @category unsafe
 */
const Deferred_unsafeMake = deferredUnsafeMake;
/**
 * Unsafely exits the `Deferred` with the specified `Exit` value, which will be
 * propagated to all fibers waiting on the value of the `Deferred`.
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeDone = deferredUnsafeDone;
//# sourceMappingURL=Deferred.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Effectable.js

/**
 * @since 2.0.0
 * @category type ids
 */
const Effectable_EffectTypeId = EffectTypeId;
/**
 * @since 2.0.0
 * @category type ids
 */
const Effectable_StreamTypeId = StreamTypeId;
/**
 * @since 2.0.0
 * @category type ids
 */
const Effectable_SinkTypeId = SinkTypeId;
/**
 * @since 2.0.0
 * @category type ids
 */
const Effectable_ChannelTypeId = ChannelTypeId;
/**
 * @since 2.0.0
 * @category prototypes
 */
const Effectable_EffectPrototype = EffectPrototype;
/**
 * @since 2.0.0
 * @category prototypes
 */
const Effectable_CommitPrototype = CommitPrototype;
/**
 * @since 2.0.0
 * @category prototypes
 */
const Effectable_StructuralCommitPrototype = StructuralCommitPrototype;
const Effectable_Base = Base;
const Effectable_StructuralBase = StructuralBase;
/**
 * @since 2.0.0
 * @category constructors
 */
class Effectable_Class extends (/* unused pure expression or super */ null && (Effectable_Base)) {}
/**
 * @since 2.0.0
 * @category constructors
 */
class StructuralClass extends (/* unused pure expression or super */ null && (Effectable_StructuralBase)) {}
//# sourceMappingURL=Effectable.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/executionStrategy.js

/** @internal */
const executionStrategy_OP_SEQUENTIAL = "Sequential";
/** @internal */
const executionStrategy_OP_PARALLEL = "Parallel";
/** @internal */
const OP_PARALLEL_N = "ParallelN";
/** @internal */
const executionStrategy_sequential = {
  _tag: executionStrategy_OP_SEQUENTIAL
};
/** @internal */
const executionStrategy_parallel = {
  _tag: executionStrategy_OP_PARALLEL
};
/** @internal */
const parallelN = parallelism => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
/** @internal */
const isSequential = self => self._tag === executionStrategy_OP_SEQUENTIAL;
/** @internal */
const isParallel = self => self._tag === executionStrategy_OP_PARALLEL;
/** @internal */
const isParallelN = self => self._tag === OP_PARALLEL_N;
/** @internal */
const executionStrategy_match = /*#__PURE__*/Function_dual(2, (self, options) => {
  switch (self._tag) {
    case executionStrategy_OP_SEQUENTIAL:
      {
        return options.onSequential();
      }
    case executionStrategy_OP_PARALLEL:
      {
        return options.onParallel();
      }
    case OP_PARALLEL_N:
      {
        return options.onParallelN(self.parallelism);
      }
  }
});
//# sourceMappingURL=executionStrategy.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/ExecutionStrategy.js

/**
 * Execute effects sequentially.
 *
 * @since 2.0.0
 * @category constructors
 */
const ExecutionStrategy_sequential = executionStrategy_sequential;
/**
 * Execute effects in parallel.
 *
 * @since 2.0.0
 * @category constructors
 */
const ExecutionStrategy_parallel = executionStrategy_parallel;
/**
 * Execute effects in parallel, up to the specified number of concurrent fibers.
 *
 * @since 2.0.0
 * @category constructors
 */
const ExecutionStrategy_parallelN = parallelN;
/**
 * Returns `true` if the specified `ExecutionStrategy` is an instance of
 * `Sequential`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const ExecutionStrategy_isSequential = isSequential;
/**
 * Returns `true` if the specified `ExecutionStrategy` is an instance of
 * `Sequential`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const ExecutionStrategy_isParallel = isParallel;
/**
 * Returns `true` if the specified `ExecutionStrategy` is an instance of
 * `Sequential`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const ExecutionStrategy_isParallelN = isParallelN;
/**
 * Folds over the specified `ExecutionStrategy` using the provided case
 * functions.
 *
 * @since 2.0.0
 * @category folding
 */
const ExecutionStrategy_match = executionStrategy_match;
//# sourceMappingURL=ExecutionStrategy.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/fiberRefs.js







/** @internal */
function fiberRefs_unsafeMake(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
/** @internal */
function fiberRefs_empty() {
  return fiberRefs_unsafeMake(new Map());
}
/** @internal */
const FiberRefsSym = /*#__PURE__*/Symbol.for("effect/FiberRefs");
/** @internal */
class FiberRefsImpl {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
const findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = undefined;
  while (ret === undefined) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
/** @internal */
const joinAs = /*#__PURE__*/Function_dual(3, (self, fiberId, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][Equal_symbol](fiberId)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[Equal_symbol](fiberId)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
/** @internal */
const forkAs = /*#__PURE__*/Function_dual(2, (self, childId) => {
  const map = new Map();
  unsafeForkAs(self, map, childId);
  return new FiberRefsImpl(map);
});
const unsafeForkAs = (self, map, fiberId) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map.set(fiberRef, stack);
    } else {
      map.set(fiberRef, [[fiberId, newValue], ...stack]);
    }
  });
};
/** @internal */
const fiberRefs_fiberRefs = self => HashSet_fromIterable(self.locals.keys());
/** @internal */
const setAll = self => forEachSequentialDiscard(fiberRefs_fiberRefs(self), fiberRef => fiberRefSet(fiberRef, getOrDefault(self, fiberRef)));
/** @internal */
const delete_ = /*#__PURE__*/Function_dual(2, (self, fiberRef) => {
  const locals = new Map(self.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
/** @internal */
const fiberRefs_get = /*#__PURE__*/Function_dual(2, (self, fiberRef) => {
  if (!self.locals.has(fiberRef)) {
    return Option_none();
  }
  return Option_some(headNonEmpty(self.locals.get(fiberRef))[1]);
});
/** @internal */
const getOrDefault = /*#__PURE__*/Function_dual(2, (self, fiberRef) => Function_pipe(fiberRefs_get(self, fiberRef), getOrElse(() => fiberRef.initial)));
/** @internal */
const updateAs = /*#__PURE__*/Function_dual(2, (self, {
  fiberId,
  fiberRef,
  value
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map([[fiberRef, [[fiberId, value]]]]));
  }
  const locals = new Map(self.locals);
  unsafeUpdateAs(locals, fiberId, fiberRef, value);
  return new FiberRefsImpl(locals);
});
const unsafeUpdateAs = (locals, fiberId, fiberRef, value) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[Equal_symbol](fiberId)) {
      if (equals(currentValue, value)) {
        return;
      } else {
        newStack = [[fiberId, value], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId, value], ...oldStack];
    }
  } else {
    newStack = [[fiberId, value]];
  }
  locals.set(fiberRef, newStack);
};
/** @internal */
const updateManyAs = /*#__PURE__*/Function_dual(2, (self, {
  entries,
  forkAs
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries));
  }
  const locals = new Map(self.locals);
  if (forkAs !== undefined) {
    unsafeForkAs(self, locals, forkAs);
  }
  entries.forEach(([fiberRef, values]) => {
    if (values.length === 1) {
      unsafeUpdateAs(locals, values[0][0], fiberRef, values[0][1]);
    } else {
      values.forEach(([fiberId, value]) => {
        unsafeUpdateAs(locals, fiberId, fiberRef, value);
      });
    }
  });
  return new FiberRefsImpl(locals);
});
//# sourceMappingURL=fiberRefs.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/FiberRefs.js

/**
 * @since 2.0.0
 * @category symbols
 */
const FiberRefs_FiberRefsSym = FiberRefsSym;
const FiberRefs_delete_ = delete_;

/**
 * Returns a set of each `FiberRef` in this collection.
 *
 * @since 2.0.0
 * @category getters
 */
const FiberRefs_fiberRefs = fiberRefs_fiberRefs;
/**
 * Forks this collection of fiber refs as the specified child fiber id. This
 * will potentially modify the value of the fiber refs, as determined by the
 * individual fiber refs that make up the collection.
 *
 * @since 2.0.0
 * @category utils
 */
const FiberRefs_forkAs = forkAs;
/**
 * Gets the value of the specified `FiberRef` in this collection of `FiberRef`
 * values if it exists or `None` otherwise.
 *
 * @since 2.0.0
 * @category getters
 */
const FiberRefs_get = fiberRefs_get;
/**
 * Gets the value of the specified `FiberRef` in this collection of `FiberRef`
 * values if it exists or the `initial` value of the `FiberRef` otherwise.
 *
 * @since 2.0.0
 * @category getters
 */
const FiberRefs_getOrDefault = getOrDefault;
/**
 * Joins this collection of fiber refs to the specified collection, as the
 * specified fiber id. This will perform diffing and merging to ensure
 * preservation of maximum information from both child and parent refs.
 *
 * @since 2.0.0
 * @category utils
 */
const FiberRefs_joinAs = joinAs;
/**
 * Set each ref to either its value or its default.
 *
 * @since 2.0.0
 * @category utils
 */
const FiberRefs_setAll = setAll;
/**
 * Updates the value of the specified `FiberRef` using the provided `FiberId`
 *
 * @since 2.0.0
 * @category utils
 */
const FiberRefs_updateAs = updateAs;
/**
 * Updates the values of the specified `FiberRef` & value pairs using the provided `FiberId`
 *
 * @since 2.0.0
 * @category utils
 */
const FiberRefs_updateManyAs = updateManyAs;
/**
 * Note: it will not copy the provided Map, make sure to provide a fresh one.
 *
 * @since 2.0.0
 * @category unsafe
 */
const FiberRefs_unsafeMake = fiberRefs_unsafeMake;
/**
 * The empty collection of `FiberRef` values.
 *
 * @category constructors
 * @since 2.0.0
 */
const FiberRefs_empty = fiberRefs_empty;
//# sourceMappingURL=FiberRefs.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/fiberRefs/patch.js




/** @internal */
const patch_OP_EMPTY = "Empty";
/** @internal */
const OP_ADD = "Add";
/** @internal */
const OP_REMOVE = "Remove";
/** @internal */
const OP_UPDATE = "Update";
/** @internal */
const OP_AND_THEN = "AndThen";
/** @internal */
const patch_empty = {
  _tag: patch_OP_EMPTY
};
/** @internal */
const patch_diff = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch = patch_empty;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== undefined) {
      const oldValue = headNonEmpty(old)[1];
      if (!equals(oldValue, newValue)) {
        patch = patch_combine({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue, newValue)
        })(patch);
      }
    } else {
      patch = patch_combine({
        _tag: OP_ADD,
        fiberRef,
        value: newValue
      })(patch);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch = patch_combine({
      _tag: OP_REMOVE,
      fiberRef
    })(patch);
  }
  return patch;
};
/** @internal */
const patch_combine = /*#__PURE__*/Function_dual(2, (self, that) => ({
  _tag: OP_AND_THEN,
  first: self,
  second: that
}));
/** @internal */
const patch_patch = /*#__PURE__*/Function_dual(3, (self, fiberId, oldValue) => {
  let fiberRefs = oldValue;
  let patches = Array_of(self);
  while (isNonEmptyReadonlyArray(patches)) {
    const head = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head._tag) {
      case patch_OP_EMPTY:
        {
          patches = tail;
          break;
        }
      case OP_ADD:
        {
          fiberRefs = updateAs(fiberRefs, {
            fiberId,
            fiberRef: head.fiberRef,
            value: head.value
          });
          patches = tail;
          break;
        }
      case OP_REMOVE:
        {
          fiberRefs = delete_(fiberRefs, head.fiberRef);
          patches = tail;
          break;
        }
      case OP_UPDATE:
        {
          const value = getOrDefault(fiberRefs, head.fiberRef);
          fiberRefs = updateAs(fiberRefs, {
            fiberId,
            fiberRef: head.fiberRef,
            value: head.fiberRef.patch(head.patch)(value)
          });
          patches = tail;
          break;
        }
      case OP_AND_THEN:
        {
          patches = Array_prepend(head.first)(Array_prepend(head.second)(tail));
          break;
        }
    }
  }
  return fiberRefs;
});
//# sourceMappingURL=patch.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/FiberRefsPatch.js

/**
 * @since 2.0.0
 * @category constructors
 */
const FiberRefsPatch_empty = patch_empty;
/**
 * Constructs a patch that describes the changes between the specified
 * collections of `FiberRef`
 *
 * @since 2.0.0
 * @category constructors
 */
const FiberRefsPatch_diff = patch_diff;
/**
 * Combines this patch and the specified patch to create a new patch that
 * describes applying the changes from this patch and the specified patch
 * sequentially.
 *
 * @since 2.0.0
 * @category constructors
 */
const FiberRefsPatch_combine = patch_combine;
/**
 * Applies the changes described by this patch to the specified collection
 * of `FiberRef` values.
 *
 * @since 2.0.0
 * @category destructors
 */
const FiberRefsPatch_patch = patch_patch;
//# sourceMappingURL=FiberRefsPatch.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/fiberStatus.js




const FiberStatusSymbolKey = "effect/FiberStatus";
/** @internal */
const FiberStatusTypeId = /*#__PURE__*/Symbol.for(FiberStatusSymbolKey);
/** @internal */
const OP_DONE = "Done";
/** @internal */
const OP_RUNNING = "Running";
/** @internal */
const OP_SUSPENDED = "Suspended";
const DoneHash = /*#__PURE__*/string(`${FiberStatusSymbolKey}-${OP_DONE}`);
/** @internal */
class Done {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol]() {
    return DoneHash;
  }
  [Equal_symbol](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
}
/** @internal */
class Running {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags) {
    this.runtimeFlags = runtimeFlags;
  }
  [symbol]() {
    return Function_pipe(Hash_hash(FiberStatusSymbolKey), combine(Hash_hash(this._tag)), combine(Hash_hash(this.runtimeFlags)), cached(this));
  }
  [Equal_symbol](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
}
/** @internal */
class Suspended {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags, blockingOn) {
    this.runtimeFlags = runtimeFlags;
    this.blockingOn = blockingOn;
  }
  [symbol]() {
    return Function_pipe(Hash_hash(FiberStatusSymbolKey), combine(Hash_hash(this._tag)), combine(Hash_hash(this.runtimeFlags)), combine(Hash_hash(this.blockingOn)), cached(this));
  }
  [Equal_symbol](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
}
/** @internal */
const fiberStatus_done = /*#__PURE__*/new Done();
/** @internal */
const running = runtimeFlags => new Running(runtimeFlags);
/** @internal */
const suspended = (runtimeFlags, blockingOn) => new Suspended(runtimeFlags, blockingOn);
/** @internal */
const isFiberStatus = u => Predicate_hasProperty(u, FiberStatusTypeId);
/** @internal */
const fiberStatus_isDone = self => self._tag === OP_DONE;
/** @internal */
const isRunning = self => self._tag === OP_RUNNING;
/** @internal */
const isSuspended = self => self._tag === OP_SUSPENDED;
//# sourceMappingURL=fiberStatus.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/FiberStatus.js

/**
 * @since 2.0.0
 * @category symbols
 */
const FiberStatus_FiberStatusTypeId = FiberStatusTypeId;
/**
 * @since 2.0.0
 * @category constructors
 */
const FiberStatus_done = fiberStatus_done;
/**
 * @since 2.0.0
 * @category constructors
 */
const FiberStatus_running = running;
/**
 * @since 2.0.0
 * @category constructors
 */
const FiberStatus_suspended = suspended;
/**
 * Returns `true` if the specified value is a `FiberStatus`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const FiberStatus_isFiberStatus = isFiberStatus;
/**
 * Returns `true` if the specified `FiberStatus` is `Done`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const FiberStatus_isDone = fiberStatus_isDone;
/**
 * Returns `true` if the specified `FiberStatus` is `Running`, `false`
 * otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const FiberStatus_isRunning = isRunning;
/**
 * Returns `true` if the specified `FiberStatus` is `Suspended`, `false`
 * otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const FiberStatus_isSuspended = isSuspended;
//# sourceMappingURL=FiberStatus.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/LogLevel.js




/**
 * @since 2.0.0
 * @category constructors
 */
const All = logLevelAll;
/**
 * @since 2.0.0
 * @category constructors
 */
const Fatal = logLevelFatal;
/**
 * @since 2.0.0
 * @category constructors
 */
const LogLevel_Error = logLevelError;
/**
 * @since 2.0.0
 * @category constructors
 */
const Warning = logLevelWarning;
/**
 * @since 2.0.0
 * @category constructors
 */
const Info = logLevelInfo;
/**
 * @since 2.0.0
 * @category constructors
 */
const Debug = logLevelDebug;
/**
 * @since 2.0.0
 * @category constructors
 */
const Trace = logLevelTrace;
/**
 * @since 2.0.0
 * @category constructors
 */
const LogLevel_None = logLevelNone;
/**
 * @since 2.0.0
 * @category constructors
 */
const allLevels = allLogLevels;
/**
 * Locally applies the specified `LogLevel` to an `Effect` workflow, reverting
 * to the previous `LogLevel` after the `Effect` workflow completes.
 *
 * @since 2.0.0
 * @category utils
 */
const locally = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (use, self) => core.fiberRefLocally(use, core.currentLogLevel, self))));
/**
 * @since 2.0.0
 * @category instances
 */
const LogLevel_Order = /*#__PURE__*/Function_pipe(Number_Order, /*#__PURE__*/Order_mapInput(level => level.ordinal));
/**
 * @since 2.0.0
 * @category ordering
 */
const LogLevel_lessThan = /*#__PURE__*/(/* unused pure expression or super */ null && (order.lessThan(LogLevel_Order)));
/**
 * @since 2.0.0
 * @category ordering
 */
const lessThanEqual = /*#__PURE__*/(/* unused pure expression or super */ null && (order.lessThanOrEqualTo(LogLevel_Order)));
/**
 * @since 2.0.0
 * @category ordering
 */
const LogLevel_greaterThan = /*#__PURE__*/greaterThan(LogLevel_Order);
/**
 * @since 2.0.0
 * @category ordering
 */
const greaterThanEqual = /*#__PURE__*/(/* unused pure expression or super */ null && (order.greaterThanOrEqualTo(LogLevel_Order)));
/**
 * @since 2.0.0
 * @category conversions
 */
const fromLiteral = literal => {
  switch (literal) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return LogLevel_Error;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return LogLevel_None;
    case "Warning":
      return Warning;
  }
};
//# sourceMappingURL=LogLevel.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Readable.js




/**
 * @since 2.0.0
 * @category type ids
 */
const Readable_TypeId = /*#__PURE__*/Symbol.for("effect/Readable");
/**
 * @since 2.0.0
 * @category refinements
 */
const isReadable = u => hasProperty(u, Readable_TypeId);
const Proto = {
  [Readable_TypeId]: Readable_TypeId,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/**
 * @since 2.0.0
 * @category constructors
 */
const Readable_make = get => {
  const self = Object.create(Proto);
  self.get = get;
  return self;
};
/**
 * @since 2.0.0
 * @category combinators
 */
const Readable_map = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => Readable_make(core.map(self.get, f)))));
/**
 * @since 2.0.0
 * @category combinators
 */
const mapEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => Readable_make(core.flatMap(self.get, f)))));
/**
 * @since 2.0.0
 * @category constructors
 */
const unwrap = effect => Readable_make(core.flatMap(effect, s => s.get));
//# sourceMappingURL=Readable.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/ref.js






/** @internal */
const RefTypeId = /*#__PURE__*/Symbol.for("effect/Ref");
/** @internal */
const refVariance = {
  /* c8 ignore next */
  _A: _ => _
};
class RefImpl {
  ref;
  [RefTypeId] = refVariance;
  [Readable_TypeId];
  constructor(ref) {
    this.ref = ref;
    this[Readable_TypeId] = Readable_TypeId;
    this.get = sync(() => MutableRef_get(this.ref));
  }
  get;
  modify(f) {
    return sync(() => {
      const current = MutableRef_get(this.ref);
      const [b, a] = f(current);
      if (current !== a) {
        MutableRef_set(a)(this.ref);
      }
      return b;
    });
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
const ref_unsafeMake = value => new RefImpl(MutableRef_make(value));
/** @internal */
const ref_make = value => sync(() => ref_unsafeMake(value));
/** @internal */
const ref_get = self => self.get;
/** @internal */
const ref_set = /*#__PURE__*/Function_dual(2, (self, value) => self.modify(() => [void 0, value]));
/** @internal */
const ref_getAndSet = /*#__PURE__*/Function_dual(2, (self, value) => self.modify(a => [a, value]));
/** @internal */
const ref_getAndUpdate = /*#__PURE__*/Function_dual(2, (self, f) => self.modify(a => [a, f(a)]));
/** @internal */
const getAndUpdateSome = /*#__PURE__*/Function_dual(2, (self, pf) => self.modify(value => {
  const option = pf(value);
  switch (option._tag) {
    case "None":
      {
        return [value, value];
      }
    case "Some":
      {
        return [value, option.value];
      }
  }
}));
/** @internal */
const ref_setAndGet = /*#__PURE__*/Function_dual(2, (self, value) => self.modify(() => [value, value]));
/** @internal */
const ref_modify = /*#__PURE__*/Function_dual(2, (self, f) => self.modify(f));
/** @internal */
const modifySome = /*#__PURE__*/Function_dual(3, (self, fallback, pf) => self.modify(value => {
  const option = pf(value);
  switch (option._tag) {
    case "None":
      {
        return [fallback, value];
      }
    case "Some":
      {
        return option.value;
      }
  }
}));
/** @internal */
const ref_update = /*#__PURE__*/Function_dual(2, (self, f) => self.modify(a => [void 0, f(a)]));
/** @internal */
const ref_updateAndGet = /*#__PURE__*/Function_dual(2, (self, f) => self.modify(a => {
  const result = f(a);
  return [result, result];
}));
/** @internal */
const updateSome = /*#__PURE__*/Function_dual(2, (self, f) => self.modify(a => [void 0, match(f(a), {
  onNone: () => a,
  onSome: b => b
})]));
/** @internal */
const updateSomeAndGet = /*#__PURE__*/Function_dual(2, (self, pf) => self.modify(value => {
  const option = pf(value);
  switch (option._tag) {
    case "None":
      {
        return [value, value];
      }
    case "Some":
      {
        return [option.value, option.value];
      }
  }
}));
/** @internal */
const ref_unsafeGet = self => MutableRef.get(self.ref);
//# sourceMappingURL=ref.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Ref.js

/**
 * @since 2.0.0
 * @category symbols
 */
const Ref_RefTypeId = RefTypeId;
/**
 * @since 2.0.0
 * @category constructors
 */
const Ref_make = ref_make;
/**
 * @since 2.0.0
 * @category getters
 */
const Ref_get = ref_get;
/**
 * @since 2.0.0
 * @category utils
 */
const Ref_getAndSet = ref_getAndSet;
/**
 * @since 2.0.0
 * @category utils
 */
const Ref_getAndUpdate = ref_getAndUpdate;
/**
 * @since 2.0.0
 * @category utils
 */
const Ref_getAndUpdateSome = getAndUpdateSome;
/**
 * @since 2.0.0
 * @category utils
 */
const Ref_modify = ref_modify;
/**
 * @since 2.0.0
 * @category utils
 */
const Ref_modifySome = modifySome;
/**
 * @since 2.0.0
 * @category utils
 */
const Ref_set = ref_set;
/**
 * @since 2.0.0
 * @category utils
 */
const Ref_setAndGet = ref_setAndGet;
/**
 * @since 2.0.0
 * @category utils
 */
const Ref_update = ref_update;
/**
 * @since 2.0.0
 * @category utils
 */
const Ref_updateAndGet = ref_updateAndGet;
/**
 * @since 2.0.0
 * @category utils
 */
const Ref_updateSome = updateSome;
/**
 * @since 2.0.0
 * @category utils
 */
const Ref_updateSomeAndGet = updateSomeAndGet;
/**
 * @since 2.0.0
 * @category unsafe
 */
const Ref_unsafeMake = ref_unsafeMake;
//# sourceMappingURL=Ref.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Scheduler.js
/**
 * @since 2.0.0
 */



/**
 * @since 2.0.0
 * @category utils
 */
class PriorityBuckets {
  /**
   * @since 2.0.0
   */
  buckets = [];
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    let bucket = undefined;
    let index;
    for (index = 0; index < this.buckets.length; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket) {
      bucket[1].push(task);
    } else {
      const newBuckets = [];
      for (let i = 0; i < index; i++) {
        newBuckets.push(this.buckets[i]);
      }
      newBuckets.push([priority, [task]]);
      for (let i = index; i < this.buckets.length; i++) {
        newBuckets.push(this.buckets[i]);
      }
      this.buckets = newBuckets;
    }
  }
}
/**
 * @since 2.0.0
 * @category constructors
 */
class MixedScheduler {
  maxNextTickBeforeTimer;
  /**
   * @since 2.0.0
   */
  running = false;
  /**
   * @since 2.0.0
   */
  tasks = new PriorityBuckets();
  constructor(
  /**
   * @since 2.0.0
   */
  maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
}
/**
 * @since 2.0.0
 * @category schedulers
 */
const defaultScheduler = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
/**
 * @since 2.0.0
 * @category constructors
 */
class SyncScheduler {
  /**
   * @since 2.0.0
   */
  tasks = new PriorityBuckets();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
}
/**
 * @since 2.0.0
 * @category constructors
 */
class ControlledScheduler {
  /**
   * @since 2.0.0
   */
  tasks = new PriorityBuckets();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(core.currentMaxOpsBeforeYield) ? fiber.getFiberRef(core.currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  step() {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
  }
}
/**
 * @since 2.0.0
 * @category constructors
 */
const makeMatrix = (...record) => {
  const index = record.sort(([p0], [p1]) => p0 < p1 ? -1 : p0 > p1 ? 1 : 0);
  return {
    shouldYield(fiber) {
      for (const scheduler of record) {
        const priority = scheduler[1].shouldYield(fiber);
        if (priority !== false) {
          return priority;
        }
      }
      return false;
    },
    scheduleTask(task, priority) {
      let scheduler = undefined;
      for (const i of index) {
        if (priority >= i[0]) {
          scheduler = i[1];
        } else {
          return (scheduler ?? defaultScheduler).scheduleTask(task, priority);
        }
      }
      return (scheduler ?? defaultScheduler).scheduleTask(task, priority);
    }
  };
};
/**
 * @since 2.0.0
 * @category utilities
 */
const defaultShouldYield = fiber => {
  return fiber.currentOpCount > fiber.getFiberRef(core.currentMaxOpsBeforeYield) ? fiber.getFiberRef(core.currentSchedulingPriority) : false;
};
/**
 * @since 2.0.0
 * @category constructors
 */
const Scheduler_make = (scheduleTask, shouldYield = defaultShouldYield) => ({
  scheduleTask,
  shouldYield
});
/**
 * @since 2.0.0
 * @category constructors
 */
const makeBatched = (callback, shouldYield = defaultShouldYield) => {
  let running = false;
  const tasks = new PriorityBuckets();
  const starveInternal = () => {
    const tasksToRun = tasks.buckets;
    tasks.buckets = [];
    for (const [_, toRun] of tasksToRun) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (tasks.buckets.length === 0) {
      running = false;
    } else {
      starve();
    }
  };
  const starve = () => callback(starveInternal);
  return Scheduler_make((task, priority) => {
    tasks.scheduleTask(task, priority);
    if (!running) {
      running = true;
      starve();
    }
  }, shouldYield);
};
/**
 * @since 2.0.0
 * @category constructors
 */
const timer = (ms, shouldYield = defaultShouldYield) => Scheduler_make(task => setTimeout(task, ms), shouldYield);
/**
 * @since 2.0.0
 * @category constructors
 */
const timerBatched = (ms, shouldYield = defaultShouldYield) => makeBatched(task => setTimeout(task, ms), shouldYield);
/** @internal */
const currentScheduler = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
/** @internal */
const withScheduler = /*#__PURE__*/Function_dual(2, (self, scheduler) => fiberRefLocally(self, currentScheduler, scheduler));
//# sourceMappingURL=Scheduler.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/blockedRequests.js







/** @internal */
const blockedRequests_empty = {
  _tag: "Empty"
};
/**
 * Combines this collection of blocked requests with the specified collection
 * of blocked requests, in parallel.
 *
 * @internal
 */
const par = (self, that) => ({
  _tag: "Par",
  left: self,
  right: that
});
/**
 * Combines this collection of blocked requests with the specified collection
 * of blocked requests, in sequence.
 *
 * @internal
 */
const seq = (self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
});
/**
 * Constructs a collection of blocked requests from the specified blocked
 * request and data source.
 *
 * @internal
 */
const single = (dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource: dataSource,
  blockedRequest
});
/** @internal */
const MapRequestResolversReducer = f => ({
  emptyCase: () => blockedRequests_empty,
  parCase: (left, right) => par(left, right),
  seqCase: (left, right) => seq(left, right),
  singleCase: (dataSource, blockedRequest) => single(f(dataSource), blockedRequest)
});
/**
 * Transforms all data sources with the specified data source aspect, which
 * can change the environment type of data sources but must preserve the
 * request type of each data source.
 *
 * @internal
 */
const mapRequestResolvers = (self, f) => blockedRequests_reduce(self, MapRequestResolversReducer(f));
/**
 * Folds over the cases of this collection of blocked requests with the
 * specified functions.
 *
 * @internal
 */
const blockedRequests_reduce = (self, reducer) => {
  let input = List.of(self);
  let output = List.empty();
  while (List.isCons(input)) {
    const current = input.head;
    switch (current._tag) {
      case "Empty":
        {
          output = List.cons(Either.right(reducer.emptyCase()), output);
          input = input.tail;
          break;
        }
      case "Par":
        {
          output = List.cons(Either.left({
            _tag: "ParCase"
          }), output);
          input = List.cons(current.left, List.cons(current.right, input.tail));
          break;
        }
      case "Seq":
        {
          output = List.cons(Either.left({
            _tag: "SeqCase"
          }), output);
          input = List.cons(current.left, List.cons(current.right, input.tail));
          break;
        }
      case "Single":
        {
          const result = reducer.singleCase(current.dataSource, current.blockedRequest);
          output = List.cons(Either.right(result), output);
          input = input.tail;
          break;
        }
    }
  }
  const result = List.reduce(output, List.empty(), (acc, current) => {
    switch (current._tag) {
      case "Left":
        {
          const left = List.unsafeHead(acc);
          const right = List.unsafeHead(List.unsafeTail(acc));
          const tail = List.unsafeTail(List.unsafeTail(acc));
          switch (current.left._tag) {
            case "ParCase":
              {
                return List.cons(reducer.parCase(left, right), tail);
              }
            case "SeqCase":
              {
                return List.cons(reducer.seqCase(left, right), tail);
              }
          }
        }
      case "Right":
        {
          return List.cons(current.right, acc);
        }
    }
  });
  if (List.isNil(result)) {
    throw new Error("BUG: BlockedRequests.reduce - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return result.head;
};
/**
 * Flattens a collection of blocked requests into a collection of pipelined
 * and batched requests that can be submitted for execution.
 *
 * @internal
 */
const blockedRequests_flatten = self => {
  let current = List_of(self);
  let updated = List_empty();
  // eslint-disable-next-line no-constant-condition
  while (1) {
    const [parallel, sequential] = List_reduce(current, [parallelCollectionEmpty(), List_empty()], ([parallel, sequential], blockedRequest) => {
      const [par, seq] = blockedRequests_step(blockedRequest);
      return [parallelCollectionCombine(parallel, par), List_appendAll(sequential, seq)];
    });
    updated = blockedRequests_merge(updated, parallel);
    if (isNil(sequential)) {
      return List_reverse(updated);
    }
    current = sequential;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
/**
 * Takes one step in evaluating a collection of blocked requests, returning a
 * collection of blocked requests that can be performed in parallel and a list
 * of blocked requests that must be performed sequentially after those
 * requests.
 */
const blockedRequests_step = requests => {
  let current = requests;
  let parallel = parallelCollectionEmpty();
  let stack = List_empty();
  let sequential = List_empty();
  // eslint-disable-next-line no-constant-condition
  while (1) {
    switch (current._tag) {
      case "Empty":
        {
          if (isNil(stack)) {
            return [parallel, sequential];
          }
          current = stack.head;
          stack = stack.tail;
          break;
        }
      case "Par":
        {
          stack = cons(current.right, stack);
          current = current.left;
          break;
        }
      case "Seq":
        {
          const left = current.left;
          const right = current.right;
          switch (left._tag) {
            case "Empty":
              {
                current = right;
                break;
              }
            case "Par":
              {
                const l = left.left;
                const r = left.right;
                current = par(seq(l, right), seq(r, right));
                break;
              }
            case "Seq":
              {
                const l = left.left;
                const r = left.right;
                current = seq(l, seq(r, right));
                break;
              }
            case "Single":
              {
                current = left;
                sequential = cons(right, sequential);
                break;
              }
          }
          break;
        }
      case "Single":
        {
          parallel = parallelCollectionAdd(parallel, current);
          if (isNil(stack)) {
            return [parallel, sequential];
          }
          current = stack.head;
          stack = stack.tail;
          break;
        }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
/**
 * Merges a collection of requests that must be executed sequentially with a
 * collection of requests that can be executed in parallel. If the collections
 * are both from the same single data source then the requests can be
 * pipelined while preserving ordering guarantees.
 */
const blockedRequests_merge = (sequential, parallel) => {
  if (isNil(sequential)) {
    return List_of(parallelCollectionToSequentialCollection(parallel));
  }
  if (parallelCollectionIsEmpty(parallel)) {
    return sequential;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential.head);
  const parKeys = parallelCollectionKeys(parallel);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel), sequential);
};
//
// circular
//
/** @internal */
const EntryTypeId = /*#__PURE__*/Symbol.for("effect/RequestBlock/Entry");
/** @internal */
class EntryImpl {
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request, result, listeners, ownerId, state) {
    this.request = request;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
}
const blockedRequestVariance = {
  /* c8 ignore next */
  _R: _ => _
};
/** @internal */
const isEntry = u => Predicate_hasProperty(u, EntryTypeId);
/** @internal */
const makeEntry = options => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
/** @internal */
const RequestBlockParallelTypeId = /*#__PURE__*/Symbol.for("effect/RequestBlock/RequestBlockParallel");
const parallelVariance = {
  /* c8 ignore next */
  _R: _ => _
};
class ParallelImpl {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map) {
    this.map = map;
  }
}
/** @internal */
const parallelCollectionEmpty = () => new ParallelImpl(HashMap_empty());
/** @internal */
const parallelCollectionMake = (dataSource, blockedRequest) => new ParallelImpl(HashMap.make([dataSource, Chunk.of(blockedRequest)]));
/** @internal */
const parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(HashMap_modifyAt(self.map, blockedRequest.dataSource, _ => orElseSome(map(_, Chunk_append(blockedRequest.blockedRequest)), () => Chunk_of(blockedRequest.blockedRequest))));
/** @internal */
const parallelCollectionCombine = (self, that) => new ParallelImpl(HashMap_reduce(self.map, that.map, (map, value, key) => HashMap_set(map, key, match(HashMap_get(map, key), {
  onNone: () => value,
  onSome: other => Chunk_appendAll(value, other)
}))));
/** @internal */
const parallelCollectionIsEmpty = self => HashMap_isEmpty(self.map);
/** @internal */
const parallelCollectionKeys = self => Array.from(HashMap_keys(self.map));
/** @internal */
const parallelCollectionToSequentialCollection = self => sequentialCollectionMake(HashMap_map(self.map, x => Chunk_of(x)));
// TODO
// /** @internal */
// export const parallelCollectionToChunk = <R>(
//   self: ParallelCollection<R>
// ): Array<[RequestResolver.RequestResolver<unknown, R>, Array<Request.Entry<unknown>>]> => Array.from(self.map) as any
/** @internal */
const SequentialCollectionTypeId = /*#__PURE__*/Symbol.for("effect/RequestBlock/RequestBlockSequential");
const sequentialVariance = {
  /* c8 ignore next */
  _R: _ => _
};
class SequentialImpl {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map) {
    this.map = map;
  }
}
/** @internal */
const sequentialCollectionMake = map => new SequentialImpl(map);
/** @internal */
const sequentialCollectionCombine = (self, that) => new SequentialImpl(HashMap_reduce(that.map, self.map, (map, value, key) => HashMap_set(map, key, match(HashMap_get(map, key), {
  onNone: () => esm_Chunk_empty(),
  onSome: a => Chunk_appendAll(a, value)
}))));
/** @internal */
const sequentialCollectionIsEmpty = self => HashMap.isEmpty(self.map);
/** @internal */
const sequentialCollectionKeys = self => Array.from(HashMap_keys(self.map));
/** @internal */
const sequentialCollectionToChunk = self => Array.from(self.map);
//# sourceMappingURL=blockedRequests.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/completedRequestMap.js


/** @internal */
const currentRequestMap = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(new Map()));
//# sourceMappingURL=completedRequestMap.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/concurrency.js

/** @internal */
const concurrency_match = (concurrency, sequential, unbounded, bounded) => {
  switch (concurrency) {
    case undefined:
      return sequential();
    case "unbounded":
      return unbounded();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, concurrency => concurrency === "unbounded" ? unbounded() : concurrency > 1 ? bounded(concurrency) : sequential());
    default:
      return concurrency > 1 ? bounded(concurrency) : sequential();
  }
};
/** @internal */
const matchSimple = (concurrency, sequential, concurrent) => {
  switch (concurrency) {
    case undefined:
      return sequential();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, concurrency => concurrency === "unbounded" || concurrency > 1 ? concurrent() : sequential());
    default:
      return concurrency > 1 ? concurrent() : sequential();
  }
};
//# sourceMappingURL=concurrency.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Clock.js


/**
 * @since 2.0.0
 * @category symbols
 */
const Clock_ClockTypeId = ClockTypeId;
/**
 * @since 2.0.0
 * @category constructors
 */
const Clock_make = clock_make;
/**
 * @since 2.0.0
 * @category constructors
 */
const Clock_sleep = sleep;
/**
 * @since 2.0.0
 * @category constructors
 */
const Clock_currentTimeMillis = currentTimeMillis;
/**
 * @since 2.0.0
 * @category constructors
 */
const Clock_currentTimeNanos = currentTimeNanos;
/**
 * @since 2.0.0
 * @category constructors
 */
const Clock_clockWith = clockWith;
/**
 * @since 2.0.0
 * @category context
 */
const Clock_Clock = clockTag;
//# sourceMappingURL=Clock.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/logSpan.js
/** @internal */
const logSpan_make = (label, startTime) => ({
  label,
  startTime
});
/** @internal */
const logSpan_render = now => self => {
  const label = self.label.replace(/[\s="]/g, "_");
  return `${label}=${now - self.startTime}ms`;
};
//# sourceMappingURL=logSpan.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/LogSpan.js
/**
 * @since 2.0.0
 */

/**
 * @since 2.0.0
 * @category constructors
 */
const LogSpan_make = logSpan_make;
/**
 * @since 2.0.0
 * @category destructors
 */
const LogSpan_render = logSpan_render;
//# sourceMappingURL=LogSpan.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Tracer.js


/**
 * @since 2.0.0
 */
const Tracer_TracerTypeId = TracerTypeId;
/**
 * @since 2.0.0
 * @category tags
 */
const ParentSpan = spanTag;
/**
 * @since 2.0.0
 * @category tags
 */
const Tracer = tracerTag;
/**
 * @since 2.0.0
 * @category constructors
 */
const Tracer_make = tracer_make;
/**
 * @since 2.0.0
 * @category constructors
 */
const Tracer_externalSpan = externalSpan;
/**
 * @since 2.0.0
 * @category constructors
 */
const Tracer_tracerWith = tracerWith;
//# sourceMappingURL=Tracer.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/doNotation.js

/** @internal */
const doNotation_let_ = map => Function_dual(3, (self, name, f) => map(self, a => Object.assign({}, a, {
  [name]: f(a)
})));
/** @internal */
const doNotation_bindTo = map => Function_dual(2, (self, name) => map(self, a => ({
  [name]: a
})));
/** @internal */
const doNotation_bind = (map, flatMap) => Function_dual(3, (self, name, f) => flatMap(self, a => map(f(a), b => Object.assign({}, a, {
  [name]: b
}))));
//# sourceMappingURL=doNotation.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/metric/label.js




/** @internal */
const MetricLabelSymbolKey = "effect/MetricLabel";
/** @internal */
const MetricLabelTypeId = /*#__PURE__*/Symbol.for(MetricLabelSymbolKey);
/** @internal */
class MetricLabelImpl {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this._hash = string(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol]() {
    return this._hash;
  }
  [Equal_symbol](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
const label_make = (key, value) => {
  return new MetricLabelImpl(key, value);
};
/** @internal */
const isMetricLabel = u => Predicate_hasProperty(u, MetricLabelTypeId);
//# sourceMappingURL=label.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/core-effect.js


























/* @internal */
const annotateLogs = /*#__PURE__*/Function_dual(args => isEffect(args[0]), function () {
  const args = arguments;
  return fiberRefLocallyWith(args[0], currentLogAnnotations, typeof args[1] === "string" ? HashMap_set(args[1], args[2]) : annotations => Object.entries(args[1]).reduce((acc, [key, value]) => HashMap_set(acc, key, value), annotations));
});
/* @internal */
const asSome = self => core_map(self, Option_some);
/* @internal */
const asSomeError = self => mapError(self, Option_some);
/* @internal */
const core_effect_try_ = arg => {
  let evaluate;
  let onFailure = undefined;
  if (typeof arg === "function") {
    evaluate = arg;
  } else {
    evaluate = arg.try;
    onFailure = arg.catch;
  }
  return sync(() => {
    try {
      return evaluate();
    } catch (error) {
      throw makeEffectError(fail(onFailure ? onFailure(error) : new UnknownException(error)));
    }
  });
};
/* @internal */
const _catch = /*#__PURE__*/Function_dual(3, (self, tag, options) => catchAll(self, e => {
  if (Predicate_hasProperty(e, tag) && e[tag] === options.failure) {
    return options.onFailure(e);
  }
  return core_fail(e);
}));
/* @internal */
const catchAllDefect = /*#__PURE__*/Function_dual(2, (self, f) => catchAllCause(self, cause => {
  const option = find(cause, _ => isDieType(_) ? Option_some(_) : Option_none());
  switch (option._tag) {
    case "None":
      {
        return failCause(cause);
      }
    case "Some":
      {
        return f(option.value.defect);
      }
  }
}));
/* @internal */
const catchSomeCause = /*#__PURE__*/Function_dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: cause => {
    const option = f(cause);
    switch (option._tag) {
      case "None":
        {
          return failCause(cause);
        }
      case "Some":
        {
          return option.value;
        }
    }
  },
  onSuccess: succeed
}));
/* @internal */
const catchSomeDefect = /*#__PURE__*/Function_dual(2, (self, pf) => catchAllCause(self, cause => {
  const option = find(cause, _ => isDieType(_) ? Option_some(_) : Option_none());
  switch (option._tag) {
    case "None":
      {
        return failCause(cause);
      }
    case "Some":
      {
        const optionEffect = pf(option.value.defect);
        return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause);
      }
  }
}));
/* @internal */
const catchTag = /*#__PURE__*/Function_dual(3, (self, k, f) => catchIf(self, isTagged(k), f));
/** @internal */
const catchTags = /*#__PURE__*/Function_dual(2, (self, cases) => {
  let keys;
  return catchIf(self, e => {
    keys ??= Object.keys(cases);
    return Predicate_hasProperty(e, "_tag") && isString(e["_tag"]) && keys.includes(e["_tag"]);
  }, e => cases[e["_tag"]](e));
});
/* @internal */
const cause = self => matchCause(self, {
  onFailure: Function_identity,
  onSuccess: () => cause_empty
});
/* @internal */
const core_effect_clockWith = Clock_clockWith;
/* @internal */
const clock = /*#__PURE__*/core_effect_clockWith(succeed);
/* @internal */
const delay = /*#__PURE__*/Function_dual(2, (self, duration) => core_zipRight(Clock_sleep(duration), self));
/* @internal */
const descriptorWith = f => withFiberRuntime((state, status) => f({
  id: state.id(),
  status,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
}));
/* @internal */
const allowInterrupt = /*#__PURE__*/descriptorWith(descriptor => HashSet_size(descriptor.interruptors) > 0 ? core_interrupt : core_void_);
/* @internal */
const descriptor = /*#__PURE__*/descriptorWith(succeed);
/* @internal */
const diffFiberRefs = self => summarized(self, core_effect_fiberRefs, patch_diff);
/* @internal */
const diffFiberRefsAndRuntimeFlags = self => summarized(self, core_zip(core_effect_fiberRefs, core_runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [patch_diff(refs, refsNew), runtimeFlags_diff(flags, flagsNew)]);
/* @internal */
const core_effect_Do = /*#__PURE__*/succeed({});
/* @internal */
const core_effect_bind = /*#__PURE__*/doNotation_bind(core_map, core_flatMap);
/* @internal */
const core_effect_bindTo = /*#__PURE__*/doNotation_bindTo(core_map);
/* @internal */
const core_effect_let_ = /*#__PURE__*/doNotation_let_(core_map);
/* @internal */
const dropUntil = /*#__PURE__*/Function_dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    dropping = core_flatMap(dropping, bool => {
      if (bool) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index);
    });
  }
  return core_map(dropping, () => builder);
}));
/* @internal */
const core_effect_dropWhile = /*#__PURE__*/Function_dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    dropping = core_flatMap(dropping, d => core_map(d ? predicate(a, index) : succeed(false), b => {
      if (!b) {
        builder.push(a);
      }
      return b;
    }));
  }
  return core_map(dropping, () => builder);
}));
/* @internal */
const core_effect_contextWith = f => core_map(context(), f);
/* @internal */
const eventually = self => core_orElse(self, () => core_flatMap(yieldNow(), () => eventually(self)));
/* @internal */
const core_effect_filterMap = /*#__PURE__*/Function_dual(2, (elements, pf) => core_map(forEachSequential(elements, Function_identity), Array_filterMap(pf)));
/* @internal */
const filterOrDie = /*#__PURE__*/Function_dual(3, (self, predicate, orDieWith) => filterOrElse(self, predicate, a => dieSync(() => orDieWith(a))));
/* @internal */
const filterOrDieMessage = /*#__PURE__*/Function_dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => dieMessage(message)));
/* @internal */
const filterOrElse = /*#__PURE__*/Function_dual(3, (self, predicate, orElse) => core_flatMap(self, a => predicate(a) ? succeed(a) : orElse(a)));
/* @internal */
const filterOrFail = /*#__PURE__*/Function_dual(args => isEffect(args[0]), (self, predicate, orFailWith) => filterOrElse(self, predicate, a => orFailWith === undefined ? core_fail(new NoSuchElementException()) : failSync(() => orFailWith(a))));
/* @internal */
const core_effect_findFirst = /*#__PURE__*/Function_dual(2, (elements, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, 0, f, next.value);
  }
  return succeed(Option_none());
}));
const findLoop = (iterator, index, f, value) => core_flatMap(f(value, index), result => {
  if (result) {
    return succeed(Option_some(value));
  }
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, index + 1, f, next.value);
  }
  return succeed(Option_none());
});
/* @internal */
const firstSuccessOf = effects => suspend(() => {
  const list = Chunk_fromIterable(effects);
  if (!isNonEmpty(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return Function_pipe(Chunk_tailNonEmpty(list), Array_reduce(Chunk_headNonEmpty(list), (left, right) => core_orElse(left, () => right)));
});
/* @internal */
const flipWith = /*#__PURE__*/Function_dual(2, (self, f) => core_flip(f(core_flip(self))));
/* @internal */
const core_effect_match = /*#__PURE__*/Function_dual(2, (self, options) => matchEffect(self, {
  onFailure: e => succeed(options.onFailure(e)),
  onSuccess: a => succeed(options.onSuccess(a))
}));
/* @internal */
const core_effect_every = /*#__PURE__*/Function_dual(2, (elements, f) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, f)));
const forAllLoop = (iterator, index, f) => {
  const next = iterator.next();
  return next.done ? succeed(true) : core_flatMap(f(next.value, index), b => b ? forAllLoop(iterator, index + 1, f) : succeed(b));
};
/* @internal */
const forever = self => {
  const loop = core_flatMap(core_flatMap(self, () => yieldNow()), () => loop);
  return loop;
};
/**
 * Inspired by https://github.com/tusharmath/qio/pull/22 (revised)
  @internal */
const core_effect_gen = function () {
  let f;
  if (arguments.length === 1) {
    f = arguments[0];
  } else {
    f = arguments[1].bind(arguments[0]);
  }
  return suspend(() => {
    const iterator = f(Function_pipe);
    const state = iterator.next();
    const run = state => {
      return state.done ? succeed(state.value) : core_flatMap(yieldWrapGet(state.value), val => run(iterator.next(val)));
    };
    return run(state);
  });
};
/* @internal */
const core_effect_fiberRefs = /*#__PURE__*/withFiberRuntime(state => succeed(state.getFiberRefs()));
/* @internal */
const core_effect_head = self => core_flatMap(self, as => {
  const iterator = as[Symbol.iterator]();
  const next = iterator.next();
  if (next.done) {
    return core_fail(new NoSuchElementException());
  }
  return succeed(next.value);
});
/* @internal */
const ignore = self => core_effect_match(self, {
  onFailure: Function_constVoid,
  onSuccess: Function_constVoid
});
/* @internal */
const ignoreLogged = self => matchCauseEffect(self, {
  onFailure: cause => logDebug(cause, "An error was silently ignored because it is not anticipated to be useful"),
  onSuccess: () => core_void_
});
/* @internal */
const inheritFiberRefs = childFiberRefs => updateFiberRefs((parentFiberId, parentFiberRefs) => FiberRefs_joinAs(parentFiberRefs, parentFiberId, childFiberRefs));
/* @internal */
const core_effect_isFailure = self => core_effect_match(self, {
  onFailure: constTrue,
  onSuccess: constFalse
});
/* @internal */
const isSuccess = self => core_effect_match(self, {
  onFailure: constFalse,
  onSuccess: constTrue
});
/* @internal */
const iterate = (initial, options) => suspend(() => {
  if (options.while(initial)) {
    return core_flatMap(options.body(initial), z2 => iterate(z2, options));
  }
  return succeed(initial);
});
/** @internal */
const logWithLevel = level => (...message) => {
  const levelOption = fromNullable(level);
  let cause = undefined;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause !== undefined) {
        cause = sequential(cause, msg);
      } else {
        cause = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (message.length === 0) {
    message = "";
  } else if (message.length === 1) {
    message = message[0];
  }
  if (cause === undefined) {
    cause = cause_empty;
  }
  return withFiberRuntime(fiberState => {
    fiberState.log(message, cause, levelOption);
    return core_void_;
  });
};
/** @internal */
const log = /*#__PURE__*/logWithLevel();
/** @internal */
const logTrace = /*#__PURE__*/logWithLevel(Trace);
/** @internal */
const logDebug = /*#__PURE__*/logWithLevel(Debug);
/** @internal */
const logInfo = /*#__PURE__*/logWithLevel(Info);
/** @internal */
const logWarning = /*#__PURE__*/logWithLevel(Warning);
/** @internal */
const logError = /*#__PURE__*/logWithLevel(LogLevel_Error);
/** @internal */
const logFatal = /*#__PURE__*/logWithLevel(Fatal);
/* @internal */
const withLogSpan = /*#__PURE__*/Function_dual(2, (effect, label) => core_flatMap(Clock_currentTimeMillis, now => fiberRefLocallyWith(effect, currentLogSpan, List_prepend(LogSpan_make(label, now)))));
/* @internal */
const logAnnotations = /*#__PURE__*/fiberRefGet(currentLogAnnotations);
/* @internal */
const loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : core_map(loopInternal(initial, options.while, options.step, options.body), Array_fromIterable);
const loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? core_flatMap(body(initial), a => core_map(loopInternal(inc(initial), cont, inc, body), List_prepend(a))) : sync(() => List_empty()));
const loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? core_flatMap(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : core_void_);
/* @internal */
const core_effect_mapAccum = /*#__PURE__*/Function_dual(3, (elements, zero, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(zero);
  let next;
  let i = 0;
  while (!(next = iterator.next()).done) {
    const index = i++;
    const value = next.value;
    result = core_flatMap(result, state => core_map(f(state, value, index), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return core_map(result, z => [z, builder]);
}));
/* @internal */
const mapErrorCause = /*#__PURE__*/Function_dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: c => failCauseSync(() => f(c)),
  onSuccess: succeed
}));
/* @internal */
const memoize = self => Function_pipe(deferredMake(), core_flatMap(deferred => Function_pipe(diffFiberRefsAndRuntimeFlags(self), intoDeferred(deferred), once, core_map(complete => core_zipRight(complete, Function_pipe(deferredAwait(deferred), core_flatMap(([patch, a]) => core_as(core_zip(patchFiberRefs(patch[0]), updateRuntimeFlags(patch[1])), a))))))));
/* @internal */
const core_effect_merge = self => matchEffect(self, {
  onFailure: e => succeed(e),
  onSuccess: succeed
});
/* @internal */
const negate = self => core_map(self, b => !b);
/* @internal */
const core_effect_none = self => core_flatMap(self, option => {
  switch (option._tag) {
    case "None":
      return core_void_;
    case "Some":
      return core_fail(new NoSuchElementException());
  }
});
/* @internal */
const once = self => core_map(Ref_make(true), ref => core_asVoid(whenEffect(self, Ref_getAndSet(ref, false))));
/* @internal */
const core_effect_option = self => matchEffect(self, {
  onFailure: () => succeed(Option_none()),
  onSuccess: a => succeed(Option_some(a))
});
/* @internal */
const orElseFail = /*#__PURE__*/Function_dual(2, (self, evaluate) => core_orElse(self, () => failSync(evaluate)));
/* @internal */
const orElseSucceed = /*#__PURE__*/Function_dual(2, (self, evaluate) => core_orElse(self, () => sync(evaluate)));
/* @internal */
const parallelErrors = self => matchCauseEffect(self, {
  onFailure: cause => {
    const errors = Array_fromIterable(cause_failures(cause));
    return errors.length === 0 ? failCause(cause) : core_fail(errors);
  },
  onSuccess: succeed
});
/* @internal */
const patchFiberRefs = patch => updateFiberRefs((fiberId, fiberRefs) => Function_pipe(patch, patch_patch(fiberId, fiberRefs)));
/* @internal */
const promise = evaluate => evaluate.length >= 1 ? core_async((resolve, signal) => {
  evaluate(signal).then(a => resolve(exitSucceed(a)), e => resolve(exitDie(e)));
}) : core_async(resolve => {
  ;
  evaluate().then(a => resolve(exitSucceed(a)), e => resolve(exitDie(e)));
});
/* @internal */
const provideService = /*#__PURE__*/Function_dual(3, (self, tag, service) => contextWithEffect(env => provideContext(self, Context_add(env, tag, service))));
/* @internal */
const provideServiceEffect = /*#__PURE__*/Function_dual(3, (self, tag, effect) => contextWithEffect(env => core_flatMap(effect, service => provideContext(self, Function_pipe(env, Context_add(tag, service))))));
/* @internal */
const core_effect_random = /*#__PURE__*/randomWith(succeed);
/* @internal */
const core_effect_reduce = /*#__PURE__*/Function_dual(3, (elements, zero, f) => Array_fromIterable(elements).reduce((acc, el, i) => core_flatMap(acc, a => f(a, el, i)), succeed(zero)));
/* @internal */
const core_effect_reduceRight = /*#__PURE__*/Function_dual(3, (elements, zero, f) => Array_fromIterable(elements).reduceRight((acc, el, i) => core_flatMap(acc, a => f(el, a, i)), succeed(zero)));
/* @internal */
const reduceWhile = /*#__PURE__*/Function_dual(3, (elements, zero, options) => core_flatMap(sync(() => elements[Symbol.iterator]()), iterator => reduceWhileLoop(iterator, 0, zero, options.while, options.body)));
const reduceWhileLoop = (iterator, index, state, predicate, f) => {
  const next = iterator.next();
  if (!next.done && predicate(state)) {
    return core_flatMap(f(state, next.value, index), nextState => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
  }
  return succeed(state);
};
/* @internal */
const repeatN = /*#__PURE__*/Function_dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));
/* @internal */
const repeatNLoop = (self, n) => core_flatMap(self, a => n <= 0 ? succeed(a) : core_zipRight(yieldNow(), repeatNLoop(self, n - 1)));
/* @internal */
const sandbox = self => matchCauseEffect(self, {
  onFailure: core_fail,
  onSuccess: succeed
});
/* @internal */
const setFiberRefs = fiberRefs => suspend(() => FiberRefs_setAll(fiberRefs));
/* @internal */
const core_effect_sleep = Clock_sleep;
/* @internal */
const succeedNone = /*#__PURE__*/succeed( /*#__PURE__*/Option_none());
/* @internal */
const succeedSome = value => succeed(Option_some(value));
/* @internal */
const summarized = /*#__PURE__*/Function_dual(3, (self, summary, f) => core_flatMap(summary, start => core_flatMap(self, value => core_map(summary, end => [f(start, end), value]))));
/* @internal */
const tagMetrics = /*#__PURE__*/Function_dual(args => isEffect(args[0]), function () {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [label_make(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => label_make(k, v)));
});
/* @internal */
const labelMetrics = /*#__PURE__*/Function_dual(2, (self, labels) => fiberRefLocallyWith(self, currentMetricLabels, old => Array_union(old, labels)));
/* @internal */
const takeUntil = /*#__PURE__*/Function_dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let effect = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    effect = core_flatMap(effect, bool => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index);
    });
  }
  return core_map(effect, () => builder);
}));
/* @internal */
const core_effect_takeWhile = /*#__PURE__*/Function_dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let taking = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    taking = core_flatMap(taking, taking => Function_pipe(taking ? predicate(a, index) : succeed(false), core_map(bool => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return core_map(taking, () => builder);
}));
/* @internal */
const tapBoth = /*#__PURE__*/Function_dual(2, (self, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self, {
  onFailure: cause => {
    const either = failureOrCause(cause);
    switch (either._tag) {
      case "Left":
        {
          return core_zipRight(onFailure(either.left), failCause(cause));
        }
      case "Right":
        {
          return failCause(cause);
        }
    }
  },
  onSuccess: a => core_as(onSuccess(a), a)
}));
/* @internal */
const tapDefect = /*#__PURE__*/Function_dual(2, (self, f) => catchAllCause(self, cause => match(keepDefects(cause), {
  onNone: () => failCause(cause),
  onSome: a => core_zipRight(f(a), failCause(cause))
})));
/* @internal */
const tapError = /*#__PURE__*/Function_dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: cause => {
    const either = failureOrCause(cause);
    switch (either._tag) {
      case "Left":
        return core_zipRight(f(either.left), failCause(cause));
      case "Right":
        return failCause(cause);
    }
  },
  onSuccess: succeed
}));
/* @internal */
const tapErrorTag = /*#__PURE__*/Function_dual(3, (self, k, f) => tapError(self, e => {
  if (isTagged(e, k)) {
    return f(e);
  }
  return core_void_;
}));
/* @internal */
const tapErrorCause = /*#__PURE__*/Function_dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: cause => core_zipRight(f(cause), failCause(cause)),
  onSuccess: succeed
}));
/* @internal */
const timed = self => timedWith(self, Clock_currentTimeNanos);
/* @internal */
const timedWith = /*#__PURE__*/Function_dual(2, (self, nanos) => summarized(self, nanos, (start, end) => Duration_nanos(end - start)));
/* @internal */
const core_effect_tracerWith = Tracer_tracerWith;
/** @internal */
const core_effect_tracer = /*#__PURE__*/core_effect_tracerWith(succeed);
/* @internal */
const tryPromise = arg => {
  let evaluate;
  let catcher = undefined;
  if (typeof arg === "function") {
    evaluate = arg;
  } else {
    evaluate = arg.try;
    catcher = arg.catch;
  }
  if (evaluate.length >= 1) {
    return core_async((resolve, signal) => {
      try {
        evaluate(signal).then(a => resolve(exitSucceed(a)), e => resolve(core_fail(catcher ? catcher(e) : new UnknownException(e))));
      } catch (e) {
        resolve(core_fail(catcher ? catcher(e) : new UnknownException(e)));
      }
    });
  }
  return core_async(resolve => {
    try {
      evaluate().then(a => resolve(exitSucceed(a)), e => resolve(core_fail(catcher ? catcher(e) : new UnknownException(e))));
    } catch (e) {
      resolve(core_fail(catcher ? catcher(e) : new UnknownException(e)));
    }
  });
};
/* @internal */
const tryMap = /*#__PURE__*/Function_dual(2, (self, options) => core_flatMap(self, a => core_effect_try_({
  try: () => options.try(a),
  catch: options.catch
})));
/* @internal */
const tryMapPromise = /*#__PURE__*/Function_dual(2, (self, options) => core_flatMap(self, a => tryPromise({
  try: options.try.length >= 1 ? signal => options.try(a, signal) : () => options.try(a),
  catch: options.catch
})));
/* @internal */
const unless = /*#__PURE__*/Function_dual(2, (self, condition) => suspend(() => condition() ? succeedNone : asSome(self)));
/* @internal */
const unlessEffect = /*#__PURE__*/Function_dual(2, (self, condition) => core_flatMap(condition, b => b ? succeedNone : asSome(self)));
/* @internal */
const unsandbox = self => mapErrorCause(self, cause_flatten);
/* @internal */
const updateFiberRefs = f => withFiberRuntime(state => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return core_void_;
});
/* @internal */
const updateService = /*#__PURE__*/Function_dual(3, (self, tag, f) => mapInputContext(self, context => Context_add(context, tag, f(Context_unsafeGet(context, tag)))));
/* @internal */
const when = /*#__PURE__*/Function_dual(2, (self, condition) => suspend(() => condition() ? core_map(self, Option_some) : succeed(Option_none())));
/* @internal */
const whenFiberRef = /*#__PURE__*/Function_dual(3, (self, fiberRef, predicate) => core_flatMap(fiberRefGet(fiberRef), s => predicate(s) ? core_map(self, a => [s, Option_some(a)]) : succeed([s, Option_none()])));
/* @internal */
const whenRef = /*#__PURE__*/Function_dual(3, (self, ref, predicate) => core_flatMap(Ref_get(ref), s => predicate(s) ? core_map(self, a => [s, Option_some(a)]) : succeed([s, Option_none()])));
/* @internal */
const withMetric = /*#__PURE__*/Function_dual(2, (self, metric) => metric(self));
/** @internal */
const serviceFunctionEffect = (getService, f) => (...args) => core_flatMap(getService, a => f(a)(...args));
/** @internal */
const serviceFunction = (getService, f) => (...args) => core_map(getService, a => f(a)(...args));
/** @internal */
const serviceFunctions = getService => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args) => core_flatMap(getService, s => s[prop](...args));
  }
});
/** @internal */
const serviceConstants = getService => new Proxy({}, {
  get(_target, prop, _receiver) {
    return core_flatMap(getService, s => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
  }
});
/** @internal */
const serviceMembers = getService => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
});
/** @internal */
const serviceOption = tag => core_map(context(), Context_getOption(tag));
/** @internal */
const serviceOptional = tag => core_flatMap(context(), Context_getOption(tag));
// -----------------------------------------------------------------------------
// tracing
// -----------------------------------------------------------------------------
/* @internal */
const annotateCurrentSpan = function () {
  const args = arguments;
  return ignore(core_flatMap(currentSpan, span => sync(() => {
    if (typeof args[0] === "string") {
      span.attribute(args[0], args[1]);
    } else {
      for (const key in args[0]) {
        span.attribute(key, args[0][key]);
      }
    }
  })));
};
/* @internal */
const annotateSpans = /*#__PURE__*/Function_dual(args => isEffect(args[0]), function () {
  const args = arguments;
  return fiberRefLocallyWith(args[0], currentTracerSpanAnnotations, typeof args[1] === "string" ? HashMap_set(args[1], args[2]) : annotations => Object.entries(args[1]).reduce((acc, [key, value]) => HashMap_set(acc, key, value), annotations));
});
/** @internal */
const currentParentSpan = /*#__PURE__*/serviceOptional(spanTag);
/** @internal */
const currentSpan = /*#__PURE__*/core_flatMap( /*#__PURE__*/context(), context => {
  const span = context.unsafeMap.get(spanTag.key);
  return span !== undefined && span._tag === "Span" ? succeed(span) : core_fail(new NoSuchElementException());
});
/* @internal */
const linkSpans = /*#__PURE__*/Function_dual(args => isEffect(args[0]), (self, span, attributes) => fiberRefLocallyWith(self, currentTracerSpanLinks, Chunk_append({
  _tag: "SpanLink",
  span,
  attributes: attributes ?? {}
})));
const core_effect_bigint0 = /*#__PURE__*/BigInt(0);
/** @internal */
const unsafeMakeSpan = (fiber, name, options) => {
  const enabled = fiber.getFiberRef(currentTracerEnabled);
  if (enabled === false) {
    return noopSpan(name);
  }
  const context = fiber.getFiberRef(currentContext);
  const services = fiber.getFiberRef(currentServices);
  const tracer = Context_get(services, tracerTag);
  const clock = Context_get(services, Clock_Clock);
  const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
  const fiberRefs = fiber.getFiberRefs();
  const annotationsFromEnv = FiberRefs_get(fiberRefs, currentTracerSpanAnnotations);
  const linksFromEnv = FiberRefs_get(fiberRefs, currentTracerSpanLinks);
  const parent = options?.parent ? Option_some(options.parent) : options?.root ? Option_none() : Context_getOption(context, spanTag);
  const links = linksFromEnv._tag === "Some" ? options?.links !== undefined ? [...toReadonlyArray(linksFromEnv.value), ...(options?.links ?? [])] : toReadonlyArray(linksFromEnv.value) : options?.links ?? Array_empty();
  const span = tracer.span(name, parent, options?.context ?? Context_empty(), links, timingEnabled ? clock.unsafeCurrentTimeNanos() : core_effect_bigint0, options?.kind ?? "internal");
  if (annotationsFromEnv._tag === "Some") {
    HashMap_forEach(annotationsFromEnv.value, (value, key) => span.attribute(key, value));
  }
  if (options?.attributes !== undefined) {
    Object.entries(options.attributes).forEach(([k, v]) => span.attribute(k, v));
  }
  return span;
};
/** @internal */
const makeSpan = (name, options) => withFiberRuntime(fiber => succeed(unsafeMakeSpan(fiber, name, options)));
/* @internal */
const spanAnnotations = /*#__PURE__*/fiberRefGet(currentTracerSpanAnnotations);
/* @internal */
const spanLinks = /*#__PURE__*/fiberRefGet(currentTracerSpanLinks);
/** @internal */
const useSpan = (name, ...args) => {
  const options = args.length === 1 ? undefined : args[0];
  const evaluate = args[args.length - 1];
  return withFiberRuntime(fiber => {
    const span = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock = Context_get(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate(span), exit => sync(() => {
      if (span.status._tag === "Ended") {
        return;
      }
      span.end(timingEnabled ? clock.unsafeCurrentTimeNanos() : core_effect_bigint0, exit);
    }));
  });
};
/** @internal */
const withParentSpan = /*#__PURE__*/Function_dual(2, (self, span) => provideService(self, spanTag, span));
/** @internal */
const withSpan = /*#__PURE__*/Function_dual(args => typeof args[0] !== "string", (self, name, options) => useSpan(name, options ?? {}, span => withParentSpan(self, span)));
// -------------------------------------------------------------------------------------
// optionality
// -------------------------------------------------------------------------------------
/* @internal */
const core_effect_fromNullable = value => value == null ? core_fail(new NoSuchElementException()) : succeed(value);
/* @internal */
const optionFromOptional = self => catchAll(core_map(self, Option_some), error => isNoSuchElementException(error) ? succeedNone : core_fail(error));
//# sourceMappingURL=core-effect.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Exit.js

/**
 * Returns `true` if the specified value is an `Exit`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const isExit = exitIsExit;
/**
 * Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const Exit_isFailure = exitIsFailure;
/**
 * Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const Exit_isSuccess = exitIsSuccess;
/**
 * Returns `true` if the specified exit is a `Failure` **and** the `Cause` of
 * the failure was due to interruption, `false` otherwise.
 *
 * @since 2.0.0
 * @category getters
 */
const Exit_isInterrupted = exitIsInterrupted;
/**
 * Maps the `Success` value of the specified exit to the provided constant
 * value.
 *
 * @since 2.0.0
 * @category mapping
 */
const Exit_as = exitAs;
/**
 * Maps the `Success` value of the specified exit to a void.
 *
 * @since 2.0.0
 * @category mapping
 */
const Exit_asVoid = exitAsVoid;
/**
 * Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`
 * otherwise.
 *
 * @since 2.0.0
 * @category getters
 */
const causeOption = exitCauseOption;
/**
 * Collects all of the specified exit values into a `Some<Exit<List<A>, E>>`. If
 * the provided iterable contains no elements, `None` will be returned.
 *
 * @since 2.0.0
 * @category constructors
 */
const Exit_all = exitCollectAll;
/**
 * Constructs a new `Exit.Failure` from the specified unrecoverable defect.
 *
 * @since 2.0.0
 * @category constructors
 */
const Exit_die = exitDie;
/**
 * Executes the predicate on the value of the specified exit if it is a
 * `Success`, otherwise returns `false`.
 *
 * @since 2.0.0
 * @category elements
 */
const Exit_exists = exitExists;
/**
 * Constructs a new `Exit.Failure` from the specified recoverable error of type
 * `E`.
 *
 * @since 2.0.0
 * @category constructors
 */
const Exit_fail = exitFail;
/**
 * Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.
 *
 * @since 2.0.0
 * @category constructors
 */
const Exit_failCause = exitFailCause;
/**
 * @since 2.0.0
 * @category sequencing
 */
const Exit_flatMap = exitFlatMap;
/**
 * @since 2.0.0
 * @category sequencing
 */
const flatMapEffect = exitFlatMapEffect;
/**
 * @since 2.0.0
 * @category sequencing
 */
const Exit_flatten = exitFlatten;
/**
 * @since 2.0.0
 * @category traversing
 */
const forEachEffect = exitForEachEffect;
/**
 * Converts an `Either<R, L>` into an `Exit<R, L>`.
 *
 * @since 2.0.0
 * @category conversions
 */
const fromEither = exitFromEither;
/**
 * Converts an `Option<A>` into an `Exit<void, A>`.
 *
 * @since 2.0.0
 * @category conversions
 */
const Exit_fromOption = exitFromOption;
/**
 * Returns the `A` if specified exit is a `Success`, otherwise returns the
 * alternate `A` value computed from the specified function which receives the
 * `Cause<E>` of the exit `Failure`.
 *
 * @since 2.0.0
 * @category getters
 */
const Exit_getOrElse = exitGetOrElse;
/**
 * Constructs a new `Exit.Failure` from the specified `FiberId` indicating that
 * the `Fiber` running an `Effect` workflow was terminated due to interruption.
 *
 * @since 2.0.0
 * @category constructors
 */
const Exit_interrupt = exitInterrupt;
/**
 * Maps over the `Success` value of the specified exit using the provided
 * function.
 *
 * @since 2.0.0
 * @category mapping
 */
const Exit_map = exitMap;
/**
 * Maps over the `Success` and `Failure` cases of the specified exit using the
 * provided functions.
 *
 * @since 2.0.0
 * @category mapping
 */
const Exit_mapBoth = exitMapBoth;
/**
 * Maps over the error contained in the `Failure` of the specified exit using
 * the provided function.
 *
 * @since 2.0.0
 * @category mapping
 */
const Exit_mapError = exitMapError;
/**
 * Maps over the `Cause` contained in the `Failure` of the specified exit using
 * the provided function.
 *
 * @since 2.0.0
 * @category mapping
 */
const Exit_mapErrorCause = exitMapErrorCause;
/**
 * @since 2.0.0
 * @category folding
 */
const Exit_match = exitMatch;
/**
 * @since 2.0.0
 * @category folding
 */
const Exit_matchEffect = exitMatchEffect;
/**
 * Constructs a new `Exit.Success` containing the specified value of type `A`.
 *
 * @since 2.0.0
 * @category constructors
 */
const Exit_succeed = exitSucceed;
const Exit_void_ = exitVoid;

/**
 * Sequentially zips the this result with the specified result or else returns
 * the failed `Cause<E | E2>`.
 *
 * @since 2.0.0
 * @category zipping
 */
const Exit_zip = exitZip;
/**
 * Sequentially zips the this result with the specified result discarding the
 * second element of the tuple or else returns the failed `Cause<E | E2>`.
 *
 * @since 2.0.0
 * @category zipping
 */
const Exit_zipLeft = exitZipLeft;
/**
 * Sequentially zips the this result with the specified result discarding the
 * first element of the tuple or else returns the failed `Cause<E | E2>`.
 *
 * @since 2.0.0
 * @category zipping
 */
const Exit_zipRight = exitZipRight;
/**
 * Parallelly zips the this result with the specified result or else returns
 * the failed `Cause<E | E2>`.
 *
 * @since 2.0.0
 * @category zipping
 */
const zipPar = exitZipPar;
/**
 * Parallelly zips the this result with the specified result discarding the
 * second element of the tuple or else returns the failed `Cause<E | E2>`.
 *
 * @since 2.0.0
 * @category zipping
 */
const zipParLeft = exitZipParLeft;
/**
 * Parallelly zips the this result with the specified result discarding the
 * first element of the tuple or else returns the failed `Cause<E | E2>`.
 *
 * @since 2.0.0
 * @category zipping
 */
const zipParRight = exitZipParRight;
/**
 * Zips this exit together with that exit using the specified combination
 * functions.
 *
 * @since 2.0.0
 * @category zipping
 */
const Exit_zipWith = exitZipWith;
//# sourceMappingURL=Exit.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/fiberMessage.js
/** @internal */
const OP_INTERRUPT_SIGNAL = "InterruptSignal";
/** @internal */
const OP_STATEFUL = "Stateful";
/** @internal */
const OP_RESUME = "Resume";
/** @internal */
const OP_YIELD_NOW = "YieldNow";
/** @internal */
const interruptSignal = cause => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause
});
/** @internal */
const stateful = onFiber => ({
  _tag: OP_STATEFUL,
  onFiber
});
/** @internal */
const resume = effect => ({
  _tag: OP_RESUME,
  effect
});
/** @internal */
const fiberMessage_yieldNow = () => ({
  _tag: OP_YIELD_NOW
});
//# sourceMappingURL=fiberMessage.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/fiberScope.js



/** @internal */
const FiberScopeSymbolKey = "effect/FiberScope";
/** @internal */
const FiberScopeTypeId = /*#__PURE__*/Symbol.for(FiberScopeSymbolKey);
/** @internal */
class Global {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = FiberId_none;
  roots = new Set();
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
}
/** @internal */
class Local {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId, parent) {
    this.fiberId = fiberId;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful(parentFiber => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
}
/** @internal */
const fiberScope_unsafeMake = fiber => {
  return new Local(fiber.id(), fiber);
};
/** @internal */
const globalScope = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberScope/Global"), () => new Global());
//# sourceMappingURL=fiberScope.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/fiber.js















/** @internal */
const FiberSymbolKey = "effect/Fiber";
/** @internal */
const FiberTypeId = /*#__PURE__*/Symbol.for(FiberSymbolKey);
/** @internal */
const fiberVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
const fiberProto = {
  [FiberTypeId]: fiberVariance,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const RuntimeFiberSymbolKey = "effect/Fiber";
/** @internal */
const RuntimeFiberTypeId = /*#__PURE__*/Symbol.for(RuntimeFiberSymbolKey);
/** @internal */
const fiber_Order = /*#__PURE__*/Function_pipe( /*#__PURE__*/Order_tuple(Number_Order, Number_Order), /*#__PURE__*/Order_mapInput(fiber => [fiber.id().startTimeMillis, fiber.id().id]));
/** @internal */
const isFiber = u => Predicate_hasProperty(u, FiberTypeId);
/** @internal */
const isRuntimeFiber = self => RuntimeFiberTypeId in self;
/** @internal */
const fiber_await = self => self.await;
/** @internal */
const children = self => self.children;
/** @internal */
const fiber_done = exit => ({
  ...fiberProto,
  id: () => FiberId_none,
  await: succeed(exit),
  children: succeed([]),
  inheritAll: core_void_,
  poll: succeed(Option_some(exit)),
  interruptAsFork: () => core_void_
});
/** @internal */
const dump = self => core_map(self.status, status => ({
  id: self.id(),
  status
}));
/** @internal */
const dumpAll = fibers => forEachSequential(fibers, dump);
/** @internal */
const fiber_fail = error => fiber_done(Exit_fail(error));
/** @internal */
const fiber_failCause = cause => fiber_done(Exit_failCause(cause));
/** @internal */
const fromEffect = effect => core_map(core_exit(effect), fiber_done);
/** @internal */
const id = self => self.id();
/** @internal */
const fiber_inheritAll = self => self.inheritAll;
/** @internal */
const interrupted = fiberId => fiber_done(Exit_interrupt(fiberId));
/** @internal */
const interruptAll = fibers => core_flatMap(fiberId, fiberId => Function_pipe(fibers, interruptAllAs(fiberId)));
/** @internal */
const interruptAllAs = /*#__PURE__*/Function_dual(2, (fibers, fiberId) => Function_pipe(forEachSequentialDiscard(fibers, interruptAsFork(fiberId)), core_zipRight(Function_pipe(fibers, forEachSequentialDiscard(fiber_await)))));
/** @internal */
const interruptAsFork = /*#__PURE__*/Function_dual(2, (self, fiberId) => self.interruptAsFork(fiberId));
/** @internal */
const fiber_join = self => core_zipLeft(core_flatten(self.await), self.inheritAll);
/** @internal */
const fiber_map = /*#__PURE__*/Function_dual(2, (self, f) => fiber_mapEffect(self, a => sync(() => f(a))));
/** @internal */
const fiber_mapEffect = /*#__PURE__*/Function_dual(2, (self, f) => ({
  ...fiberProto,
  id: () => self.id(),
  await: core_flatMap(self.await, forEachEffect(f)),
  children: self.children,
  inheritAll: self.inheritAll,
  poll: core_flatMap(self.poll, result => {
    switch (result._tag) {
      case "None":
        return succeed(Option_none());
      case "Some":
        return Function_pipe(forEachEffect(result.value, f), core_map(Option_some));
    }
  }),
  interruptAsFork: id => self.interruptAsFork(id)
}));
/** @internal */
const mapFiber = /*#__PURE__*/Function_dual(2, (self, f) => core_map(self.await, Exit_match({
  onFailure: cause => fiber_failCause(cause),
  onSuccess: a => f(a)
})));
/** @internal */
const fiber_match = /*#__PURE__*/Function_dual(2, (self, {
  onFiber,
  onRuntimeFiber
}) => {
  if (isRuntimeFiber(self)) {
    return onRuntimeFiber(self);
  }
  return onFiber(self);
});
/** @internal */
const fiber_never = {
  ...fiberProto,
  id: () => FiberId_none,
  await: never,
  children: /*#__PURE__*/succeed([]),
  inheritAll: never,
  poll: /*#__PURE__*/succeed( /*#__PURE__*/Option_none()),
  interruptAsFork: () => never
};
/** @internal */
const fiber_orElse = /*#__PURE__*/Function_dual(2, (self, that) => ({
  ...fiberProto,
  id: () => FiberId_getOrElse(self.id(), that.id()),
  await: core_zipWith(self.await, that.await, (exit1, exit2) => Exit_isSuccess(exit1) ? exit1 : exit2),
  children: self.children,
  inheritAll: core_zipRight(that.inheritAll, self.inheritAll),
  poll: core_zipWith(self.poll, that.poll, (option1, option2) => {
    switch (option1._tag) {
      case "None":
        {
          return Option_none();
        }
      case "Some":
        {
          return Exit_isSuccess(option1.value) ? option1 : option2;
        }
    }
  }),
  interruptAsFork: id => Function_pipe(interruptAsFiber(self, id), core_zipRight(Function_pipe(that, interruptAsFiber(id))), core_asVoid)
}));
/** @internal */
const fiber_orElseEither = /*#__PURE__*/Function_dual(2, (self, that) => fiber_orElse(fiber_map(self, Either_left), fiber_map(that, Either_right)));
/** @internal */
const fiber_poll = self => self.poll;
// forked from https://github.com/sindresorhus/parse-ms/blob/4da2ffbdba02c6e288c08236695bdece0adca173/index.js
// MIT License
// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
/** @internal */
const parseMs = milliseconds => {
  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
  return {
    days: roundTowardsZero(milliseconds / 86400000),
    hours: roundTowardsZero(milliseconds / 3600000) % 24,
    minutes: roundTowardsZero(milliseconds / 60000) % 60,
    seconds: roundTowardsZero(milliseconds / 1000) % 60,
    milliseconds: roundTowardsZero(milliseconds) % 1000,
    microseconds: roundTowardsZero(milliseconds * 1000) % 1000,
    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1000
  };
};
/** @internal */
const renderStatus = status => {
  if (FiberStatus_isDone(status)) {
    return "Done";
  }
  if (FiberStatus_isRunning(status)) {
    return "Running";
  }
  const isInterruptible = interruptible(status.runtimeFlags) ? "interruptible" : "uninterruptible";
  return `Suspended(${isInterruptible})`;
};
/** @internal */
const fiber_pretty = self => core_flatMap(Clock_currentTimeMillis, now => core_map(dump(self), dump => {
  const time = now - dump.id.startTimeMillis;
  const {
    days,
    hours,
    milliseconds,
    minutes,
    seconds
  } = parseMs(time);
  const lifeMsg = (days === 0 ? "" : `${days}d`) + (days === 0 && hours === 0 ? "" : `${hours}h`) + (days === 0 && hours === 0 && minutes === 0 ? "" : `${minutes}m`) + (days === 0 && hours === 0 && minutes === 0 && seconds === 0 ? "" : `${seconds}s`) + `${milliseconds}ms`;
  const waitMsg = FiberStatus_isSuspended(dump.status) ? (() => {
    const ids = FiberId_ids(dump.status.blockingOn);
    return HashSet_size(ids) > 0 ? `waiting on ` + Array.from(ids).map(id => `${id}`).join(", ") : "";
  })() : "";
  const statusMsg = renderStatus(dump.status);
  return `[Fiber](#${dump.id.id}) (${lifeMsg}) ${waitMsg}\n   Status: ${statusMsg}`;
}));
/** @internal */
const unsafeRoots = () => Array.from(globalScope.roots);
/** @internal */
const roots = /*#__PURE__*/sync(unsafeRoots);
/** @internal */
const fiber_status = self => self.status;
/** @internal */
const fiber_succeed = value => fiber_done(Exit_succeed(value));
const fiber_void_ = /*#__PURE__*/fiber_succeed(void 0);

/** @internal */
const currentFiberURI = "effect/FiberCurrent";
/** @internal */
const getCurrentFiber = () => fromNullable(globalThis[currentFiberURI]);
//# sourceMappingURL=fiber.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/logger.js









/** @internal */
const LoggerSymbolKey = "effect/Logger";
/** @internal */
const LoggerTypeId = /*#__PURE__*/Symbol.for(LoggerSymbolKey);
const loggerVariance = {
  /* c8 ignore next */
  _Message: _ => _,
  /* c8 ignore next */
  _Output: _ => _
};
/** @internal */
const makeLogger = log => ({
  [LoggerTypeId]: loggerVariance,
  log,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
});
/** @internal */
const logger_mapInput = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => makeLogger(options => self.log({
  ...options,
  message: f(options.message)
})))));
/** @internal */
const mapInputOptions = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => makeLogger(options => self.log(f(options))))));
/** @internal */
const filterLogLevel = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => makeLogger(options => f(options.logLevel) ? Option.some(self.log(options)) : Option.none()))));
/** @internal */
const logger_map = /*#__PURE__*/Function_dual(2, (self, f) => makeLogger(options => f(self.log(options))));
/** @internal */
const logger_none = {
  [LoggerTypeId]: loggerVariance,
  log: Function_constVoid,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const simple = log => ({
  [LoggerTypeId]: loggerVariance,
  log: ({
    message
  }) => log(message),
  pipe() {
    return pipeArguments(this, arguments);
  }
});
/** @internal */
const logger_succeed = value => {
  return simple(() => value);
};
/** @internal */
const logger_sync = evaluate => {
  return simple(evaluate);
};
/** @internal */
const logger_zip = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => makeLogger(options => [self.log(options), that.log(options)]))));
/** @internal */
const logger_zipLeft = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => logger_map(logger_zip(self, that), tuple => tuple[0]))));
/** @internal */
const logger_zipRight = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => logger_map(logger_zip(self, that), tuple => tuple[1]))));
/** @internal */
const stringLogger = /*#__PURE__*/makeLogger(({
  annotations,
  cause,
  date,
  fiberId,
  logLevel,
  message,
  spans
}) => {
  const nowMillis = date.getTime();
  const outputArray = [`timestamp=${date.toISOString()}`, `level=${logLevel.label}`, `fiber=${threadName(fiberId)}`];
  let output = outputArray.join(" ");
  if (Array.isArray(message)) {
    for (let i = 0; i < message.length; i++) {
      const stringMessage = toStringUnknown(message[i]);
      if (stringMessage.length > 0) {
        output = output + " message=";
        output = appendQuoted(stringMessage, output);
      }
    }
  } else {
    const stringMessage = toStringUnknown(message);
    if (stringMessage.length > 0) {
      output = output + " message=";
      output = appendQuoted(stringMessage, output);
    }
  }
  if (cause != null && cause._tag !== "Empty") {
    output = output + " cause=";
    output = appendQuoted(pretty(cause), output);
  }
  if (isCons(spans)) {
    output = output + " ";
    let first = true;
    for (const span of spans) {
      if (first) {
        first = false;
      } else {
        output = output + " ";
      }
      output = output + Function_pipe(span, LogSpan_render(nowMillis));
    }
  }
  if (Function_pipe(annotations, HashMap_size) > 0) {
    output = output + " ";
    let first = true;
    for (const [key, value] of annotations) {
      if (first) {
        first = false;
      } else {
        output = output + " ";
      }
      output = output + filterKeyName(key);
      output = output + "=";
      output = appendQuoted(toStringUnknown(value), output);
    }
  }
  return output;
});
/** @internal */
const escapeDoubleQuotes = str => `"${str.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
const textOnly = /^[^\s"=]+$/;
/** @internal */
const appendQuoted = (label, output) => output + (label.match(textOnly) ? label : escapeDoubleQuotes(label));
/** @internal */
const logfmtLogger = /*#__PURE__*/(/* unused pure expression or super */ null && (makeLogger(({
  annotations,
  cause,
  date,
  fiberId,
  logLevel,
  message,
  spans
}) => {
  const nowMillis = date.getTime();
  const outputArray = [`timestamp=${date.toISOString()}`, `level=${logLevel.label}`, `fiber=${_fiberId.threadName(fiberId)}`];
  let output = outputArray.join(" ");
  if (Array.isArray(message)) {
    for (let i = 0; i < message.length; i++) {
      const stringMessage = Inspectable.toStringUnknown(message[i], 0);
      if (stringMessage.length > 0) {
        output = output + " message=";
        output = appendQuotedLogfmt(stringMessage, output);
      }
    }
  } else {
    const stringMessage = Inspectable.toStringUnknown(message, 0);
    if (stringMessage.length > 0) {
      output = output + " message=";
      output = appendQuotedLogfmt(stringMessage, output);
    }
  }
  if (cause != null && cause._tag !== "Empty") {
    output = output + " cause=";
    output = appendQuotedLogfmt(Cause.pretty(cause), output);
  }
  if (List.isCons(spans)) {
    output = output + " ";
    let first = true;
    for (const span of spans) {
      if (first) {
        first = false;
      } else {
        output = output + " ";
      }
      output = output + pipe(span, renderLogSpanLogfmt(nowMillis));
    }
  }
  if (pipe(annotations, HashMap.size) > 0) {
    output = output + " ";
    let first = true;
    for (const [key, value] of annotations) {
      if (first) {
        first = false;
      } else {
        output = output + " ";
      }
      output = output + filterKeyName(key);
      output = output + "=";
      output = appendQuotedLogfmt(Inspectable.toStringUnknown(value, 0), output);
    }
  }
  return output;
})));
/** @internal */
const structuredLogger = /*#__PURE__*/makeLogger(({
  annotations,
  cause,
  date,
  fiberId,
  logLevel,
  message,
  spans
}) => {
  const now = date.getTime();
  const annotationsObj = {};
  const spansObj = {};
  if (HashMap_size(annotations) > 0) {
    for (const [k, v] of annotations) {
      annotationsObj[k] = structuredMessage(v);
    }
  }
  if (isCons(spans)) {
    for (const span of spans) {
      spansObj[span.label] = now - span.startTime;
    }
  }
  return {
    message: structuredMessage(message),
    logLevel: logLevel.label,
    timestamp: date.toISOString(),
    cause: cause_isEmpty(cause) ? undefined : pretty(cause),
    annotations: annotationsObj,
    spans: spansObj,
    fiberId: threadName(fiberId)
  };
});
const structuredMessage = u => {
  switch (typeof u) {
    case "bigint":
    case "function":
    case "symbol":
      {
        return String(u);
      }
    default:
      {
        return u;
      }
  }
};
/** @internal */
const jsonLogger = /*#__PURE__*/logger_map(structuredLogger, stringifyCircular);
/** @internal */
const filterKeyName = key => key.replace(/[\s="]/g, "_");
/** @internal */
const escapeDoubleQuotesLogfmt = str => JSON.stringify(str);
/** @internal */
const appendQuotedLogfmt = (label, output) => output + (label.match(textOnly) ? label : escapeDoubleQuotesLogfmt(label));
/** @internal */
const renderLogSpanLogfmt = now => self => {
  const label = filterKeyName(self.label);
  return `${label}=${now - self.startTime}ms`;
};
/** @internal */
const isLogger = u => {
  return typeof u === "object" && u != null && LoggerTypeId in u;
};
//# sourceMappingURL=logger.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/metric/keyType.js






/** @internal */
const MetricKeyTypeSymbolKey = "effect/MetricKeyType";
/** @internal */
const MetricKeyTypeTypeId = /*#__PURE__*/Symbol.for(MetricKeyTypeSymbolKey);
/** @internal */
const CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
/** @internal */
const CounterKeyTypeTypeId = /*#__PURE__*/Symbol.for(CounterKeyTypeSymbolKey);
/** @internal */
const FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
/** @internal */
const FrequencyKeyTypeTypeId = /*#__PURE__*/Symbol.for(FrequencyKeyTypeSymbolKey);
/** @internal */
const GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
/** @internal */
const GaugeKeyTypeTypeId = /*#__PURE__*/Symbol.for(GaugeKeyTypeSymbolKey);
/** @internal */
const HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
/** @internal */
const HistogramKeyTypeTypeId = /*#__PURE__*/Symbol.for(HistogramKeyTypeSymbolKey);
/** @internal */
const SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
/** @internal */
const SummaryKeyTypeTypeId = /*#__PURE__*/Symbol.for(SummaryKeyTypeSymbolKey);
const metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _Out: _ => _
};
/** @internal */
class CounterKeyType {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint) {
    this.incremental = incremental;
    this.bigint = bigint;
    this._hash = string(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [Equal_symbol](that) {
    return isCounterKey(that);
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
const FrequencyKeyTypeHash = /*#__PURE__*/string(FrequencyKeyTypeSymbolKey);
/** @internal */
class FrequencyKeyType {
  preregisteredWords;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;
  constructor(preregisteredWords) {
    this.preregisteredWords = preregisteredWords;
  }
  [symbol]() {
    return FrequencyKeyTypeHash;
  }
  [Equal_symbol](that) {
    return isFrequencyKey(that);
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
const GaugeKeyTypeHash = /*#__PURE__*/string(GaugeKeyTypeSymbolKey);
/** @internal */
class GaugeKeyType {
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
  constructor(bigint) {
    this.bigint = bigint;
  }
  [symbol]() {
    return GaugeKeyTypeHash;
  }
  [Equal_symbol](that) {
    return isGaugeKey(that);
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/**
 * @category model
 * @since 2.0.0
 */
class HistogramKeyType {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = Function_pipe(string(HistogramKeyTypeSymbolKey), combine(Hash_hash(this.boundaries)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [Equal_symbol](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
class SummaryKeyType {
  maxAge;
  maxSize;
  error;
  quantiles;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;
  constructor(maxAge, maxSize, error, quantiles) {
    this.maxAge = maxAge;
    this.maxSize = maxSize;
    this.error = error;
    this.quantiles = quantiles;
    this._hash = Function_pipe(string(SummaryKeyTypeSymbolKey), combine(Hash_hash(this.maxAge)), combine(Hash_hash(this.maxSize)), combine(Hash_hash(this.error)), combine(array(this.quantiles)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [Equal_symbol](that) {
    return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/**
 * @since 2.0.0
 * @category constructors
 */
const counter = options => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
/**
 * @since 2.0.0
 * @category constructors
 */
const frequency = options => new FrequencyKeyType(options?.preregisteredWords ?? []);
/**
 * @since 2.0.0
 * @category constructors
 */
const gauge = options => new GaugeKeyType(options?.bigint ?? false);
/**
 * @since 2.0.0
 * @category constructors
 */
const histogram = boundaries => {
  return new HistogramKeyType(boundaries);
};
/**
 * @since 2.0.0
 * @category constructors
 */
const summary = options => {
  return new SummaryKeyType(Duration.decode(options.maxAge), options.maxSize, options.error, options.quantiles);
};
/**
 * @since 2.0.0
 * @category refinements
 */
const isMetricKeyType = u => hasProperty(u, MetricKeyTypeTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isCounterKey = u => Predicate_hasProperty(u, CounterKeyTypeTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isFrequencyKey = u => Predicate_hasProperty(u, FrequencyKeyTypeTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isGaugeKey = u => Predicate_hasProperty(u, GaugeKeyTypeTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isHistogramKey = u => Predicate_hasProperty(u, HistogramKeyTypeTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isSummaryKey = u => Predicate_hasProperty(u, SummaryKeyTypeTypeId);
//# sourceMappingURL=keyType.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/metric/key.js









/** @internal */
const MetricKeySymbolKey = "effect/MetricKey";
/** @internal */
const MetricKeyTypeId = /*#__PURE__*/Symbol.for(MetricKeySymbolKey);
const metricKeyVariance = {
  /* c8 ignore next */
  _Type: _ => _
};
const arrayEquivilence = /*#__PURE__*/Array_getEquivalence(equals);
/** @internal */
class MetricKeyImpl {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags;
    this._hash = Function_pipe(string(this.name + this.description), combine(Hash_hash(this.keyType)), combine(array(this.tags)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [Equal_symbol](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
const isMetricKey = u => Predicate_hasProperty(u, MetricKeyTypeId);
/** @internal */
const key_counter = (name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options?.description));
/** @internal */
const key_frequency = (name, options) => new MetricKeyImpl(name, metricKeyType.frequency(options), Option.fromNullable(options?.description));
/** @internal */
const key_gauge = (name, options) => new MetricKeyImpl(name, metricKeyType.gauge(options), Option.fromNullable(options?.description));
/** @internal */
const key_histogram = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description));
/** @internal */
const key_summary = options => new MetricKeyImpl(options.name, metricKeyType.summary(options), Option.fromNullable(options.description));
/** @internal */
const tagged = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, key, value) => taggedWithLabels(self, [metricLabel.make(key, value)]))));
/** @internal */
const taggedWithLabels = /*#__PURE__*/Function_dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, Array_union(self.tags, extraTags)));
//# sourceMappingURL=key.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/MutableHashMap.js






const MutableHashMap_TypeId = /*#__PURE__*/Symbol.for("effect/MutableHashMap");
const MutableHashMapProto = {
  [MutableHashMap_TypeId]: MutableHashMap_TypeId,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
class MutableHashMapIterator {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self) {
    this.self = self;
    this.referentialIterator = self.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== undefined) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this.self);
  }
}
class BucketIterator {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === undefined) {
      const result = this.backing.next();
      if (result.done) {
        return result;
      }
      this.currentBucket = result.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = undefined;
      return this.next();
    }
    return result;
  }
}
/**
 * @since 2.0.0
 * @category constructors
 */
const MutableHashMap_empty = () => {
  const self = Object.create(MutableHashMapProto);
  self.referential = new Map();
  self.buckets = new Map();
  self.bucketsSize = 0;
  return self;
};
/**
 * @since 2.0.0
 * @category constructors
 */
const MutableHashMap_make = (...entries) => MutableHashMap_fromIterable(entries);
/**
 * Creates a new `MutableHashMap` from an iterable collection of key/value pairs.
 *
 * @since 2.0.0
 * @category constructors
 */
const MutableHashMap_fromIterable = entries => {
  const self = MutableHashMap_empty();
  for (const [key, value] of entries) {
    MutableHashMap_set(self, key, value);
  }
  return self;
};
/**
 * @since 2.0.0
 * @category elements
 */
const MutableHashMap_get = /*#__PURE__*/Function_dual(2, (self, key) => {
  if (isEqual(key) === false) {
    return self.referential.has(key) ? Option_some(self.referential.get(key)) : Option_none();
  }
  const hash = key[symbol]();
  const bucket = self.buckets.get(hash);
  if (bucket === undefined) {
    return Option_none();
  }
  return getFromBucket(self, bucket, key);
});
const getFromBucket = (self, bucket, key, remove = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[Equal_symbol](bucket[i][0])) {
      const value = bucket[i][1];
      if (remove) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return Option_some(value);
    }
  }
  return Option_none();
};
/**
 * @since 2.0.0
 * @category elements
 */
const MutableHashMap_has = /*#__PURE__*/Function_dual(2, (self, key) => Option_isSome(MutableHashMap_get(self, key)));
/**
 * @since 2.0.0
 */
const MutableHashMap_set = /*#__PURE__*/Function_dual(3, (self, key, value) => {
  if (isEqual(key) === false) {
    self.referential.set(key, value);
    return self;
  }
  const hash = key[symbol]();
  const bucket = self.buckets.get(hash);
  if (bucket === undefined) {
    self.buckets.set(hash, [[key, value]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket(self, bucket, key);
  bucket.push([key, value]);
  self.bucketsSize++;
  return self;
});
const removeFromBucket = (self, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[Equal_symbol](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
};
/**
 * Updates the value of the specified key within the `MutableHashMap` if it exists.
 *
 * @since 2.0.0
 */
const MutableHashMap_modify = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, key, f) => {
  if (Equal.isEqual(key) === false) {
    if (self.referential.has(key)) {
      self.referential.set(key, f(self.referential.get(key)));
    }
    return self;
  }
  const hash = key[Hash.symbol]();
  const bucket = self.buckets.get(hash);
  if (bucket === undefined) {
    return self;
  }
  const value = getFromBucket(self, bucket, key, true);
  if (Option.isNone(value)) {
    return self;
  }
  bucket.push([key, f(value.value)]);
  self.bucketsSize++;
  return self;
})));
/**
 * Set or remove the specified key in the `MutableHashMap` using the specified
 * update function.
 *
 * @since 2.0.0
 */
const MutableHashMap_modifyAt = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, key, f) => {
  if (Equal.isEqual(key) === false) {
    const result = f(MutableHashMap_get(self, key));
    if (Option.isSome(result)) {
      MutableHashMap_set(self, key, result.value);
    } else {
      MutableHashMap_remove(self, key);
    }
    return self;
  }
  const hash = key[Hash.symbol]();
  const bucket = self.buckets.get(hash);
  if (bucket === undefined) {
    const result = f(Option.none());
    return Option.isSome(result) ? MutableHashMap_set(self, key, result.value) : self;
  }
  const result = f(getFromBucket(self, bucket, key, true));
  if (Option.isNone(result)) {
    if (bucket.length === 0) {
      self.buckets.delete(hash);
    }
    return self;
  }
  bucket.push([key, result.value]);
  self.bucketsSize++;
  return self;
})));
/**
 * @since 2.0.0
 */
const MutableHashMap_remove = /*#__PURE__*/Function_dual(2, (self, key) => {
  if (isEqual(key) === false) {
    self.referential.delete(key);
    return self;
  }
  const hash = key[symbol]();
  const bucket = self.buckets.get(hash);
  if (bucket === undefined) {
    return self;
  }
  removeFromBucket(self, bucket, key);
  if (bucket.length === 0) {
    self.buckets.delete(hash);
  }
  return self;
});
/**
 * @since 2.0.0
 */
const clear = self => {
  self.referential.clear();
  self.buckets.clear();
  self.bucketsSize = 0;
  return self;
};
/**
 * @since 2.0.0
 * @category elements
 */
const MutableHashMap_size = self => {
  return self.referential.size + self.bucketsSize;
};
//# sourceMappingURL=MutableHashMap.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/metric/state.js






/** @internal */
const MetricStateSymbolKey = "effect/MetricState";
/** @internal */
const MetricStateTypeId = /*#__PURE__*/Symbol.for(MetricStateSymbolKey);
/** @internal */
const CounterStateSymbolKey = "effect/MetricState/Counter";
/** @internal */
const CounterStateTypeId = /*#__PURE__*/Symbol.for(CounterStateSymbolKey);
/** @internal */
const FrequencyStateSymbolKey = "effect/MetricState/Frequency";
/** @internal */
const FrequencyStateTypeId = /*#__PURE__*/Symbol.for(FrequencyStateSymbolKey);
/** @internal */
const GaugeStateSymbolKey = "effect/MetricState/Gauge";
/** @internal */
const GaugeStateTypeId = /*#__PURE__*/Symbol.for(GaugeStateSymbolKey);
/** @internal */
const HistogramStateSymbolKey = "effect/MetricState/Histogram";
/** @internal */
const HistogramStateTypeId = /*#__PURE__*/Symbol.for(HistogramStateSymbolKey);
/** @internal */
const SummaryStateSymbolKey = "effect/MetricState/Summary";
/** @internal */
const SummaryStateTypeId = /*#__PURE__*/Symbol.for(SummaryStateSymbolKey);
const metricStateVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
class CounterState {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count) {
    this.count = count;
  }
  [symbol]() {
    return Function_pipe(Hash_hash(CounterStateSymbolKey), combine(Hash_hash(this.count)), cached(this));
  }
  [Equal_symbol](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
const arrayEquals = /*#__PURE__*/Array_getEquivalence(equals);
/** @internal */
class FrequencyState {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol]() {
    return Function_pipe(string(FrequencyStateSymbolKey), combine(array(Array_fromIterable(this.occurrences.entries()))), cached(this));
  }
  [Equal_symbol](that) {
    return isFrequencyState(that) && arrayEquals(Array_fromIterable(this.occurrences.entries()), Array_fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
class GaugeState {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value) {
    this.value = value;
  }
  [symbol]() {
    return Function_pipe(Hash_hash(GaugeStateSymbolKey), combine(Hash_hash(this.value)), cached(this));
  }
  [Equal_symbol](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
class HistogramState {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count, min, max, sum) {
    this.buckets = buckets;
    this.count = count;
    this.min = min;
    this.max = max;
    this.sum = sum;
  }
  [symbol]() {
    return Function_pipe(Hash_hash(HistogramStateSymbolKey), combine(Hash_hash(this.buckets)), combine(Hash_hash(this.count)), combine(Hash_hash(this.min)), combine(Hash_hash(this.max)), combine(Hash_hash(this.sum)), cached(this));
  }
  [Equal_symbol](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
class SummaryState {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error, quantiles, count, min, max, sum) {
    this.error = error;
    this.quantiles = quantiles;
    this.count = count;
    this.min = min;
    this.max = max;
    this.sum = sum;
  }
  [symbol]() {
    return Function_pipe(Hash_hash(SummaryStateSymbolKey), combine(Hash_hash(this.error)), combine(Hash_hash(this.quantiles)), combine(Hash_hash(this.count)), combine(Hash_hash(this.min)), combine(Hash_hash(this.max)), combine(Hash_hash(this.sum)), cached(this));
  }
  [Equal_symbol](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
const state_counter = count => new CounterState(count);
/** @internal */
const state_frequency = occurrences => {
  return new FrequencyState(occurrences);
};
/** @internal */
const state_gauge = count => new GaugeState(count);
/** @internal */
const state_histogram = options => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
/** @internal */
const state_summary = options => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
/** @internal */
const isMetricState = u => hasProperty(u, MetricStateTypeId);
/** @internal */
const isCounterState = u => Predicate_hasProperty(u, CounterStateTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isFrequencyState = u => Predicate_hasProperty(u, FrequencyStateTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isGaugeState = u => Predicate_hasProperty(u, GaugeStateTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isHistogramState = u => Predicate_hasProperty(u, HistogramStateTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isSummaryState = u => Predicate_hasProperty(u, SummaryStateTypeId);
//# sourceMappingURL=state.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/metric/hook.js







/** @internal */
const MetricHookSymbolKey = "effect/MetricHook";
/** @internal */
const MetricHookTypeId = /*#__PURE__*/Symbol.for(MetricHookSymbolKey);
const metricHookVariance = {
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _Out: _ => _
};
/** @internal */
const hook_make = options => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  },
  ...options
});
/** @internal */
const onUpdate = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  get: self.get,
  update: input => {
    self.update(input);
    return f(input);
  }
}))));
const hook_bigint0 = /*#__PURE__*/BigInt(0);
/** @internal */
const hook_counter = key => {
  let sum = key.keyType.bigint ? hook_bigint0 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? value => value >= hook_bigint0 : value => value >= 0 : _value => true;
  return hook_make({
    get: () => state_counter(sum),
    update: value => {
      if (canUpdate(value)) {
        sum = sum + value;
      }
    }
  });
};
/** @internal */
const hook_frequency = key => {
  const values = new Map();
  for (const word of key.keyType.preregisteredWords) {
    values.set(word, 0);
  }
  const update = word => {
    const slotCount = values.get(word) ?? 0;
    values.set(word, slotCount + 1);
  };
  return hook_make({
    get: () => state_frequency(values),
    update
  });
};
/** @internal */
const hook_gauge = (_key, startAt) => {
  let value = startAt;
  return hook_make({
    get: () => state_gauge(value),
    update: v => {
      value = v;
    }
  });
};
/** @internal */
const hook_histogram = key => {
  const bounds = key.keyType.boundaries.values;
  const size = bounds.length;
  const values = new Uint32Array(size + 1);
  const boundaries = new Float32Array(size);
  let count = 0;
  let sum = 0;
  let min = Number.MAX_VALUE;
  let max = Number.MIN_VALUE;
  Function_pipe(bounds, sort(Number_Order), Array_map((n, i) => {
    boundaries[i] = n;
  }));
  // Insert the value into the right bucket with a binary search
  const update = value => {
    let from = 0;
    let to = size;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      // The special case when to / from have a distance of one
      if (to === from + 1) {
        if (value <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values[from] = values[from] + 1;
    count = count + 1;
    sum = sum + value;
    if (value < min) {
      min = value;
    }
    if (value > max) {
      max = value;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size);
    let cumulated = 0;
    for (let i = 0; i < size; i++) {
      const boundary = boundaries[i];
      const value = values[i];
      cumulated = cumulated + value;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return hook_make({
    get: () => state_histogram({
      buckets: getBuckets(),
      count,
      min,
      max,
      sum
    }),
    update
  });
};
/** @internal */
const hook_summary = key => {
  const {
    error,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = Function_pipe(quantiles, sort(Number_Order));
  const values = allocate(maxSize);
  let head = 0;
  let count = 0;
  let sum = 0;
  let min = Number.MAX_VALUE;
  let max = Number.MIN_VALUE;
  // Just before the snapshot we filter out all values older than maxAge
  const snapshot = now => {
    const builder = [];
    // If the buffer is not full yet it contains valid items at the 0..last
    // indices and null values at the rest of the positions.
    //
    // If the buffer is already full then all elements contains a valid
    // measurement with timestamp.
    //
    // At any given point in time we can enumerate all the non-null elements in
    // the buffer and filter them by timestamp to get a valid view of a time
    // window.
    //
    // The order does not matter because it gets sorted before passing to
    // `calculateQuantiles`.
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values[i];
      if (item != null) {
        const [t, v] = item;
        const age = Duration_millis(now - t);
        if (Duration_greaterThanOrEqualTo(age, zero) && age <= maxAge) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error, sortedQuantiles, sort(builder, Number_Order));
  };
  const observe = (value, timestamp) => {
    if (maxSize > 0) {
      head = head + 1;
      const target = head % maxSize;
      values[target] = [timestamp, value];
    }
    count = count + 1;
    sum = sum + value;
    if (value < min) {
      min = value;
    }
    if (value > max) {
      max = value;
    }
  };
  return hook_make({
    get: () => state_summary({
      error,
      quantiles: snapshot(Date.now()),
      count,
      min,
      max,
      sum
    }),
    update: ([value, timestamp]) => observe(value, timestamp)
  });
};
/** @internal */
const calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
  // The number of samples examined
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return Array_empty();
  }
  const head = sortedQuantiles[0];
  const tail = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error, sampleCount, Option_none(), 0, head, sortedSamples);
  const resolved = Array_of(resolvedHead);
  tail.forEach(quantile => {
    resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return Array_map(resolved, rq => [rq.quantile, rq.value]);
};
/** @internal */
const resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
  let error_1 = error;
  let sampleCount_1 = sampleCount;
  let current_1 = current;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error;
  let sampleCount_2 = sampleCount;
  let current_2 = current;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  // eslint-disable-next-line no-constant-condition
  while (1) {
    // If the remaining list of samples is empty, there is nothing more to resolve
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: Option_none(),
        consumed: consumed_1,
        rest: []
      };
    }
    // If the quantile is the 100% quantile, we can take the maximum of all the
    // remaining values as the result
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: Option_some(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    // Split into two chunks - the first chunk contains all elements of the same
    // value as the chunk head
    const sameHead = span(rest_1, n => n <= rest_1[0]);
    // How many elements do we want to accept for this quantile
    const desired = quantile_1 * sampleCount_1;
    // The error margin
    const allowedError = error_1 / 2 * desired;
    // Taking into account the elements consumed from the samples so far and the
    // number of same elements at the beginning of the chunk, calculate the number
    // of elements we would have if we selected the current head as result
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    // If we haven't got enough elements yet, recurse
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = Array_head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    // If we have too many elements, select the previous value and hand back the
    // the rest as leftover
    if (candConsumed > desired + allowedError) {
      return {
        quantile: quantile_1,
        value: current_1,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    // If we are in the target interval, select the current head and hand back the leftover after dropping all elements
    // from the sample chunk that are equal to the current head
    switch (current_1._tag) {
      case "None":
        {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = Array_head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
      case "Some":
        {
          const prevError = Math.abs(desired - current_1.value);
          if (candError < prevError) {
            error_2 = error_1;
            sampleCount_2 = sampleCount_1;
            current_2 = Array_head(rest_1);
            consumed_2 = candConsumed;
            quantile_2 = quantile_1;
            rest_2 = sameHead[1];
            error_1 = error_2;
            sampleCount_1 = sampleCount_2;
            current_1 = current_2;
            consumed_1 = consumed_2;
            quantile_1 = quantile_2;
            rest_1 = rest_2;
            continue;
          }
          return {
            quantile: quantile_1,
            value: Option_some(current_1.value),
            consumed: consumed_1,
            rest: rest_1
          };
        }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/metric/pair.js

/** @internal */
const MetricPairSymbolKey = "effect/MetricPair";
/** @internal */
const MetricPairTypeId = /*#__PURE__*/Symbol.for(MetricPairSymbolKey);
const metricPairVariance = {
  /* c8 ignore next */
  _Type: _ => _
};
/** @internal */
const pair_make = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};
/** @internal */
const pair_unsafeMake = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return Pipeable_pipeArguments(this, arguments);
    }
  };
};
//# sourceMappingURL=pair.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/metric/registry.js






/** @internal */
const MetricRegistrySymbolKey = "effect/MetricRegistry";
/** @internal */
const MetricRegistryTypeId = /*#__PURE__*/Symbol.for(MetricRegistrySymbolKey);
/** @internal */
class MetricRegistryImpl {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = MutableHashMap_empty();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(pair_unsafeMake(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = Function_pipe(this.map, MutableHashMap_get(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value = Function_pipe(this.map, MutableHashMap_get(key), getOrUndefined);
    if (value == null) {
      const counter = hook_counter(key);
      if (!Function_pipe(this.map, MutableHashMap_has(key))) {
        Function_pipe(this.map, MutableHashMap_set(key, counter));
      }
      value = counter;
    }
    return value;
  }
  getFrequency(key) {
    let value = Function_pipe(this.map, MutableHashMap_get(key), getOrUndefined);
    if (value == null) {
      const frequency = hook_frequency(key);
      if (!Function_pipe(this.map, MutableHashMap_has(key))) {
        Function_pipe(this.map, MutableHashMap_set(key, frequency));
      }
      value = frequency;
    }
    return value;
  }
  getGauge(key) {
    let value = Function_pipe(this.map, MutableHashMap_get(key), getOrUndefined);
    if (value == null) {
      const gauge = hook_gauge(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!Function_pipe(this.map, MutableHashMap_has(key))) {
        Function_pipe(this.map, MutableHashMap_set(key, gauge));
      }
      value = gauge;
    }
    return value;
  }
  getHistogram(key) {
    let value = Function_pipe(this.map, MutableHashMap_get(key), getOrUndefined);
    if (value == null) {
      const histogram = hook_histogram(key);
      if (!Function_pipe(this.map, MutableHashMap_has(key))) {
        Function_pipe(this.map, MutableHashMap_set(key, histogram));
      }
      value = histogram;
    }
    return value;
  }
  getSummary(key) {
    let value = Function_pipe(this.map, MutableHashMap_get(key), getOrUndefined);
    if (value == null) {
      const summary = hook_summary(key);
      if (!Function_pipe(this.map, MutableHashMap_has(key))) {
        Function_pipe(this.map, MutableHashMap_set(key, summary));
      }
      value = summary;
    }
    return value;
  }
}
/** @internal */
const registry_make = () => {
  return new MetricRegistryImpl();
};
//# sourceMappingURL=registry.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/metric.js













/** @internal */
const MetricSymbolKey = "effect/Metric";
/** @internal */
const MetricTypeId = /*#__PURE__*/Symbol.for(MetricSymbolKey);
const metricVariance = {
  /* c8 ignore next */
  _Type: _ => _,
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _Out: _ => _
};
/** @internal */
const globalMetricRegistry = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/Metric/globalMetricRegistry"), () => registry_make());
/** @internal */
const metric_make = function (keyType, unsafeUpdate, unsafeValue) {
  const metric = Object.assign(effect => core_tap(effect, a => metric_update(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return Pipeable_pipeArguments(this, arguments);
    }
  });
  return metric;
};
/** @internal */
const metric_mapInput = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => metric_make(self.keyType, (input, extraTags) => self.unsafeUpdate(f(input), extraTags), self.unsafeValue))));
/** @internal */
const metric_counter = (name, options) => fromMetricKey(key_counter(name, options));
/** @internal */
const metric_frequency = (name, options) => fromMetricKey(metricKey.frequency(name, options));
/** @internal */
const withConstantInput = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, input) => metric_mapInput(self, () => input))));
/** @internal */
const fromMetricKey = key => {
  let untaggedHook;
  const hookCache = new WeakMap();
  const hook = extraTags => {
    if (extraTags.length === 0) {
      if (untaggedHook !== undefined) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook = hookCache.get(extraTags);
    if (hook !== undefined) {
      return hook;
    }
    hook = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook);
    return hook;
  };
  return metric_make(key.keyType, (input, extraTags) => hook(extraTags).update(input), extraTags => hook(extraTags).get());
};
/** @internal */
const metric_gauge = (name, options) => fromMetricKey(metricKey.gauge(name, options));
/** @internal */
const metric_histogram = (name, boundaries, description) => fromMetricKey(key_histogram(name, boundaries, description));
/* @internal */
const metric_increment = self => metric_update(self, self.keyType.bigint ? BigInt(1) : 1);
/* @internal */
const incrementBy = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, amount) => metric_update(self, amount))));
/** @internal */
const metric_map = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => metric_make(self.keyType, self.unsafeUpdate, extraTags => f(self.unsafeValue(extraTags))))));
/** @internal */
const mapType = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => metric_make(f(self.keyType), self.unsafeUpdate, self.unsafeValue))));
/* @internal */
const metric_set = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, value) => metric_update(self, value))));
/** @internal */
const metric_succeed = out => metric_make(void 0, constVoid, () => out);
/** @internal */
const metric_sync = evaluate => metric_make(void 0, constVoid, evaluate);
/** @internal */
const metric_summary = options => withNow(summaryTimestamp(options));
/** @internal */
const summaryTimestamp = options => fromMetricKey(metricKey.summary(options));
/** @internal */
const metric_tagged = /*#__PURE__*/Function_dual(3, (self, key, value) => metric_taggedWithLabels(self, [label_make(key, value)]));
/** @internal */
const taggedWithLabelsInput = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => metric_map(metric_make(self.keyType, (input, extraTags) => self.unsafeUpdate(input, Arr.union(f(input), extraTags)), self.unsafeValue), constVoid))));
/** @internal */
const metric_taggedWithLabels = /*#__PURE__*/Function_dual(2, (self, extraTags) => {
  return metric_make(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, Array_union(extraTags, extraTags1)), extraTags1 => self.unsafeValue(Array_union(extraTags, extraTags1)));
});
/** @internal */
const metric_timer = (name, description) => {
  const boundaries = metricBoundaries.exponential({
    start: 0.5,
    factor: 2,
    count: 35
  });
  const base = pipe(metric_histogram(name, boundaries, description), metric_tagged("time_unit", "milliseconds"));
  return metric_mapInput(base, Duration.toMillis);
};
/** @internal */
const timerWithBoundaries = (name, boundaries, description) => {
  const base = pipe(metric_histogram(name, metricBoundaries.fromIterable(boundaries), description), metric_tagged("time_unit", "milliseconds"));
  return metric_mapInput(base, Duration.toMillis);
};
/* @internal */
const trackAll = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, input) => effect => core.matchCauseEffect(effect, {
  onFailure: cause => core.zipRight(metric_update(self, input), core.failCause(cause)),
  onSuccess: value => core.zipRight(metric_update(self, input), core.succeed(value))
}))));
/* @internal */
const trackDefect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, metric) => trackDefectWith(self, metric, identity))));
/* @internal */
const trackDefectWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, metric, f) => {
  const updater = defect => metric_update(metric, f(defect));
  return _effect.tapDefect(self, cause => core.forEachSequentialDiscard(Cause.defects(cause), updater));
})));
/* @internal */
const trackDuration = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, metric) => trackDurationWith(self, metric, identity))));
/* @internal */
const trackDurationWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, metric, f) => Clock.clockWith(clock => {
  const startTime = clock.unsafeCurrentTimeNanos();
  return core.tap(self, _ => {
    const endTime = clock.unsafeCurrentTimeNanos();
    const duration = Duration.nanos(endTime - startTime);
    return metric_update(metric, f(duration));
  });
}))));
/* @internal */
const trackError = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, metric) => trackErrorWith(self, metric, a => a))));
/* @internal */
const trackErrorWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, metric, f) => {
  const updater = error => metric_update(metric, f(error));
  return _effect.tapError(self, updater);
})));
/* @internal */
const trackSuccess = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, metric) => trackSuccessWith(self, metric, a => a))));
/* @internal */
const trackSuccessWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, metric, f) => {
  const updater = value => metric_update(metric, f(value));
  return core.tap(self, updater);
})));
/* @internal */
const metric_update = /*#__PURE__*/Function_dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, tags => sync(() => self.unsafeUpdate(input, tags))));
/* @internal */
const value = self => core.fiberRefGetWith(core.currentMetricLabels, tags => core.sync(() => self.unsafeValue(tags)));
/** @internal */
const withNow = self => metric_mapInput(self, input => [input, Date.now()]);
/** @internal */
const metric_zip = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => metric_make([self.keyType, that.keyType], (input, extraTags) => {
  const [l, r] = input;
  self.unsafeUpdate(l, extraTags);
  that.unsafeUpdate(r, extraTags);
}, extraTags => [self.unsafeValue(extraTags), that.unsafeValue(extraTags)]))));
/** @internal */
const unsafeSnapshot = () => globalMetricRegistry.snapshot();
/** @internal */
const snapshot = /*#__PURE__*/(/* unused pure expression or super */ null && (core.sync(unsafeSnapshot)));
//# sourceMappingURL=metric.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/metric/boundaries.js







/** @internal */
const MetricBoundariesSymbolKey = "effect/MetricBoundaries";
/** @internal */
const MetricBoundariesTypeId = /*#__PURE__*/Symbol.for(MetricBoundariesSymbolKey);
/** @internal */
class MetricBoundariesImpl {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values) {
    this.values = values;
    this._hash = Function_pipe(string(MetricBoundariesSymbolKey), combine(array(this.values)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [Equal_symbol](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
const isMetricBoundaries = u => Predicate_hasProperty(u, MetricBoundariesTypeId);
/** @internal */
const boundaries_fromIterable = iterable => {
  const values = Function_pipe(iterable, Array_appendAll(Chunk_of(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values);
};
/** @internal */
const linear = options => pipe(Arr.makeBy(options.count - 1, i => options.start + i * options.width), Chunk.unsafeFromArray, boundaries_fromIterable);
/** @internal */
const exponential = options => Function_pipe(Array_makeBy(options.count - 1, i => options.start * Math.pow(options.factor, i)), unsafeFromArray, boundaries_fromIterable);
//# sourceMappingURL=boundaries.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/request.js





/** @internal */
const RequestSymbolKey = "effect/Request";
/** @internal */
const RequestTypeId = /*#__PURE__*/Symbol.for(RequestSymbolKey);
const requestVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
const RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
/** @internal */
const isRequest = u => Predicate_hasProperty(u, RequestTypeId);
/** @internal */
const request_of = () => args => Object.assign(Object.create(RequestPrototype), args);
/** @internal */
const request_tagged = tag => args => {
  const request = Object.assign(Object.create(RequestPrototype), args);
  request._tag = tag;
  return request;
};
/** @internal */
const request_Class = /*#__PURE__*/function () {
  function Class(args) {
    if (args) {
      Object.assign(this, args);
    }
  }
  Class.prototype = RequestPrototype;
  return Class;
}();
/** @internal */
const TaggedClass = tag => {
  return class TaggedClass extends request_Class {
    _tag = tag;
  };
};
/** @internal */
const request_complete = /*#__PURE__*/Function_dual(2, (self, result) => fiberRefGetWith(currentRequestMap, map => sync(() => {
  if (map.has(self)) {
    const entry = map.get(self);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
/** @internal */
const completeEffect = /*#__PURE__*/Function_dual(2, (self, effect) => matchEffect(effect, {
  onFailure: error => request_complete(self, exitFail(error)),
  onSuccess: value => request_complete(self, exitSucceed(value))
}));
/** @internal */
const request_fail = /*#__PURE__*/Function_dual(2, (self, error) => request_complete(self, exitFail(error)));
/** @internal */
const request_failCause = /*#__PURE__*/Function_dual(2, (self, cause) => request_complete(self, exitFailCause(cause)));
/** @internal */
const request_succeed = /*#__PURE__*/Function_dual(2, (self, value) => request_complete(self, exitSucceed(value)));
/** @internal */
class Listeners {
  count = 0;
  observers = new Set();
  interrupted = false;
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach(f => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach(f => f(this.count));
  }
}
/**
 * @internal
 */
const filterOutCompleted = requests => core.fiberRefGetWith(completedRequestMap.currentRequestMap, map => core.succeed(requests.filter(request => !(map.get(request)?.state.completed === true))));
//# sourceMappingURL=request.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/supervisor.js






/** @internal */
const SupervisorSymbolKey = "effect/Supervisor";
/** @internal */
const SupervisorTypeId = /*#__PURE__*/Symbol.for(SupervisorSymbolKey);
/** @internal */
const supervisorVariance = {
  /* c8 ignore next */
  _T: _ => _
};
/** @internal */
class ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context, effect, parent, fiber) {
    this.underlying.onStart(context, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.underlying.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.underlying.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, Function_pipe(this.value, core_map(f)));
  }
  zip(right) {
    return new Zip(this, right);
  }
}
/** @internal */
class Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
  get value() {
    return core_zip(this.left.value, this.right.value);
  }
  onStart(context, effect, parent, fiber) {
    this.left.onStart(context, effect, parent, fiber);
    this.right.onStart(context, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.left.onEnd(value, fiber);
    this.right.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.left.onEffect(fiber, effect);
    this.right.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, Function_pipe(this.value, core_map(f)));
  }
  zip(right) {
    return new Zip(this, right);
  }
}
/** @internal */
const isZip = self => Predicate_hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
/** @internal */
class Track {
  [SupervisorTypeId] = supervisorVariance;
  fibers = new Set();
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
    //
  }
  onSuspend(_fiber) {
    //
  }
  onResume(_fiber) {
    //
  }
  map(f) {
    return new ProxySupervisor(this, Function_pipe(this.value, core_map(f)));
  }
  zip(right) {
    return new Zip(this, right);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}
/** @internal */
class Const {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect) {
    this.effect = effect;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
    //
  }
  onEnd(_value, _fiber) {
    //
  }
  onEffect(_fiber, _effect) {
    //
  }
  onSuspend(_fiber) {
    //
  }
  onResume(_fiber) {
    //
  }
  map(f) {
    return new ProxySupervisor(this, Function_pipe(this.value, core_map(f)));
  }
  zip(right) {
    return new Zip(this, right);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}
class FibersIn {
  ref;
  [SupervisorTypeId] = supervisorVariance;
  constructor(ref) {
    this.ref = ref;
  }
  get value() {
    return core.sync(() => MutableRef.get(this.ref));
  }
  onStart(_context, _effect, _parent, fiber) {
    pipe(this.ref, MutableRef.set(pipe(MutableRef.get(this.ref), SortedSet.add(fiber))));
  }
  onEnd(_value, fiber) {
    pipe(this.ref, MutableRef.set(pipe(MutableRef.get(this.ref), SortedSet.remove(fiber))));
  }
  onEffect(_fiber, _effect) {
    //
  }
  onSuspend(_fiber) {
    //
  }
  onResume(_fiber) {
    //
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, core.map(f)));
  }
  zip(right) {
    return new Zip(this, right);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}
/** @internal */
const unsafeTrack = () => {
  return new Track();
};
/** @internal */
const track = /*#__PURE__*/sync(unsafeTrack);
/** @internal */
const supervisor_fromEffect = effect => {
  return new Const(effect);
};
/** @internal */
const supervisor_none = /*#__PURE__*/GlobalValue_globalValue("effect/Supervisor/none", () => supervisor_fromEffect(core_void_));
/** @internal */
const fibersIn = ref => core.sync(() => new FibersIn(ref));
//# sourceMappingURL=supervisor.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Differ.js








/**
 * @since 2.0.0
 * @category symbol
 */
const Differ_TypeId = DifferTypeId;
const Differ_ChunkPatchTypeId = ChunkPatchTypeId;
const Differ_ContextPatchTypeId = ContextPatchTypeId;
const Differ_HashMapPatchTypeId = HashMapPatchTypeId;
const Differ_HashSetPatchTypeId = HashSetPatchTypeId;
const Differ_OrPatchTypeId = OrPatchTypeId;
const Differ_ReadonlyArrayPatchTypeId = ReadonlyArrayPatchTypeId;
/**
 * An empty patch that describes no changes.
 *
 * @since 2.0.0
 * @category patch
 */
const Differ_empty = self => self.empty;
/**
 * @since 2.0.0
 * @category patch
 */
const Differ_diff = /*#__PURE__*/(/* unused pure expression or super */ null && (Dual.dual(3, (self, oldValue, newValue) => self.diff(oldValue, newValue))));
/**
 * Combines two patches to produce a new patch that describes the updates of
 * the first patch and then the updates of the second patch. The combine
 * operation should be associative. In addition, if the combine operation is
 * commutative then joining multiple fibers concurrently will result in
 * deterministic `FiberRef` values.
 *
 * @since 2.0.0
 * @category patch
 */
const Differ_combine = /*#__PURE__*/(/* unused pure expression or super */ null && (Dual.dual(3, (self, first, second) => self.combine(first, second))));
/**
 * Applies a patch to an old value to produce a new value that is equal to the
 * old value with the updates described by the patch.
 *
 * @since 2.0.0
 * @category patch
 */
const Differ_patch = /*#__PURE__*/(/* unused pure expression or super */ null && (Dual.dual(3, (self, patch, oldValue) => self.patch(patch, oldValue))));
/**
 * Constructs a new `Differ`.
 *
 * @since 2.0.0
 * @category constructors
 */
const Differ_make = differ_make;
/**
 * Constructs a differ that knows how to diff `Env` values.
 *
 * @since 2.0.0
 * @category constructors
 */
const Differ_environment = environment;
/**
 * Constructs a differ that knows how to diff a `Chunk` of values given a
 * differ that knows how to diff the values.
 *
 * @since 2.0.0
 * @category constructors
 */
const Differ_chunk = chunk;
/**
 * Constructs a differ that knows how to diff a `HashMap` of keys and values given
 * a differ that knows how to diff the values.
 *
 * @since 2.0.0
 * @category constructors
 */
const Differ_hashMap = hashMap;
/**
 * Constructs a differ that knows how to diff a `HashSet` of values.
 *
 * @since 2.0.0
 * @category constructors
 */
const Differ_hashSet = hashSet;
/**
 * Combines this differ and the specified differ to produce a differ that
 * knows how to diff the sum of their values.
 *
 * @since 2.0.0
 */
const Differ_orElseEither = differ_orElseEither;
/**
 * Constructs a differ that knows how to diff a `ReadonlyArray` of values.
 *
 * @since 2.0.0
 * @category constructors
 */
const Differ_readonlyArray = differ_readonlyArray;
/**
 * Transforms the type of values that this differ knows how to differ using
 * the specified functions that map the new and old value types to each other.
 *
 * @since 2.0.0
 */
const Differ_transform = transform;
/**
 * Constructs a differ that just diffs two values by returning a function that
 * sets the value to the new value. This differ does not support combining
 * multiple updates to the value compositionally and should only be used when
 * there is no compositional way to update them.
 *
 * @since 2.0.0
 */
const Differ_update = differ_update;
/**
 * A variant of `update` that allows specifying the function that will be used
 * to combine old values with new values.
 *
 * @since 2.0.0
 */
const Differ_updateWith = updateWith;
/**
 * Combines this differ and the specified differ to produce a new differ that
 * knows how to diff the product of their values.
 *
 * @since 2.0.0
 */
const Differ_zip = differ_zip;
//# sourceMappingURL=Differ.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/supervisor/patch.js






/** @internal */
const supervisor_patch_OP_EMPTY = "Empty";
/** @internal */
const OP_ADD_SUPERVISOR = "AddSupervisor";
/** @internal */
const OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
/** @internal */
const patch_OP_AND_THEN = "AndThen";
/**
 * The empty `SupervisorPatch`.
 *
 * @internal
 */
const supervisor_patch_empty = {
  _tag: supervisor_patch_OP_EMPTY
};
/**
 * Combines two patches to produce a new patch that describes applying the
 * updates from this patch and then the updates from the specified patch.
 *
 * @internal
 */
const supervisor_patch_combine = (self, that) => {
  return {
    _tag: patch_OP_AND_THEN,
    first: self,
    second: that
  };
};
/**
 * Applies a `SupervisorPatch` to a `Supervisor` to produce a new `Supervisor`.
 *
 * @internal
 */
const supervisor_patch_patch = (self, supervisor) => {
  return patchLoop(supervisor, Chunk_of(self));
};
/** @internal */
const patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty(patches)) {
    const head = Chunk_headNonEmpty(patches);
    switch (head._tag) {
      case supervisor_patch_OP_EMPTY:
        {
          patches = Chunk_tailNonEmpty(patches);
          break;
        }
      case OP_ADD_SUPERVISOR:
        {
          supervisor = supervisor.zip(head.supervisor);
          patches = Chunk_tailNonEmpty(patches);
          break;
        }
      case OP_REMOVE_SUPERVISOR:
        {
          supervisor = removeSupervisor(supervisor, head.supervisor);
          patches = Chunk_tailNonEmpty(patches);
          break;
        }
      case patch_OP_AND_THEN:
        {
          patches = Chunk_prepend(head.first)(Chunk_prepend(head.second)(Chunk_tailNonEmpty(patches)));
          break;
        }
    }
  }
  return supervisor;
};
/** @internal */
const removeSupervisor = (self, that) => {
  if (equals(self, that)) {
    return supervisor_none;
  } else {
    if (isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
};
/** @internal */
const patch_toSet = self => {
  if (equals(self, supervisor_none)) {
    return HashSet_empty();
  } else {
    if (isZip(self)) {
      return Function_pipe(patch_toSet(self.left), HashSet_union(patch_toSet(self.right)));
    } else {
      return HashSet_make(self);
    }
  }
};
/** @internal */
const supervisor_patch_diff = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return supervisor_patch_empty;
  }
  const oldSupervisors = patch_toSet(oldValue);
  const newSupervisors = patch_toSet(newValue);
  const added = Function_pipe(newSupervisors, HashSet_difference(oldSupervisors), HashSet_reduce(supervisor_patch_empty, (patch, supervisor) => supervisor_patch_combine(patch, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = Function_pipe(oldSupervisors, HashSet_difference(newSupervisors), HashSet_reduce(supervisor_patch_empty, (patch, supervisor) => supervisor_patch_combine(patch, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return supervisor_patch_combine(added, removed);
};
/** @internal */
const patch_differ = /*#__PURE__*/Differ_make({
  empty: supervisor_patch_empty,
  patch: supervisor_patch_patch,
  combine: supervisor_patch_combine,
  diff: supervisor_patch_diff
});
//# sourceMappingURL=patch.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/fiberRuntime.js




















































/** @internal */
const fiberStarted = /*#__PURE__*/metric_counter("effect_fiber_started", {
  incremental: true
});
/** @internal */
const fiberActive = /*#__PURE__*/metric_counter("effect_fiber_active");
/** @internal */
const fiberSuccesses = /*#__PURE__*/metric_counter("effect_fiber_successes", {
  incremental: true
});
/** @internal */
const fiberFailures = /*#__PURE__*/metric_counter("effect_fiber_failures", {
  incremental: true
});
/** @internal */
const fiberLifetimes = /*#__PURE__*/metric_tagged( /*#__PURE__*/metric_histogram("effect_fiber_lifetimes", /*#__PURE__*/exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
/** @internal */
const EvaluationSignalContinue = "Continue";
/** @internal */
const EvaluationSignalDone = "Done";
/** @internal */
const EvaluationSignalYieldNow = "Yield";
const runtimeFiberVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
const fiberRuntime_absurd = _ => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
const YieldedOp = /*#__PURE__*/Symbol.for("effect/internal/fiberRuntime/YieldedOp");
const yieldedOpChannel = /*#__PURE__*/GlobalValue_globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
const contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value) => {
    return cont.effect_instruction_i1(value);
  },
  ["OnStep"]: (_, _cont, value) => {
    return exitSucceed(exitSucceed(value));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {
    return cont.effect_instruction_i2(value);
  },
  [OP_REVERT_FLAGS]: (self, cont, value) => {
    self.patchRuntimeFlags(self._runtimeFlags, cont.patch);
    if (interruptible(self._runtimeFlags) && self.isInterrupted()) {
      return exitFailCause(self.getInterruptedCause());
    } else {
      return exitSucceed(value);
    }
  },
  [OP_WHILE]: (self, cont, value) => {
    cont.effect_instruction_i2(value);
    if (cont.effect_instruction_i0()) {
      self.pushStack(cont);
      return cont.effect_instruction_i1();
    } else {
      return core_void_;
    }
  }
};
const drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self, runtimeFlags, cur, message) => {
    message.onFiber(self, FiberStatus_running(runtimeFlags));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return core_flatMap(yieldNow(), () => cur);
  }
};
/**
 * Executes all requests, submitting requests to each data source in parallel.
 */
const runBlockedRequests = self => forEachSequentialDiscard(blockedRequests_flatten(self), requestsByRequestResolver => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential]) => {
  const map = new Map();
  const arr = [];
  for (const block of sequential) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach(entry => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map);
}, false, false));
/** @internal */
class FiberRuntime {
  [FiberTypeId] = fiberVariance;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
  _fiberRefs;
  _fiberId;
  _runtimeFlags;
  _queue = new Array();
  _children = null;
  _observers = new Array();
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _supervisor;
  _scheduler;
  _tracer;
  currentOpCount = 0;
  isYielding = false;
  constructor(fiberId, fiberRefs0, runtimeFlags0) {
    this._runtimeFlags = runtimeFlags0;
    this._fiberId = fiberId;
    this._fiberRefs = fiberRefs0;
    this._supervisor = this.getFiberRef(currentSupervisor);
    this._scheduler = this.getFiberRef(currentScheduler);
    if (runtimeMetrics(runtimeFlags0)) {
      const tags = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags);
      fiberActive.unsafeUpdate(1, tags);
    }
    this._tracer = Context_get(this.getFiberRef(currentServices), tracerTag);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect) {
    this.tell(resume(effect));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_, status) => status);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status) => {
      if (FiberStatus_isDone(status)) {
        return state._runtimeFlags;
      }
      return status.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return fiberScope_unsafeMake(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask(fiber => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask(fiber => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status)));
      }));
      return deferredAwait(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return core_async(resume => {
      const cb = exit => resume(succeed(exit));
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch = Function_pipe(runtimeFlags_diff(parentRuntimeFlags, updatedRuntimeFlags),
      // Do not inherit WindDown or Interruption!
      RuntimeFlagsPatch_exclude(Interruption), RuntimeFlagsPatch_exclude(WindDown));
      return updateRuntimeFlags(patch);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId) {
    this.tell(interruptSignal(interrupt(fiberId)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter(o => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this._runtimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this._tracer = Context_get(this.getFiberRef(currentServices), tracerTag);
    this._supervisor = this.getFiberRef(currentSupervisor);
    this._scheduler = this.getFiberRef(currentScheduler);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs) {
    this._fiberRefs = fiberRefs;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      // Maybe someone added something to the queue between us checking, and us
      // giving up the drain. If so, we need to restart the draining, but only
      // if we beat everyone else to the restart:
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this._scheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      // @ts-expect-error
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !cause_isEmpty(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause) {
    this.addInterruptedCause(cause);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone = false;
      const body = () => {
        const next = it.next();
        if (!next.done) {
          return core_asVoid(next.value.await);
        } else {
          return sync(() => {
            isDone = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone,
        body,
        step: () => {
          //
        }
      });
    }
    return null;
  }
  reportExitValue(exit) {
    if (runtimeMetrics(this._runtimeFlags)) {
      const tags = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
      fiberActive.unsafeUpdate(-1, tags);
      switch (exit._tag) {
        case OP_SUCCESS:
          {
            fiberSuccesses.unsafeUpdate(1, tags);
            break;
          }
        case OP_FAILURE:
          {
            fiberFailures.unsafeUpdate(1, tags);
            break;
          }
      }
    }
    if (exit._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit.cause, level);
      }
    }
  }
  setExitValue(exit) {
    this._exitValue = exit;
    this.reportExitValue(exit);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit);
    }
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause, overrideLogLevel) {
    const logLevel = Option_isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
    if (LogLevel_greaterThan(minimumLogLevel, logLevel)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (HashSet_size(loggers) > 0) {
      const clockService = Context_get(this.getFiberRef(currentServices), clockTag);
      const date = new Date(clockService.unsafeCurrentTimeMillis());
      for (const logger of loggers) {
        logger.log({
          fiberId: this.id(),
          logLevel,
          message,
          cause,
          context: contextMap,
          spans,
          annotations,
          date
        });
      }
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW:
        {
          return EvaluationSignalYieldNow;
        }
      case OP_INTERRUPT_SIGNAL:
        {
          this.processNewInterruptSignal(message.cause);
          if (this._asyncInterruptor !== null) {
            this._asyncInterruptor(exitFailCause(message.cause));
            this._asyncInterruptor = null;
          }
          return EvaluationSignalContinue;
        }
      case OP_RESUME:
        {
          this._asyncInterruptor = null;
          this._asyncBlockingOn = null;
          this.evaluateEffect(message.effect);
          return EvaluationSignalContinue;
        }
      case OP_STATEFUL:
        {
          message.onFiber(this, this._exitValue !== null ? FiberStatus_done : FiberStatus_suspended(this._runtimeFlags, this._asyncBlockingOn));
          return EvaluationSignalContinue;
        }
      default:
        {
          return fiberRuntime_absurd(message);
        }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this._supervisor.onResume(this);
    try {
      let effect = interruptible(this._runtimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect !== null) {
        const eff = effect;
        const exit = this.runLoop(eff);
        if (exit === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this._runtimeFlags)) {
              this.tell(fiberMessage_yieldNow());
              this.tell(resume(exitVoid));
              effect = null;
            } else {
              effect = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            // Terminate this evaluation, async resumption will continue evaluation:
            effect = null;
          }
        } else {
          this._runtimeFlags = Function_pipe(this._runtimeFlags, runtimeFlags_enable(WindDown));
          const interruption = this.interruptAllChildren();
          if (interruption !== null) {
            effect = core_flatMap(interruption, () => exit);
          } else {
            if (this._queue.length === 0) {
              // No more messages to process, so we will allow the fiber to end life:
              this.setExitValue(exit);
            } else {
              // There are messages, possibly added by the final op executed by
              // the fiber. To be safe, we should execute those now before we
              // allow the fiber to end life:
              this.tell(resume(exit));
            }
            effect = null;
          }
        }
      }
    } finally {
      this._supervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        // Because we're special casing `start`, we have to be responsible
        // for spinning up the fiber if there were new messages added to
        // the queue between the completion of the effect and the transition
        // to the not running state.
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect) {
    this.tell(resume(effect));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch) {
    const newRuntimeFlags = runtimeFlags_patch(oldRuntimeFlags, patch);
    globalThis[currentFiberURI] = this;
    this._runtimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags, asyncRegister) {
    let alreadyCalled = false;
    const callback = effect => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect));
      }
    };
    if (interruptible(runtimeFlags)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this._runtimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return core_map(fiberRefGet(currentContext), context => Context_unsafeGet(context, op));
  }
  ["Left"](op) {
    return core_fail(op.left);
  }
  ["None"](_) {
    return core_fail(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  [OP_SYNC](op) {
    const value = op.effect_instruction_i0();
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        // @ts-expect-error
        fiberRuntime_absurd(cont);
      }
      // @ts-expect-error
      return contOpSuccess[cont._op](this, cont, value);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        // @ts-expect-error
        fiberRuntime_absurd(cont);
      }
      // @ts-expect-error
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== undefined) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE:
          {
            if (!(interruptible(this._runtimeFlags) && this.isInterrupted())) {
              return cont.effect_instruction_i1(cause);
            } else {
              return exitFailCause(stripFailures(cause));
            }
          }
        case "OnStep":
          {
            if (!(interruptible(this._runtimeFlags) && this.isInterrupted())) {
              return exitSucceed(exitFailCause(cause));
            } else {
              return exitFailCause(stripFailures(cause));
            }
          }
        case OP_REVERT_FLAGS:
          {
            this.patchRuntimeFlags(this._runtimeFlags, cont.patch);
            if (interruptible(this._runtimeFlags) && this.isInterrupted()) {
              return exitFailCause(sequential(cause, this.getInterruptedCause()));
            } else {
              return exitFailCause(cause);
            }
          }
        default:
          {
            fiberRuntime_absurd(cont);
          }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return op.effect_instruction_i0(this, FiberStatus_running(this._runtimeFlags));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this._runtimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this._runtimeFlags = snap.flags;
      const patchRefs = FiberRefsPatch_diff(snap.refs, refs);
      const patchFlags = runtimeFlags_diff(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime(newFiber => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(FiberRefsPatch_patch(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber._runtimeFlags = runtimeFlags_patch(patchFlags)(newFiber._runtimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask(restore => core_flatMap(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this._runtimeFlags;
    const newRuntimeFlags = runtimeFlags_patch(oldRuntimeFlags, updateFlags);
    // One more chance to short circuit: if we're immediately going
    // to interrupt. Interruption will cause immediate reversion of
    // the flag, so as long as we "peek ahead", there's no need to
    // set them to begin with.
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      // Impossible to short circuit, so record the changes
      this.patchRuntimeFlags(this._runtimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        // Since we updated the flags, we need to revert them
        const revertFlags = runtimeFlags_diff(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return op.effect_instruction_i1(oldRuntimeFlags);
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this._runtimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this.isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_COMMIT](op) {
    return op.commit();
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    // eslint-disable-next-line no-constant-condition
    while (true) {
      if ((this._runtimeFlags & OpSupervision) !== 0) {
        this._supervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this._runtimeFlags, cur);
      }
      if (!this.isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this._scheduler.shouldYield(this);
        if (shouldYield !== false) {
          this.isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = core_flatMap(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        if (!("_op" in cur) || !(cur._op in this)) {
          // @ts-expect-error
          fiberRuntime_absurd(cur);
        }
        // @ts-expect-error
        cur = this._tracer.context(() => {
          if (getCurrentVersion() !== cur[Effectable_EffectTypeId]._V) {
            return dieMessage(`Cannot execute an Effect versioned ${cur[Effectable_EffectTypeId]._V} with a Runtime of version ${getCurrentVersion()}`);
          }
          // @ts-expect-error
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (isEffectError(e)) {
          cur = exitFailCause(e.cause);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(FiberId_none)));
        } else {
          cur = exitFailCause(die(e));
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
}
// circular with Logger
/** @internal */
const currentMinimumLogLevel = /*#__PURE__*/GlobalValue_globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
/** @internal */
const loggerWithConsoleLog = self => makeLogger(opts => {
  const services = FiberRefs_getOrDefault(opts.context, currentServices);
  Context_get(services, console_consoleTag).unsafe.log(self.log(opts));
});
/** @internal */
const loggerWithConsoleError = self => internalLogger.makeLogger(opts => {
  const services = FiberRefs.getOrDefault(opts.context, defaultServices.currentServices);
  Context.get(services, consoleTag).unsafe.error(self.log(opts));
});
/** @internal */
const defaultLogger = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
/** @internal */
const fiberRuntime_jsonLogger = /*#__PURE__*/(/* unused pure expression or super */ null && (globalValue( /*#__PURE__*/Symbol.for("effect/Logger/jsonLogger"), () => loggerWithConsoleLog(internalLogger.jsonLogger))));
/** @internal */
const logFmtLogger = /*#__PURE__*/(/* unused pure expression or super */ null && (globalValue( /*#__PURE__*/Symbol.for("effect/Logger/logFmtLogger"), () => loggerWithConsoleLog(internalLogger.logfmtLogger))));
/** @internal */
const fiberRuntime_structuredLogger = /*#__PURE__*/(/* unused pure expression or super */ null && (globalValue( /*#__PURE__*/Symbol.for("effect/Logger/structuredLogger"), () => loggerWithConsoleLog(internalLogger.structuredLogger))));
/** @internal */
const tracerLogger = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations,
  cause,
  context,
  fiberId,
  logLevel,
  message
}) => {
  const span = flatMap(fiberRefs_get(context, currentContext), Context_getOption(spanTag));
  const clockService = map(fiberRefs_get(context, currentServices), _ => Context_get(_, clockTag));
  if (span._tag === "None" || span.value._tag === "ExternalSpan" || clockService._tag === "None") {
    return;
  }
  const attributes = Object.fromEntries(HashMap_map(annotations, toStringUnknown));
  attributes["effect.fiberId"] = FiberId_threadName(fiberId);
  attributes["effect.logLevel"] = logLevel.label;
  if (cause !== null && cause._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause);
  }
  span.value.event(String(message), clockService.value.unsafeCurrentTimeNanos(), attributes);
}));
/** @internal */
const loggerWithSpanAnnotations = self => internalLogger.mapInputOptions(self, options => {
  const span = Option.flatMap(fiberRefs.get(options.context, core.currentContext), Context.getOption(tracer.spanTag));
  if (span._tag === "None") {
    return options;
  }
  return {
    ...options,
    annotations: pipe(options.annotations, HashMap.set("effect.traceId", span.value.traceId), HashMap.set("effect.spanId", span.value.spanId), span.value._tag === "Span" ? HashMap.set("effect.spanName", span.value.name) : identity)
  };
});
/** @internal */
const currentLoggers = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(HashSet_make(defaultLogger, tracerLogger)));
/** @internal */
const batchedLogger = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, window, f) => core.flatMap(scope, scope => {
  let buffer = [];
  const flush = core.suspend(() => {
    if (buffer.length === 0) {
      return core.void;
    }
    const arr = buffer;
    buffer = [];
    return f(arr);
  });
  return core.uninterruptibleMask(restore => pipe(internalEffect.sleep(window), core.zipRight(flush), internalEffect.forever, restore, forkDaemon, core.flatMap(fiber => core.scopeAddFinalizer(scope, core.interruptFiber(fiber))), core.zipRight(addFinalizer(() => flush)), core.as(internalLogger.makeLogger(options => {
    buffer.push(self.log(options));
  }))));
}))));
const annotateLogsScoped = function () {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, HashMap_set(arguments[0], arguments[1]));
  }
  const entries = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, HashMap_mutate(annotations => {
    for (let i = 0; i < entries.length; i++) {
      const [key, value] = entries[i];
      HashMap_set(annotations, key, value);
    }
    return annotations;
  }));
};
// circular with Effect
/* @internal */
const acquireRelease = /*#__PURE__*/Function_dual(args => isEffect(args[0]), (acquire, release) => uninterruptible(core_tap(acquire, a => addFinalizer(exit => release(a, exit)))));
/* @internal */
const acquireReleaseInterruptible = /*#__PURE__*/Function_dual(args => isEffect(args[0]), (acquire, release) => ensuring(acquire, addFinalizer(exit => release(exit))));
/* @internal */
const addFinalizer = finalizer => withFiberRuntime(runtime => {
  const acquireRefs = runtime.getFiberRefs();
  const acquireFlags = runtime._runtimeFlags;
  return core_flatMap(scope, scope => scopeAddFinalizerExit(scope, exit => withFiberRuntime(runtimeFinalizer => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer._runtimeFlags;
    const patchRefs = FiberRefsPatch_diff(preRefs, acquireRefs);
    const patchFlags = runtimeFlags_diff(preFlags, acquireFlags);
    const inverseRefs = FiberRefsPatch_diff(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(FiberRefsPatch_patch(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer(exit), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(FiberRefsPatch_patch(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
/* @internal */
const daemonChildren = self => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, Option_some(globalScope));
  return forkScope(self);
};
/** @internal */
const _existsParFound = /*#__PURE__*/Symbol.for("effect/Effect/existsPar/found");
/* @internal */
const fiberRuntime_exists = /*#__PURE__*/Function_dual(args => isIterable(args[0]) && !isEffect(args[0]), (elements, f, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, f)), () => matchEffect(fiberRuntime_forEach(elements, (a, i) => if_(f(a, i), {
  onTrue: () => core_fail(_existsParFound),
  onFalse: () => core_void_
}), options), {
  onFailure: e => e === _existsParFound ? succeed(true) : core_fail(e),
  onSuccess: () => succeed(false)
})));
const existsLoop = (iterator, index, f) => {
  const next = iterator.next();
  if (next.done) {
    return succeed(false);
  }
  return Function_pipe(core_flatMap(f(next.value, index), b => b ? succeed(b) : existsLoop(iterator, index + 1, f)));
};
/* @internal */
const fiberRuntime_filter = /*#__PURE__*/Function_dual(args => isIterable(args[0]) && !isEffect(args[0]), (elements, f, options) => {
  const predicate = options?.negate ? (a, i) => core_map(f(a, i), Boolean_not) : f;
  return matchSimple(options?.concurrency, () => suspend(() => Array_fromIterable(elements).reduceRight((effect, a, i) => core_zipWith(effect, suspend(() => predicate(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array()))), () => core_map(fiberRuntime_forEach(elements, (a, i) => core_map(predicate(a, i), b => b ? Option_some(a) : Option_none()), options), Array_getSomes));
});
// === all
const allResolveInput = input => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, Option_none()];
  }
  const keys = Object.keys(input);
  const size = keys.length;
  return [keys.map(k => input[k]), Option_some(values => {
    const res = {};
    for (let i = 0; i < size; i++) {
      ;
      res[keys[i]] = values[i];
    }
    return res;
  })];
};
const allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(core_either(effect));
  }
  return core_flatMap(fiberRuntime_forEach(eitherEffects, Function_identity, {
    concurrency: options?.concurrency,
    batching: options?.batching
  }), eithers => {
    const none = Option_none();
    const size = eithers.length;
    const errors = new Array(size);
    const successes = new Array(size);
    let errored = false;
    for (let i = 0; i < size; i++) {
      const either = eithers[i];
      if (either._tag === "Left") {
        errors[i] = Option_some(either.left);
        errored = true;
      } else {
        successes[i] = either.right;
        errors[i] = none;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? core_fail(reconcile.value(errors)) : core_fail(errors);
    } else if (options?.discard) {
      return core_void_;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
const allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(core_either(effect));
  }
  if (options?.discard) {
    return fiberRuntime_forEach(eitherEffects, Function_identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true
    });
  }
  return core_map(fiberRuntime_forEach(eitherEffects, Function_identity, {
    concurrency: options?.concurrency,
    batching: options?.batching
  }), eithers => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
/* @internal */
const fiberRuntime_all = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options?.mode === "validate") {
    return allValidate(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither(effects, reconcile, options);
  }
  return reconcile._tag === "Some" ? core_map(fiberRuntime_forEach(effects, Function_identity, options), reconcile.value) : fiberRuntime_forEach(effects, Function_identity, options);
};
/* @internal */
const allWith = options => arg => fiberRuntime_all(arg, options);
/* @internal */
const allSuccesses = (elements, options) => core_map(fiberRuntime_all(Array_fromIterable(elements).map(core_exit), options), Array_filterMap(exit => exitIsSuccess(exit) ? Option_some(exit.effect_instruction_i0) : Option_none()));
/* @internal */
const fiberRuntime_replicate = /*#__PURE__*/Function_dual(2, (self, n) => Array.from({
  length: n
}, () => self));
/* @internal */
const replicateEffect = /*#__PURE__*/Function_dual(args => isEffect(args[0]), (self, n, options) => fiberRuntime_all(fiberRuntime_replicate(self, n), options));
/* @internal */
const fiberRuntime_forEach = /*#__PURE__*/Function_dual(args => isIterable(args[0]), (self, f, options) => withFiberRuntime(r => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options?.discard) {
    return concurrency_match(options.concurrency, () => finalizersMask(ExecutionStrategy_sequential)(restore => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMask(ExecutionStrategy_parallel)(restore => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), n => finalizersMask(ExecutionStrategy_parallelN(n))(restore => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return concurrency_match(options?.concurrency, () => finalizersMask(ExecutionStrategy_sequential)(restore => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMask(ExecutionStrategy_parallel)(restore => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), n => finalizersMask(ExecutionStrategy_parallelN(n))(restore => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
/* @internal */
const forEachParUnbounded = (self, f, batching) => suspend(() => {
  const as = Array_fromIterable(self);
  const array = new Array(as.length);
  const fn = (a, i) => core_flatMap(f(a, i), b => sync(() => array[i] = b));
  return core_zipRight(forEachConcurrentDiscard(as, fn, batching, false), succeed(array));
});
/** @internal */
const forEachConcurrentDiscard = (self, f, batching, processAll, n) => uninterruptibleMask(restore => transplant(graft => withFiberRuntime(parent => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return core_void_;
  }
  let counter = 0;
  let interrupted = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = new Set();
  const results = new Array();
  const interruptAll = () => fibers.forEach(fiber => {
    fiber._scheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = () => {
    const exits = results.filter(({
      exit
    }) => exit._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit
    }) => exit);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent._runtimeFlags, globalScope);
    parent._scheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted = true;
    interruptAll();
  };
  const stepOrExit = batching ? step : core_exit;
  const processingFiber = runFiber(core_async(resume => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted) {
          onInterruptSignal();
        }
      }
    };
    const next = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter++;
        const returnNextElement = () => {
          const a = todos.pop();
          index = counter++;
          return core_flatMap(yieldNow(), () => core_flatMap(stepOrExit(restore(f(a, index))), onRes));
        };
        const onRes = res => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = core_flatMap(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted) {
          fiber._scheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver(wrapped => {
          let exit;
          if (wrapped._op === "Failure") {
            exit = wrapped;
          } else {
            exit = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit, index);
          if (results.length === target) {
            resume(succeed(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const requests = residual.map(blocked => blocked.effect_instruction_i0).reduce(par);
            resume(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid), ...residual.map(blocked => blocked.effect_instruction_i1)], i => i, batching, true, n))));
          } else {
            next();
          }
        });
      }
    };
    for (let i = 0; i < fibersCount; i++) {
      next();
    }
  }));
  return core_asVoid(onExit(core_flatten(restore(fiber_join(processingFiber))), exitMatch({
    onFailure: () => {
      onInterruptSignal();
      const target = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return core_async(cb => {
        const exits = [];
        let count = 0;
        let index = 0;
        const check = (index, hitNext) => exit => {
          exits[index] = exit;
          count++;
          if (count === target) {
            cb(getOrThrow(exitCollectAll(exits, {
              parallel: true
            })));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        };
        const next = () => {
          runFiber(toPop.pop(), true).addObserver(check(index, true));
          index++;
        };
        processingFiber.addObserver(check(index, false));
        index++;
        for (let i = 0; i < concurrency; i++) {
          next();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, f => f.inheritAll)
  })));
})));
/* @internal */
const forEachParN = (self, n, f, batching) => suspend(() => {
  const as = Array_fromIterable(self);
  const array = new Array(as.length);
  const fn = (a, i) => core_map(f(a, i), b => array[i] = b);
  return core_zipRight(forEachConcurrentDiscard(as, fn, batching, false, n), succeed(array));
});
/* @internal */
const fork = self => withFiberRuntime((state, status) => succeed(unsafeFork(self, state, status.runtimeFlags)));
/* @internal */
const forkDaemon = self => forkWithScopeOverride(self, globalScope);
/* @internal */
const forkWithErrorHandler = /*#__PURE__*/Function_dual(2, (self, handler) => fork(onError(self, cause => {
  const either = failureOrCause(cause);
  switch (either._tag) {
    case "Left":
      return handler(either.left);
    case "Right":
      return failCause(either.right);
  }
})));
/** @internal */
const unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect);
  return childFiber;
};
/** @internal */
const unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
/** @internal */
const unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = FiberId_unsafeMake();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber._supervisor;
  supervisor.onStart(childContext, effect, Option_some(parentFiber), childFiber);
  childFiber.addObserver(exit => supervisor.onEnd(exit, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : Function_pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
/* @internal */
const forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
/* @internal */
const mergeAll = /*#__PURE__*/Function_dual(args => Predicate_isFunction(args[2]), (elements, zero, f, options) => matchSimple(options?.concurrency, () => Array_fromIterable(elements).reduce((acc, a, i) => core_zipWith(acc, a, (acc, a) => f(acc, a, i)), succeed(zero)), () => core_flatMap(Ref_make(zero), acc => core_flatMap(fiberRuntime_forEach(elements, (effect, i) => core_flatMap(effect, a => Ref_update(acc, b => f(b, a, i))), options), () => Ref_get(acc)))));
/* @internal */
const fiberRuntime_partition = /*#__PURE__*/Function_dual(args => isIterable(args[0]), (elements, f, options) => Function_pipe(fiberRuntime_forEach(elements, (a, i) => core_either(f(a, i)), options), core_map(chunk => core_partitionMap(chunk, Function_identity))));
/* @internal */
const validateAll = /*#__PURE__*/Function_dual(args => isIterable(args[0]), (elements, f, options) => core_flatMap(fiberRuntime_partition(elements, f, {
  concurrency: options?.concurrency,
  batching: options?.batching
}), ([es, bs]) => es.length === 0 ? options?.discard ? core_void_ : succeed(bs) : core_fail(es)));
/* @internal */
const raceAll = all => {
  const list = Chunk_fromIterable(all);
  if (!isNonEmpty(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  const self = Chunk_headNonEmpty(list);
  const effects = Chunk_tailNonEmpty(list);
  const inheritAll = res => Function_pipe(fiber_inheritAll(res[1]), core_as(res[0]));
  return Function_pipe(deferredMake(), core_flatMap(done => Function_pipe(Ref_make(effects.length), core_flatMap(fails => uninterruptibleMask(restore => Function_pipe(fork(core_interruptible(self)), core_flatMap(head => Function_pipe(effects, forEachSequential(effect => fork(core_interruptible(effect))), core_map(fibers => unsafeFromArray(fibers)), core_map(tail => Function_pipe(tail, Chunk_prepend(head))), core_tap(fibers => Function_pipe(fibers, Array_reduce(core_void_, (effect, fiber) => Function_pipe(effect, core_zipRight(Function_pipe(fiber_await(fiber), core_flatMap(raceAllArbiter(fibers, fiber, done, fails)), fork, core_asVoid)))))), core_flatMap(fibers => Function_pipe(restore(Function_pipe(_await(done), core_flatMap(inheritAll))), onInterrupt(() => Function_pipe(fibers, Array_reduce(core_void_, (effect, fiber) => Function_pipe(effect, core_zipLeft(interruptFiber(fiber))))))))))))))));
};
const raceAllArbiter = (fibers, winner, deferred, fails) => exit => exitMatchEffect(exit, {
  onFailure: cause => Function_pipe(Ref_modify(fails, fails => [fails === 0 ? Function_pipe(deferredFailCause(deferred, cause), core_asVoid) : core_void_, fails - 1]), core_flatten),
  onSuccess: value => Function_pipe(deferredSucceed(deferred, [value, winner]), core_flatMap(set => set ? Function_pipe(Chunk_fromIterable(fibers), Array_reduce(core_void_, (effect, fiber) => fiber === winner ? effect : Function_pipe(effect, core_zipLeft(interruptFiber(fiber))))) : core_void_))
});
/* @internal */
const reduceEffect = /*#__PURE__*/Function_dual(args => isIterable(args[0]) && !isEffect(args[0]), (elements, zero, f, options) => matchSimple(options?.concurrency, () => Array_fromIterable(elements).reduce((acc, a, i) => core_zipWith(acc, a, (acc, a) => f(acc, a, i)), zero), () => suspend(() => Function_pipe(mergeAll([zero, ...elements], Option_none(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None":
      {
        return Option_some(elem);
      }
    case "Some":
      {
        return Option_some(f(acc.value, elem, i));
      }
  }
}, options), core_map(option => {
  switch (option._tag) {
    case "None":
      {
        throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
      }
    case "Some":
      {
        return option.value;
      }
  }
})))));
/* @internal */
const parallelFinalizers = self => contextWithEffect(context => match(Context_getOption(context, scopeTag), {
  onNone: () => self,
  onSome: scope => {
    switch (scope.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return core_flatMap(scopeFork(scope, ExecutionStrategy_parallel), inner => scopeExtend(self, inner));
    }
  }
}));
/* @internal */
const parallelNFinalizers = parallelism => self => contextWithEffect(context => match(Context_getOption(context, scopeTag), {
  onNone: () => self,
  onSome: scope => {
    if (scope.strategy._tag === "ParallelN" && scope.strategy.parallelism === parallelism) {
      return self;
    }
    return core_flatMap(scopeFork(scope, ExecutionStrategy_parallelN(parallelism)), inner => scopeExtend(self, inner));
  }
}));
/* @internal */
const finalizersMask = strategy => self => contextWithEffect(context => match(Context_getOption(context, scopeTag), {
  onNone: () => self(Function_identity),
  onSome: scope => {
    const patch = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
    switch (scope.strategy._tag) {
      case "Parallel":
        return patch(self(parallelFinalizers));
      case "Sequential":
        return patch(self(sequentialFinalizers));
      case "ParallelN":
        return patch(self(parallelNFinalizers(scope.strategy.parallelism)));
    }
  }
}));
/* @internal */
const scopeWith = f => core_flatMap(scopeTag, f);
/* @internal */
const scopedEffect = effect => core_flatMap(scopeMake(), scope => scopeUse(effect, scope));
/* @internal */
const sequentialFinalizers = self => contextWithEffect(context => match(Context_getOption(context, scopeTag), {
  onNone: () => self,
  onSome: scope => {
    switch (scope.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return core_flatMap(scopeFork(scope, ExecutionStrategy_sequential), inner => scopeExtend(self, inner));
    }
  }
}));
/* @internal */
const tagMetricsScoped = (key, value) => labelMetricsScoped([label_make(key, value)]);
/* @internal */
const labelMetricsScoped = labels => fiberRefLocallyScopedWith(currentMetricLabels, old => Array_union(old, labels));
/* @internal */
const using = /*#__PURE__*/Function_dual(2, (self, use) => acquireUseRelease(scopeMake(), scope => core_flatMap(scopeExtend(self, scope), use), (scope, exit) => scopeClose(scope, exit)));
/** @internal */
const validate = /*#__PURE__*/Function_dual(args => isEffect(args[1]), (self, that, options) => validateWith(self, that, (a, b) => [a, b], options));
/** @internal */
const validateWith = /*#__PURE__*/Function_dual(args => isEffect(args[1]), (self, that, f, options) => core_flatten(zipWithOptions(core_exit(self), core_exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f,
  onFailure: (ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
}), options)));
/* @internal */
const validateAllPar = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (elements, f) => core.flatMap(fiberRuntime_partition(elements, f), ([es, bs]) => es.length === 0 ? core.succeed(bs) : core.fail(es)))));
/* @internal */
const validateAllParDiscard = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (elements, f) => core.flatMap(fiberRuntime_partition(elements, f), ([es, _]) => es.length === 0 ? core.void : core.fail(es)))));
/* @internal */
const validateFirst = /*#__PURE__*/Function_dual(args => isIterable(args[0]), (elements, f, options) => core_flip(fiberRuntime_forEach(elements, (a, i) => core_flip(f(a, i)), options)));
/* @internal */
const withClockScoped = value => fiberRefLocallyScopedWith(currentServices, Context_add(clockTag, value));
/* @internal */
const withRandomScoped = value => fiberRefLocallyScopedWith(currentServices, Context_add(randomTag, value));
/* @internal */
const withConfigProviderScoped = value => fiberRefLocallyScopedWith(currentServices, Context_add(configProviderTag, value));
/* @internal */
const withEarlyRelease = self => scopeWith(parent => core_flatMap(scopeFork(parent, executionStrategy_sequential), child => Function_pipe(self, scopeExtend(child), core_map(value => [fiberIdWith(fiberId => scopeClose(child, exitInterrupt(fiberId))), value]))));
/** @internal */
const zipOptions = /*#__PURE__*/Function_dual(args => isEffect(args[1]), (self, that, options) => zipWithOptions(self, that, (a, b) => [a, b], options));
/** @internal */
const zipLeftOptions = /*#__PURE__*/Function_dual(args => isEffect(args[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return core_zipLeft(self, that);
  }
  return zipWithOptions(self, that, (a, _) => a, options);
});
/** @internal */
const zipRightOptions = /*#__PURE__*/Function_dual(args => isEffect(args[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return core_zipRight(self, that);
  }
  return zipWithOptions(self, that, (_, b) => b, options);
});
/** @internal */
const zipWithOptions = /*#__PURE__*/Function_dual(args => isEffect(args[1]), (self, that, f, options) => core_map(fiberRuntime_all([self, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching
}), ([a, a2]) => f(a, a2)));
/* @internal */
const withRuntimeFlagsScoped = update => {
  if (update === RuntimeFlagsPatch_empty) {
    return core_void_;
  }
  return Function_pipe(core_runtimeFlags, core_flatMap(runtimeFlags => {
    const updatedRuntimeFlags = runtimeFlags_patch(runtimeFlags, update);
    const revertRuntimeFlags = runtimeFlags_diff(updatedRuntimeFlags, runtimeFlags);
    return Function_pipe(updateRuntimeFlags(update), core_zipRight(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), core_asVoid);
  }), uninterruptible);
};
// circular with Scope
/** @internal */
const scopeTag = /*#__PURE__*/GenericTag("effect/Scope");
/* @internal */
const scope = scopeTag;
const scopeUnsafeAddFinalizer = (scope, fin) => {
  if (scope.state._tag === "Open") {
    scope.state.finalizers.add(fin);
  }
};
const ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const fin = exit => newScope.close(exit);
      this.state.finalizers.add(fin);
      scopeUnsafeAddFinalizer(newScope, _ => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(fin);
        }
      }));
      return newScope;
    });
  },
  close(exit) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return core_void_;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit
      };
      if (finalizers.length === 0) {
        return core_void_;
      }
      return isSequential(this.strategy) ? Function_pipe(forEachSequential(finalizers, fin => core_exit(fin(exit))), core_flatMap(results => Function_pipe(exitCollectAll(results), map(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? Function_pipe(forEachParUnbounded(finalizers, fin => core_exit(fin(exit)), false), core_flatMap(results => Function_pipe(exitCollectAll(results, {
        parallel: true
      }), map(exitAsVoid), getOrElse(() => exitVoid)))) : Function_pipe(forEachParN(finalizers, this.strategy.parallelism, fin => core_exit(fin(exit)), false), core_flatMap(results => Function_pipe(exitCollectAll(results, {
        parallel: true
      }), map(exitAsVoid), getOrElse(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.add(fin);
      return core_void_;
    });
  }
};
const scopeUnsafeMake = (strategy = executionStrategy_sequential) => {
  const scope = Object.create(ScopeImplProto);
  scope.strategy = strategy;
  scope.state = {
    _tag: "Open",
    finalizers: new Set()
  };
  return scope;
};
/* @internal */
const scopeMake = (strategy = executionStrategy_sequential) => sync(() => scopeUnsafeMake(strategy));
/* @internal */
const scopeExtend = /*#__PURE__*/Function_dual(2, (effect, scope) => mapInputContext(effect,
// @ts-expect-error
Context_merge(Context_make(scopeTag, scope))));
/* @internal */
const scopeUse = /*#__PURE__*/Function_dual(2, (effect, scope) => Function_pipe(effect, scopeExtend(scope), onExit(exit => scope.close(exit))));
// circular with Supervisor
/** @internal */
const fiberRefUnsafeMakeSupervisor = initial => fiberRefUnsafeMakePatch(initial, {
  differ: patch_differ,
  fork: supervisor_patch_empty
});
// circular with FiberRef
/* @internal */
const fiberRefLocallyScoped = /*#__PURE__*/Function_dual(2, (self, value) => core_asVoid(acquireRelease(core_flatMap(fiberRefGet(self), oldValue => core_as(fiberRefSet(self, value), oldValue)), oldValue => fiberRefSet(self, oldValue))));
/* @internal */
const fiberRefLocallyScopedWith = /*#__PURE__*/Function_dual(2, (self, f) => fiberRefGetWith(self, a => fiberRefLocallyScoped(self, f(a))));
/* @internal */
const fiberRefMake = (initial, options) => fiberRefMakeWith(() => core.fiberRefUnsafeMake(initial, options));
/* @internal */
const fiberRefMakeWith = ref => acquireRelease(core.tap(core.sync(ref), ref => core.fiberRefUpdate(ref, identity)), fiberRef => core.fiberRefDelete(fiberRef));
/* @internal */
const fiberRefMakeContext = initial => fiberRefMakeWith(() => core.fiberRefUnsafeMakeContext(initial));
/* @internal */
const fiberRefMakeRuntimeFlags = initial => fiberRefMakeWith(() => core.fiberRefUnsafeMakeRuntimeFlags(initial));
/** @internal */
const currentRuntimeFlags = /*#__PURE__*/fiberRefUnsafeMakeRuntimeFlags(runtimeFlags_none);
/** @internal */
const currentSupervisor = /*#__PURE__*/fiberRefUnsafeMakeSupervisor(supervisor_none);
// circular with Fiber
/* @internal */
const fiberAwaitAll = fibers => core_asVoid(fiber_await(fiberAll(fibers)));
/** @internal */
const fiberAll = fibers => ({
  [FiberTypeId]: fiberVariance,
  id: () => Array_fromIterable(fibers).reduce((id, fiber) => FiberId_combine(id, fiber.id()), FiberId_none),
  await: core_exit(forEachParUnbounded(fibers, fiber => core_flatten(fiber.await), false)),
  children: core_map(forEachParUnbounded(fibers, fiber => fiber.children, false), Array_flatten),
  inheritAll: forEachSequentialDiscard(fibers, fiber => fiber.inheritAll),
  poll: core_map(forEachSequential(fibers, fiber => fiber.poll), reduceRight(Option_some(exitSucceed(new Array())), (optionB, optionA) => {
    switch (optionA._tag) {
      case "None":
        {
          return Option_none();
        }
      case "Some":
        {
          switch (optionB._tag) {
            case "None":
              {
                return Option_none();
              }
            case "Some":
              {
                return Option_some(exitZipWith(optionA.value, optionB.value, {
                  onSuccess: (a, chunk) => [a, ...chunk],
                  onFailure: parallel
                }));
              }
          }
        }
    }
  })),
  interruptAsFork: fiberId => forEachSequentialDiscard(fibers, fiber => fiber.interruptAsFork(fiberId)),
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
});
/* @internal */
const fiberInterruptFork = self => core_asVoid(forkDaemon(interruptFiber(self)));
/* @internal */
const fiberJoinAll = fibers => fiber_join(fiberAll(fibers));
/* @internal */
const fiberScoped = self => acquireRelease(succeed(self), interruptFiber);
//
// circular race
//
/** @internal */
const raceWith = /*#__PURE__*/Function_dual(3, (self, other, options) => raceFibersWith(self, other, {
  onSelfWin: (winner, loser) => core_flatMap(winner.await, exit => {
    switch (exit._tag) {
      case OP_SUCCESS:
        {
          return core_flatMap(winner.inheritAll, () => options.onSelfDone(exit, loser));
        }
      case OP_FAILURE:
        {
          return options.onSelfDone(exit, loser);
        }
    }
  }),
  onOtherWin: (winner, loser) => core_flatMap(winner.await, exit => {
    switch (exit._tag) {
      case OP_SUCCESS:
        {
          return core_flatMap(winner.inheritAll, () => options.onOtherDone(exit, loser));
        }
      case OP_FAILURE:
        {
          return options.onOtherDone(exit, loser);
        }
    }
  })
}));
/** @internal */
const disconnect = self => uninterruptibleMask(restore => fiberIdWith(fiberId => core_flatMap(forkDaemon(restore(self)), fiber => Function_pipe(restore(fiber_join(fiber)), onInterrupt(() => Function_pipe(fiber, interruptAsFork(fiberId)))))));
/** @internal */
const race = /*#__PURE__*/Function_dual(2, (self, that) => fiberIdWith(parentFiberId => raceWith(self, that, {
  onSelfDone: (exit, right) => exitMatchEffect(exit, {
    onFailure: cause => Function_pipe(fiber_join(right), mapErrorCause(cause2 => parallel(cause, cause2))),
    onSuccess: value => Function_pipe(right, interruptAsFiber(parentFiberId), core_as(value))
  }),
  onOtherDone: (exit, left) => exitMatchEffect(exit, {
    onFailure: cause => Function_pipe(fiber_join(left), mapErrorCause(cause2 => parallel(cause2, cause))),
    onSuccess: value => Function_pipe(left, interruptAsFiber(parentFiberId), core_as(value))
  })
})));
/** @internal */
const raceFibersWith = /*#__PURE__*/Function_dual(3, (self, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = MutableRef_make(true);
  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return core_async(cb => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self);
    rightFiber.startFork(other);
  }, FiberId_combine(leftFiber.id(), rightFiber.id()));
}));
const completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
/** @internal */
const ensuring = /*#__PURE__*/Function_dual(2, (self, finalizer) => uninterruptibleMask(restore => matchCauseEffect(restore(self), {
  onFailure: cause1 => matchCauseEffect(finalizer, {
    onFailure: cause2 => failCause(sequential(cause1, cause2)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: a => core_as(finalizer, a)
})));
/** @internal */
const invokeWithInterrupt = (self, entries, onInterrupt) => fiberIdWith(id => core_flatMap(core_flatMap(forkDaemon(core_interruptible(self)), processing => core_async(cb => {
  const counts = entries.map(_ => _.listeners.count);
  const checkDone = () => {
    if (counts.every(count => count === 0)) {
      if (entries.every(_ => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach(f => f());
        onInterrupt?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver(exit => {
    cleanup.forEach(f => f());
    cb(exit);
  });
  const cleanup = entries.map((r, i) => {
    const observer = count => {
      counts[i] = count;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach(f => f());
  });
})), () => suspend(() => {
  const residual = entries.flatMap(entry => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, entry => request_complete(entry.request, exitInterrupt(id)));
})));
/** @internal */
const interruptWhenPossible = /*#__PURE__*/Function_dual(2, (self, all) => fiberRefGetWith(currentRequestMap, map => suspend(() => {
  const entries = Array_fromIterable(all).flatMap(_ => map.has(_) ? [map.get(_)] : []);
  return invokeWithInterrupt(self, entries);
})));
// circular Tracer
/** @internal */
const makeSpanScoped = (name, options) => uninterruptible(withFiberRuntime(fiber => {
  const scope = Context_unsafeGet(fiber.getFiberRef(currentContext), scopeTag);
  const span = unsafeMakeSpan(fiber, name, options);
  const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
  const clock_ = Context_get(fiber.getFiberRef(currentServices), clockTag);
  return core_as(scopeAddFinalizerExit(scope, exit => sync(() => {
    if (span.status._tag === "Ended") {
      return;
    }
    span.end(timingEnabled ? clock_.unsafeCurrentTimeNanos() : BigInt(0), exit);
  })), span);
}));
/* @internal */
const withTracerScoped = value => fiberRefLocallyScopedWith(currentServices, Context_add(tracerTag, value));
/** @internal */
const withSpanScoped = /*#__PURE__*/Function_dual(args => typeof args[0] !== "string", (self, name, options) => core_flatMap(makeSpanScoped(name, options), span => provideService(self, spanTag, span)));
//# sourceMappingURL=fiberRuntime.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/console.js







/** @internal */
const console_console = /*#__PURE__*/core_map( /*#__PURE__*/fiberRefGet(currentServices), /*#__PURE__*/Context_get(console_consoleTag));
/** @internal */
const consoleWith = f => fiberRefGetWith(currentServices, services => f(Context_get(services, console_consoleTag)));
/** @internal */
const withConsole = /*#__PURE__*/Function_dual(2, (effect, value) => fiberRefLocallyWith(effect, currentServices, Context_add(console_consoleTag, value)));
/** @internal */
const withConsoleScoped = console => fiberRefLocallyScopedWith(currentServices, Context_add(console_consoleTag, console));
/** @internal */
const setConsole = console => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(defaultConsole.consoleTag, console)));
/** @internal */
const assert = (condition, ...args) => consoleWith(_ => _.assert(condition, ...args));
/** @internal */
const console_clear = /*#__PURE__*/(/* unused pure expression or super */ null && (consoleWith(_ => _.clear)));
/** @internal */
const count = label => consoleWith(_ => _.count(label));
/** @internal */
const countReset = label => consoleWith(_ => _.countReset(label));
/** @internal */
const debug = (...args) => consoleWith(_ => _.debug(...args));
/** @internal */
const dir = (item, options) => consoleWith(_ => _.dir(item, options));
/** @internal */
const dirxml = (...args) => consoleWith(_ => _.dirxml(...args));
/** @internal */
const error = (...args) => consoleWith(_ => _.error(...args));
/** @internal */
const console_group = options => consoleWith(_ => fiberRuntime.acquireRelease(_.group(options), () => _.groupEnd));
/** @internal */
const info = (...args) => consoleWith(_ => _.info(...args));
/** @internal */
const console_log = (...args) => consoleWith(_ => _.log(...args));
/** @internal */
const table = (tabularData, properties) => consoleWith(_ => _.table(tabularData, properties));
/** @internal */
const time = label => consoleWith(_ => fiberRuntime.acquireRelease(_.time(label), () => _.timeEnd(label)));
/** @internal */
const timeLog = (label, ...args) => consoleWith(_ => _.timeLog(label, ...args));
/** @internal */
const trace = (...args) => consoleWith(_ => _.trace(...args));
/** @internal */
const warn = (...args) => consoleWith(_ => _.warn(...args));
/** @internal */
const withGroup = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(args => core.isEffect(args[0]), (self, options) => consoleWith(_ => core.acquireUseRelease(_.group(options), () => self, () => _.groupEnd)))));
/** @internal */
const withTime = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(args => core.isEffect(args[0]), (self, label) => consoleWith(_ => core.acquireUseRelease(_.time(label), () => self, () => _.timeEnd(label))))));
//# sourceMappingURL=console.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/schedule/interval.js



/** @internal */
const IntervalSymbolKey = "effect/ScheduleInterval";
/** @internal */
const IntervalTypeId = /*#__PURE__*/Symbol.for(IntervalSymbolKey);
/** @internal */
const interval_empty = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
/** @internal */
const interval_make = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return interval_empty;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
/** @internal */
const interval_lessThan = /*#__PURE__*/Function_dual(2, (self, that) => interval_min(self, that) === self);
/** @internal */
const interval_min = /*#__PURE__*/Function_dual(2, (self, that) => {
  if (self.endMillis <= that.startMillis) return self;
  if (that.endMillis <= self.startMillis) return that;
  if (self.startMillis < that.startMillis) return self;
  if (that.startMillis < self.startMillis) return that;
  if (self.endMillis <= that.endMillis) return self;
  return that;
});
/** @internal */
const interval_max = /*#__PURE__*/Function_dual(2, (self, that) => interval_min(self, that) === self ? that : self);
/** @internal */
const interval_isEmpty = self => {
  return self.startMillis >= self.endMillis;
};
/** @internal */
const interval_isNonEmpty = self => {
  return !interval_isEmpty(self);
};
/** @internal */
const intersect = /*#__PURE__*/Function_dual(2, (self, that) => {
  const start = Math.max(self.startMillis, that.startMillis);
  const end = Math.min(self.endMillis, that.endMillis);
  return interval_make(start, end);
});
/** @internal */
const interval_size = self => {
  return Duration_millis(self.endMillis - self.startMillis);
};
/** @internal */
const interval_union = /*#__PURE__*/Function_dual(2, (self, that) => {
  const start = Math.max(self.startMillis, that.startMillis);
  const end = Math.min(self.endMillis, that.endMillis);
  return start < end ? Option_none() : Option_some(interval_make(start, end));
});
/** @internal */
const after = startMilliseconds => {
  return interval_make(startMilliseconds, Number.POSITIVE_INFINITY);
};
/** @internal */
const before = endMilliseconds => {
  return interval_make(Number.NEGATIVE_INFINITY, endMilliseconds);
};
//# sourceMappingURL=interval.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/ScheduleInterval.js

/**
 * @since 2.0.0
 * @category symbols
 */
const ScheduleInterval_IntervalTypeId = IntervalTypeId;
/**
 * Constructs a new interval from the two specified endpoints. If the start
 * endpoint greater than the end endpoint, then a zero size interval will be
 * returned.
 *
 * @since 2.0.0
 * @category constructors
 */
const ScheduleInterval_make = interval_make;
/**
 * An `Interval` of zero-width.
 *
 * @since 2.0.0
 * @category constructors
 */
const ScheduleInterval_empty = interval_empty;
/**
 * Returns `true` if this `Interval` is less than `that` interval, `false`
 * otherwise.
 *
 * @since 2.0.0
 * @category ordering
 */
const ScheduleInterval_lessThan = interval_lessThan;
/**
 * Returns the minimum of two `Interval`s.
 *
 * @since 2.0.0
 * @category ordering
 */
const ScheduleInterval_min = interval_min;
/**
 * Returns the maximum of two `Interval`s.
 *
 * @since 2.0.0
 * @category ordering
 */
const ScheduleInterval_max = interval_max;
/**
 * Returns `true` if the specified `Interval` is empty, `false` otherwise.
 *
 * @since 2.0.0
 * @category ordering
 */
const ScheduleInterval_isEmpty = interval_isEmpty;
/**
 * Returns `true` if the specified `Interval` is non-empty, `false` otherwise.
 *
 * @since 2.0.0
 * @category ordering
 */
const ScheduleInterval_isNonEmpty = interval_isNonEmpty;
/**
 * Computes a new `Interval` which is the intersection of this `Interval` and
 * that `Interval`.
 *
 * @since 2.0.0
 * @category ordering
 */
const ScheduleInterval_intersect = intersect;
/**
 * Calculates the size of the `Interval` as the `Duration` from the start of the
 * interval to the end of the interval.
 *
 * @since 2.0.0
 * @category getters
 */
const ScheduleInterval_size = interval_size;
/**
 * Computes a new `Interval` which is the union of this `Interval` and that
 * `Interval` as a `Some`, otherwise returns `None` if the two intervals cannot
 * form a union.
 *
 * @since 2.0.0
 * @category utils
 */
const ScheduleInterval_union = interval_union;
/**
 * Construct an `Interval` that includes all time equal to and after the
 * specified start time.
 *
 * @since 2.0.0
 * @category constructors
 */
const ScheduleInterval_after = after;
/**
 * Construct an `Interval` that includes all time equal to and before the
 * specified end time.
 *
 * @category constructors
 * @since 2.0.0
 */
const ScheduleInterval_before = before;
//# sourceMappingURL=ScheduleInterval.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/schedule/intervals.js





/** @internal */
const IntervalsSymbolKey = "effect/ScheduleIntervals";
/** @internal */
const IntervalsTypeId = /*#__PURE__*/Symbol.for(IntervalsSymbolKey);
/** @internal */
const intervals_make = intervals => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
/** @internal */
const intervals_empty = /*#__PURE__*/intervals_make( /*#__PURE__*/esm_Chunk_empty());
/** @internal */
const intervals_fromIterable = intervals => Array.from(intervals).reduce((intervals, interval) => Function_pipe(intervals, intervals_union(intervals_make(Chunk_of(interval)))), intervals_empty);
/** @internal */
const intervals_union = /*#__PURE__*/Function_dual(2, (self, that) => {
  if (!isNonEmpty(that.intervals)) {
    return self;
  }
  if (!isNonEmpty(self.intervals)) {
    return that;
  }
  if (Chunk_headNonEmpty(self.intervals).startMillis < Chunk_headNonEmpty(that.intervals).startMillis) {
    return unionLoop(Chunk_tailNonEmpty(self.intervals), that.intervals, Chunk_headNonEmpty(self.intervals), esm_Chunk_empty());
  }
  return unionLoop(self.intervals, Chunk_tailNonEmpty(that.intervals), Chunk_headNonEmpty(that.intervals), esm_Chunk_empty());
});
/** @internal */
const unionLoop = (_self, _that, _interval, _acc) => {
  let self = _self;
  let that = _that;
  let interval = _interval;
  let acc = _acc;
  while (isNonEmpty(self) || isNonEmpty(that)) {
    if (!isNonEmpty(self) && isNonEmpty(that)) {
      if (interval.endMillis < Chunk_headNonEmpty(that).startMillis) {
        acc = Function_pipe(acc, Chunk_prepend(interval));
        interval = Chunk_headNonEmpty(that);
        that = Chunk_tailNonEmpty(that);
        self = esm_Chunk_empty();
      } else {
        interval = ScheduleInterval_make(interval.startMillis, Chunk_headNonEmpty(that).endMillis);
        that = Chunk_tailNonEmpty(that);
        self = esm_Chunk_empty();
      }
    } else if (isNonEmpty(self) && Chunk_isEmpty(that)) {
      if (interval.endMillis < Chunk_headNonEmpty(self).startMillis) {
        acc = Function_pipe(acc, Chunk_prepend(interval));
        interval = Chunk_headNonEmpty(self);
        that = esm_Chunk_empty();
        self = Chunk_tailNonEmpty(self);
      } else {
        interval = ScheduleInterval_make(interval.startMillis, Chunk_headNonEmpty(self).endMillis);
        that = esm_Chunk_empty();
        self = Chunk_tailNonEmpty(self);
      }
    } else if (isNonEmpty(self) && isNonEmpty(that)) {
      if (Chunk_headNonEmpty(self).startMillis < Chunk_headNonEmpty(that).startMillis) {
        if (interval.endMillis < Chunk_headNonEmpty(self).startMillis) {
          acc = Function_pipe(acc, Chunk_prepend(interval));
          interval = Chunk_headNonEmpty(self);
          self = Chunk_tailNonEmpty(self);
        } else {
          interval = ScheduleInterval_make(interval.startMillis, Chunk_headNonEmpty(self).endMillis);
          self = Chunk_tailNonEmpty(self);
        }
      } else if (interval.endMillis < Chunk_headNonEmpty(that).startMillis) {
        acc = Function_pipe(acc, Chunk_prepend(interval));
        interval = Chunk_headNonEmpty(that);
        that = Chunk_tailNonEmpty(that);
      } else {
        interval = ScheduleInterval_make(interval.startMillis, Chunk_headNonEmpty(that).endMillis);
        that = Chunk_tailNonEmpty(that);
      }
    } else {
      throw new Error(getBugErrorMessage("Intervals.unionLoop"));
    }
  }
  return intervals_make(Function_pipe(acc, Chunk_prepend(interval), Chunk_reverse));
};
/** @internal */
const intervals_intersect = /*#__PURE__*/Function_dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, esm_Chunk_empty()));
/** @internal */
const intersectLoop = (_left, _right, _acc) => {
  let left = _left;
  let right = _right;
  let acc = _acc;
  while (isNonEmpty(left) && isNonEmpty(right)) {
    const interval = Function_pipe(Chunk_headNonEmpty(left), ScheduleInterval_intersect(Chunk_headNonEmpty(right)));
    const intervals = ScheduleInterval_isEmpty(interval) ? acc : Function_pipe(acc, Chunk_prepend(interval));
    if (Function_pipe(Chunk_headNonEmpty(left), ScheduleInterval_lessThan(Chunk_headNonEmpty(right)))) {
      left = Chunk_tailNonEmpty(left);
    } else {
      right = Chunk_tailNonEmpty(right);
    }
    acc = intervals;
  }
  return intervals_make(Chunk_reverse(acc));
};
/** @internal */
const start = self => {
  return Function_pipe(self.intervals, Chunk_head, getOrElse(() => ScheduleInterval_empty)).startMillis;
};
/** @internal */
const end = self => {
  return Function_pipe(self.intervals, Chunk_head, getOrElse(() => ScheduleInterval_empty)).endMillis;
};
/** @internal */
const intervals_lessThan = /*#__PURE__*/Function_dual(2, (self, that) => start(self) < start(that));
/** @internal */
const intervals_isNonEmpty = self => {
  return isNonEmpty(self.intervals);
};
/** @internal */
const intervals_max = /*#__PURE__*/Function_dual(2, (self, that) => intervals_lessThan(self, that) ? that : self);
//# sourceMappingURL=intervals.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/ScheduleIntervals.js

/**
 * @since 2.0.0
 * @category symbols
 */
const ScheduleIntervals_IntervalsTypeId = IntervalsTypeId;
/**
 * Creates a new `Intervals` from a `List` of `Interval`s.
 *
 * @since 2.0.0
 * @category constructors
 */
const ScheduleIntervals_make = intervals_make;
/**
 * Constructs an empty list of `Interval`s.
 *
 * @since 2.0.0
 * @category constructors
 */
const ScheduleIntervals_empty = intervals_empty;
/**
 * Creates `Intervals` from the specified `Iterable<Interval>`.
 *
 * @since 2.0.0
 * @category constructors
 */
const ScheduleIntervals_fromIterable = intervals_fromIterable;
/**
 * Computes the union of this `Intervals` and  that `Intervals`
 *
 * @since 2.0.0
 * @category utils
 */
const ScheduleIntervals_union = intervals_union;
/**
 * Produces the intersection of this `Intervals` and that `Intervals`.
 *
 * @since 2.0.0
 * @category utils
 */
const ScheduleIntervals_intersect = intervals_intersect;
/**
 * The start of the earliest interval in the specified `Intervals`.
 *
 * @since 2.0.0
 * @category getters
 */
const ScheduleIntervals_start = start;
/**
 * The end of the latest interval in the specified `Intervals`.
 *
 * @since 2.0.0
 * @category getters
 */
const ScheduleIntervals_end = end;
/**
 * Returns `true` if the start of this `Intervals` is before the start of that
 * `Intervals`, `false` otherwise.
 *
 * @since 2.0.0
 * @category ordering
 */
const ScheduleIntervals_lessThan = intervals_lessThan;
/**
 * Returns `true` if this `Intervals` is non-empty, `false` otherwise.
 *
 * @since 2.0.0
 * @category getters
 */
const ScheduleIntervals_isNonEmpty = intervals_isNonEmpty;
/**
 * Returns the maximum of the two `Intervals` (i.e. which has the latest start).
 *
 * @since 2.0.0
 * @category ordering
 */
const ScheduleIntervals_max = intervals_max;
//# sourceMappingURL=ScheduleIntervals.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/schedule/decision.js


/** @internal */
const OP_CONTINUE = "Continue";
/** @internal */
const decision_OP_DONE = "Done";
/** @internal */
const _continue = intervals => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
/** @internal */
const continueWith = interval => {
  return {
    _tag: OP_CONTINUE,
    intervals: ScheduleIntervals_make(Chunk_of(interval))
  };
};
/** @internal */
const decision_done = {
  _tag: decision_OP_DONE
};
/** @internal */
const isContinue = self => {
  return self._tag === OP_CONTINUE;
};
/** @internal */
const decision_isDone = self => {
  return self._tag === decision_OP_DONE;
};
//# sourceMappingURL=decision.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/ScheduleDecision.js
/**
 * @since 2.0.0
 */

const ScheduleDecision_continue = _continue;

/**
 * @since 2.0.0
 * @category constructors
 */
const ScheduleDecision_continueWith = continueWith;
/**
 * @since 2.0.0
 * @category constructors
 */
const ScheduleDecision_done = decision_done;
/**
 * @since 2.0.0
 * @category refinements
 */
const ScheduleDecision_isContinue = isContinue;
/**
 * @since 2.0.0
 * @category refinements
 */
const ScheduleDecision_isDone = decision_isDone;
//# sourceMappingURL=ScheduleDecision.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/schedule.js



















/** @internal */
const ScheduleSymbolKey = "effect/Schedule";
/** @internal */
const ScheduleTypeId = /*#__PURE__*/Symbol.for(ScheduleSymbolKey);
/** @internal */
const isSchedule = u => Predicate_hasProperty(u, ScheduleTypeId);
/** @internal */
const ScheduleDriverSymbolKey = "effect/ScheduleDriver";
/** @internal */
const ScheduleDriverTypeId = /*#__PURE__*/Symbol.for(ScheduleDriverSymbolKey);
const scheduleVariance = {
  /* c8 ignore next */
  _Out: _ => _,
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
const scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: _ => _,
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
/** @internal */
class ScheduleImpl {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step) {
    this.initial = initial;
    this.step = step;
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
class ScheduleDriverImpl {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule, ref) {
    this.schedule = schedule;
    this.ref = ref;
  }
  get state() {
    return core_map(ref_get(this.ref), tuple => tuple[1]);
  }
  get last() {
    return core_flatMap(ref_get(this.ref), ([element, _]) => {
      switch (element._tag) {
        case "None":
          {
            return failSync(() => new NoSuchElementException());
          }
        case "Some":
          {
            return succeed(element.value);
          }
      }
    });
  }
  get reset() {
    return ref_set(this.ref, [Option_none(), this.schedule.initial]);
  }
  next(input) {
    return Function_pipe(core_map(ref_get(this.ref), tuple => tuple[1]), core_flatMap(state => Function_pipe(Clock_currentTimeMillis, core_flatMap(now => Function_pipe(suspend(() => this.schedule.step(now, input, state)), core_flatMap(([state, out, decision]) => {
      const setState = ref_set(this.ref, [Option_some(out), state]);
      if (ScheduleDecision_isDone(decision)) {
        return core_zipRight(setState, core_fail(Option_none()));
      }
      const millis = ScheduleIntervals_start(decision.intervals) - now;
      if (millis <= 0) {
        return core_as(setState, out);
      }
      return Function_pipe(setState, core_zipRight(core_effect_sleep(Duration_millis(millis))), core_as(out));
    }))))));
  }
}
/** @internal */
const makeWithState = (initial, step) => new ScheduleImpl(initial, step);
/** @internal */
const addDelay = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => addDelayEffect(self, out => core.sync(() => f(out))))));
/** @internal */
const addDelayEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => modifyDelayEffect(self, (out, duration) => core.map(f(out), delay => Duration.sum(duration, Duration.decode(delay)))))));
/** @internal */
const schedule_andThen = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => schedule_map(andThenEither(self, that), Either.merge))));
/** @internal */
const andThenEither = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => makeWithState([self.initial, that.initial, true], (now, input, state) => state[2] ? core.flatMap(self.step(now, input, state[0]), ([lState, out, decision]) => {
  if (ScheduleDecision.isDone(decision)) {
    return core.map(that.step(now, input, state[1]), ([rState, out, decision]) => [[lState, rState, false], Either.right(out), decision]);
  }
  return core.succeed([[lState, state[1], true], Either.left(out), decision]);
}) : core.map(that.step(now, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], Either.right(out), decision])))));
/** @internal */
const schedule_as = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, out) => schedule_map(self, () => out))));
/** @internal */
const schedule_asVoid = self => schedule_map(self, constVoid);
/** @internal */
const bothInOut = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => makeWithState([self.initial, that.initial], (now, [in1, in2], state) => core.zipWith(self.step(now, in1, state[0]), that.step(now, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {
  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {
    const interval = pipe(lDecision.intervals, Intervals.union(rDecision.intervals));
    return [[lState, rState], [out, out2], ScheduleDecision.continue(interval)];
  }
  return [[lState, rState], [out, out2], ScheduleDecision.done];
})))));
/** @internal */
const check = /*#__PURE__*/Function_dual(2, (self, test) => checkEffect(self, (input, out) => sync(() => test(input, out))));
/** @internal */
const checkEffect = /*#__PURE__*/Function_dual(2, (self, test) => makeWithState(self.initial, (now, input, state) => core_flatMap(self.step(now, input, state), ([state, out, decision]) => {
  if (ScheduleDecision_isDone(decision)) {
    return succeed([state, out, ScheduleDecision_done]);
  }
  return core_map(test(input, out), cont => cont ? [state, out, decision] : [state, out, ScheduleDecision_done]);
})));
/** @internal */
const collectAllInputs = () => collectAllOutputs(schedule_identity());
/** @internal */
const collectAllOutputs = self => schedule_reduce(self, Chunk.empty(), (outs, out) => pipe(outs, Chunk.append(out)));
/** @internal */
const collectUntil = f => collectAllOutputs(recurUntil(f));
/** @internal */
const collectUntilEffect = f => collectAllOutputs(recurUntilEffect(f));
/** @internal */
const collectWhile = f => collectAllOutputs(recurWhile(f));
/** @internal */
const collectWhileEffect = f => collectAllOutputs(recurWhileEffect(f));
/** @internal */
const schedule_compose = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => makeWithState([self.initial, that.initial], (now, input, state) => core.flatMap(self.step(now, input, state[0]), ([lState, out, lDecision]) => core.map(that.step(now, out, state[1]), ([rState, out2, rDecision]) => ScheduleDecision.isDone(lDecision) ? [[lState, rState], out2, ScheduleDecision.done] : ScheduleDecision.isDone(rDecision) ? [[lState, rState], out2, ScheduleDecision.done] : [[lState, rState], out2, ScheduleDecision.continue(pipe(lDecision.intervals, Intervals.max(rDecision.intervals)))]))))));
/** @internal */
const schedule_mapInput = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => mapInputEffect(self, input2 => core.sync(() => f(input2))))));
/** @internal */
const schedule_mapInputContext = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.mapInputContext(self.step(now, input, state), f)))));
/** @internal */
const mapInputEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => makeWithState(self.initial, (now, input2, state) => core.flatMap(f(input2), input => self.step(now, input, state))))));
/** @internal */
const cron = expression => {
  const parsed = Cron.isCron(expression) ? Either.right(expression) : Cron.parse(expression);
  return makeWithState([true, [Number.MIN_SAFE_INTEGER, 0, 0]], (now, _, [initial, previous]) => {
    if (now < previous[0]) {
      return core.succeed([[false, previous], [previous[1], previous[2]], ScheduleDecision.continueWith(Interval.make(previous[1], previous[2]))]);
    }
    if (Either.isLeft(parsed)) {
      return core.die(parsed.left);
    }
    const cron = parsed.right;
    const date = new Date(now);
    let next;
    if (initial && Cron.match(cron, date)) {
      next = now;
    } else {
      const result = Cron.next(cron, date);
      next = result.getTime();
    }
    const start = beginningOfMinute(next);
    const end = endOfMinute(next);
    const interval = Interval.make(start, end);
    return core.succeed([[false, [next, start, end]], [start, end], ScheduleDecision.continueWith(interval)]);
  });
};
/** @internal */
const dayOfMonth = day => {
  return makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {
    if (!Number.isInteger(day) || day < 1 || 31 < day) {
      return core.dieSync(() => new core.IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));
    }
    const n = state[1];
    const initial = n === 0;
    const day0 = nextDayOfMonth(now, day, initial);
    const start = beginningOfDay(day0);
    const end = endOfDay(day0);
    const interval = Interval.make(start, end);
    return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);
  });
};
/** @internal */
const dayOfWeek = day => {
  return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {
    if (!Number.isInteger(day) || day < 1 || 7 < day) {
      return core.dieSync(() => new core.IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));
    }
    const n = state[1];
    const initial = n === 0;
    const day0 = nextDay(now, day, initial);
    const start = beginningOfDay(day0);
    const end = endOfDay(day0);
    const interval = Interval.make(start, end);
    return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);
  });
};
/** @internal */
const delayed = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => delayedEffect(self, duration => core.sync(() => f(duration))))));
/** @internal */
const delayedEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => modifyDelayEffect(self, (_, delay) => f(delay)))));
/** @internal */
const delayedSchedule = schedule => addDelay(schedule, x => x);
/** @internal */
const delays = self => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), core.flatMap(([state, _, decision]) => {
  if (ScheduleDecision.isDone(decision)) {
    return core.succeed([state, Duration.zero, decision]);
  }
  return core.succeed([state, Duration.millis(Intervals.start(decision.intervals) - now), decision]);
})));
/** @internal */
const schedule_mapBoth = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, {
  onInput,
  onOutput
}) => schedule_map(schedule_mapInput(self, onInput), onOutput))));
/** @internal */
const mapBothEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, {
  onInput,
  onOutput
}) => schedule_mapEffect(mapInputEffect(self, onInput), onOutput))));
/** @internal */
const driver = self => Function_pipe(ref_make([Option_none(), self.initial]), core_map(ref => new ScheduleDriverImpl(self, ref)));
/** @internal */
const duration = durationInput => {
  const duration = Duration.decode(durationInput);
  const durationMillis = Duration.toMillis(duration);
  return makeWithState(true, (now, _, state) => core.succeed(state ? [false, duration, ScheduleDecision.continueWith(Interval.after(now + durationMillis))] : [false, Duration.zero, ScheduleDecision.done]));
};
/** @internal */
const schedule_either = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => schedule_union(self, that))));
/** @internal */
const eitherWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, that, f) => schedule_unionWith(self, that, f))));
/** @internal */
const schedule_ensuring = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, finalizer) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => ScheduleDecision.isDone(decision) ? core.as(finalizer, [state, out, decision]) : core.succeed([state, out, decision]))))));
/** @internal */
const schedule_exponential = (baseInput, factor = 2.0) => {
  const base = Duration.decode(baseInput);
  return delayedSchedule(schedule_map(schedule_forever, i => Duration.times(base, Math.pow(factor, i))));
};
/** @internal */
const fibonacci = oneInput => {
  const one = Duration.decode(oneInput);
  return delayedSchedule(pipe(schedule_unfold([one, one], ([a, b]) => [b, Duration.sum(a, b)]), schedule_map(out => out[0])));
};
/** @internal */
const fixed = intervalInput => {
  const interval = Duration.decode(intervalInput);
  const intervalMillis = Duration.toMillis(interval);
  return makeWithState([Option.none(), 0], (now, _, [option, n]) => core.sync(() => {
    switch (option._tag) {
      case "None":
        {
          return [[Option.some([now, now + intervalMillis]), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + intervalMillis))];
        }
      case "Some":
        {
          const [startMillis, lastRun] = option.value;
          const runningBehind = now > lastRun + intervalMillis;
          const boundary = Equal.equals(interval, Duration.zero) ? interval : Duration.millis(intervalMillis - (now - startMillis) % intervalMillis);
          const sleepTime = Equal.equals(boundary, Duration.zero) ? interval : boundary;
          const nextRun = runningBehind ? now : now + Duration.toMillis(sleepTime);
          return [[Option.some([startMillis, nextRun]), n + 1], n, ScheduleDecision.continueWith(Interval.after(nextRun))];
        }
    }
  }));
};
/** @internal */
const fromDelay = delay => duration(delay);
/** @internal */
const fromDelays = (delay, ...delays) => makeWithState([[delay, ...delays].map(_ => Duration.decode(_)), true], (now, _, [durations, cont]) => core.sync(() => {
  if (cont) {
    const x = durations[0];
    const interval = Interval.after(now + Duration.toMillis(x));
    if (durations.length >= 2) {
      return [[durations.slice(1), true], x, ScheduleDecision.continueWith(interval)];
    }
    const y = durations.slice(1);
    return [[[x, ...y], false], x, ScheduleDecision.continueWith(interval)];
  }
  return [[durations, false], Duration.zero, ScheduleDecision.done];
}));
/** @internal */
const fromFunction = f => schedule_map(schedule_identity(), f);
/** @internal */
const hourOfDay = hour => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {
  if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {
    return core.dieSync(() => new core.IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));
  }
  const n = state[1];
  const initial = n === 0;
  const hour0 = nextHour(now, hour, initial);
  const start = beginningOfHour(hour0);
  const end = endOfHour(hour0);
  const interval = Interval.make(start, end);
  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);
});
/** @internal */
const schedule_identity = () => makeWithState(void 0, (now, input, state) => core.succeed([state, input, ScheduleDecision.continueWith(Interval.after(now))]));
/** @internal */
const schedule_intersect = /*#__PURE__*/Function_dual(2, (self, that) => intersectWith(self, that, ScheduleIntervals_intersect));
/** @internal */
const intersectWith = /*#__PURE__*/Function_dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => Function_pipe(core_zipWith(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), core_flatMap(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (ScheduleDecision_isContinue(lDecision) && ScheduleDecision_isContinue(rDecision)) {
    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out, out2], ScheduleDecision_done]);
}))));
/** @internal */
const intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (ScheduleIntervals_isNonEmpty(combined)) {
    return succeed([[lState, rState], [out, out2], ScheduleDecision_continue(combined)]);
  }
  if (Function_pipe(lInterval, ScheduleIntervals_lessThan(rInterval))) {
    return core_flatMap(self.step(ScheduleIntervals_end(lInterval), input, lState), ([lState, out, decision]) => {
      if (ScheduleDecision_isDone(decision)) {
        return succeed([[lState, rState], [out, out2], ScheduleDecision_done]);
      }
      return intersectWithLoop(self, that, input, lState, out, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return core_flatMap(that.step(ScheduleIntervals_end(rInterval), input, rState), ([rState, out2, decision]) => {
    if (ScheduleDecision_isDone(decision)) {
      return succeed([[lState, rState], [out, out2], ScheduleDecision_done]);
    }
    return intersectWithLoop(self, that, input, lState, out, lInterval, rState, out2, decision.intervals, f);
  });
};
/** @internal */
const jittered = self => jitteredWith(self, {
  min: 0.8,
  max: 1.2
});
/** @internal */
const jitteredWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, options) => {
  const {
    max,
    min
  } = Object.assign({
    min: 0.8,
    max: 1.2
  }, options);
  return delayedEffect(self, duration => core.map(Random.next, random => {
    const d = Duration.toMillis(duration);
    const jittered = d * min * (1 - random) + d * max * random;
    return Duration.millis(jittered);
  }));
})));
/** @internal */
const schedule_linear = baseInput => {
  const base = Duration.decode(baseInput);
  return delayedSchedule(schedule_map(schedule_forever, i => Duration.times(base, i + 1)));
};
/** @internal */
const schedule_map = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => schedule_mapEffect(self, out => core.sync(() => f(out))))));
/** @internal */
const schedule_mapEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => core.map(f(out), out2 => [state, out2, decision]))))));
/** @internal */
const minuteOfHour = minute => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {
  if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {
    return core.dieSync(() => new core.IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const minute0 = nextMinute(now, minute, initial);
  const start = beginningOfMinute(minute0);
  const end = endOfMinute(minute0);
  const interval = Interval.make(start, end);
  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);
});
/** @internal */
const modifyDelay = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => modifyDelayEffect(self, (out, duration) => core.sync(() => f(out, duration))))));
/** @internal */
const modifyDelayEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => {
  if (ScheduleDecision.isDone(decision)) {
    return core.succeed([state, out, decision]);
  }
  const intervals = decision.intervals;
  const delay = Interval.size(Interval.make(now, Intervals.start(intervals)));
  return core.map(f(out, delay), durationInput => {
    const duration = Duration.decode(durationInput);
    const oldStart = Intervals.start(intervals);
    const newStart = now + Duration.toMillis(duration);
    const delta = newStart - oldStart;
    const newEnd = Math.min(Math.max(0, Intervals.end(intervals) + delta), Number.MAX_SAFE_INTEGER);
    const newInterval = Interval.make(newStart, newEnd);
    return [state, out, ScheduleDecision.continueWith(newInterval)];
  });
})))));
/** @internal */
const onDecision = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => core.as(f(out, decision), [state, out, decision]))))));
/** @internal */
const passthrough = self => makeWithState(self.initial, (now, input, state) => Function_pipe(self.step(now, input, state), core_map(([state, _, decision]) => [state, input, decision])));
/** @internal */
const schedule_provideContext = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, context) => makeWithState(self.initial, (now, input, state) => core.provideContext(self.step(now, input, state), context)))));
/** @internal */
const schedule_provideService = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, tag, service) => makeWithState(self.initial, (now, input, state) => core.contextWithEffect(env => core.provideContext(
// @ts-expect-error
self.step(now, input, state), Context.add(env, tag, service)))))));
/** @internal */
const recurUntil = f => untilInput(schedule_identity(), f);
/** @internal */
const recurUntilEffect = f => untilInputEffect(schedule_identity(), f);
/** @internal */
const recurUntilOption = pf => untilOutput(schedule_map(schedule_identity(), pf), Option.isSome);
/** @internal */
const recurUpTo = durationInput => {
  const duration = Duration.decode(durationInput);
  return whileOutput(elapsed, elapsed => Duration.lessThan(elapsed, duration));
};
/** @internal */
const recurWhile = f => whileInput(schedule_identity(), f);
/** @internal */
const recurWhileEffect = f => whileInputEffect(schedule_identity(), f);
/** @internal */
const recurs = n => whileOutput(schedule_forever, out => out < n);
/** @internal */
const schedule_reduce = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, zero, f) => schedule_reduceEffect(self, zero, (z, out) => core.sync(() => f(z, out))))));
/** @internal */
const schedule_reduceEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, zero, f) => makeWithState([self.initial, zero], (now, input, [s, z]) => core.flatMap(self.step(now, input, s), ([s, out, decision]) => ScheduleDecision.isDone(decision) ? core.succeed([[s, z], z, decision]) : core.map(f(z, out), z2 => [[s, z2], z, decision]))))));
/** @internal */
const repeatForever = self => makeWithState(self.initial, (now, input, state) => {
  const step = (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => ScheduleDecision.isDone(decision) ? step(now, input, self.initial) : core.succeed([state, out, decision]));
  return step(now, input, state);
});
/** @internal */
const repetitions = self => schedule_reduce(self, 0, (n, _) => n + 1);
/** @internal */
const resetAfter = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, durationInput) => {
  const duration = Duration.decode(durationInput);
  return pipe(self, schedule_intersect(elapsed), resetWhen(([, time]) => Duration.greaterThanOrEqualTo(time, duration)), schedule_map(out => out[0]));
})));
/** @internal */
const resetWhen = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => f(out) ? self.step(now, input, self.initial) : core.succeed([state, out, decision]))))));
/** @internal */
const run = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, now, input) => pipe(runLoop(self, now, Chunk.fromIterable(input), self.initial, Chunk.empty()), core.map(list => Chunk.reverse(list))))));
/** @internal */
const runLoop = (self, now, inputs, state, acc) => {
  if (!Chunk.isNonEmpty(inputs)) {
    return core.succeed(acc);
  }
  const input = Chunk.headNonEmpty(inputs);
  const nextInputs = Chunk.tailNonEmpty(inputs);
  return core.flatMap(self.step(now, input, state), ([state, out, decision]) => {
    if (ScheduleDecision.isDone(decision)) {
      return core.sync(() => pipe(acc, Chunk.prepend(out)));
    }
    return runLoop(self, Intervals.start(decision.intervals), nextInputs, state, Chunk.prepend(acc, out));
  });
};
/** @internal */
const secondOfMinute = second => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {
  if (!Number.isInteger(second) || second < 0 || 59 < second) {
    return core.dieSync(() => new core.IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const second0 = nextSecond(now, second, initial);
  const start = beginningOfSecond(second0);
  const end = endOfSecond(second0);
  const interval = Interval.make(start, end);
  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);
});
/** @internal */
const spaced = duration => addDelay(schedule_forever, () => duration);
/** @internal */
const schedule_succeed = value => schedule_map(schedule_forever, () => value);
/** @internal */
const schedule_sync = evaluate => schedule_map(schedule_forever, evaluate);
/** @internal */
const tapInput = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.zipRight(f(input), self.step(now, input, state))))));
/** @internal */
const tapOutput = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.tap(self.step(now, input, state), ([, out]) => f(out))))));
/** @internal */
const schedule_unfold = (initial, f) => makeWithState(initial, (now, _, state) => sync(() => [f(state), state, ScheduleDecision_continueWith(ScheduleInterval_after(now))]));
/** @internal */
const schedule_union = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => schedule_unionWith(self, that, Intervals.union))));
/** @internal */
const schedule_unionWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => core.zipWith(self.step(now, input, state[0]), that.step(now, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {
  if (ScheduleDecision.isDone(lDecision) && ScheduleDecision.isDone(rDecision)) {
    return [[lState, rState], [l, r], ScheduleDecision.done];
  }
  if (ScheduleDecision.isDone(lDecision) && ScheduleDecision.isContinue(rDecision)) {
    return [[lState, rState], [l, r], ScheduleDecision.continue(rDecision.intervals)];
  }
  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isDone(rDecision)) {
    return [[lState, rState], [l, r], ScheduleDecision.continue(lDecision.intervals)];
  }
  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {
    const combined = f(lDecision.intervals, rDecision.intervals);
    return [[lState, rState], [l, r], ScheduleDecision.continue(combined)];
  }
  throw new Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues");
})))));
/** @internal */
const untilInput = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => check(self, (input, _) => !f(input)))));
/** @internal */
const untilInputEffect = /*#__PURE__*/Function_dual(2, (self, f) => checkEffect(self, (input, _) => negate(f(input))));
/** @internal */
const untilOutput = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => check(self, (_, out) => !f(out)))));
/** @internal */
const untilOutputEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => checkEffect(self, (_, out) => effect.negate(f(out))))));
/** @internal */
const upTo = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, duration) => schedule_zipLeft(self, recurUpTo(duration)))));
/** @internal */
const whileInput = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => check(self, (input, _) => f(input)))));
/** @internal */
const whileInputEffect = /*#__PURE__*/Function_dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));
/** @internal */
const whileOutput = /*#__PURE__*/Function_dual(2, (self, f) => check(self, (_, out) => f(out)));
/** @internal */
const whileOutputEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => checkEffect(self, (_, out) => f(out)))));
/** @internal */
const windowed = intervalInput => {
  const interval = Duration.decode(intervalInput);
  const millis = Duration.toMillis(interval);
  return makeWithState([Option.none(), 0], (now, _, [option, n]) => {
    switch (option._tag) {
      case "None":
        {
          return core.succeed([[Option.some(now), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + millis))]);
        }
      case "Some":
        {
          return core.succeed([[Option.some(option.value), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + (millis - (now - option.value) % millis)))]);
        }
    }
  });
};
/** @internal */
const schedule_zipLeft = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => schedule_map(schedule_intersect(self, that), out => out[0]))));
/** @internal */
const schedule_zipRight = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => schedule_map(schedule_intersect(self, that), out => out[1]))));
/** @internal */
const schedule_zipWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, that, f) => schedule_map(schedule_intersect(self, that), ([out, out2]) => f(out, out2)))));
// -----------------------------------------------------------------------------
// Seconds
// -----------------------------------------------------------------------------
/** @internal */
const beginningOfSecond = now => {
  const date = new Date(now);
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0).getTime();
};
/** @internal */
const endOfSecond = now => {
  const date = new Date(beginningOfSecond(now));
  return date.setSeconds(date.getSeconds() + 1);
};
/** @internal */
const nextSecond = (now, second, initial) => {
  const date = new Date(now);
  if (date.getSeconds() === second && initial) {
    return now;
  }
  if (date.getSeconds() < second) {
    return date.setSeconds(second);
  }
  // Set seconds to the provided value and add one minute
  const newDate = new Date(date.setSeconds(second));
  return newDate.setTime(newDate.getTime() + 1000 * 60);
};
// -----------------------------------------------------------------------------
// Minutes
// -----------------------------------------------------------------------------
/** @internal */
const beginningOfMinute = now => {
  const date = new Date(now);
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), 0, 0).getTime();
};
/** @internal */
const endOfMinute = now => {
  const date = new Date(beginningOfMinute(now));
  return date.setMinutes(date.getMinutes() + 1);
};
/** @internal */
const nextMinute = (now, minute, initial) => {
  const date = new Date(now);
  if (date.getMinutes() === minute && initial) {
    return now;
  }
  if (date.getMinutes() < minute) {
    return date.setMinutes(minute);
  }
  // Set minutes to the provided value and add one hour
  const newDate = new Date(date.setMinutes(minute));
  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60);
};
// -----------------------------------------------------------------------------
// Hours
// -----------------------------------------------------------------------------
/** @internal */
const beginningOfHour = now => {
  const date = new Date(now);
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), 0, 0, 0).getTime();
};
/** @internal */
const endOfHour = now => {
  const date = new Date(beginningOfHour(now));
  return date.setHours(date.getHours() + 1);
};
/** @internal */
const nextHour = (now, hour, initial) => {
  const date = new Date(now);
  if (date.getHours() === hour && initial) {
    return now;
  }
  if (date.getHours() < hour) {
    return date.setHours(hour);
  }
  // Set hours to the provided value and add one day
  const newDate = new Date(date.setHours(hour));
  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60 * 24);
};
// -----------------------------------------------------------------------------
// Days
// -----------------------------------------------------------------------------
/** @internal */
const beginningOfDay = now => {
  const date = new Date(now);
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0).getTime();
};
/** @internal */
const endOfDay = now => {
  const date = new Date(beginningOfDay(now));
  return date.setDate(date.getDate() + 1);
};
/** @internal */
const nextDay = (now, dayOfWeek, initial) => {
  const date = new Date(now);
  if (date.getDay() === dayOfWeek && initial) {
    return now;
  }
  const nextDayOfWeek = (7 + dayOfWeek - date.getDay()) % 7;
  return date.setDate(date.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));
};
/** @internal */
const nextDayOfMonth = (now, day, initial) => {
  const date = new Date(now);
  if (date.getDate() === day && initial) {
    return now;
  }
  if (date.getDate() < day) {
    return date.setDate(day);
  }
  return findNextMonth(now, day, 1);
};
/** @internal */
const findNextMonth = (now, day, months) => {
  const d = new Date(now);
  const tmp1 = new Date(d.setDate(day));
  const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));
  if (tmp2.getDate() === day) {
    const d2 = new Date(now);
    const tmp3 = new Date(d2.setDate(day));
    return tmp3.setMonth(tmp3.getMonth() + months);
  }
  return findNextMonth(now, day, months + 1);
};
// circular with Effect
const ScheduleDefectTypeId = /*#__PURE__*/Symbol.for("effect/Schedule/ScheduleDefect");
class ScheduleDefect {
  error;
  [ScheduleDefectTypeId];
  constructor(error) {
    this.error = error;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
}
const isScheduleDefect = u => Predicate_hasProperty(u, ScheduleDefectTypeId);
const scheduleDefectWrap = self => catchAll(self, e => core_die(new ScheduleDefect(e)));
const scheduleDefectRefail = self => catchAllCause(self, cause => match(find(cause, _ => isDieType(_) && isScheduleDefect(_.defect) ? Option_some(_.defect) : Option_none()), {
  onNone: () => failCause(cause),
  onSome: error => core_fail(error.error)
}));
/** @internal */
const repeat_Effect = /*#__PURE__*/Function_dual(2, (self, schedule) => repeatOrElse_Effect(self, schedule, (e, _) => core_fail(e)));
/** @internal */
const repeat_combined = /*#__PURE__*/Function_dual(2, (self, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self, options);
  }
  const base = options.schedule ?? passthrough(schedule_forever);
  const withWhile = options.while ? whileInputEffect(base, a => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, a => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? schedule_intersect(withUntil, recurs(options.times)) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
/** @internal */
const repeatOrElse_Effect = /*#__PURE__*/Function_dual(3, (self, schedule, orElse) => core_flatMap(driver(schedule), driver => matchEffect(self, {
  onFailure: error => orElse(error, Option_none()),
  onSuccess: value => repeatOrElseEffectLoop(self, driver, orElse, value)
})));
/** @internal */
const repeatOrElseEffectLoop = (self, driver, orElse, value) => {
  return matchEffect(driver.next(value), {
    onFailure: () => orDie(driver.last),
    onSuccess: b => matchEffect(self, {
      onFailure: error => orElse(error, Option_some(b)),
      onSuccess: value => repeatOrElseEffectLoop(self, driver, orElse, value)
    })
  });
};
/** @internal */
const retry_Effect = /*#__PURE__*/Function_dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => core_fail(e)));
/** @internal */
const retry_combined = /*#__PURE__*/Function_dual(2, (self, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self, options);
  }
  const base = options.schedule ?? schedule_forever;
  const withWhile = options.while ? whileInputEffect(base, e => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, e => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? schedule_intersect(withUntil, recurs(options.times)) : withUntil;
  return scheduleDefectRefail(retry_Effect(self, withTimes));
});
/** @internal */
const retryOrElse_Effect = /*#__PURE__*/Function_dual(3, (self, policy, orElse) => core_flatMap(driver(policy), driver => retryOrElse_EffectLoop(self, driver, orElse)));
/** @internal */
const retryOrElse_EffectLoop = (self, driver, orElse) => {
  return catchAll(self, e => matchEffect(driver.next(e), {
    onFailure: () => Function_pipe(driver.last, orDie, core_flatMap(out => orElse(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self, driver, orElse)
  }));
};
/** @internal */
const schedule_Effect = /*#__PURE__*/Function_dual(2, (self, schedule) => scheduleFrom_Effect(self, void 0, schedule));
/** @internal */
const scheduleFrom_Effect = /*#__PURE__*/Function_dual(3, (self, initial, schedule) => core_flatMap(driver(schedule), driver => scheduleFrom_EffectLoop(self, initial, driver)));
/** @internal */
const scheduleFrom_EffectLoop = (self, initial, driver) => matchEffect(driver.next(initial), {
  onFailure: () => orDie(driver.last),
  onSuccess: () => core_flatMap(self, a => scheduleFrom_EffectLoop(self, a, driver))
});
/** @internal */
const schedule_count = /*#__PURE__*/(/* unused pure expression or super */ null && (schedule_unfold(0, n => n + 1)));
/** @internal */
const elapsed = /*#__PURE__*/(/* unused pure expression or super */ null && (makeWithState( /*#__PURE__*/Option.none(), (now, _, state) => {
  switch (state._tag) {
    case "None":
      {
        return core.succeed([Option.some(now), Duration.zero, ScheduleDecision.continueWith(Interval.after(now))]);
      }
    case "Some":
      {
        return core.succeed([Option.some(state.value), Duration.millis(now - state.value), ScheduleDecision.continueWith(Interval.after(now))]);
      }
  }
})));
/** @internal */
const schedule_forever = /*#__PURE__*/schedule_unfold(0, n => n + 1);
/** @internal */
const schedule_once = /*#__PURE__*/(/* unused pure expression or super */ null && (schedule_asVoid( /*#__PURE__*/recurs(1))));
/** @internal */
const stop = /*#__PURE__*/(/* unused pure expression or super */ null && (schedule_asVoid( /*#__PURE__*/recurs(0))));
//# sourceMappingURL=schedule.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/effect/circular.js






















/** @internal */
class Semaphore {
  permits;
  waiters = new Set();
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = n => core_async(resume => {
    if (this.free < n) {
      const observer = () => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume(succeed(n));
      };
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume(succeed(n));
  });
  updateTaken = f => withFiberRuntime(fiber => {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  });
  release = n => this.updateTaken(taken => taken - n);
  releaseAll = this.updateTaken(_ => 0);
  withPermits = n => self => uninterruptibleMask(restore => core_flatMap(restore(this.take(n)), permits => ensuring(restore(self), this.release(permits))));
}
/** @internal */
const unsafeMakeSemaphore = permits => new Semaphore(permits);
/** @internal */
const makeSemaphore = permits => sync(() => unsafeMakeSemaphore(permits));
/** @internal */
const awaitAllChildren = self => ensuringChildren(self, fiberAwaitAll);
/** @internal */
const circular_cached = /*#__PURE__*/Function_dual(2, (self, timeToLive) => core_map(cachedInvalidateWithTTL(self, timeToLive), tuple => tuple[0]));
/** @internal */
const cachedInvalidateWithTTL = /*#__PURE__*/Function_dual(2, (self, timeToLive) => {
  const duration = decode(timeToLive);
  return core_flatMap(context(), env => core_map(makeSynchronized(Option_none()), cache => [provideContext(getCachedValue(self, duration, cache), env), invalidateCache(cache)]));
});
/** @internal */
const computeCachedValue = (self, timeToLive, start) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return Function_pipe(deferredMake(), core_tap(deferred => intoDeferred(self, deferred)), core_map(deferred => Option_some([start + timeToLiveMillis, deferred])));
};
/** @internal */
const getCachedValue = (self, timeToLive, cache) => uninterruptibleMask(restore => Function_pipe(core_effect_clockWith(clock => clock.currentTimeMillis), core_flatMap(time => updateSomeAndGetEffectSynchronized(cache, option => {
  switch (option._tag) {
    case "None":
      {
        return Option_some(computeCachedValue(self, timeToLive, time));
      }
    case "Some":
      {
        const [end] = option.value;
        return end - time <= 0 ? Option_some(computeCachedValue(self, timeToLive, time)) : Option_none();
      }
  }
})), core_flatMap(option => Option_isNone(option) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option.value[1])))));
/** @internal */
const invalidateCache = cache => ref_set(cache, Option_none());
/** @internal */
const ensuringChild = /*#__PURE__*/Function_dual(2, (self, f) => ensuringChildren(self, children => f(fiberAll(children))));
/** @internal */
const ensuringChildren = /*#__PURE__*/Function_dual(2, (self, children) => core_flatMap(track, supervisor => Function_pipe(supervised(self, supervisor), ensuring(core_flatMap(supervisor.value, children)))));
/** @internal */
const forkAll = /*#__PURE__*/Function_dual(args => isIterable(args[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : core_map(forEachSequential(effects, fork), fiberAll));
/** @internal */
const forkIn = /*#__PURE__*/Function_dual(2, (self, scope) => uninterruptibleMask(restore => core_flatMap(scope.fork(executionStrategy_sequential), child => Function_pipe(restore(self), onExit(exit => child.close(exit)), forkDaemon, core_tap(fiber => child.addFinalizer(() => fiberIdWith(fiberId => equals(fiberId, fiber.id()) ? core_void_ : core_asVoid(interruptFiber(fiber)))))))));
/** @internal */
const forkScoped = self => scopeWith(scope => forkIn(self, scope));
/** @internal */
const fromFiber = fiber => fiber_join(fiber);
/** @internal */
const fromFiberEffect = fiber => suspend(() => core_flatMap(fiber, fiber_join));
const memoKeySymbol = /*#__PURE__*/Symbol.for("effect/Effect/memoizeFunction.key");
class Key {
  a;
  eq;
  [memoKeySymbol] = memoKeySymbol;
  constructor(a, eq) {
    this.a = a;
    this.eq = eq;
  }
  [Equal_symbol](that) {
    if (Predicate_hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol]() {
    return this.eq ? 0 : cached(this, Hash_hash(this.a));
  }
}
/** @internal */
const cachedFunction = (f, eq) => {
  return Function_pipe(sync(() => MutableHashMap_empty()), core_flatMap(makeSynchronized), core_map(ref => a => Function_pipe(ref.modifyEffect(map => {
    const result = Function_pipe(map, MutableHashMap_get(new Key(a, eq)));
    if (Option_isNone(result)) {
      return Function_pipe(deferredMake(), core_tap(deferred => Function_pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), core_map(deferred => [deferred, Function_pipe(map, MutableHashMap_set(new Key(a, eq), deferred))]));
    }
    return succeed([result.value, map]);
  }), core_flatMap(deferredAwait), core_flatMap(([patch, b]) => Function_pipe(patchFiberRefs(patch), core_as(b))))));
};
/** @internal */
const raceFirst = /*#__PURE__*/Function_dual(2, (self, that) => Function_pipe(core_exit(self), race(core_exit(that)), effect => core_flatten(effect)));
/** @internal */
const scheduleForked = /*#__PURE__*/Function_dual(2, (self, schedule) => Function_pipe(self, schedule_Effect(schedule), forkScoped));
/** @internal */
const supervised = /*#__PURE__*/Function_dual(2, (self, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, s => s.zip(supervisor));
  return supervise(self);
});
/** @internal */
const timeout = /*#__PURE__*/Function_dual(2, (self, duration) => timeoutFail(self, {
  onTimeout: () => new TimeoutException(),
  duration
}));
/** @internal */
const timeoutFail = /*#__PURE__*/Function_dual(2, (self, {
  duration,
  onTimeout
}) => core_flatten(timeoutTo(self, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration
})));
/** @internal */
const timeoutFailCause = /*#__PURE__*/Function_dual(2, (self, {
  duration,
  onTimeout
}) => core_flatten(timeoutTo(self, {
  onTimeout: () => failCauseSync(onTimeout),
  onSuccess: succeed,
  duration
})));
/** @internal */
const timeoutOption = /*#__PURE__*/Function_dual(2, (self, duration) => timeoutTo(self, {
  duration,
  onSuccess: Option_some,
  onTimeout: Option_none
}));
/** @internal */
const timeoutTo = /*#__PURE__*/Function_dual(2, (self, {
  duration,
  onSuccess,
  onTimeout
}) => fiberIdWith(parentFiberId => raceFibersWith(self, core_interruptible(core_effect_sleep(duration)), {
  onSelfWin: (winner, loser) => core_flatMap(winner.await, exit => {
    if (exit._tag === "Success") {
      return core_flatMap(winner.inheritAll, () => core_as(interruptAsFiber(loser, parentFiberId), onSuccess(exit.value)));
    } else {
      return core_flatMap(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit.cause));
    }
  }),
  onOtherWin: (winner, loser) => core_flatMap(winner.await, exit => {
    if (exit._tag === "Success") {
      return core_flatMap(winner.inheritAll, () => core_as(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return core_flatMap(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit.cause));
    }
  }),
  otherScope: globalScope
})));
// circular with Synchronized
/** @internal */
const SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
/** @internal */
const SynchronizedTypeId = /*#__PURE__*/Symbol.for(SynchronizedSymbolKey);
/** @internal */
const synchronizedVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
class SynchronizedImpl {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [Readable_TypeId];
  constructor(ref, withLock) {
    this.ref = ref;
    this.withLock = withLock;
    this[Readable_TypeId] = Readable_TypeId;
    this.get = ref_get(this.ref);
  }
  get;
  modify(f) {
    return this.modifyEffect(a => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(Function_pipe(core_flatMap(ref_get(this.ref), f), core_flatMap(([b, a]) => core_as(ref_set(this.ref, a), b))));
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
const makeSynchronized = value => sync(() => unsafeMakeSynchronized(value));
/** @internal */
const unsafeMakeSynchronized = value => {
  const ref = ref_unsafeMake(value);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};
/** @internal */
const updateSomeAndGetEffectSynchronized = /*#__PURE__*/Function_dual(2, (self, pf) => self.modifyEffect(value => {
  const result = pf(value);
  switch (result._tag) {
    case "None":
      {
        return succeed([value, value]);
      }
    case "Some":
      {
        return core_map(result.value, a => [a, a]);
      }
  }
}));
// circular with Fiber
/** @internal */
const zipFiber = /*#__PURE__*/Function_dual(2, (self, that) => zipWithFiber(self, that, (a, b) => [a, b]));
/** @internal */
const zipLeftFiber = /*#__PURE__*/Function_dual(2, (self, that) => zipWithFiber(self, that, (a, _) => a));
/** @internal */
const zipRightFiber = /*#__PURE__*/Function_dual(2, (self, that) => zipWithFiber(self, that, (_, b) => b));
/** @internal */
const zipWithFiber = /*#__PURE__*/Function_dual(3, (self, that, f) => ({
  [FiberTypeId]: fiberVariance,
  id: () => Function_pipe(self.id(), FiberId_getOrElse(that.id())),
  await: Function_pipe(self.await, core_flatten, zipWithOptions(core_flatten(that.await), f, {
    concurrent: true
  }), core_exit),
  children: self.children,
  inheritAll: core_zipRight(that.inheritAll, self.inheritAll),
  poll: core_zipWith(self.poll, that.poll, (optionA, optionB) => Function_pipe(optionA, flatMap(exitA => Function_pipe(optionB, map(exitB => Exit_zipWith(exitA, exitB, {
    onSuccess: f,
    onFailure: parallel
  })))))),
  interruptAsFork: id => core_zipRight(self.interruptAsFork(id), that.interruptAsFork(id)),
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}));
//# sourceMappingURL=circular.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/opCodes/layer.js
/** @internal */
const OP_EXTEND_SCOPE = "ExtendScope";
/** @internal */
const OP_FOLD = "Fold";
/** @internal */
const OP_FRESH = "Fresh";
/** @internal */
const OP_FROM_EFFECT = "FromEffect";
/** @internal */
const OP_SCOPED = "Scoped";
/** @internal */
const OP_SUSPEND = "Suspend";
/** @internal */
const OP_PROVIDE = "Provide";
/** @internal */
const OP_PROVIDE_MERGE = "ProvideMerge";
/** @internal */
const layer_OP_ZIP_WITH = "ZipWith";
//# sourceMappingURL=layer.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Fiber.js




/**
 * @since 2.0.0
 * @category symbols
 */
const Fiber_FiberTypeId = FiberTypeId;
/**
 * @since 2.0.0
 * @category symbols
 */
const Fiber_RuntimeFiberTypeId = RuntimeFiberTypeId;
/**
 * @since 2.0.0
 * @category instances
 */
const Fiber_Order = fiber_Order;
/**
 * Returns `true` if the specified value is a `Fiber`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const Fiber_isFiber = isFiber;
/**
 * Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`
 * otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const Fiber_isRuntimeFiber = isRuntimeFiber;
/**
 * The identity of the fiber.
 *
 * @since 2.0.0
 * @category getters
 */
const Fiber_id = id;
const Fiber_await = fiber_await;

/**
 * Awaits on all fibers to be completed, successfully or not.
 *
 * @since 2.0.0
 * @category destructors
 */
const awaitAll = fiberAwaitAll;
/**
 * Retrieves the immediate children of the fiber.
 *
 * @since 2.0.0
 * @category getters
 */
const Fiber_children = children;
/**
 * Collects all fibers into a single fiber producing an in-order list of the
 * results.
 *
 * @since 2.0.0
 * @category constructors
 */
const Fiber_all = fiberAll;
/**
 * A fiber that is done with the specified `Exit` value.
 *
 * @since 2.0.0
 * @category constructors
 */
const Fiber_done = fiber_done;
/**
 * @since 2.0.0
 * @category destructors
 */
const Fiber_dump = dump;
/**
 * @since 2.0.0
 * @category destructors
 */
const Fiber_dumpAll = dumpAll;
/**
 * A fiber that has already failed with the specified value.
 *
 * @since 2.0.0
 * @category constructors
 */
const Fiber_fail = fiber_fail;
/**
 * Creates a `Fiber` that has already failed with the specified cause.
 *
 * @since 2.0.0
 * @category constructors
 */
const Fiber_failCause = fiber_failCause;
/**
 * Lifts an `Effect` into a `Fiber`.
 *
 * @since 2.0.0
 * @category conversions
 */
const Fiber_fromEffect = fromEffect;
/**
 * Gets the current fiber if one is running.
 *
 * @since 2.0.0
 * @category utilities
 */
const Fiber_getCurrentFiber = getCurrentFiber;
/**
 * Inherits values from all `FiberRef` instances into current fiber. This
 * will resume immediately.
 *
 * @since 2.0.0
 * @category destructors
 */
const inheritAll = fiber_inheritAll;
/**
 * Interrupts the fiber from whichever fiber is calling this method. If the
 * fiber has already exited, the returned effect will resume immediately.
 * Otherwise, the effect will resume when the fiber exits.
 *
 * @since 2.0.0
 * @category interruption
 */
const Fiber_interrupt = interruptFiber;
/**
 * Constructrs a `Fiber` that is already interrupted.
 *
 * @since 2.0.0
 * @category constructors
 */
const Fiber_interrupted = interrupted;
/**
 * Interrupts the fiber as if interrupted from the specified fiber. If the
 * fiber has already exited, the returned effect will resume immediately.
 * Otherwise, the effect will resume when the fiber exits.
 *
 * @since 2.0.0
 * @category interruption
 */
const interruptAs = interruptAsFiber;
/**
 * Interrupts the fiber as if interrupted from the specified fiber. If the
 * fiber has already exited, the returned effect will resume immediately.
 * Otherwise, the effect will resume when the fiber exits.
 *
 * @since 2.0.0
 * @category interruption
 */
const Fiber_interruptAsFork = interruptAsFork;
/**
 * Interrupts all fibers, awaiting their interruption.
 *
 * @since 2.0.0
 * @category interruption
 */
const Fiber_interruptAll = interruptAll;
/**
 * Interrupts all fibers as by the specified fiber, awaiting their
 * interruption.
 *
 * @since 2.0.0
 * @category interruption
 */
const Fiber_interruptAllAs = interruptAllAs;
/**
 * Interrupts the fiber from whichever fiber is calling this method. The
 * interruption will happen in a separate daemon fiber, and the returned
 * effect will always resume immediately without waiting.
 *
 * @since 2.0.0
 * @category interruption
 */
const interruptFork = fiberInterruptFork;
/**
 * Joins the fiber, which suspends the joining fiber until the result of the
 * fiber has been determined. Attempting to join a fiber that has erred will
 * result in a catchable error. Joining an interrupted fiber will result in an
 * "inner interruption" of this fiber, unlike interruption triggered by
 * another fiber, "inner interruption" can be caught and recovered.
 *
 * @since 2.0.0
 * @category destructors
 */
const Fiber_join = fiber_join;
/**
 * Joins all fibers, awaiting their _successful_ completion. Attempting to
 * join a fiber that has erred will result in a catchable error, _if_ that
 * error does not result from interruption.
 *
 * @since 2.0.0
 * @category destructors
 */
const joinAll = fiberJoinAll;
/**
 * Maps over the value the Fiber computes.
 *
 * @since 2.0.0
 * @category mapping
 */
const Fiber_map = fiber_map;
/**
 * Effectually maps over the value the fiber computes.
 *
 * @since 2.0.0
 * @category mapping
 */
const Fiber_mapEffect = fiber_mapEffect;
/**
 * Passes the success of this fiber to the specified callback, and continues
 * with the fiber that it returns.
 *
 * @since 2.0.0
 * @category mapping
 */
const Fiber_mapFiber = mapFiber;
/**
 * Folds over the `Fiber` or `RuntimeFiber`.
 *
 * @since 2.0.0
 * @category folding
 */
const Fiber_match = fiber_match;
/**
 * A fiber that never fails or succeeds.
 *
 * @since 2.0.0
 * @category constructors
 */
const Fiber_never = fiber_never;
/**
 * Returns a fiber that prefers `this` fiber, but falls back to the `that` one
 * when `this` one fails. Interrupting the returned fiber will interrupt both
 * fibers, sequentially, from left to right.
 *
 * @since 2.0.0
 * @category alternatives
 */
const Fiber_orElse = fiber_orElse;
/**
 * Returns a fiber that prefers `this` fiber, but falls back to the `that` one
 * when `this` one fails. Interrupting the returned fiber will interrupt both
 * fibers, sequentially, from left to right.
 *
 * @since 2.0.0
 * @category alternatives
 */
const Fiber_orElseEither = fiber_orElseEither;
/**
 * Tentatively observes the fiber, but returns immediately if it is not
 * already done.
 *
 * @since 2.0.0
 * @category getters
 */
const Fiber_poll = fiber_poll;
/**
 * Pretty-prints a `RuntimeFiber`.
 *
 * @since 2.0.0
 * @category destructors
 */
const Fiber_pretty = fiber_pretty;
/**
 * Returns a chunk containing all root fibers.
 *
 * @since 2.0.0
 * @category constructors
 */
const Fiber_roots = roots;
/**
 * Returns a chunk containing all root fibers.
 *
 * @since 2.0.0
 * @category constructors
 */
const Fiber_unsafeRoots = unsafeRoots;
/**
 * Converts this fiber into a scoped effect. The fiber is interrupted when the
 * scope is closed.
 *
 * @since 2.0.0
 * @category destructors
 */
const scoped = fiberScoped;
/**
 * Returns the `FiberStatus` of a `RuntimeFiber`.
 *
 * @since 2.0.0
 * @category getters
 */
const Fiber_status = fiber_status;
/**
 * Returns a fiber that has already succeeded with the specified value.
 *
 * @since 2.0.0
 * @category constructors
 */
const Fiber_succeed = fiber_succeed;
const Fiber_void_ = fiber_void_;

/**
 * Zips this fiber and the specified fiber together, producing a tuple of
 * their output.
 *
 * @since 2.0.0
 * @category zipping
 */
const Fiber_zip = zipFiber;
/**
 * Same as `zip` but discards the output of that `Fiber`.
 *
 * @since 2.0.0
 * @category zipping
 */
const Fiber_zipLeft = zipLeftFiber;
/**
 * Same as `zip` but discards the output of this `Fiber`.
 *
 * @since 2.0.0
 * @category zipping
 */
const Fiber_zipRight = zipRightFiber;
/**
 * Zips this fiber with the specified fiber, combining their results using the
 * specified combiner function. Both joins and interruptions are performed in
 * sequential order from left to right.
 *
 * @since 2.0.0
 * @category zipping
 */
const Fiber_zipWith = zipWithFiber;
//# sourceMappingURL=Fiber.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Scope.js
/**
 * @since 2.0.0
 */


/**
 * @since 2.0.0
 * @category symbols
 */
const Scope_ScopeTypeId = ScopeTypeId;
/**
 * @since 2.0.0
 * @category symbols
 */
const Scope_CloseableScopeTypeId = CloseableScopeTypeId;
/**
 * @since 2.0.0
 * @category context
 */
const Scope_Scope = scopeTag;
/**
 * Adds a finalizer to this scope. The finalizer is guaranteed to be run when
 * the scope is closed.
 *
 * @since 2.0.0
 * @category utils
 */
const Scope_addFinalizer = scopeAddFinalizer;
/**
 * A simplified version of `addFinalizerWith` when the `finalizer` does not
 * depend on the `Exit` value that the scope is closed with.
 *
 * @since 2.0.0
 * @category utils
 */
const addFinalizerExit = scopeAddFinalizerExit;
/**
 * Closes a scope with the specified exit value, running all finalizers that
 * have been added to the scope.
 *
 * @since 2.0.0
 * @category destructors
 */
const Scope_close = scopeClose;
/**
 * Extends the scope of an `Effect` workflow that needs a scope into this
 * scope by providing it to the workflow but not closing the scope when the
 * workflow completes execution. This allows extending a scoped value into a
 * larger scope.
 *
 * @since 2.0.0
 * @category utils
 */
const Scope_extend = scopeExtend;
/**
 * Forks a new scope that is a child of this scope. The child scope will
 * automatically be closed when this scope is closed.
 *
 * @since 2.0.0
 * @category utils
 */
const Scope_fork = scopeFork;
/**
 * Uses the scope by providing it to an `Effect` workflow that needs a scope,
 * guaranteeing that the scope is closed with the result of that workflow as
 * soon as the workflow completes execution, whether by success, failure, or
 * interruption.
 *
 * @since 2.0.0
 * @category destructors
 */
const use = scopeUse;
/**
 * Creates a Scope where Finalizers will run according to the `ExecutionStrategy`.
 *
 * If an ExecutionStrategy is not provided `sequential` will be used.
 *
 * @since 2.0.0
 * @category constructors
 */
const Scope_make = scopeMake;
//# sourceMappingURL=Scope.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/runtime.js





















/** @internal */
const runtime_unsafeFork = runtime => (self, options) => {
  const fiberId = FiberId_unsafeMake();
  const fiberRefUpdates = [[currentContext, [[fiberId, runtime.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId, options.scheduler]]]);
  }
  let fiberRefs = FiberRefs_updateManyAs(runtime.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId
  });
  if (options?.updateRefs) {
    fiberRefs = options.updateRefs(fiberRefs, fiberId);
  }
  const fiberRuntime = new FiberRuntime(fiberId, fiberRefs, runtime.runtimeFlags);
  let effect = self;
  if (options?.scope) {
    effect = core_flatMap(Scope_fork(options.scope, executionStrategy_sequential), closeableScope => core_zipRight(scopeAddFinalizer(closeableScope, fiberIdWith(id => equals(id, fiberRuntime.id()) ? core_void_ : interruptAsFiber(fiberRuntime, id))), onExit(self, exit => Scope_close(closeableScope, exit))));
  }
  const supervisor = fiberRuntime._supervisor;
  // we can compare by reference here as _supervisor.none is wrapped with globalValue
  if (supervisor !== supervisor_none) {
    supervisor.onStart(runtime.context, effect, Option_none(), fiberRuntime);
    fiberRuntime.addObserver(exit => supervisor.onEnd(exit, fiberRuntime));
  }
  globalScope.add(runtime.runtimeFlags, fiberRuntime);
  // Only an explicit false will prevent immediate execution
  if (options?.immediate === false) {
    fiberRuntime.resume(effect);
  } else {
    fiberRuntime.start(effect);
  }
  return fiberRuntime;
};
/** @internal */
const unsafeRunCallback = runtime => (effect, options = {}) => {
  const fiberRuntime = runtime_unsafeFork(runtime)(effect, options);
  if (options.onExit) {
    fiberRuntime.addObserver(exit => {
      options.onExit(exit);
    });
  }
  return (id, cancelOptions) => unsafeRunCallback(runtime)(Function_pipe(fiberRuntime, interruptAs(id ?? FiberId_none)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? exit => cancelOptions.onExit(Exit_flatten(exit)) : undefined
  });
};
/** @internal */
const unsafeRunSync = runtime => effect => {
  const result = unsafeRunSyncExit(runtime)(effect);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  } else {
    return result.effect_instruction_i0;
  }
};
class AsyncFiberExceptionImpl extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
}
const asyncFiberException = fiber => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error;
};
/** @internal */
const isAsyncFiberException = u => Predicate.isTagged(u, "AsyncFiberException") && "fiber" in u;
/** @internal */
const FiberFailureId = /*#__PURE__*/Symbol.for("effect/Runtime/FiberFailure");
/** @internal */
const FiberFailureCauseId = /*#__PURE__*/Symbol.for("effect/Runtime/FiberFailure/Cause");
class FiberFailureImpl extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause) {
    super();
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause;
    const prettyErrors = cause_prettyErrors(cause);
    if (prettyErrors.length > 0) {
      const head = prettyErrors[0];
      this.name = head.message.split(":")[0];
      this.message = head.message.substring(this.name.length + 2);
      this.stack = pretty(cause);
    }
    this.name = `(FiberFailure) ${this.name}`;
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId]);
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
}
/** @internal */
const fiberFailure = cause => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new FiberFailureImpl(cause);
  Error.stackTraceLimit = limit;
  return error;
};
/** @internal */
const isFiberFailure = u => Predicate.hasProperty(u, FiberFailureId);
const fastPath = effect => {
  const op = effect;
  switch (op._op) {
    case "Failure":
    case "Success":
      {
        // @ts-expect-error
        return op;
      }
    case "Left":
      {
        return exitFail(op.left);
      }
    case "Right":
      {
        return exitSucceed(op.right);
      }
    case "Some":
      {
        return exitSucceed(op.value);
      }
    case "None":
      {
        // @ts-expect-error
        return exitFail(NoSuchElementException());
      }
  }
};
/** @internal */
const unsafeRunSyncExit = runtime => effect => {
  const op = fastPath(effect);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler();
  const fiberRuntime = runtime_unsafeFork(runtime)(effect, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  throw asyncFiberException(fiberRuntime);
};
/** @internal */
const unsafeRunPromise = runtime => (effect, options) => unsafeRunPromiseExit(runtime)(effect, options).then(result => {
  switch (result._tag) {
    case OP_SUCCESS:
      {
        return result.effect_instruction_i0;
      }
    case OP_FAILURE:
      {
        throw fiberFailure(result.effect_instruction_i0);
      }
  }
});
/** @internal */
const unsafeRunPromiseExit = runtime => (effect, options) => new Promise(resolve => {
  const op = fastPath(effect);
  if (op) {
    resolve(op);
  }
  const fiber = runtime_unsafeFork(runtime)(effect);
  fiber.addObserver(exit => {
    resolve(exit);
  });
  if (options?.signal !== undefined) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      });
    }
  }
});
/** @internal */
class RuntimeImpl {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context, runtimeFlags, fiberRefs) {
    this.context = context;
    this.runtimeFlags = runtimeFlags;
    this.fiberRefs = fiberRefs;
  }
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
}
/** @internal */
const runtime_make = options => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
/** @internal */
const runtime_runtime = () => withFiberRuntime((state, status) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status.runtimeFlags, state.getFiberRefs())));
/** @internal */
const defaultRuntimeFlags = /*#__PURE__*/runtimeFlags_make(Interruption, CooperativeYielding, RuntimeMetrics);
/** @internal */
const defaultRuntime = /*#__PURE__*/runtime_make({
  context: /*#__PURE__*/Context_empty(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /*#__PURE__*/FiberRefs_empty()
});
/** @internal */
const runtime_updateRuntimeFlags = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => runtime_make({
  context: self.context,
  runtimeFlags: f(self.runtimeFlags),
  fiberRefs: self.fiberRefs
}))));
/** @internal */
const disableRuntimeFlag = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, flag) => runtime_updateRuntimeFlags(self, runtimeFlags.disable(flag)))));
/** @internal */
const enableRuntimeFlag = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, flag) => runtime_updateRuntimeFlags(self, runtimeFlags.enable(flag)))));
/** @internal */
const updateContext = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => runtime_make({
  context: f(self.context),
  runtimeFlags: self.runtimeFlags,
  fiberRefs: self.fiberRefs
}))));
/** @internal */
const runtime_provideService = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, tag, service) => updateContext(self, Context.add(tag, service)))));
/** @internal */
const runtime_updateFiberRefs = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => runtime_make({
  context: self.context,
  runtimeFlags: self.runtimeFlags,
  fiberRefs: f(self.fiberRefs)
}))));
/** @internal */
const setFiberRef = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, fiberRef, value) => runtime_updateFiberRefs(self, FiberRefs.updateAs({
  fiberId: FiberId.none,
  fiberRef,
  value
})))));
/** @internal */
const deleteFiberRef = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, fiberRef) => runtime_updateFiberRefs(self, FiberRefs.delete(fiberRef)))));
/** @internal */
const unsafeRunEffect = /*#__PURE__*/unsafeRunCallback(defaultRuntime);
/** @internal */
const unsafeForkEffect = /*#__PURE__*/runtime_unsafeFork(defaultRuntime);
/** @internal */
const unsafeRunPromiseEffect = /*#__PURE__*/unsafeRunPromise(defaultRuntime);
/** @internal */
const unsafeRunPromiseExitEffect = /*#__PURE__*/unsafeRunPromiseExit(defaultRuntime);
/** @internal */
const unsafeRunSyncEffect = /*#__PURE__*/unsafeRunSync(defaultRuntime);
/** @internal */
const unsafeRunSyncExitEffect = /*#__PURE__*/unsafeRunSyncExit(defaultRuntime);
// circular with Effect
/** @internal */
const asyncEffect = register => suspend(() => {
  let cleanup = undefined;
  return core_flatMap(deferredMake(), deferred => core_flatMap(runtime_runtime(), runtime => uninterruptibleMask(restore => core_zipRight(fork(restore(matchCauseEffect(register(cb => unsafeRunCallback(runtime)(intoDeferred(cb, deferred))), {
    onFailure: cause => deferredFailCause(deferred, cause),
    onSuccess: cleanup_ => {
      cleanup = cleanup_;
      return core_void_;
    }
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? core_void_))))));
});
//# sourceMappingURL=runtime.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/synchronizedRef.js



/** @internal */
const getAndUpdateEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => self.modifyEffect(value => core.map(f(value), result => [value, result])))));
/** @internal */
const getAndUpdateSomeEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, pf) => self.modifyEffect(value => {
  const result = pf(value);
  switch (result._tag) {
    case "None":
      {
        return core.succeed([value, value]);
      }
    case "Some":
      {
        return core.map(result.value, newValue => [value, newValue]);
      }
  }
}))));
/** @internal */
const synchronizedRef_modify = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => self.modify(f))));
/** @internal */
const modifyEffect = /*#__PURE__*/Function_dual(2, (self, f) => self.modifyEffect(f));
/** @internal */
const modifySomeEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, fallback, pf) => self.modifyEffect(value => pipe(pf(value), Option.getOrElse(() => core.succeed([fallback, value])))))));
/** @internal */
const updateEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => self.modifyEffect(value => core.map(f(value), result => [undefined, result])))));
/** @internal */
const updateAndGetEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => self.modifyEffect(value => core.map(f(value), result => [result, result])))));
/** @internal */
const updateSomeEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, pf) => self.modifyEffect(value => {
  const result = pf(value);
  switch (result._tag) {
    case "None":
      {
        return core.succeed([void 0, value]);
      }
    case "Some":
      {
        return core.map(result.value, a => [void 0, a]);
      }
  }
}))));
//# sourceMappingURL=synchronizedRef.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/layer.js






















/** @internal */
const LayerSymbolKey = "effect/Layer";
/** @internal */
const LayerTypeId = /*#__PURE__*/Symbol.for(LayerSymbolKey);
const layerVariance = {
  /* c8 ignore next */
  _RIn: _ => _,
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _ROut: _ => _
};
/** @internal */
const layer_proto = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const MemoMapTypeIdKey = "effect/Layer/MemoMap";
/** @internal */
const MemoMapTypeId = /*#__PURE__*/Symbol.for(MemoMapTypeIdKey);
/** @internal */
const isLayer = u => Predicate_hasProperty(u, LayerTypeId);
/** @internal */
const isFresh = self => {
  return self._tag === OP_FRESH;
};
// -----------------------------------------------------------------------------
// MemoMap
// -----------------------------------------------------------------------------
/** @internal */
class MemoMapImpl {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer, scope) {
    return Function_pipe(modifyEffect(this.ref, map => {
      const inMap = map.get(layer);
      if (inMap !== undefined) {
        const [acquire, release] = inMap;
        const cached = Function_pipe(acquire, core_flatMap(([patch, b]) => Function_pipe(patchFiberRefs(patch), core_as(b))), onExit(exitMatch({
          onFailure: () => core_void_,
          onSuccess: () => scopeAddFinalizerExit(scope, release)
        })));
        return succeed([cached, map]);
      }
      return Function_pipe(ref_make(0), core_flatMap(observers => Function_pipe(deferredMake(), core_flatMap(deferred => Function_pipe(ref_make(() => core_void_), core_map(finalizerRef => {
        const resource = uninterruptibleMask(restore => Function_pipe(scopeMake(), core_flatMap(innerScope => Function_pipe(restore(core_flatMap(makeBuilder(layer, innerScope, true), f => diffFiberRefs(f(this)))), core_exit, core_flatMap(exit => {
          switch (exit._tag) {
            case OP_FAILURE:
              {
                return Function_pipe(deferredFailCause(deferred, exit.effect_instruction_i0), core_zipRight(scopeClose(innerScope, exit)), core_zipRight(failCause(exit.effect_instruction_i0)));
              }
            case OP_SUCCESS:
              {
                return Function_pipe(ref_set(finalizerRef, exit => Function_pipe(scopeClose(innerScope, exit), whenEffect(ref_modify(observers, n => [n === 1, n - 1])), core_asVoid)), core_zipRight(ref_update(observers, n => n + 1)), core_zipRight(scopeAddFinalizerExit(scope, exit => Function_pipe(sync(() => map.delete(layer)), core_zipRight(ref_get(finalizerRef)), core_flatMap(finalizer => finalizer(exit))))), core_zipRight(deferredSucceed(deferred, exit.effect_instruction_i0)), core_as(exit.effect_instruction_i0[1]));
              }
          }
        })))));
        const memoized = [Function_pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => core_void_,
          onSuccess: () => ref_update(observers, n => n + 1)
        }))), exit => Function_pipe(ref_get(finalizerRef), core_flatMap(finalizer => finalizer(exit)))];
        return [resource, isFresh(layer) ? map : map.set(layer, memoized)];
      }))))));
    }), core_flatten);
  }
}
/** @internal */
const makeMemoMap = /*#__PURE__*/suspend(() => core_map(makeSynchronized(new Map()), ref => new MemoMapImpl(ref)));
/** @internal */
const unsafeMakeMemoMap = () => new MemoMapImpl(circular.unsafeMakeSynchronized(new Map()));
/** @internal */
const build = self => fiberRuntime.scopeWith(scope => buildWithScope(self, scope));
/** @internal */
const buildWithScope = /*#__PURE__*/Function_dual(2, (self, scope) => core_flatMap(makeMemoMap, memoMap => core_flatMap(makeBuilder(self, scope), run => run(memoMap))));
/** @internal */
const buildWithMemoMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, memoMap, scope) => core.flatMap(makeBuilder(self, scope), run => run(memoMap)))));
const makeBuilder = (self, scope, inMemoMap = false) => {
  const op = self;
  switch (op._tag) {
    case "Locally":
      {
        return sync(() => memoMap => op.f(memoMap.getOrElseMemoize(op.self, scope)));
      }
    case "ExtendScope":
      {
        return sync(() => memoMap => scopeWith(scope => memoMap.getOrElseMemoize(op.layer, scope)));
      }
    case "Fold":
      {
        return sync(() => memoMap => Function_pipe(memoMap.getOrElseMemoize(op.layer, scope), matchCauseEffect({
          onFailure: cause => memoMap.getOrElseMemoize(op.failureK(cause), scope),
          onSuccess: value => memoMap.getOrElseMemoize(op.successK(value), scope)
        })));
      }
    case "Fresh":
      {
        return sync(() => _ => Function_pipe(op.layer, buildWithScope(scope)));
      }
    case "FromEffect":
      {
        return inMemoMap ? sync(() => _ => op.effect) : sync(() => memoMap => memoMap.getOrElseMemoize(self, scope));
      }
    case "Provide":
      {
        return sync(() => memoMap => Function_pipe(memoMap.getOrElseMemoize(op.first, scope), core_flatMap(env => Function_pipe(memoMap.getOrElseMemoize(op.second, scope), provideContext(env)))));
      }
    case "Scoped":
      {
        return inMemoMap ? sync(() => _ => scopeExtend(op.effect, scope)) : sync(() => memoMap => memoMap.getOrElseMemoize(self, scope));
      }
    case "Suspend":
      {
        return sync(() => memoMap => memoMap.getOrElseMemoize(op.evaluate(), scope));
      }
    case "ProvideMerge":
      {
        return sync(() => memoMap => Function_pipe(memoMap.getOrElseMemoize(op.first, scope), core_zipWith(memoMap.getOrElseMemoize(op.second, scope), op.zipK)));
      }
    case "ZipWith":
      {
        return sync(() => memoMap => Function_pipe(memoMap.getOrElseMemoize(op.first, scope), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope), op.zipK, {
          concurrent: true
        })));
      }
  }
};
// -----------------------------------------------------------------------------
// Layer
// -----------------------------------------------------------------------------
/** @internal */
const layer_catchAll = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, onFailure) => layer_match(self, {
  onFailure,
  onSuccess: succeedContext
}))));
/** @internal */
const layer_catchAllCause = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, onFailure) => layer_matchCause(self, {
  onFailure,
  onSuccess: succeedContext
}))));
/** @internal */
const layer_die = defect => layer_failCause(Cause.die(defect));
/** @internal */
const layer_dieSync = evaluate => layer_failCauseSync(() => Cause.die(evaluate()));
/** @internal */
const discard = self => layer_map(self, () => Context.empty());
/** @internal */
const layer_context = () => fromEffectContext(core.context());
/** @internal */
const extendScope = self => {
  const extendScope = Object.create(layer_proto);
  extendScope._tag = OpCodes.OP_EXTEND_SCOPE;
  extendScope.layer = self;
  return extendScope;
};
/** @internal */
const layer_fail = error => layer_failCause(Cause.fail(error));
/** @internal */
const layer_failSync = evaluate => layer_failCauseSync(() => Cause.fail(evaluate()));
/** @internal */
const layer_failCause = cause => fromEffectContext(core.failCause(cause));
/** @internal */
const layer_failCauseSync = evaluate => fromEffectContext(core.failCauseSync(evaluate));
/** @internal */
const layer_flatMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => layer_match(self, {
  onFailure: layer_fail,
  onSuccess: f
}))));
/** @internal */
const layer_flatten = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, tag) => layer_flatMap(self, Context.get(tag)))));
/** @internal */
const fresh = self => {
  const fresh = Object.create(layer_proto);
  fresh._tag = OpCodes.OP_FRESH;
  fresh.layer = self;
  return fresh;
};
/** @internal */
const layer_fromEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (a, b) => {
  const tagFirst = Context.isTag(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return fromEffectContext(core.map(effect, service => Context.make(tag, service)));
})));
/** @internal */
const fromEffectDiscard = effect => fromEffectContext(core.map(effect, () => Context.empty()));
/** @internal */
function fromEffectContext(effect) {
  const fromEffect = Object.create(layer_proto);
  fromEffect._tag = OpCodes.OP_FROM_EFFECT;
  fromEffect.effect = effect;
  return fromEffect;
}
/** @internal */
const layer_fiberRefLocally = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, ref, value) => locallyEffect(self, core.fiberRefLocally(ref, value)))));
/** @internal */
const locallyEffect = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => {
  const locally = Object.create(layer_proto);
  locally._tag = "Locally";
  locally.self = self;
  locally.f = f;
  return locally;
})));
/** @internal */
const layer_fiberRefLocallyWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, ref, value) => locallyEffect(self, core.fiberRefLocallyWith(ref, value)))));
/** @internal */
const layer_fiberRefLocallyScoped = (self, value) => scopedDiscard(fiberRuntime.fiberRefLocallyScoped(self, value));
/** @internal */
const layer_fiberRefLocallyScopedWith = (self, value) => scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(self, value));
/** @internal */
const layer_fromFunction = (tagA, tagB, f) => fromEffectContext(core.map(tagA, a => Context.make(tagB, f(a))));
/** @internal */
const launch = self => fiberRuntime.scopedEffect(core.zipRight(fiberRuntime.scopeWith(scope => pipe(self, buildWithScope(scope))), core.never));
/** @internal */
const layer_map = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => layer_flatMap(self, context => succeedContext(f(context))))));
/** @internal */
const layer_mapError = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => layer_catchAll(self, error => layer_failSync(() => f(error))))));
/** @internal */
const layer_matchCause = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  const fold = Object.create(layer_proto);
  fold._tag = OpCodes.OP_FOLD;
  fold.layer = self;
  fold.failureK = onFailure;
  fold.successK = onSuccess;
  return fold;
})));
/** @internal */
const layer_match = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, {
  onFailure,
  onSuccess
}) => layer_matchCause(self, {
  onFailure: cause => {
    const failureOrCause = Cause.failureOrCause(cause);
    switch (failureOrCause._tag) {
      case "Left":
        {
          return onFailure(failureOrCause.left);
        }
      case "Right":
        {
          return layer_failCause(failureOrCause.right);
        }
    }
  },
  onSuccess
}))));
/** @internal */
const layer_memoize = self => fiberRuntime.scopeWith(scope => core.map(effect.memoize(buildWithScope(self, scope)), fromEffectContext));
/** @internal */
const layer_merge = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => layer_zipWith(self, that, (a, b) => Context.merge(a, b)))));
/** @internal */
const layer_mergeAll = (...layers) => {
  let final = layers[0];
  for (let i = 1; i < layers.length; i++) {
    final = layer_merge(final, layers[i]);
  }
  return final;
};
/** @internal */
const layer_orDie = self => layer_catchAll(self, defect => layer_die(defect));
/** @internal */
const layer_orElse = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => layer_catchAll(self, that))));
/** @internal */
const layer_passthrough = self => layer_merge(layer_context(), self);
/** @internal */
const project = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(4, (self, tagA, tagB, f) => layer_map(self, context => Context.make(tagB, f(Context.unsafeGet(context, tagA)))))));
/** @internal */
const retry = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, schedule) => layer_suspend(() => {
  const stateTag = Context.GenericTag("effect/Layer/retry/{ state: unknown }");
  return pipe(layer_succeed(stateTag, {
    state: schedule.initial
  }), layer_flatMap(env => retryLoop(self, schedule, stateTag, pipe(env, Context.get(stateTag)).state)));
}))));
const retryLoop = (self, schedule, stateTag, state) => {
  return pipe(self, layer_catchAll(error => pipe(retryUpdate(schedule, stateTag, error, state), layer_flatMap(env => fresh(retryLoop(self, schedule, stateTag, pipe(env, Context.get(stateTag)).state))))));
};
const retryUpdate = (schedule, stateTag, error, state) => {
  return layer_fromEffect(stateTag, pipe(Clock.currentTimeMillis, core.flatMap(now => pipe(schedule.step(now, error, state), core.flatMap(([state, _, decision]) => ScheduleDecision.isDone(decision) ? core.fail(error) : pipe(Clock.sleep(Duration.millis(Intervals.start(decision.intervals) - now)), core.as({
    state
  })))))));
};
/** @internal */
const layer_scoped = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (a, b) => {
  const tagFirst = Context.isTag(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return scopedContext(core.map(effect, service => Context.make(tag, service)));
})));
/** @internal */
const scopedDiscard = effect => scopedContext(pipe(effect, core.as(Context.empty())));
/** @internal */
const scopedContext = effect => {
  const scoped = Object.create(layer_proto);
  scoped._tag = OpCodes.OP_SCOPED;
  scoped.effect = effect;
  return scoped;
};
/** @internal */
const layer_scope = /*#__PURE__*/(/* unused pure expression or super */ null && (scopedContext( /*#__PURE__*/core.map( /*#__PURE__*/fiberRuntime.acquireRelease( /*#__PURE__*/fiberRuntime.scopeMake(), (scope, exit) => scope.close(exit)), scope => Context.make(Scope.Scope, scope)))));
/** @internal */
const service = tag => layer_fromEffect(tag, tag);
/** @internal */
const layer_succeed = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (a, b) => {
  const tagFirst = Context.isTag(a);
  const tag = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(core.succeed(Context.make(tag, resource)));
})));
/** @internal */
const succeedContext = context => {
  return fromEffectContext(core.succeed(context));
};
/** @internal */
const layer_empty = /*#__PURE__*/(/* unused pure expression or super */ null && (succeedContext( /*#__PURE__*/Context.empty())));
/** @internal */
const layer_suspend = evaluate => {
  const suspend = Object.create(layer_proto);
  suspend._tag = OpCodes.OP_SUSPEND;
  suspend.evaluate = evaluate;
  return suspend;
};
/** @internal */
const layer_sync = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (a, b) => {
  const tagFirst = Context.isTag(a);
  const tag = tagFirst ? a : b;
  const evaluate = tagFirst ? b : a;
  return fromEffectContext(core.sync(() => Context.make(tag, evaluate())));
})));
/** @internal */
const syncContext = evaluate => {
  return fromEffectContext(core.sync(evaluate));
};
/** @internal */
const layer_tap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => layer_flatMap(self, context => fromEffectContext(core.as(f(context), context))))));
/** @internal */
const layer_tapError = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => layer_catchAll(self, e => fromEffectContext(core.flatMap(f(e), () => core.fail(e)))))));
/** @internal */
const layer_tapErrorCause = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, f) => layer_catchAllCause(self, cause => fromEffectContext(core.flatMap(f(cause), () => core.failCause(cause)))))));
/** @internal */
const toRuntime = self => pipe(fiberRuntime.scopeWith(scope => buildWithScope(self, scope)), core.flatMap(context => pipe(runtime.runtime(), core.provideContext(context))));
/** @internal */
const toRuntimeWithMemoMap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, memoMap) => core.flatMap(fiberRuntime.scopeWith(scope => buildWithMemoMap(self, memoMap, scope)), context => pipe(runtime.runtime(), core.provideContext(context))))));
/** @internal */
const provide = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (that, self) => layer_suspend(() => {
  const provideTo = Object.create(layer_proto);
  provideTo._tag = OpCodes.OP_PROVIDE;
  provideTo.first = Object.create(layer_proto, {
    _tag: {
      value: OpCodes.OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: layer_context(),
      enumerable: true
    },
    second: {
      value: self
    },
    zipK: {
      value: (a, b) => pipe(a, Context.merge(b))
    }
  });
  provideTo.second = that;
  return provideTo;
}))));
/** @internal */
const provideMerge = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (that, self) => {
  const zipWith = Object.create(layer_proto);
  zipWith._tag = OpCodes.OP_PROVIDE_MERGE;
  zipWith.first = self;
  zipWith.second = provide(that, self);
  zipWith.zipK = (a, b) => {
    return pipe(a, Context.merge(b));
  };
  return zipWith;
})));
/** @internal */
const layer_zipWith = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(3, (self, that, f) => layer_suspend(() => {
  const zipWith = Object.create(layer_proto);
  zipWith._tag = OpCodes.OP_ZIP_WITH;
  zipWith.first = self;
  zipWith.second = that;
  zipWith.zipK = f;
  return zipWith;
}))));
/** @internal */
const unwrapEffect = self => {
  const tag = Context.GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return layer_flatMap(layer_fromEffect(tag, self), context => Context.get(context, tag));
};
/** @internal */
const unwrapScoped = self => {
  const tag = Context.GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return layer_flatMap(layer_scoped(tag, self), context => Context.get(context, tag));
};
// -----------------------------------------------------------------------------
// tracing
// -----------------------------------------------------------------------------
/** @internal */
const layer_withSpan = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(args => isLayer(args[0]), (self, name, options) => unwrapScoped(core.map(options?.onEnd ? core.tap(fiberRuntime.makeSpanScoped(name, options), span => fiberRuntime.addFinalizer(exit => options.onEnd(span, exit))) : fiberRuntime.makeSpanScoped(name, options), span => layer_withParentSpan(self, span))))));
/** @internal */
const layer_withParentSpan = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, span) => provide(self, succeedContext(Context.make(tracer.spanTag, span))))));
// circular with Effect
const provideSomeLayer = /*#__PURE__*/Function_dual(2, (self, layer) => acquireUseRelease(scopeMake(), scope => core_flatMap(buildWithScope(layer, scope), context => provideSomeContext(self, context)), (scope, exit) => scopeClose(scope, exit)));
const provideSomeRuntime = /*#__PURE__*/Function_dual(2, (self, rt) => {
  const patchRefs = FiberRefsPatch_diff(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = runtimeFlags_diff(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask(restore => withFiberRuntime(fiber => {
    const oldRefs = fiber.getFiberRefs();
    const newRefs = FiberRefsPatch_patch(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber._runtimeFlags;
    const newFlags = runtimeFlags_patch(patchFlags)(oldFlags);
    const rollbackRefs = FiberRefsPatch_diff(newRefs, oldRefs);
    const rollbackFlags = runtimeFlags_diff(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber._runtimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self), rt.context), withFiberRuntime(fiber => {
      fiber.setFiberRefs(FiberRefsPatch_patch(fiber.id(), fiber.getFiberRefs())(rollbackRefs));
      fiber._runtimeFlags = runtimeFlags_patch(rollbackFlags)(fiber._runtimeFlags);
      return core_void_;
    }));
  }));
});
/** @internal */
const effect_provide = /*#__PURE__*/Function_dual(2, (self, source) => isLayer(source) ? provideSomeLayer(self, source) : Context_isContext(source) ? provideSomeContext(self, source) : provideSomeRuntime(self, source));
//# sourceMappingURL=layer.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/MutableList.js
/**
 * @since 2.0.0
 */



const MutableList_TypeId = /*#__PURE__*/Symbol.for("effect/MutableList");
const MutableListProto = {
  [MutableList_TypeId]: MutableList_TypeId,
  [Symbol.iterator]() {
    let done = false;
    let head = this.head;
    return {
      next() {
        if (done) {
          return this.return();
        }
        if (head == null) {
          done = true;
          return this.return();
        }
        const value = head.value;
        head = head.next;
        return {
          done,
          value
        };
      },
      return(value) {
        if (!done) {
          done = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
/** @internal */
const makeNode = value => ({
  value,
  removed: false,
  prev: undefined,
  next: undefined
});
/**
 * Creates an empty `MutableList`.
 *
 * @since 2.0.0
 * @category constructors
 */
const MutableList_empty = () => {
  const list = Object.create(MutableListProto);
  list.head = undefined;
  list.tail = undefined;
  list._length = 0;
  return list;
};
/**
 * Creates a new `MutableList` from an iterable collection of values.
 *
 * @since 2.0.0
 * @category constructors
 */
const MutableList_fromIterable = iterable => {
  const list = MutableList_empty();
  for (const element of iterable) {
    MutableList_append(list, element);
  }
  return list;
};
/**
 * Creates a new `MutableList` from the specified elements.
 *
 * @since 2.0.0
 * @category constructors
 */
const MutableList_make = (...elements) => MutableList_fromIterable(elements);
/**
 * Returns `true` if the list contains zero elements, `false`, otherwise.
 *
 * @since 2.0.0
 * @category getters
 */
const MutableList_isEmpty = self => MutableList_length(self) === 0;
/**
 * Returns the length of the list.
 *
 * @since 2.0.0
 * @category getters
 */
const MutableList_length = self => self._length;
/**
 * Returns the last element of the list, if it exists.
 *
 * @since 2.0.0
 * @category getters
 */
const MutableList_tail = self => self.tail === undefined ? undefined : self.tail.value;
/**
 * Returns the first element of the list, if it exists.
 *
 * @since 2.0.0
 * @category getters
 */
const MutableList_head = self => self.head === undefined ? undefined : self.head.value;
/**
 * Executes the specified function `f` for each element in the list.
 *
 * @since 2.0.0
 * @category traversing
 */
const MutableList_forEach = /*#__PURE__*/(/* unused pure expression or super */ null && (Dual.dual(2, (self, f) => {
  let current = self.head;
  while (current !== undefined) {
    f(current.value);
    current = current.next;
  }
})));
/**
 * Removes all elements from the doubly-linked list.
 *
 * @since 2.0.0
 */
const MutableList_reset = self => {
  ;
  self._length = 0;
  self.head = undefined;
  self.tail = undefined;
  return self;
};
/**
 * Appends the specified element to the end of the `MutableList`.
 *
 * @category concatenating
 * @since 2.0.0
 */
const MutableList_append = /*#__PURE__*/Function_dual(2, (self, value) => {
  const node = makeNode(value);
  if (self.head === undefined) {
    self.head = node;
  }
  if (self.tail === undefined) {
    self.tail = node;
  } else {
    self.tail.next = node;
    node.prev = self.tail;
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
/**
 * Removes the first value from the list and returns it, if it exists.
 *
 * @since 0.0.1
 */
const shift = self => {
  const head = self.head;
  if (head !== undefined) {
    MutableList_remove(self, head);
    return head.value;
  }
  return undefined;
};
/**
 * Removes the last value from the list and returns it, if it exists.
 *
 * @since 0.0.1
 */
const MutableList_pop = self => {
  const tail = self.tail;
  if (tail !== undefined) {
    MutableList_remove(self, tail);
    return tail.value;
  }
  return undefined;
};
/**
 * Prepends the specified value to the beginning of the list.
 *
 * @category concatenating
 * @since 2.0.0
 */
const MutableList_prepend = /*#__PURE__*/(/* unused pure expression or super */ null && (Dual.dual(2, (self, value) => {
  const node = makeNode(value);
  node.next = self.head;
  if (self.head !== undefined) {
    self.head.prev = node;
  }
  self.head = node;
  if (self.tail === undefined) {
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
})));
const MutableList_remove = (self, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== undefined && node.next !== undefined) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== undefined) {
    self.tail = node.prev;
    node.prev.next = undefined;
  } else if (node.next !== undefined) {
    self.head = node.next;
    node.next.prev = undefined;
  } else {
    self.tail = undefined;
    self.head = undefined;
  }
  if (self._length > 0) {
    ;
    self._length -= 1;
  }
};
//# sourceMappingURL=MutableList.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/MutableQueue.js
/**
 * @since 2.0.0
 */





const MutableQueue_TypeId = /*#__PURE__*/Symbol.for("effect/MutableQueue");
/**
 * @since 2.0.0
 * @category symbol
 */
const EmptyMutableQueue = /*#__PURE__*/Symbol.for("effect/mutable/MutableQueue/Empty");
const MutableQueueProto = {
  [MutableQueue_TypeId]: MutableQueue_TypeId,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
const MutableQueue_make = capacity => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = MutableList_empty();
  queue.capacity = capacity;
  return queue;
};
/**
 * Creates a new bounded `MutableQueue`.
 *
 * @since 2.0.0
 * @category constructors
 */
const bounded = capacity => MutableQueue_make(capacity);
/**
 * Creates a new unbounded `MutableQueue`.
 *
 * @since 2.0.0
 * @category constructors
 */
const unbounded = () => MutableQueue_make(undefined);
/**
 * Returns the current number of elements in the queue.
 *
 * @since 2.0.0
 * @category getters
 */
const MutableQueue_length = self => MutableList.length(self.queue);
/**
 * Returns `true` if the queue is empty, `false` otherwise.
 *
 * @since 2.0.0
 * @category getters
 */
const MutableQueue_isEmpty = self => MutableList.isEmpty(self.queue);
/**
 * Returns `true` if the queue is full, `false` otherwise.
 *
 * @since 2.0.0
 * @category getters
 */
const isFull = self => self.capacity === undefined ? false : MutableList.length(self.queue) === self.capacity;
/**
 * The **maximum** number of elements that a queue can hold.
 *
 * **Note**: unbounded queues can still implement this interface with
 * `capacity = Infinity`.
 *
 * @since 2.0.0
 * @category getters
 */
const capacity = self => self.capacity === undefined ? Infinity : self.capacity;
/**
 * Offers an element to the queue.
 *
 * Returns whether the enqueue was successful or not.
 *
 * @since 2.0.0
 */
const offer = /*#__PURE__*/Function_dual(2, (self, value) => {
  const queueLength = MutableList_length(self.queue);
  if (self.capacity !== undefined && queueLength === self.capacity) {
    return false;
  }
  MutableList_append(value)(self.queue);
  return true;
});
/**
 * Enqueues a collection of values into the queue.
 *
 * Returns a `Chunk` of the values that were **not** able to be enqueued.
 *
 * @since 2.0.0
 */
const offerAll = /*#__PURE__*/(/* unused pure expression or super */ null && (Dual.dual(2, (self, values) => {
  const iterator = values[Symbol.iterator]();
  let next;
  let remainder = Chunk.empty();
  let offering = true;
  while (offering && (next = iterator.next()) && !next.done) {
    offering = offer(next.value)(self);
  }
  while (next != null && !next.done) {
    remainder = Chunk.prepend(next.value)(remainder);
    next = iterator.next();
  }
  return Chunk.reverse(remainder);
})));
/**
 * Dequeues an element from the queue.
 *
 * Returns either an element from the queue, or the `def` param.
 *
 * **Note**: if there is no meaningful default for your type, you can always
 * use `poll(MutableQueue.EmptyMutableQueue)`.
 *
 * @since 2.0.0
 */
const MutableQueue_poll = /*#__PURE__*/Function_dual(2, (self, def) => {
  if (MutableList_isEmpty(self.queue)) {
    return def;
  }
  return shift(self.queue);
});
/**
 * Dequeues up to `n` elements from the queue.
 *
 * Returns a `List` of up to `n` elements.
 *
 * @since 2.0.0
 */
const pollUpTo = /*#__PURE__*/(/* unused pure expression or super */ null && (Dual.dual(2, (self, n) => {
  let result = Chunk.empty();
  let count = 0;
  while (count < n) {
    const element = MutableQueue_poll(EmptyMutableQueue)(self);
    if (element === EmptyMutableQueue) {
      break;
    }
    result = Chunk.prepend(element)(result);
    count += 1;
  }
  return Chunk.reverse(result);
})));
//# sourceMappingURL=MutableQueue.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/cache.js


















/** @internal */
const cache_complete = (key, exit, entryStats, timeToLiveMillis) => data_struct({
  _tag: "Complete",
  key,
  exit,
  entryStats,
  timeToLiveMillis
});
/** @internal */
const cache_pending = (key, deferred) => data_struct({
  _tag: "Pending",
  key,
  deferred
});
/** @internal */
const refreshing = (deferred, complete) => data_struct({
  _tag: "Refreshing",
  deferred,
  complete
});
/** @internal */
const MapKeyTypeId = /*#__PURE__*/Symbol.for("effect/Cache/MapKey");
class MapKeyImpl {
  current;
  [MapKeyTypeId] = MapKeyTypeId;
  previous = undefined;
  next = undefined;
  constructor(current) {
    this.current = current;
  }
  [symbol]() {
    return Function_pipe(Hash_hash(this.current), combine(Hash_hash(this.previous)), combine(Hash_hash(this.next)), cached(this));
  }
  [Equal_symbol](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
}
/** @internal */
const makeMapKey = current => new MapKeyImpl(current);
/** @internal */
const isMapKey = u => Predicate_hasProperty(u, MapKeyTypeId);
class KeySetImpl {
  head = undefined;
  tail = undefined;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === undefined) {
        this.head = key;
        this.tail = key;
      } else {
        const previous = key.previous;
        const next = key.next;
        if (next !== undefined) {
          key.next = undefined;
          if (previous !== undefined) {
            previous.next = next;
            next.previous = previous;
          } else {
            this.head = next;
            this.head.previous = undefined;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== undefined) {
      const next = key.next;
      if (next !== undefined) {
        key.next = undefined;
        this.head = next;
        this.head.previous = undefined;
      } else {
        this.head = undefined;
        this.tail = undefined;
      }
    }
    return key;
  }
}
/** @internal */
const makeKeySet = () => new KeySetImpl();
/**
 * Constructs a new `CacheState` from the specified values.
 *
 * @internal
 */
const makeCacheState = (map, keys, accesses, updating, hits, misses) => ({
  map,
  keys,
  accesses,
  updating,
  hits,
  misses
});
/**
 * Constructs an initial cache state.
 *
 * @internal
 */
const initialCacheState = () => makeCacheState(MutableHashMap_empty(), makeKeySet(), unbounded(), MutableRef_make(false), 0, 0);
/** @internal */
const CacheSymbolKey = "effect/Cache";
/** @internal */
const CacheTypeId = /*#__PURE__*/Symbol.for(CacheSymbolKey);
const cacheVariance = {
  /* c8 ignore next */
  _Key: _ => _,
  /* c8 ignore next */
  _Error: _ => _,
  /* c8 ignore next */
  _Value: _ => _
};
/** @internal */
const makeCacheStats = options => options;
/** @internal */
const makeEntryStats = loadedMillis => ({
  loadedMillis
});
class CacheImpl {
  capacity;
  context;
  fiberId;
  lookup;
  timeToLive;
  [CacheTypeId] = cacheVariance;
  cacheState;
  constructor(capacity, context, fiberId, lookup, timeToLive) {
    this.capacity = capacity;
    this.context = context;
    this.fiberId = fiberId;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return core_map(this.getEither(key), Either_merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: MutableHashMap_size(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match(MutableHashMap_get(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(Option_none());
      },
      onSome: value => this.resolveMapValue(value)
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match(MutableHashMap_get(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(Option_none());
      },
      onSome: value => this.resolveMapValue(value, true)
    }));
  }
  contains(key) {
    return sync(() => MutableHashMap_has(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option = MutableHashMap_get(this.cacheState.map, key);
      if (Option_isSome(option)) {
        switch (option.value._tag) {
          case "Complete":
            {
              const loaded = option.value.entryStats.loadedMillis;
              return Option_some(makeEntryStats(loaded));
            }
          case "Pending":
            {
              return Option_none();
            }
          case "Refreshing":
            {
              const loaded = option.value.complete.entryStats.loadedMillis;
              return Option_some(makeEntryStats(loaded));
            }
        }
      }
      return Option_none();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k = key;
      let mapKey = undefined;
      let deferred = undefined;
      let value = getOrUndefined(MutableHashMap_get(this.cacheState.map, k));
      if (value === undefined) {
        deferred = Deferred_unsafeMake(this.fiberId);
        mapKey = makeMapKey(k);
        if (MutableHashMap_has(this.cacheState.map, k)) {
          value = getOrUndefined(MutableHashMap_get(this.cacheState.map, k));
        } else {
          MutableHashMap_set(this.cacheState.map, k, cache_pending(mapKey, deferred));
        }
      }
      if (value === undefined) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return core_map(this.lookupValueOf(key, deferred), Either_right);
      } else {
        return core_flatMap(this.resolveMapValue(value), match({
          onNone: () => this.getEither(key),
          onSome: value => succeed(Either_left(value))
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      MutableHashMap_remove(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when) {
    return sync(() => {
      const value = MutableHashMap_get(this.cacheState.map, key);
      if (Option_isSome(value) && value.value._tag === "Complete") {
        if (value.value.exit._tag === "Success") {
          if (when(value.value.exit.value)) {
            MutableHashMap_remove(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = MutableHashMap_empty();
    });
  }
  refresh(key) {
    return core_effect_clockWith(clock => suspend(() => {
      const k = key;
      const deferred = Deferred_unsafeMake(this.fiberId);
      let value = getOrUndefined(MutableHashMap_get(this.cacheState.map, k));
      if (value === undefined) {
        if (MutableHashMap_has(this.cacheState.map, k)) {
          value = getOrUndefined(MutableHashMap_get(this.cacheState.map, k));
        } else {
          MutableHashMap_set(this.cacheState.map, k, cache_pending(makeMapKey(k), deferred));
        }
      }
      if (value === undefined) {
        return core_asVoid(this.lookupValueOf(key, deferred));
      } else {
        switch (value._tag) {
          case "Complete":
            {
              if (this.hasExpired(clock, value.timeToLiveMillis)) {
                const found = getOrUndefined(MutableHashMap_get(this.cacheState.map, k));
                if (equals(found, value)) {
                  MutableHashMap_remove(this.cacheState.map, k);
                }
                return core_asVoid(this.get(key));
              }
              // Only trigger the lookup if we're still the current value, `completedResult`
              return Function_pipe(this.lookupValueOf(key, deferred), when(() => {
                const current = getOrUndefined(MutableHashMap_get(this.cacheState.map, k));
                if (equals(current, value)) {
                  const mapValue = refreshing(deferred, value);
                  MutableHashMap_set(this.cacheState.map, k, mapValue);
                  return true;
                }
                return false;
              }), core_asVoid);
            }
          case "Pending":
            {
              return _await(value.deferred);
            }
          case "Refreshing":
            {
              return _await(value.deferred);
            }
        }
      }
    }));
  }
  set(key, value) {
    return core_effect_clockWith(clock => sync(() => {
      const now = clock.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = Exit_succeed(value);
      const mapValue = cache_complete(makeMapKey(k), lookupResult, makeEntryStats(now), now + toMillis(decode(this.timeToLive(lookupResult))));
      MutableHashMap_set(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return MutableHashMap_size(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values.push(entry[1].exit.value);
        }
      }
      return values;
    });
  }
  get entries() {
    return sync(() => {
      const values = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values.push([entry[0], entry[1].exit.value]);
        }
      }
      return values;
    });
  }
  get keys() {
    return sync(() => {
      const keys = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys.push(entry[0]);
        }
      }
      return keys;
    });
  }
  resolveMapValue(value, ignorePending = false) {
    return core_effect_clockWith(clock => {
      switch (value._tag) {
        case "Complete":
          {
            this.trackAccess(value.key);
            if (this.hasExpired(clock, value.timeToLiveMillis)) {
              MutableHashMap_remove(this.cacheState.map, value.key.current);
              return succeed(Option_none());
            }
            this.trackHit();
            return core_map(value.exit, Option_some);
          }
        case "Pending":
          {
            this.trackAccess(value.key);
            this.trackHit();
            if (ignorePending) {
              return succeed(Option_none());
            }
            return core_map(_await(value.deferred), Option_some);
          }
        case "Refreshing":
          {
            this.trackAccess(value.complete.key);
            this.trackHit();
            if (this.hasExpired(clock, value.complete.timeToLiveMillis)) {
              if (ignorePending) {
                return succeed(Option_none());
              }
              return core_map(_await(value.deferred), Option_some);
            }
            return core_map(value.complete.exit, Option_some);
          }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop = true;
      while (loop) {
        const key = MutableQueue_poll(this.cacheState.accesses, EmptyMutableQueue);
        if (key === EmptyMutableQueue) {
          loop = false;
        } else {
          this.cacheState.keys.add(key);
        }
      }
      let size = MutableHashMap_size(this.cacheState.map);
      loop = size > this.capacity;
      while (loop) {
        const key = this.cacheState.keys.remove();
        if (key !== undefined) {
          if (MutableHashMap_has(this.cacheState.map, key.current)) {
            MutableHashMap_remove(this.cacheState.map, key.current);
            size = size - 1;
            loop = size > this.capacity;
          }
        } else {
          loop = false;
        }
      }
      MutableRef_set(this.cacheState.updating, false);
    }
  }
  hasExpired(clock, timeToLiveMillis) {
    return clock.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return core_effect_clockWith(clock => suspend(() => {
      const key = input;
      return Function_pipe(this.lookup(input), provideContext(this.context), core_exit, core_flatMap(exit => {
        const now = clock.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now);
        const value = cache_complete(makeMapKey(key), exit, stats, now + toMillis(decode(this.timeToLive(exit))));
        MutableHashMap_set(this.cacheState.map, key, value);
        return core_zipRight(Deferred_done(deferred, exit), exit);
      }), onInterrupt(() => core_zipRight(Deferred_interrupt(deferred), sync(() => {
        MutableHashMap_remove(this.cacheState.map, key);
      }))));
    }));
  }
}
/** @internal */
const cache_make = options => {
  const timeToLive = Duration.decode(options.timeToLive);
  return makeWith({
    capacity: options.capacity,
    lookup: options.lookup,
    timeToLive: () => timeToLive
  });
};
/** @internal */
const makeWith = options => core.map(fiberRuntime.all([core.context(), core.fiberId]), ([context, fiberId]) => new CacheImpl(options.capacity, context, fiberId, options.lookup, exit => Duration.decode(options.timeToLive(exit))));
/** @internal */
const unsafeMakeWith = (capacity, lookup, timeToLive) => new CacheImpl(capacity, Context_empty(), fiberId_none, lookup, exit => decode(timeToLive(exit)));
//# sourceMappingURL=cache.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/query.js








/** @internal */
const currentCache = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => core_map(deferredMake(), handle => ({
  listeners: new Listeners(),
  handle
})), () => seconds(60))));
/** @internal */
const currentCacheEnabled = /*#__PURE__*/GlobalValue_globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
/** @internal */
const fromRequest = (request, dataSource) => core_flatMap(isEffect(dataSource) ? dataSource : succeed(dataSource), ds => fiberIdWith(id => {
  const proxy = new Proxy(request, {});
  return fiberRefGetWith(currentCacheEnabled, cacheEnabled => {
    if (cacheEnabled) {
      const cached = fiberRefGetWith(currentCache, cache => core_flatMap(cache.getEither(proxy), orNew => {
        switch (orNew._tag) {
          case "Left":
            {
              if (orNew.left.listeners.interrupted) {
                return core_flatMap(cache.invalidateWhen(proxy, entry => entry.handle === orNew.left.handle), () => cached);
              }
              orNew.left.listeners.increment();
              return uninterruptibleMask(restore => core_flatMap(core_exit(blocked(blockedRequests_empty, restore(deferredAwait(orNew.left.handle)))), exit => {
                orNew.left.listeners.decrement();
                return exit;
              }));
            }
          case "Right":
            {
              orNew.right.listeners.increment();
              return uninterruptibleMask(restore => core_flatMap(core_exit(blocked(single(ds, makeEntry({
                request: proxy,
                result: orNew.right.handle,
                listeners: orNew.right.listeners,
                ownerId: id,
                state: {
                  completed: false
                }
              })), restore(deferredAwait(orNew.right.handle)))), () => {
                orNew.right.listeners.decrement();
                return deferredAwait(orNew.right.handle);
              }));
            }
        }
      }));
      return cached;
    }
    const listeners = new Listeners();
    listeners.increment();
    return core_flatMap(deferredMake(), ref => ensuring(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
}));
/** @internal */
const cacheRequest = (request, result) => {
  return fiberRefGetWith(currentCacheEnabled, cacheEnabled => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, cache => core_flatMap(cache.getEither(request), orNew => {
        switch (orNew._tag) {
          case "Left":
            {
              return core_void_;
            }
          case "Right":
            {
              return deferredComplete(orNew.right.handle, result);
            }
        }
      }));
    }
    return core_void_;
  });
};
/** @internal */
const withRequestCaching = /*#__PURE__*/Function_dual(2, (self, strategy) => fiberRefLocally(self, currentCacheEnabled, strategy));
/** @internal */
const withRequestCache = /*#__PURE__*/Function_dual(2,
// @ts-expect-error
(self, cache) => fiberRefLocally(self, currentCache, cache));
//# sourceMappingURL=query.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Request.js





/**
 * @since 2.0.0
 * @category symbols
 */
const Request_RequestTypeId = RequestTypeId;
/**
 * Returns `true` if the specified value is a `Request`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const Request_isRequest = isRequest;
/**
 * Constructs a new `Request`.
 *
 * @since 2.0.0
 * @category constructors
 */
const Request_of = request_of;
/**
 * Constructs a new `Request`.
 *
 * @since 2.0.0
 * @category constructors
 */
const Request_tagged = request_tagged;
/**
 * Provides a constructor for a Request Class.
 *
 * @example
 * import { Request } from "effect"
 *
 * type Success = string
 * type Error = never
 *
 * class MyRequest extends Request.Class<Success, Error, {
 *   readonly id: string
 * }> {}
 *
 * @since 2.0.0
 * @category constructors
 */
const Request_Class = request_Class;
/**
 * Provides a Tagged constructor for a Request Class.
 *
 * @example
 * import { Request } from "effect"
 *
 * type Success = string
 * type Error = never
 *
 * class MyRequest extends Request.TaggedClass("MyRequest")<Success, Error, {
 *   readonly name: string
 * }> {}
 *
 * @since 2.0.0
 * @category constructors
 */
const Request_TaggedClass = TaggedClass;
/**
 * Complete a `Request` with the specified result.
 *
 * @since 2.0.0
 * @category request completion
 */
const Request_complete = request_complete;
/**
 * Interrupts the child effect when requests are no longer needed
 *
 * @since 2.0.0
 * @category request completion
 */
const Request_interruptWhenPossible = interruptWhenPossible;
/**
 * Complete a `Request` with the specified effectful computation, failing the
 * request with the error from the effect workflow if it fails, and completing
 * the request with the value of the effect workflow if it succeeds.
 *
 * @since 2.0.0
 * @category request completion
 */
const Request_completeEffect = completeEffect;
/**
 * Complete a `Request` with the specified error.
 *
 * @since 2.0.0
 * @category request completion
 */
const Request_fail = request_fail;
/**
 * Complete a `Request` with the specified cause.
 *
 * @since 2.0.0
 * @category request completion
 */
const Request_failCause = request_failCause;
/**
 * Complete a `Request` with the specified value.
 *
 * @since 2.0.0
 * @category request completion
 */
const Request_succeed = request_succeed;
/**
 * @since 2.0.0
 * @category models
 */
const makeCache = options => cache.make({
  ...options,
  lookup: () => core.map(core.deferredMake(), handle => ({
    listeners: new internal.Listeners(),
    handle
  }))
});
/**
 * @since 2.0.0
 * @category symbols
 */
const Request_EntryTypeId = /*#__PURE__*/(/* unused pure expression or super */ null && (Symbol.for("effect/RequestBlock.Entry")));
/**
 * @since 2.0.0
 * @category guards
 */
const Request_isEntry = isEntry;
/**
 * @since 2.0.0
 * @category constructors
 */
const Request_makeEntry = makeEntry;
//# sourceMappingURL=Request.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Effect.js














// -------------------------------------------------------------------------------------
// models
// -------------------------------------------------------------------------------------
/**
 * @since 2.0.0
 * @category symbols
 */
const Effect_EffectTypeId = core_EffectTypeId;
// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * This function returns `true` if the specified value is an `Effect` value,
 * `false` otherwise.
 *
 * This function can be useful for checking the type of a value before
 * attempting to operate on it as an `Effect` value. For example, you could
 * use `isEffect` to check the type of a value before using it as an
 * argument to a function that expects an `Effect` value.
 *
 * @param u - The value to check for being an `Effect` value.
 *
 * @returns `true` if the specified value is an `Effect` value, `false`
 * otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const Effect_isEffect = isEffect;
// -------------------------------------------------------------------------------------
// caching
// -------------------------------------------------------------------------------------
/**
 * Returns an effect that, if evaluated, will return the cached result of this
 * effect. Cached results will expire after `timeToLive` duration.
 *
 * @since 2.0.0
 * @category caching
 */
const cachedWithTTL = circular_cached;
/**
 * Returns an effect that, if evaluated, will return the cached result of this
 * effect. Cached results will expire after `timeToLive` duration. In
 * addition, returns an effect that can be used to invalidate the current
 * cached value before the `timeToLive` duration expires.
 *
 * @since 2.0.0
 * @category caching
 */
const Effect_cachedInvalidateWithTTL = cachedInvalidateWithTTL;
/**
 * Returns an effect that, if evaluated, will return the lazily computed
 * result of this effect.
 *
 * @since 2.0.0
 * @category caching
 */
const Effect_cached = memoize;
/**
 * Returns a memoized version of the specified effectual function.
 *
 * @since 2.0.0
 * @category caching
 */
const Effect_cachedFunction = cachedFunction;
/**
 * Returns an effect that will be executed at most once, even if it is
 * evaluated multiple times.
 *
 * @example
 * import { Effect, Console } from "effect"
 *
 * const program = Effect.gen(function* (_) {
 *   const twice = Console.log("twice")
 *   yield* _(twice, Effect.repeatN(1))
 *   const once = yield* _(Console.log("once"), Effect.once)
 *   yield* _(once, Effect.repeatN(1))
 * })
 *
 * Effect.runFork(program)
 * // Output:
 * // twice
 * // twice
 * // once
 *
 * @since 2.0.0
 * @category caching
 */
const Effect_once = once;
// -------------------------------------------------------------------------------------
// collecting & elements
// -------------------------------------------------------------------------------------
/**
 * Runs all the provided effects in sequence respecting the structure provided in input.
 *
 * Supports multiple arguments, a single argument tuple / array or record / struct.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_all = fiberRuntime_all;
/**
 * Data-last variant of `Effect.all`.
 *
 * Runs all the provided effects in sequence respecting the structure provided in input.
 *
 * Supports multiple arguments, a single argument tuple / array or record / struct.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_allWith = allWith;
/**
 * Evaluate and run each effect in the structure and collect the results,
 * discarding results from failed effects.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_allSuccesses = allSuccesses;
/**
 * Drops all elements until the effectful predicate returns true.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_dropUntil = dropUntil;
/**
 * Drops all elements so long as the predicate returns true.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_dropWhile = core_effect_dropWhile;
/**
 * Determines whether all elements of the `Collection<A>` satisfies the effectual
 * predicate `f`.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_every = core_effect_every;
/**
 * Determines whether any element of the `Iterable<A>` satisfies the effectual
 * predicate `f`.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_exists = fiberRuntime_exists;
/**
 * Filters the collection using the specified effectful predicate.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_filter = fiberRuntime_filter;
/**
 * Performs a filter and map in a single step.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_filterMap = core_effect_filterMap;
/**
 * Returns the first element that satisfies the effectful predicate.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_findFirst = core_effect_findFirst;
/**
 * This function takes an iterable of `Effect` values and returns a new
 * `Effect` value that represents the first `Effect` value in the iterable
 * that succeeds. If all of the `Effect` values in the iterable fail, then
 * the resulting `Effect` value will fail as well.
 *
 * This function is sequential, meaning that the `Effect` values in the
 * iterable will be executed in sequence, and the first one that succeeds
 * will determine the outcome of the resulting `Effect` value.
 *
 * @param effects - The iterable of `Effect` values to evaluate.
 *
 * @returns A new `Effect` value that represents the first successful
 * `Effect` value in the iterable, or a failed `Effect` value if all of the
 * `Effect` values in the iterable fail.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_firstSuccessOf = firstSuccessOf;
/**
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_forEach = fiberRuntime_forEach;
/**
 * Returns a successful effect with the head of the collection if the collection
 * is non-empty, or fails with the error `None` if the collection is empty.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_head = core_effect_head;
/**
 * Merges an `Iterable<Effect<A, E, R>>` to a single effect, working
 * sequentially.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_mergeAll = mergeAll;
/**
 * Feeds elements of type `A` to a function `f` that returns an effect.
 * Collects all successes and failures in a tupled fashion.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_partition = fiberRuntime_partition;
/**
 * Folds an `Iterable<A>` using an effectual function f, working sequentially
 * from left to right.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_reduce = core_effect_reduce;
/**
 * Reduces an `Iterable<Effect<A, E, R>>` to a single effect.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_reduceEffect = reduceEffect;
/**
 * Folds an `Iterable<A>` using an effectual function f, working sequentially from left to right.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_reduceRight = core_effect_reduceRight;
/**
 * Folds over the elements in this chunk from the left, stopping the fold early
 * when the predicate is not satisfied.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_reduceWhile = reduceWhile;
/**
 * Replicates the given effect `n` times.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_replicate = fiberRuntime_replicate;
/**
 * Performs this effect the specified number of times and collects the
 * results.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_replicateEffect = replicateEffect;
/**
 * Takes elements until the effectual predicate returns true.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_takeUntil = takeUntil;
/**
 * Takes all elements so long as the effectual predicate returns true.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_takeWhile = core_effect_takeWhile;
/**
 * Feeds elements of type `A` to `f` and accumulates all errors in error
 * channel or successes in success channel.
 *
 * This combinator is lossy meaning that if there are errors all successes
 * will be lost. To retain all information please use `partition`.
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_validateAll = validateAll;
/**
 * Feeds elements of type `A` to `f` until it succeeds. Returns first success
 * or the accumulation of all errors.
 *
 * If `elements` is empty then `Effect.fail([])` is returned.
 *
 * @example
 * import { Effect, Exit } from "effect"
 *
 * const f = (n: number) => (n > 0 ? Effect.succeed(n) : Effect.fail(`${n} is negative`))
 *
 * assert.deepStrictEqual(Effect.runSyncExit(Effect.validateFirst([], f)), Exit.fail([]))
 * assert.deepStrictEqual(Effect.runSyncExit(Effect.validateFirst([1, 2], f)), Exit.succeed(1))
 * assert.deepStrictEqual(Effect.runSyncExit(Effect.validateFirst([1, -1], f)), Exit.succeed(1))
 * assert.deepStrictEqual(Effect.runSyncExit(Effect.validateFirst([-1, 2], f)), Exit.succeed(2))
 * assert.deepStrictEqual(Effect.runSyncExit(Effect.validateFirst([-1, -2], f)), Exit.fail(['-1 is negative', '-2 is negative']))
 *
 * @since 2.0.0
 * @category collecting & elements
 */
const Effect_validateFirst = validateFirst;
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * Imports an asynchronous side-effect into a pure `Effect` value. The callback
 * function `Effect<A, E, R> => void` **MUST** be called at most once.
 *
 * The registration function can optionally return an Effect, which will be
 * executed if the `Fiber` executing this Effect is interrupted.
 *
 * The registration function can also receive an `AbortSignal` if required for
 * interruption.
 *
 * The `FiberId` of the fiber that may complete the async callback may also be
 * specified. This is called the "blocking fiber" because it suspends the fiber
 * executing the `async` Effect (i.e. semantically blocks the fiber from making
 * progress). Specifying this fiber id in cases where it is known will improve
 * diagnostics, but not affect the behavior of the returned effect.
 *
 * @since 2.0.0
 * @category constructors
 */
const Effect_async = core_async;
/**
 * Converts an asynchronous, callback-style API into an `Effect`, which will
 * be executed asynchronously.
 *
 * With this variant, the registration function may return a an `Effect`.
 *
 * @since 2.0.0
 * @category constructors
 */
const Effect_asyncEffect = asyncEffect;
/**
 * Low level constructor that enables for custom stack tracing cutpoints.
 *
 * It is meant to be called with a bag of instructions that become available in the "this" of the effect.
 *
 * @example
 * import { Effect } from "effect"
 *
 * const throwingFunction = () => { throw new Error() }
 * const blowUp = Effect.custom(throwingFunction, function() {
 *   return Effect.succeed(this.effect_instruction_i0())
 * })
 *
 * @since 2.0.0
 * @category constructors
 */
const Effect_custom = custom;
/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_withFiberRuntime = withFiberRuntime;
/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_fail = core_fail;
/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_failSync = failSync;
/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_failCause = failCause;
/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_failCauseSync = failCauseSync;
/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_die = core_die;
/**
 * Returns an effect that dies with a `RuntimeException` having the specified
 * text message. This method can be used for terminating a fiber because a
 * defect has been detected in the code.
 *
 * @since 2.0.0
 * @category constructors
 */
const Effect_dieMessage = dieMessage;
/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_dieSync = dieSync;
/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_gen = core_effect_gen;
/**
 * Returns an effect that will never produce anything. The moral equivalent of
 * `while(true) {}`, only without the wasted CPU cycles.
 *
 * @since 2.0.0
 * @category constructors
 */
const Effect_never = never;
/**
 * Requires the option produced by this value to be `None`.
 *
 * @since 2.0.0
 * @category constructors
 */
const Effect_none = core_effect_none;
/**
 * Like `tryPromise` but produces a defect in case of errors.
 *
 * An optional `AbortSignal` can be provided to allow for interruption of the
 * wrapped Promise api.
 *
 * @since 2.0.0
 * @category constructors
 */
const Effect_promise = promise;
/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_succeed = succeed;
/**
 * Returns an effect which succeeds with `None`.
 *
 * @since 2.0.0
 * @category constructors
 */
const Effect_succeedNone = succeedNone;
/**
 * Returns an effect which succeeds with the value wrapped in a `Some`.
 *
 * @since 2.0.0
 * @category constructors
 */
const Effect_succeedSome = succeedSome;
/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_suspend = suspend;
/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_sync = sync;
const _void = core_void_;

/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_yieldNow = yieldNow;
// -------------------------------------------------------------------------------------
// error handling
// -------------------------------------------------------------------------------------
const Effect_catch = _catch;

/**
 * Recovers from all recoverable errors.
 *
 * **Note**: that `Effect.catchAll` will not recover from unrecoverable defects. To
 * recover from both recoverable and unrecoverable errors use
 * `Effect.catchAllCause`.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_catchAll = catchAll;
/**
 * Recovers from both recoverable and unrecoverable errors.
 *
 * See `sandbox`, `mapErrorCause` for other functions that can
 * recover from defects.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_catchAllCause = catchAllCause;
/**
 * Recovers from all defects with provided function.
 *
 * **WARNING**: There is no sensible way to recover from defects. This
 * method should be used only at the boundary between Effect and an external
 * system, to transmit information on a defect for diagnostic or explanatory
 * purposes.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_catchAllDefect = catchAllDefect;
/**
 * Recovers from errors that match the given predicate.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_catchIf = catchIf;
/**
 * Recovers from some or all of the error cases.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_catchSome = catchSome;
/**
 * Recovers from some or all of the error cases with provided cause.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_catchSomeCause = catchSomeCause;
/**
 * Recovers from some or all of the defects with provided partial function.
 *
 * **WARNING**: There is no sensible way to recover from defects. This
 * method should be used only at the boundary between Effect and an external
 * system, to transmit information on a defect for diagnostic or explanatory
 * purposes.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_catchSomeDefect = catchSomeDefect;
/**
 * Recovers from the specified tagged error.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_catchTag = catchTag;
/**
 * Recovers from the specified tagged errors.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_catchTags = catchTags;
/**
 * Returns an effect that succeeds with the cause of failure of this effect,
 * or `Cause.empty` if the effect did succeed.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_cause = cause;
/**
 * Returns an effect that ignores errors and runs repeatedly until it
 * eventually succeeds.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_eventually = eventually;
/**
 * Returns a new effect that ignores the success or failure of this effect.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_ignore = ignore;
/**
 * Returns a new effect that ignores the success or failure of this effect,
 * but which also logs failures at the Debug level, just in case the failure
 * turns out to be important.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_ignoreLogged = ignoreLogged;
/**
 * Exposes all parallel errors in a single call.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_parallelErrors = parallelErrors;
/**
 * Exposes the full `Cause` of failure for the specified effect.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_sandbox = sandbox;
/**
 * Retries according to the options provided
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_retry = retry_combined;
/**
 * Retries with the specified schedule, until it fails, and then both the
 * value produced by the schedule together with the last error are passed to
 * the recovery function.
 *
 * @since 2.0.0
 * @category error handling
 */
const retryOrElse = retryOrElse_Effect;
const Effect_try_ = core_effect_try_;

/**
 * Returns an effect whose success is mapped by the specified side effecting
 * `try` function, translating any promise rejections into typed failed effects
 * via the `catch` function.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_tryMap = tryMap;
/**
 * Returns an effect whose success is mapped by the specified side effecting
 * `try` function, translating any promise rejections into typed failed effects
 * via the `catch` function.
 *
 * An optional `AbortSignal` can be provided to allow for interruption of the
 * wrapped Promise api.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_tryMapPromise = tryMapPromise;
/**
 * Create an `Effect` that when executed will construct `promise` and wait for
 * its result, errors will produce failure as `unknown`.
 *
 * An optional `AbortSignal` can be provided to allow for interruption of the
 * wrapped Promise api.
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_tryPromise = tryPromise;
/**
 * The inverse operation `sandbox(effect)`
 *
 * Terminates with exceptions on the `Left` side of the `Either` error, if it
 * exists. Otherwise extracts the contained `Effect<A, E, R>`
 *
 * @since 2.0.0
 * @category error handling
 */
const Effect_unsandbox = unsandbox;
// -------------------------------------------------------------------------------------
// interuption
// -------------------------------------------------------------------------------------
/**
 * This function checks if any fibers are attempting to interrupt the current
 * fiber, and if so, performs self-interruption.
 *
 * Note that this allows for interruption to occur in uninterruptible regions.
 *
 * @returns A new `Effect` value that represents the check for interruption
 * and the potential self-interruption of the current fiber.
 *
 * @since 2.0.0
 * @category interruption
 */
const Effect_allowInterrupt = allowInterrupt;
/**
 * Checks the interrupt status, and produces the effect returned by the
 * specified callback.
 *
 * @since 2.0.0
 * @category interruption
 */
const Effect_checkInterruptible = checkInterruptible;
/**
 * Returns an effect whose interruption will be disconnected from the
 * fiber's own interruption, being performed in the background without
 * slowing down the fiber's interruption.
 *
 * This method is useful to create "fast interrupting" effects. For
 * example, if you call this on a bracketed effect, then even if the
 * effect is "stuck" in acquire or release, its interruption will return
 * immediately, while the acquire / release are performed in the
 * background.
 *
 * See timeout and race for other applications.
 *
 * @since 2.0.0
 * @category interruption
 */
const Effect_disconnect = disconnect;
/**
 * @since 2.0.0
 * @category interruption
 */
const Effect_interrupt = core_interrupt;
/**
 * @since 2.0.0
 * @category interruption
 */
const Effect_interruptWith = interruptWith;
/**
 * @since 2.0.0
 * @category interruption
 */
const Effect_interruptible = core_interruptible;
/**
 * @since 2.0.0
 * @category interruption
 */
const Effect_interruptibleMask = interruptibleMask;
/**
 * @since 2.0.0
 * @category interruption
 */
const Effect_onInterrupt = onInterrupt;
/**
 * @since 2.0.0
 * @category interruption
 */
const Effect_uninterruptible = uninterruptible;
/**
 * @since 2.0.0
 * @category interruption
 */
const Effect_uninterruptibleMask = uninterruptibleMask;
// -------------------------------------------------------------------------------------
// mapping
// -------------------------------------------------------------------------------------
/**
 * This function maps the success value of an `Effect` value to a specified
 * constant value.
 *
 * @param value - The constant value that the success value of the `Effect`
 * value will be mapped to.
 * @param self - The `Effect` value whose success value will be mapped to the
 * specified constant value.
 *
 * @returns A new `Effect` value that represents the mapping of the success
 * value of the original `Effect` value to the specified constant value.
 *
 * @since 2.0.0
 * @category mapping
 */
const Effect_as = core_as;
/**
 * This function maps the success value of an `Effect` value to a `Some` value
 * in an `Option` value. If the original `Effect` value fails, the returned
 * `Effect` value will also fail.
 *
 * @param self - The `Effect` value whose success value will be mapped to a
 * `Some` value in an `Option` value.
 *
 * @returns A new `Effect` value that represents the mapping of the success
 * value of the original `Effect` value to a `Some` value in an `Option`
 * value. The returned `Effect` value may fail if the original `Effect` value
 * fails.
 *
 * @category mapping
 * @since 2.0.0
 */
const Effect_asSome = asSome;
/**
 * This function maps the error value of an `Effect` value to a `Some` value
 * in an `Option` value. If the original `Effect` value succeeds, the returned
 * `Effect` value will also succeed.
 *
 * @param self - The `Effect` value whose error value will be mapped to a
 * `Some` value in an `Option` value.
 *
 * @returns A new `Effect` value that represents the mapping of the error
 * value of the original `Effect` value to a `Some` value in an `Option`
 * value. The returned `Effect` value may succeed if the original `Effect`
 * value succeeds.
 *
 * @category mapping
 * @since 2.0.0
 */
const Effect_asSomeError = asSomeError;
/**
 * This function maps the success value of an `Effect` value to `void`. If the
 * original `Effect` value succeeds, the returned `Effect` value will also
 * succeed. If the original `Effect` value fails, the returned `Effect` value
 * will fail with the same error.
 *
 * @param self - The `Effect` value whose success value will be mapped to `void`.
 *
 * @returns A new `Effect` value that represents the mapping of the success
 * value of the original `Effect` value to `void`.
 *
 * @since 2.0.0
 * @category mapping
 */
const Effect_asVoid = core_asVoid;
/**
 * Returns an effect that swaps the error/success cases. This allows you to
 * use all methods on the error channel, possibly before flipping back.
 *
 * @since 2.0.0
 * @category mapping
 */
const Effect_flip = core_flip;
/**
 * Swaps the error/value parameters, applies the function `f` and flips the
 * parameters back
 *
 * @since 2.0.0
 * @category mapping
 */
const Effect_flipWith = flipWith;
/**
 * @since 2.0.0
 * @category mapping
 */
const Effect_map = core_map;
/**
 * Statefully and effectfully maps over the elements of this chunk to produce
 * new elements.
 *
 * @since 2.0.0
 * @category mapping
 */
const Effect_mapAccum = core_effect_mapAccum;
/**
 * Returns an effect whose failure and success channels have been mapped by
 * the specified `onFailure` and `onSuccess` functions.
 *
 * @since 2.0.0
 * @category mapping
 */
const Effect_mapBoth = core_mapBoth;
/**
 * Returns an effect with its error channel mapped using the specified function.
 *
 * @since 2.0.0
 * @category mapping
 */
const Effect_mapError = mapError;
/**
 * Returns an effect with its full cause of failure mapped using the specified
 * function. This can be used to transform errors while preserving the
 * original structure of `Cause`.
 *
 * See `sandbox`, `catchAllCause` for other functions for dealing
 * with defects.
 *
 * @since 2.0.0
 * @category mapping
 */
const Effect_mapErrorCause = mapErrorCause;
/**
 * Returns a new effect where the error channel has been merged into the
 * success channel to their common combined type.
 *
 * @since 2.0.0
 * @category mapping
 */
const Effect_merge = core_effect_merge;
/**
 * Returns a new effect where boolean value of this effect is negated.
 *
 * @since 2.0.0
 * @category mapping
 */
const Effect_negate = negate;
// -------------------------------------------------------------------------------------
// scoping, resources & finalization
// -------------------------------------------------------------------------------------
/**
 * This function constructs a scoped resource from an `acquire` and `release`
 * `Effect` value.
 *
 * If the `acquire` `Effect` value successfully completes execution, then the
 * `release` `Effect` value will be added to the finalizers associated with the
 * scope of this `Effect` value, and it is guaranteed to be run when the scope
 * is closed.
 *
 * The `acquire` and `release` `Effect` values will be run uninterruptibly.
 * Additionally, the `release` `Effect` value may depend on the `Exit` value
 * specified when the scope is closed.
 *
 * @param acquire - The `Effect` value that acquires the resource.
 * @param release - The `Effect` value that releases the resource.
 *
 * @returns A new `Effect` value that represents the scoped resource.
 *
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_acquireRelease = acquireRelease;
/**
 * This function constructs a scoped resource from an `acquire` and `release`
 * `Effect` value.
 *
 * If the `acquire` `Effect` value successfully completes execution, then the
 * `release` `Effect` value will be added to the finalizers associated with the
 * scope of this `Effect` value, and it is guaranteed to be run when the scope
 * is closed.
 *
 * The `acquire` `Effect` values will be run interruptibly.
 * The `release` `Effect` values will be run uninterruptibly.
 *
 * Additionally, the `release` `Effect` value may depend on the `Exit` value
 * specified when the scope is closed.
 *
 * @param acquire - The `Effect` value that acquires the resource.
 * @param release - The `Effect` value that releases the resource.
 *
 * @returns A new `Effect` value that represents the scoped resource.
 *
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_acquireReleaseInterruptible = acquireReleaseInterruptible;
/**
 * This function is used to ensure that an `Effect` value that represents the
 * acquisition of a resource (for example, opening a file, launching a thread,
 * etc.) will not be interrupted, and that the resource will always be released
 * when the `Effect` value completes execution.
 *
 * `acquireUseRelease` does the following:
 *
 *   1. Ensures that the `Effect` value that acquires the resource will not be
 *      interrupted. Note that acquisition may still fail due to internal
 *      reasons (such as an uncaught exception).
 *   2. Ensures that the `release` `Effect` value will not be interrupted,
 *      and will be executed as long as the acquisition `Effect` value
 *      successfully acquires the resource.
 *
 * During the time period between the acquisition and release of the resource,
 * the `use` `Effect` value will be executed.
 *
 * If the `release` `Effect` value fails, then the entire `Effect` value will
 * fail, even if the `use` `Effect` value succeeds. If this fail-fast behavior
 * is not desired, errors produced by the `release` `Effect` value can be caught
 * and ignored.
 *
 * @param acquire - The `Effect` value that acquires the resource.
 * @param use - The `Effect` value that is executed between the acquisition
 * and release of the resource.
 * @param release - The `Effect` value that releases the resource.
 *
 * @returns A new `Effect` value that represents the acquisition, use, and
 * release of the resource.
 *
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_acquireUseRelease = acquireUseRelease;
/**
 * This function adds a finalizer to the scope of the calling `Effect` value.
 * The finalizer is guaranteed to be run when the scope is closed, and it may
 * depend on the `Exit` value that the scope is closed with.
 *
 * @param finalizer - The finalizer to add to the scope of the calling
 * `Effect` value. This function must take an `Exit` value as its parameter,
 * and return a new `Effect` value.
 *
 * @returns A new `Effect` value that represents the addition of the finalizer
 * to the scope of the calling `Effect` value.
 *
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_addFinalizer = addFinalizer;
/**
 * Returns an effect that, if this effect _starts_ execution, then the
 * specified `finalizer` is guaranteed to be executed, whether this effect
 * succeeds, fails, or is interrupted.
 *
 * For use cases that need access to the effect's result, see `onExit`.
 *
 * Finalizers offer very powerful guarantees, but they are low-level, and
 * should generally not be used for releasing resources. For higher-level
 * logic built on `ensuring`, see the `acquireRelease` family of methods.
 *
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_ensuring = ensuring;
/**
 * Runs the specified effect if this effect fails, providing the error to the
 * effect if it exists. The provided effect will not be interrupted.
 *
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_onError = onError;
/**
 * Ensures that a cleanup functions runs, whether this effect succeeds, fails,
 * or is interrupted.
 *
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_onExit = onExit;
/**
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_parallelFinalizers = parallelFinalizers;
/**
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_finalizersMask = finalizersMask;
/**
 * Returns a new scoped workflow that runs finalizers added to the scope of
 * this workflow sequentially in the reverse of the order in which they were
 * added. Note that finalizers are run sequentially by default so this only
 * has meaning if used within a scope where finalizers are being run in
 * parallel.
 *
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_sequentialFinalizers = sequentialFinalizers;
/**
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_scope = scope;
/**
 * Accesses the current scope and uses it to perform the specified effect.
 *
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_scopeWith = scopeWith;
/**
 * Scopes all resources uses in this workflow to the lifetime of the workflow,
 * ensuring that their finalizers are run as soon as this workflow completes
 * execution, whether by success, failure, or interruption.
 *
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_scoped = scopedEffect;
/**
 * Scopes all resources acquired by `resource` to the lifetime of `use`
 * without effecting the scope of any resources acquired by `use`.
 *
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_using = using;
/**
 * Returns a new scoped workflow that returns the result of this workflow as
 * well as a finalizer that can be run to close the scope of this workflow.
 *
 * @since 2.0.0
 * @category scoping, resources & finalization
 */
const Effect_withEarlyRelease = withEarlyRelease;
// -------------------------------------------------------------------------------------
// supervision & fibers
// -------------------------------------------------------------------------------------
/**
 * Returns a new effect that will not succeed with its value before first
 * waiting for the end of all child fibers forked by the effect.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_awaitAllChildren = awaitAllChildren;
/**
 * Returns a new workflow that will not supervise any fibers forked by this
 * workflow.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_daemonChildren = daemonChildren;
/**
 * Constructs an effect with information about the current `Fiber`.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_descriptor = descriptor;
/**
 * Constructs an effect based on information about the current `Fiber`.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_descriptorWith = descriptorWith;
/**
 * Returns a new workflow that executes this one and captures the changes in
 * `FiberRef` values.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_diffFiberRefs = diffFiberRefs;
/**
 * Acts on the children of this fiber (collected into a single fiber),
 * guaranteeing the specified callback will be invoked, whether or not this
 * effect succeeds.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_ensuringChild = ensuringChild;
/**
 * Acts on the children of this fiber, guaranteeing the specified callback
 * will be invoked, whether or not this effect succeeds.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_ensuringChildren = ensuringChildren;
/**
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_fiberId = fiberId;
/**
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_fiberIdWith = fiberIdWith;
/**
 * Returns an effect that forks this effect into its own separate fiber,
 * returning the fiber immediately, without waiting for it to begin executing
 * the effect.
 *
 * You can use the `fork` method whenever you want to execute an effect in a
 * new fiber, concurrently and without "blocking" the fiber executing other
 * effects. Using fibers can be tricky, so instead of using this method
 * directly, consider other higher-level methods, such as `raceWith`,
 * `zipPar`, and so forth.
 *
 * The fiber returned by this method has methods to interrupt the fiber and to
 * wait for it to finish executing the effect. See `Fiber` for more
 * information.
 *
 * Whenever you use this method to launch a new fiber, the new fiber is
 * attached to the parent fiber's scope. This means when the parent fiber
 * terminates, the child fiber will be terminated as well, ensuring that no
 * fibers leak. This behavior is called "auto supervision", and if this
 * behavior is not desired, you may use the `forkDaemon` or `forkIn` methods.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_fork = fork;
/**
 * Forks the effect into a new fiber attached to the global scope. Because the
 * new fiber is attached to the global scope, when the fiber executing the
 * returned effect terminates, the forked fiber will continue running.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_forkDaemon = forkDaemon;
/**
 * Returns an effect that forks all of the specified values, and returns a
 * composite fiber that produces a list of their results, in order.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_forkAll = forkAll;
/**
 * Forks the effect in the specified scope. The fiber will be interrupted
 * when the scope is closed.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_forkIn = forkIn;
/**
 * Forks the fiber in a `Scope`, interrupting it when the scope is closed.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_forkScoped = forkScoped;
/**
 * Like fork but handles an error with the provided handler.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_forkWithErrorHandler = forkWithErrorHandler;
/**
 * Creates an `Effect` value that represents the exit value of the specified
 * fiber.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_fromFiber = fromFiber;
/**
 * Creates an `Effect` value that represents the exit value of the specified
 * fiber.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_fromFiberEffect = fromFiberEffect;
/**
 * Returns an effect with the behavior of this one, but where all child fibers
 * forked in the effect are reported to the specified supervisor.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_supervised = supervised;
/**
 * Transplants specified effects so that when those effects fork other
 * effects, the forked effects will be governed by the scope of the fiber that
 * executes this effect.
 *
 * This can be used to "graft" deep grandchildren onto a higher-level scope,
 * effectively extending their lifespans into the parent scope.
 *
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_transplant = transplant;
/**
 * @since 2.0.0
 * @category supervision & fibers
 */
const Effect_withConcurrency = withConcurrency;
// ---------------------------------------------------------------------------------------
// scheduler
// ---------------------------------------------------------------------------------------
/**
 * Sets the provided scheduler for usage in the wrapped effect
 *
 * @since 2.0.0
 * @category scheduler
 */
const Effect_withScheduler = withScheduler;
/**
 * Sets the scheduling priority used when yielding
 *
 * @since 2.0.0
 * @category utils
 */
const Effect_withSchedulingPriority = withSchedulingPriority;
/**
 * Sets the maximum number of operations before yield by the default schedulers
 *
 * @since 2.0.0
 * @category utils
 */
const Effect_withMaxOpsBeforeYield = withMaxOpsBeforeYield;
// ---------------------------------------------------------------------------------------
// clock
// ---------------------------------------------------------------------------------------
/**
 * Retreives the `Clock` service from the context
 *
 * @since 2.0.0
 * @category clock
 */
const Effect_clock = clock;
/**
 * Retreives the `Clock` service from the context and provides it to the
 * specified effectful function.
 *
 * @since 2.0.0
 * @category clock
 */
const Effect_clockWith = core_effect_clockWith;
/**
 * Sets the implementation of the clock service to the specified value and
 * restores it to its original value when the scope is closed.
 *
 * @since 2.0.0
 * @category constructors
 */
const Effect_withClockScoped = withClockScoped;
/**
 * Executes the specified workflow with the specified implementation of the
 * clock service.
 *
 * @since 2.0.0
 * @category clock
 */
const Effect_withClock = withClock;
// -------------------------------------------------------------------------------------
// console
// -------------------------------------------------------------------------------------
/**
 * Retreives the `Console` service from the context
 *
 * @since 2.0.0
 * @category console
 */
const Effect_console = console_console;
/**
 * Retreives the `Console` service from the context and provides it to the
 * specified effectful function.
 *
 * @since 2.0.0
 * @category console
 */
const Effect_consoleWith = consoleWith;
/**
 * Sets the implementation of the console service to the specified value and
 * restores it to its original value when the scope is closed.
 *
 * @since 2.0.0
 * @category constructors
 */
const Effect_withConsoleScoped = withConsoleScoped;
/**
 * Executes the specified workflow with the specified implementation of the
 * console service.
 *
 * @since 2.0.0
 * @category console
 */
const Effect_withConsole = withConsole;
// ---------------------------------------------------------------------------------------
// delays & timeouts
// ---------------------------------------------------------------------------------------
/**
 * Returns an effect that is delayed from this effect by the specified
 * `Duration`.
 *
 * @since 2.0.0
 * @category delays & timeouts
 */
const Effect_delay = delay;
/**
 * Returns an effect that suspends for the specified duration. This method is
 * asynchronous, and does not actually block the fiber executing the effect.
 *
 * @since 2.0.0
 * @category delays & timeouts
 */
const Effect_sleep = core_effect_sleep;
/**
 * Returns a new effect that executes this one and times the execution.
 *
 * @since 2.0.0
 * @category delays & timeouts
 */
const Effect_timed = timed;
/**
 * A more powerful variation of `timed` that allows specifying the clock.
 *
 * @since 2.0.0
 * @category delays & timeouts
 */
const Effect_timedWith = timedWith;
/**
 * Returns an effect that will timeout this effect, failing with a `Cause.TimeoutException`
 * if the timeout elapses before the effect has produced a value.
 *
 * If the timeout elapses without producing a value, the running effect will
 * be safely interrupted.
 *
 * WARNING: The effect returned by this method will not itself return until
 * the underlying effect is actually interrupted. This leads to more
 * predictable resource utilization. If early return is desired, then instead
 * of using `effect.timeout(d)`, use `effect.disconnect.timeout(d)`, which
 * first disconnects the effect's interruption signal before performing the
 * timeout, resulting in earliest possible return, before an underlying effect
 * has been successfully interrupted.
 *
 * @since 2.0.0
 * @category delays & timeouts
 */
const Effect_timeout = timeout;
/**
 * Returns an effect that will timeout this effect, returning `None` if the
 * timeout elapses before the effect has produced a value; and returning
 * `Some` of the produced value otherwise.
 *
 * If the timeout elapses without producing a value, the running effect will
 * be safely interrupted.
 *
 * WARNING: The effect returned by this method will not itself return until
 * the underlying effect is actually interrupted. This leads to more
 * predictable resource utilization. If early return is desired, then instead
 * of using `effect.timeout(d)`, use `effect.disconnect.timeout(d)`, which
 * first disconnects the effect's interruption signal before performing the
 * timeout, resulting in earliest possible return, before an underlying effect
 * has been successfully interrupted.
 *
 * @since 3.1.0
 * @category delays & timeouts
 */
const Effect_timeoutOption = timeoutOption;
/**
 * The same as `timeout`, but instead of producing a `None` in the event of
 * timeout, it will produce the specified error.
 *
 * @since 2.0.0
 * @category delays & timeouts
 */
const Effect_timeoutFail = timeoutFail;
/**
 * The same as `timeout`, but instead of producing a `None` in the event of
 * timeout, it will produce the specified failure.
 *
 * @since 2.0.0
 * @category delays & timeouts
 */
const Effect_timeoutFailCause = timeoutFailCause;
/**
 * Returns an effect that will timeout this effect, returning either the
 * default value if the timeout elapses before the effect has produced a
 * value or returning the result of applying the function `onSuccess` to the
 * success value of the effect.
 *
 * If the timeout elapses without producing a value, the running effect will
 * be safely interrupted.
 *
 * @since 2.0.0
 * @category delays & timeouts
 */
const Effect_timeoutTo = timeoutTo;
// -------------------------------------------------------------------------------------
// config
// -------------------------------------------------------------------------------------
/**
 * Retrieves the default config provider, and passes it to the specified
 * function, which may return an effect that uses the provider to perform some
 * work or compute some value.
 *
 * @since 2.0.0
 * @category config
 */
const Effect_configProviderWith = configProviderWith;
/**
 * Executes the specified workflow with the specified configuration provider.
 *
 * @since 2.0.0
 * @category config
 */
const Effect_withConfigProvider = withConfigProvider;
/**
 * Sets the configuration provider to the specified value and restores it to its original value
 * when the scope is closed.
 *
 * @since 2.0.0
 * @category config
 */
const Effect_withConfigProviderScoped = withConfigProviderScoped;
// -------------------------------------------------------------------------------------
// context
// -------------------------------------------------------------------------------------
/**
 * @since 2.0.0
 * @category context
 */
const Effect_context = context;
/**
 * Accesses the context of the effect.
 *
 * @since 2.0.0
 * @category context
 */
const Effect_contextWith = core_effect_contextWith;
/**
 * Effectually accesses the context of the effect.
 *
 * @since 2.0.0
 * @category context
 */
const Effect_contextWithEffect = contextWithEffect;
/**
 * Provides some of the context required to run this effect,
 * leaving the remainder `R0`.
 *
 * @since 2.0.0
 * @category context
 */
const Effect_mapInputContext = mapInputContext;
/**
 * Splits the context into two parts, providing one part using the
 * specified layer/context/runtime and leaving the remainder `R0`
 *
 * @since 2.0.0
 * @category context
 */
const Effect_provide = effect_provide;
/**
 * Provides the effect with the single service it requires. If the effect
 * requires more than one service use `provide` instead.
 *
 * @since 2.0.0
 * @category context
 */
const Effect_provideService = provideService;
/**
 * Provides the effect with the single service it requires. If the effect
 * requires more than one service use `provide` instead.
 *
 * @since 2.0.0
 * @category context
 */
const Effect_provideServiceEffect = provideServiceEffect;
/**
 * @since 2.0.0
 * @category context
 */
const Effect_serviceFunction = serviceFunction;
/**
 * @since 2.0.0
 * @category context
 */
const Effect_serviceFunctionEffect = serviceFunctionEffect;
/**
 * @since 2.0.0
 * @category context
 */
const Effect_serviceFunctions = serviceFunctions;
/**
 * @since 2.0.0
 * @category context
 */
const Effect_serviceConstants = serviceConstants;
/**
 * @since 2.0.0
 * @category context
 */
const Effect_serviceMembers = serviceMembers;
/**
 * @since 2.0.0
 * @category context
 */
const Effect_serviceOption = serviceOption;
/**
 * @since 2.0.0
 * @category context
 */
const Effect_serviceOptional = serviceOptional;
/**
 * Updates the service with the required service entry.
 *
 * @since 2.0.0
 * @category context
 */
const Effect_updateService = updateService;
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * The "do simulation" in allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 *
 * @see {@link bind}
 * @see {@link bindTo}
 * @see {@link let_ let}
 *
 * @example
 * import { Effect, pipe } from "effect"
 *
 * const result = pipe(
 *   Effect.Do,
 *   Effect.bind("x", () => Effect.succeed(2)),
 *   Effect.bind("y", () => Effect.succeed(3)),
 *   Effect.let("sum", ({ x, y }) => x + y)
 * )
 * assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
 *
 * @category do notation
 * @since 2.0.0
 */
const Effect_Do = core_effect_Do;
/**
 * The "do simulation" in allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 *
 * @see {@link Do}
 * @see {@link bindTo}
 * @see {@link let_ let}
 *
 * @example
 * import { Effect, pipe } from "effect"
 *
 * const result = pipe(
 *   Effect.Do,
 *   Effect.bind("x", () => Effect.succeed(2)),
 *   Effect.bind("y", () => Effect.succeed(3)),
 *   Effect.let("sum", ({ x, y }) => x + y)
 * )
 * assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
 *
 * @category do notation
 * @since 2.0.0
 */
const Effect_bind = core_effect_bind;
/**
 * The "do simulation" in allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 *
 * @see {@link Do}
 * @see {@link bind}
 * @see {@link let_ let}
 *
 * @example
 * import { Effect, pipe } from "effect"
 *
 * const result = pipe(
 *   Effect.Do,
 *   Effect.bind("x", () => Effect.succeed(2)),
 *   Effect.bind("y", () => Effect.succeed(3)),
 *   Effect.let("sum", ({ x, y }) => x + y)
 * )
 * assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
 *
 * @category do notation
 * @since 2.0.0
 */
const Effect_bindTo = core_effect_bindTo;
const Effect_let_ = core_effect_let_;

// -------------------------------------------------------------------------------------
// conversions
// -------------------------------------------------------------------------------------
/**
 * Returns an effect whose failure and success have been lifted into an
 * `Either`. The resulting effect cannot fail, because the failure case has
 * been exposed as part of the `Either` success case.
 *
 * This method is useful for recovering from effects that may fail.
 *
 * The error parameter of the returned `Effect` is `never`, since it is
 * guaranteed the effect does not model failure.
 *
 * @since 2.0.0
 * @category conversions
 */
const Effect_either = core_either;
/**
 * @since 2.0.0
 * @category conversions
 */
const exit = core_exit;
/**
 * Returns an effect that will succeed or fail the specified `Deferred` based
 * upon the result of the effect. Also synchronizes interruption, so if the
 * provided effect is interrupted, the specified `Deferred` will be interrupted
 * as well.
 *
 * @since 2.0.0
 * @category conversions
 */
const Effect_intoDeferred = intoDeferred;
/**
 * Executes this effect, skipping the error but returning optionally the
 * success.
 *
 * @since 2.0.0
 * @category conversions
 */
const Effect_option = core_effect_option;
// -------------------------------------------------------------------------------------
// filtering & conditionals
// -------------------------------------------------------------------------------------
const Effect_if_ = if_;

/**
 * Filter the specified effect with the provided function, dying with specified
 * defect if the predicate fails.
 *
 * @since 2.0.0
 * @category filtering & conditionals
 */
const Effect_filterOrDie = filterOrDie;
/**
 * Filter the specified effect with the provided function, dying with specified
 * message if the predicate fails.
 *
 * @since 2.0.0
 * @category filtering & conditionals
 */
const Effect_filterOrDieMessage = filterOrDieMessage;
/**
 * Filters the specified effect with the provided function returning the value
 * of the effect if it is successful, otherwise returns the value of `orElse`.
 *
 * @since 2.0.0
 * @category filtering & conditionals
 */
const Effect_filterOrElse = filterOrElse;
/**
 * Filter the specified effect with the provided function, failing with specified
 * error if the predicate fails.
 *
 * In addition to the filtering capabilities discussed earlier, you have the option to further
 * refine and narrow down the type of the success channel by providing a
 * [user-defined type guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).
 * Let's explore this concept through an example:
 *
 * @example
 * import { Effect, pipe } from "effect"
 *
 * // Define a user interface
 * interface User {
 *   readonly name: string
 * }
 *
 * // Assume an asynchronous authentication function
 * declare const auth: () => Promise<User | null>
 *
 * const program = pipe(
 *   Effect.promise(() => auth()),
 *   Effect.filterOrFail(
 *     // Define a guard to narrow down the type
 *     (user): user is User => user !== null,
 *     () => new Error("Unauthorized")
 *   ),
 *   Effect.map((user) => user.name) // The 'user' here has type `User`, not `User | null`
 * )
 *
 * @since 2.0.0
 * @category filtering & conditionals
 */
const Effect_filterOrFail = filterOrFail;
/**
 * The moral equivalent of `if (!p) exp`.
 *
 * @since 2.0.0
 * @category filtering & conditionals
 */
const Effect_unless = unless;
/**
 * The moral equivalent of `if (!p) exp` when `p` has side-effects.
 *
 * @since 2.0.0
 * @category filtering & conditionals
 */
const Effect_unlessEffect = unlessEffect;
/**
 * The moral equivalent of `if (p) exp`.
 *
 * @since 2.0.0
 * @category filtering & conditionals
 */
const Effect_when = when;
/**
 * @since 2.0.0
 * @category filtering & conditionals
 */
const Effect_whenEffect = whenEffect;
/**
 * Executes this workflow when value of the specified `FiberRef` satisfies the
 * predicate.
 *
 * @since 2.0.0
 * @category filtering & conditionals
 */
const Effect_whenFiberRef = whenFiberRef;
/**
 * Executes this workflow when the value of the `Ref` satisfies the predicate.
 *
 * @since 2.0.0
 * @category filtering & conditionals
 */
const Effect_whenRef = whenRef;
// -------------------------------------------------------------------------------------
// sequencing
// -------------------------------------------------------------------------------------
/**
 * This function is a pipeable operator that maps over an `Effect` value,
 * flattening the result of the mapping function into a new `Effect` value.
 *
 * @param f - The mapping function to apply to the `Effect` value.
 * This function must return another `Effect` value.
 *
 * @returns A new `Effect` value that is the result of flattening the
 * mapped `Effect` value.
 *
 * @since 2.0.0
 * @category sequencing
 */
const Effect_flatMap = core_flatMap;
/**
 * Executes a sequence of two actions, typically two `Effect`s, where the second action can depend on the result of the first action.
 *
 * The `that` action can take various forms:
 *
 * - a value
 * - a function returning a value
 * - a promise
 * - a function returning a promise
 * - an effect
 * - a function returning an effect
 *
 * @example
 * import { Effect } from "effect"
 *
 * assert.deepStrictEqual(Effect.runSync(Effect.succeed("aa").pipe(Effect.andThen(1))), 1)
 * assert.deepStrictEqual(Effect.runSync(Effect.succeed("aa").pipe(Effect.andThen((s) => s.length))), 2)
 *
 * assert.deepStrictEqual(await Effect.runPromise(Effect.succeed("aa").pipe(Effect.andThen(Promise.resolve(1)))), 1)
 * assert.deepStrictEqual(await Effect.runPromise(Effect.succeed("aa").pipe(Effect.andThen((s) => Promise.resolve(s.length)))), 2)
 *
 * assert.deepStrictEqual(Effect.runSync(Effect.succeed("aa").pipe(Effect.andThen(Effect.succeed(1)))), 1)
 * assert.deepStrictEqual(Effect.runSync(Effect.succeed("aa").pipe(Effect.andThen((s) => Effect.succeed(s.length)))), 2)
 *
 * @since 2.0.0
 * @category sequencing
 */
const Effect_andThen = core_andThen;
/**
 * @since 2.0.0
 * @category sequencing
 */
const Effect_flatten = core_flatten;
/**
 * Returns an effect that races this effect with all the specified effects,
 * yielding the value of the first effect to succeed with a value. Losers of
 * the race will be interrupted immediately
 *
 * @since 2.0.0
 * @category sequencing
 */
const Effect_raceAll = raceAll;
/**
 * Returns an effect that races this effect with the specified effect,
 * returning the first successful `A` from the faster side. If one effect
 * succeeds, the other will be interrupted. If neither succeeds, then the
 * effect will fail with some error.
 *
 * @since 2.0.0
 * @category sequencing
 */
const Effect_race = race;
/**
 * Returns an effect that races this effect with the specified effect,
 * yielding the first result to complete, whether by success or failure. If
 * neither effect completes, then the composed effect will not complete.
 *
 * WARNING: The raced effect will safely interrupt the "loser", but will not
 * resume until the loser has been cleanly terminated. If early return is
 * desired, then instead of performing `l raceFirst r`, perform
 * `l.disconnect raceFirst r.disconnect`, which disconnects left and right
 * interrupt signal, allowing a fast return, with interruption performed
 * in the background.
 *
 * @since 2.0.0
 * @category sequencing
 */
const Effect_raceFirst = raceFirst;
/**
 * Returns an effect that races this effect with the specified effect, calling
 * the specified finisher as soon as one result or the other has been computed.
 *
 * @since 2.0.0
 * @category sequencing
 */
const Effect_raceWith = raceWith;
/**
 * Summarizes a effect by computing some value before and after execution, and
 * then combining the values to produce a summary, together with the result of
 * execution.
 *
 * @since 2.0.0
 * @category sequencing
 */
const Effect_summarized = summarized;
/**
 * @since 2.0.0
 * @category sequencing
 */
const Effect_tap = core_tap;
/**
 * Returns an effect that effectfully "peeks" at the failure or success of
 * this effect.
 *
 * @since 2.0.0
 * @category sequencing
 */
const Effect_tapBoth = tapBoth;
/**
 * Returns an effect that effectually "peeks" at the defect of this effect.
 *
 * @since 2.0.0
 * @category sequencing
 */
const Effect_tapDefect = tapDefect;
/**
 * Returns an effect that effectfully "peeks" at the failure of this effect.
 *
 * @since 2.0.0
 * @category sequencing
 */
const Effect_tapError = tapError;
/**
 * Returns an effect that effectfully "peeks" at the specific tagged failure of this effect.
 *
 * @since 2.0.0
 * @category sequencing
 */
const Effect_tapErrorTag = tapErrorTag;
/**
 * Returns an effect that effectually "peeks" at the cause of the failure of
 * this effect.
 *
 * @since 2.0.0
 * @category sequencing
 */
const Effect_tapErrorCause = tapErrorCause;
// -------------------------------------------------------------------------------------
// repetition / recursion
// -------------------------------------------------------------------------------------
/**
 * Repeats this effect forever (until the first error).
 *
 * @since 2.0.0
 * @category repetition / recursion
 */
const Effect_forever = forever;
/**
 * The `Effect.iterate` function allows you to iterate with an effectful operation. It uses an effectful `body` operation to change the state during each iteration and continues the iteration as long as the `while` function evaluates to `true`:
 *
 * ```ts
 * Effect.iterate(initial, options: { while, body })
 * ```
 *
 * We can think of `Effect.iterate` as equivalent to a `while` loop in JavaScript:
 *
 * ```ts
 * let result = initial
 *
 * while (options.while(result)) {
 *   result = options.body(result)
 * }
 *
 * return result
 * ```
 *
 * @since 2.0.0
 * @category repetition / recursion
 */
const Effect_iterate = iterate;
/**
 * The `Effect.loop` function allows you to repeatedly change the state based on an `step` function until a condition given by the `while` function is evaluated to `true`:
 *
 * ```ts
 * Effect.loop(initial, options: { while, step, body })
 * ```
 *
 * It collects all intermediate states in an array and returns it as the final result.
 *
 * We can think of Effect.loop as equivalent to a while loop in JavaScript:
 *
 * ```ts
 * let state = initial
 * const result = []
 *
 * while (options.while(state)) {
 *   result.push(options.body(state))
 *   state = options.step(state)
 * }
 *
 * return result
 * ```
 *
 * @since 2.0.0
 * @category repetition / recursion
 */
const Effect_loop = loop;
/**
 * Returns a new effect that repeats this effect according to the specified
 * schedule or until the first failure. Scheduled recurrences are in addition
 * to the first execution, so that `io.repeat(Schedule.once)` yields an effect
 * that executes `io`, and then if that succeeds, executes `io` an additional
 * time.
 *
 * @since 2.0.0
 * @category repetition / recursion
 */
const repeat = repeat_combined;
/**
 * Returns a new effect that repeats this effect the specified number of times
 * or until the first failure. Repeats are in addition to the first execution,
 * so that `io.repeatN(1)` yields an effect that executes `io`, and then if
 * that succeeds, executes `io` an additional time.
 *
 * @since 2.0.0
 * @category repetition / recursion
 */
const Effect_repeatN = repeatN;
/**
 * Returns a new effect that repeats this effect according to the specified
 * schedule or until the first failure, at which point, the failure value and
 * schedule output are passed to the specified handler.
 *
 * Scheduled recurrences are in addition to the first execution, so that
 * `pipe(effect, Effect.repeat(Schedule.once()))` yields an effect that executes
 * `effect`, and then if that succeeds, executes `effect` an additional time.
 *
 * @since 2.0.0
 * @category repetition / recursion
 */
const repeatOrElse = repeatOrElse_Effect;
/**
 * Runs this effect according to the specified schedule.
 *
 * See `scheduleFrom` for a variant that allows the schedule's decision to
 * depend on the result of this effect.
 *
 * @since 2.0.0
 * @category repetition / recursion
 */
const schedule = schedule_Effect;
/**
 * Runs this effect according to the specified schedule in a new fiber
 * attached to the current scope.
 *
 * @since 2.0.0
 * @category repetition / recursion
 */
const Effect_scheduleForked = scheduleForked;
/**
 * Runs this effect according to the specified schedule starting from the
 * specified input value.
 *
 * @since 2.0.0
 * @category repetition / recursion
 */
const scheduleFrom = scheduleFrom_Effect;
/**
 * @since 2.0.0
 * @category repetition / recursion
 */
const Effect_whileLoop = whileLoop;
// -------------------------------------------------------------------------------------
// fiber refs
// -------------------------------------------------------------------------------------
/**
 * Returns a collection of all `FiberRef` values for the fiber running this
 * effect.
 *
 * @since 2.0.0
 * @category fiber refs
 */
const getFiberRefs = core_effect_fiberRefs;
/**
 * Inherits values from all `FiberRef` instances into current fiber.
 *
 * @since 2.0.0
 * @category fiber refs
 */
const Effect_inheritFiberRefs = inheritFiberRefs;
/**
 * @since 2.0.0
 * @category fiber refs
 */
const Effect_locally = fiberRefLocally;
/**
 * @since 2.0.0
 * @category fiber refs
 */
const locallyWith = fiberRefLocallyWith;
/**
 * @since 2.0.0
 * @category fiber refs
 */
const locallyScoped = fiberRefLocallyScoped;
/**
 * @since 2.0.0
 * @category fiber refs
 */
const locallyScopedWith = fiberRefLocallyScopedWith;
/**
 * Applies the specified changes to the `FiberRef` values for the fiber
 * running this workflow.
 *
 * @since 2.0.0
 * @category fiber refs
 */
const Effect_patchFiberRefs = patchFiberRefs;
/**
 * Sets the `FiberRef` values for the fiber running this effect to the values
 * in the specified collection of `FiberRef` values.
 *
 * @since 2.0.0
 * @category fiber refs
 */
const Effect_setFiberRefs = setFiberRefs;
/**
 * Updates the `FiberRef` values for the fiber running this effect using the
 * specified function.
 *
 * @since 2.0.0
 * @category fiber refs
 */
const Effect_updateFiberRefs = updateFiberRefs;
// -------------------------------------------------------------------------------------
// getters & folding
// -------------------------------------------------------------------------------------
/**
 * Returns `true` if this effect is a failure, `false` otherwise.
 *
 * @since 2.0.0
 * @category getters & folding
 */
const Effect_isFailure = core_effect_isFailure;
/**
 * Returns `true` if this effect is a success, `false` otherwise.
 *
 * @since 2.0.0
 * @category getters & folding
 */
const Effect_isSuccess = isSuccess;
/**
 * Folds over the failure value or the success value to yield an effect that
 * does not fail, but succeeds with the value returned by the left or right
 * function passed to `match`.
 *
 * @since 2.0.0
 * @category getters & folding
 */
const Effect_match = core_effect_match;
/**
 * @since 2.0.0
 * @category getters & folding
 */
const Effect_matchCause = matchCause;
/**
 * @since 2.0.0
 * @category getters & folding
 */
const Effect_matchCauseEffect = matchCauseEffect;
/**
 * @since 2.0.0
 * @category getters & folding
 */
const Effect_matchEffect = matchEffect;
// -------------------------------------------------------------------------------------
// logging
// -------------------------------------------------------------------------------------
/**
 * Logs the specified message or cause at the current log level.
 *
 * You can set the current log level using `FiberRef.currentLogLevel`.
 *
 * @since 2.0.0
 * @category logging
 */
const Effect_log = log;
/**
 * Logs the specified message or cause at the specified log level.
 *
 * @since 2.0.0
 * @category logging
 */
const Effect_logWithLevel = (level, ...message) => effect.logWithLevel(level)(...message);
/**
 * Logs the specified message or cause at the Trace log level.
 *
 * @since 2.0.0
 * @category logging
 */
const Effect_logTrace = logTrace;
/**
 * Logs the specified message or cause at the Debug log level.
 *
 * @since 2.0.0
 * @category logging
 */
const Effect_logDebug = logDebug;
/**
 * Logs the specified message or cause at the Info log level.
 *
 * @since 2.0.0
 * @category logging
 */
const Effect_logInfo = logInfo;
/**
 * Logs the specified message or cause at the Warning log level.
 *
 * @since 2.0.0
 * @category logging
 */
const Effect_logWarning = logWarning;
/**
 * Logs the specified message or cause at the Error log level.
 *
 * @since 2.0.0
 * @category logging
 */
const Effect_logError = logError;
/**
 * Logs the specified message or cause at the Fatal log level.
 *
 * @since 2.0.0
 * @category logging
 */
const Effect_logFatal = logFatal;
/**
 * Adjusts the label for the current logging span.
 *
 * @since 2.0.0
 * @category logging
 */
const Effect_withLogSpan = withLogSpan;
/**
 * Annotates each log in this effect with the specified log annotation.
 *
 * @since 2.0.0
 * @category logging
 */
const Effect_annotateLogs = annotateLogs;
/**
 * Annotates each log with the specified log annotation(s), until the Scope is closed.
 *
 * @since 3.1.0
 * @category logging
 * @example
 * import { Effect } from "effect"
 *
 * Effect.gen(function*() {
 *   yield* Effect.log("no annotations")
 *   yield* Effect.annotateLogsScoped({ foo: "bar" })
 *   yield* Effect.log("annotated with foo=bar")
 * }).pipe(
 *   Effect.scoped,
 *   Effect.andThen(Effect.log("no annotations again"))
 * )
 */
const Effect_annotateLogsScoped = annotateLogsScoped;
/**
 * Retrieves the log annotations associated with the current scope.
 *
 * @since 2.0.0
 * @category logging
 */
const Effect_logAnnotations = logAnnotations;
/**
 * Decides wether child fibers will report or not unhandled errors via the logger
 *
 * @since 2.0.0
 * @category logging
 */
const Effect_withUnhandledErrorLogLevel = withUnhandledErrorLogLevel;
// -------------------------------------------------------------------------------------
// alternatives
// -------------------------------------------------------------------------------------
/**
 * Translates effect failure into death of the fiber, making all failures
 * unchecked and not a part of the type of the effect.
 *
 * @since 2.0.0
 * @category alternatives
 */
const Effect_orDie = orDie;
/**
 * Keeps none of the errors, and terminates the fiber with them, using the
 * specified function to convert the `E` into a `Throwable`.
 *
 * @since 2.0.0
 * @category alternatives
 */
const Effect_orDieWith = orDieWith;
/**
 * Executes this effect and returns its value, if it succeeds, but otherwise
 * executes the specified effect.
 *
 * @since 2.0.0
 * @category alternatives
 */
const Effect_orElse = core_orElse;
/**
 * Executes this effect and returns its value, if it succeeds, but otherwise
 * fails with the specified error.
 *
 * @since 2.0.0
 * @category alternatives
 */
const Effect_orElseFail = orElseFail;
/**
 * Executes this effect and returns its value, if it succeeds, but
 * otherwise succeeds with the specified value.
 *
 * @since 2.0.0
 * @category alternatives
 */
const Effect_orElseSucceed = orElseSucceed;
// -------------------------------------------------------------------------------------
// random
// -------------------------------------------------------------------------------------
/**
 * Retreives the `Random` service from the context.
 *
 * @since 2.0.0
 * @category random
 */
const Effect_random = core_effect_random;
/**
 * Retreives the `Random` service from the context and uses it to run the
 * specified workflow.
 *
 * @since 2.0.0
 * @category random
 */
const Effect_randomWith = randomWith;
/**
 * Executes the specified workflow with the specified implementation of the
 * random service.
 *
 * @since 2.0.0
 * @category random
 */
const Effect_withRandom = withRandom;
/**
 * Sets the implementation of the random service to the specified value and
 * restores it to its original value when the scope is closed.
 *
 * @since 2.0.0
 * @category constructors
 */
const Effect_withRandomScoped = withRandomScoped;
// -------------------------------------------------------------------------------------
// runtime
// -------------------------------------------------------------------------------------
/**
 * Returns an effect that accesses the runtime, which can be used to
 * (unsafely) execute tasks. This is useful for integration with legacy code
 * that must call back into Effect code.
 *
 * @since 2.0.0
 * @category runtime
 */
const Effect_runtime = runtime_runtime;
/**
 * Retrieves an effect that succeeds with the current runtime flags, which
 * govern behavior and features of the runtime system.
 *
 * @since 2.0.0
 * @category runtime
 */
const getRuntimeFlags = core_runtimeFlags;
/**
 * @since 2.0.0
 * @category runtime
 */
const patchRuntimeFlags = updateRuntimeFlags;
/**
 * @since 2.0.0
 * @category runtime
 */
const withRuntimeFlagsPatch = withRuntimeFlags;
/**
 * @since 2.0.0
 * @category runtime
 */
const withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
// -------------------------------------------------------------------------------------
// metrics
// -------------------------------------------------------------------------------------
/**
 * Tags each metric in this effect with the specific tag.
 *
 * @since 2.0.0
 * @category metrics
 */
const Effect_tagMetrics = tagMetrics;
/**
 * Tags each metric in this effect with the specific tag.
 *
 * @since 2.0.0
 * @category metrics
 */
const Effect_labelMetrics = labelMetrics;
/**
 * Tags each metric in a scope with a the specific tag.
 *
 * @since 2.0.0
 * @category metrics
 */
const Effect_tagMetricsScoped = tagMetricsScoped;
/**
 * Tags each metric in a scope with a the specific tag.
 *
 * @since 2.0.0
 * @category metrics
 */
const Effect_labelMetricsScoped = labelMetricsScoped;
/**
 * Retrieves the metric labels associated with the current scope.
 *
 * @since 2.0.0
 * @category metrics
 */
const Effect_metricLabels = metricLabels;
/**
 * @since 2.0.0
 * @category metrics
 */
const Effect_withMetric = withMetric;
/**
 * Unsafely creates a new Semaphore
 *
 * @since 2.0.0
 * @category semaphore
 */
const Effect_unsafeMakeSemaphore = unsafeMakeSemaphore;
/**
 * Creates a new Semaphore
 *
 * @since 2.0.0
 * @category semaphore
 */
const Effect_makeSemaphore = makeSemaphore;
// -------------------------------------------------------------------------------------
// execution
// -------------------------------------------------------------------------------------
/**
 * @since 2.0.0
 * @category execution
 */
const runFork = unsafeForkEffect;
/**
 * @since 2.0.0
 * @category execution
 */
const runCallback = unsafeRunEffect;
/**
 * Runs an `Effect` workflow, returning a `Promise` which resolves with the
 * result of the workflow or rejects with an error.
 *
 * @since 2.0.0
 * @category execution
 */
const runPromise = unsafeRunPromiseEffect;
/**
 * Runs an `Effect` workflow, returning a `Promise` which resolves with the
 * `Exit` value of the workflow.
 *
 * @since 2.0.0
 * @category execution
 */
const runPromiseExit = unsafeRunPromiseExitEffect;
/**
 * @since 2.0.0
 * @category execution
 */
const runSync = unsafeRunSyncEffect;
/**
 * @since 2.0.0
 * @category execution
 */
const runSyncExit = unsafeRunSyncExitEffect;
// -------------------------------------------------------------------------------------
// zipping
// -------------------------------------------------------------------------------------
/**
 * Sequentially zips the this result with the specified result. Combines both
 * `Cause`s when both effects fail.
 *
 * @since 2.0.0
 * @category zipping
 */
const Effect_validate = validate;
/**
 * Sequentially zips this effect with the specified effect using the specified
 * combiner function. Combines the causes in case both effect fail.
 *
 * @since 2.0.0
 * @category zipping
 */
const Effect_validateWith = validateWith;
/**
 * @since 2.0.0
 * @category zipping
 */
const Effect_zip = zipOptions;
/**
 * Sequentially run this effect with the specified effect, _discarding_ the result
 * of the second effect (`that`) in the chain.
 *
 * `{ concurrent: true }` can be passed to the options to make it a concurrent execution
 * of both effects instead of sequential.
 *
 * @example
 *
 * import { Effect } from 'effect';
 *
 * const effect = Effect.succeed("a message").pipe(
 *   Effect.zipLeft(Effect.succeed(42)),
 * )
 *
 * assert.deepStrictEqual(Effect.runSync(effect), "a message");
 *
 * @since 2.0.0
 * @category zipping
 */
const Effect_zipLeft = zipLeftOptions;
/**
 * Sequentially run this effect with the specified effect, _returning_ the result
 * of the second effect (`that`) in the chain.
 *
 * `{ concurrent: true }` can be passed to the options to make it a concurrent execution
 * of both effects instead of sequential.
 *
 * @example
 *
 * import { Effect } from 'effect';
 *
 * const effect = Effect.succeed("a message").pipe(
 *   Effect.zipRight(Effect.succeed(42)),
 * )
 *
 * assert.deepStrictEqual(Effect.runSync(effect), 42);
 *
 * @since 2.0.0
 * @category zipping
 */
const Effect_zipRight = zipRightOptions;
/**
 * @since 2.0.0
 * @category zipping
 */
const Effect_zipWith = zipWithOptions;
// -------------------------------------------------------------------------------------
// applicatives
// -------------------------------------------------------------------------------------
/**
 * @category combining
 * @since 2.0.0
 */
const Effect_ap = /*#__PURE__*/(/* unused pure expression or super */ null && (dual(2, (self, that) => Effect_zipWith(self, that, (f, a) => f(a)))));
// -------------------------------------------------------------------------------------
// requests & batching
// -------------------------------------------------------------------------------------
/**
 * @category requests & batching
 * @since 2.0.0
 */
const Effect_blocked = blocked;
/**
 * @category requests & batching
 * @since 2.0.0
 */
const Effect_runRequestBlock = runRequestBlock;
/**
 * @category requests & batching
 * @since 2.0.0
 */
const Effect_step = step;
/**
 * @since 2.0.0
 * @category requests & batching
 */
const request = /*#__PURE__*/Function_dual(args => Request_isRequest(args[0]), fromRequest);
/**
 * @since 2.0.0
 * @category requests & batching
 */
const cacheRequestResult = cacheRequest;
/**
 * @since 2.0.0
 * @category requests & batching
 */
const Effect_withRequestBatching = withRequestBatching;
/**
 * @since 2.0.0
 * @category requests & batching
 */
const Effect_withRequestCaching = withRequestCaching;
/**
 * @since 2.0.0
 * @category requests & batching
 */
const Effect_withRequestCache = withRequestCache;
// -------------------------------------------------------------------------------------
// tracing
// -------------------------------------------------------------------------------------
/**
 * @since 2.0.0
 * @category tracing
 */
const Effect_tracer = core_effect_tracer;
/**
 * @since 2.0.0
 * @category tracing
 */
const Effect_tracerWith = tracerWith;
/**
 * @since 2.0.0
 * @category tracing
 */
const Effect_withTracer = withTracer;
/**
 * @since 2.0.0
 * @category tracing
 */
const Effect_withTracerScoped = withTracerScoped;
/**
 * Disable the tracer for the given Effect.
 *
 * @since 2.0.0
 * @category tracing
 * @example
 * import { Effect } from "effect"
 *
 * Effect.succeed(42).pipe(
 *   Effect.withSpan("my-span"),
 *   // the span will not be registered with the tracer
 *   Effect.withTracerEnabled(false)
 * )
 */
const Effect_withTracerEnabled = withTracerEnabled;
/**
 * @since 2.0.0
 * @category tracing
 */
const Effect_withTracerTiming = withTracerTiming;
/**
 * Adds an annotation to each span in this effect.
 *
 * @since 2.0.0
 * @category tracing
 */
const Effect_annotateSpans = annotateSpans;
/**
 * Adds an annotation to the current span if available
 *
 * @since 2.0.0
 * @category tracing
 */
const Effect_annotateCurrentSpan = annotateCurrentSpan;
/**
 * @since 2.0.0
 * @category tracing
 */
const Effect_currentSpan = currentSpan;
/**
 * @since 2.0.0
 * @category tracing
 */
const Effect_currentParentSpan = currentParentSpan;
/**
 * @since 2.0.0
 * @category tracing
 */
const Effect_spanAnnotations = spanAnnotations;
/**
 * @since 2.0.0
 * @category tracing
 */
const Effect_spanLinks = spanLinks;
/**
 * For all spans in this effect, add a link with the provided span.
 *
 * @since 2.0.0
 * @category tracing
 */
const Effect_linkSpans = linkSpans;
/**
 * Create a new span for tracing.
 *
 * @since 2.0.0
 * @category tracing
 */
const Effect_makeSpan = makeSpan;
/**
 * Create a new span for tracing, and automatically close it when the Scope
 * finalizes.
 *
 * The span is not added to the current span stack, so no child spans will be
 * created for it.
 *
 * @since 2.0.0
 * @category tracing
 */
const Effect_makeSpanScoped = makeSpanScoped;
/**
 * Create a new span for tracing, and automatically close it when the effect
 * completes.
 *
 * The span is not added to the current span stack, so no child spans will be
 * created for it.
 *
 * @since 2.0.0
 * @category tracing
 */
const Effect_useSpan = useSpan;
/**
 * Wraps the effect with a new span for tracing.
 *
 * @since 2.0.0
 * @category tracing
 */
const Effect_withSpan = withSpan;
/**
 * Wraps the effect with a new span for tracing.
 *
 * The span is ended when the Scope is finalized.
 *
 * @since 2.0.0
 * @category tracing
 */
const Effect_withSpanScoped = withSpanScoped;
/**
 * Adds the provided span to the current span stack.
 *
 * @since 2.0.0
 * @category tracing
 */
const Effect_withParentSpan = withParentSpan;
// -------------------------------------------------------------------------------------
// optionality
// -------------------------------------------------------------------------------------
/**
 * Returns an effect that errors with `NoSuchElementException` if the value is
 * null or undefined, otherwise succeeds with the value.
 *
 * @since 2.0.0
 * @category optionality
 */
const Effect_fromNullable = core_effect_fromNullable;
/**
 * Wraps the success value of this effect with `Option.some`, and maps
 * `Cause.NoSuchElementException` to `Option.none`.
 *
 * @since 2.0.0
 * @category optionality
 */
const Effect_optionFromOptional = optionFromOptional;
/**
 * @since 2.0.0
 * @category constructors
 */
const Effect_Tag = id => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {}
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  const cache = new Map();
  const done = new Proxy(TagClass, {
    get(_target, prop, _receiver) {
      if (prop === "use") {
        // @ts-expect-error
        return body => core.andThen(TagClass, body);
      }
      if (prop in TagClass) {
        // @ts-expect-error
        return TagClass[prop];
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn = (...args) =>
      // @ts-expect-error
      core.andThen(TagClass, s => {
        if (typeof s[prop] === "function") {
          // @ts-expect-error
          cache.set(prop, (...args) => core.andThen(TagClass, s => s[prop](...args)));
          return s[prop](...args);
        }
        // @ts-expect-error
        cache.set(prop, core.andThen(TagClass, s => s[prop]));
        return s[prop];
      });
      // @ts-expect-error
      const cn = core.andThen(TagClass, s => s[prop]);
      Object.assign(fn, cn);
      Object.setPrototypeOf(fn, Object.getPrototypeOf(cn));
      cache.set(prop, fn);
      return fn;
    }
  });
  return done;
};
//# sourceMappingURL=Effect.js.map
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-endpoint/dist-es/index.js + 10 modules
var dist_es = __webpack_require__(1496);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/middleware-serde/dist-es/index.js + 3 modules
var middleware_serde_dist_es = __webpack_require__(6391);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/node_modules/@smithy/smithy-client/dist-es/index.js + 29 modules
var smithy_client_dist_es = __webpack_require__(3810);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/endpoint/EndpointParameters.js
var EndpointParameters = __webpack_require__(7207);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/protocols/Aws_query.js
var Aws_query = __webpack_require__(784);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/commands/GetCallerIdentityCommand.js






class GetCallerIdentityCommand extends smithy_client_dist_es/* Command */.uB
    .classBuilder()
    .ep({
    ...EndpointParameters/* commonParams */.S,
})
    .m(function (Command, cs, config, o) {
    return [
        (0,middleware_serde_dist_es/* getSerdePlugin */.TM)(config, this.serialize, this.deserialize),
        (0,dist_es/* getEndpointPlugin */.rD)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSSecurityTokenServiceV20110615", "GetCallerIdentity", {})
    .n("STSClient", "GetCallerIdentityCommand")
    .f(void 0, void 0)
    .ser(Aws_query/* se_GetCallerIdentityCommand */.GQ)
    .de(Aws_query/* de_GetCallerIdentityCommand */.hW)
    .build() {
}

;// CONCATENATED MODULE: ./src/core/aws/common/errors.ts

const mapAwsServiceError = (serviceName) => (output) => Effect_filterOrFail(output, (output) => output.$metadata.httpStatusCode == 200, (output) => ({
    _tag: 'AwsServiceError',
    service: serviceName,
    message: 'Failed to get AWS account info',
    metadata: output.$metadata
}));
const mapAwsUnExpectedResponseError = (serviceName, condition) => (input) => Effect_filterOrFail(input, condition, (input) => ({
    _tag: 'AwsUnExpectedResponseError',
    service: serviceName,
    response: input,
    message: 'UnExpected AWS Service Response'
}));
const tryAwsServiceCall = (options) => (command) => Function_pipe(Effect_tryPromise({
    try: (abort) => options.try(options.service.get(options.request), command, abort),
    catch: () => ({
        _tag: 'AwsServiceError',
        service: options.service.name,
        message: 'Failure while calling AWS service'
    })
}), mapAwsServiceError(options.service.name), mapAwsUnExpectedResponseError(options.service.name, options.expect));
const safeAwsServiceCall = (options) => (command) => pipe(Effect.tryPromise({
    try: () => options.service.get(options.request).send(command),
    catch: () => ({
        _tag: 'AwsServiceError',
        service: options.service.name,
        message: 'Failed to get AWS account info'
    })
}), mapAwsServiceError(options.service.name), mapAwsUnExpectedResponseError(options.service.name, options.expect));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
const resolveParamsForS3 = async (endpointParams) => {
    const bucket = endpointParams?.Bucket || "";
    if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if (isArnBucketName(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
            throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
    }
    else if (!isDnsCompatibleBucketName(bucket) ||
        (bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:")) ||
        bucket.toLowerCase() !== bucket ||
        bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
    }
    return endpointParams;
};
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
const DOT_PATTERN = /\./;
const S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
const isArnBucketName = (bucketName) => {
    const [arn, partition, service, , , bucket] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = Boolean(isArn && partition && service && bucket);
    if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return isValidArn;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
    const configProvider = async () => {
        const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
            return configValue();
        }
        return configValue;
    };
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
        return async () => {
            const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
            const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
            return configValue;
        };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
            const endpoint = await configProvider();
            if (endpoint && typeof endpoint === "object") {
                if ("url" in endpoint) {
                    return endpoint.url.href;
                }
                if ("hostname" in endpoint) {
                    const { protocol, hostname, port, path } = endpoint;
                    return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
                }
            }
            return endpoint;
        };
    }
    return configProvider;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError extends ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/property-provider/dist-es/chain.js

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/property-provider/dist-es/fromStatic.js
const fromStatic = (staticValue) => () => Promise.resolve(staticValue);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/property-provider/dist-es/memoize.js
const memoize_memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-config-provider/dist-es/fromEnv.js

const fromEnv_fromEnv = (envVarSelector) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
};

// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${external_path_.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0,external_os_.homedir)();
    return homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = createHash("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile } = external_fs_.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/types/dist-es/extensions/checksum.js
var checksum_AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(checksum_AlgorithmId || (checksum_AlgorithmId = {}));
const checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => checksum_AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => checksum_AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/types/dist-es/http.js
var http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(http_FieldPosition || (http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/types/dist-es/middleware.js
const SMITHY_CONTEXT_KEY = "__smithy_context";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/types/dist-es/profile.js
var profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(profile_IniSectionType || (profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(profile_IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === profile_IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath_getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || (0,external_path_.join)(getHomeDir_getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(profile_IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: slurpFile_readFile } = external_fs_.promises;
const filePromisesHash = {};
const slurpFile_slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = slurpFile_readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const swallowError = () => ({});
const loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles_loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath_getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        slurpFile_slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile_slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js


const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = getProfileName(init);
    const { configFile, credentialsFile } = await loadSharedConfigFiles_loadSharedConfigFiles(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message ||
            `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-config-provider/dist-es/fromStatic.js

const fromStatic_isFunction = (func) => typeof func === "function";
const fromStatic_fromStatic = (defaultValue) => fromStatic_isFunction(defaultValue) ? async () => await defaultValue() : fromStatic(defaultValue);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-config-provider/dist-es/configLoader.js




const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize_memoize(chain(fromEnv_fromEnv(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic_fromStatic(defaultValue)));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-config-provider/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointUrlConfig.js

const ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
const CONFIG_ENDPOINT_URL = "endpoint_url";
const getEndpointUrlConfig = (serviceId) => ({
    environmentVariableSelector: (env) => {
        const serviceSuffixParts = serviceId.split(" ").map((w) => w.toUpperCase());
        const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
        if (serviceEndpointUrl)
            return serviceEndpointUrl;
        const endpointUrl = env[ENV_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    configFileSelector: (profile, config) => {
        if (config && profile.services) {
            const servicesSection = config[["services", profile.services].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR)];
            if (servicesSection) {
                const servicePrefixParts = serviceId.split(" ").map((w) => w.toLowerCase());
                const endpointUrl = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR)];
                if (endpointUrl)
                    return endpointUrl;
            }
        }
        const endpointUrl = profile[CONFIG_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    default: undefined,
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.js


const getEndpointFromConfig = async (serviceId) => loadConfig(getEndpointUrlConfig(serviceId))();

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
        for (const pair of querystring.split("&")) {
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
                value = decodeURIComponent(value);
            }
            if (!(key in query)) {
                query[key] = value;
            }
            else if (Array.isArray(query[key])) {
                query[key].push(value);
            }
            else {
                query[key] = [query[key], value];
            }
        }
    }
    return query;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/url-parser/dist-es/index.js

const parseUrl = (url) => {
    if (typeof url === "string") {
        return parseUrl(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
        query = parseQueryString(search);
    }
    return {
        hostname,
        port: port ? parseInt(port) : undefined,
        protocol,
        path: pathname,
        query,
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js

const toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
        if ("url" in endpoint) {
            return parseUrl(endpoint.url);
        }
        return endpoint;
    }
    return parseUrl(endpoint);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js




const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.endpoint) {
        const endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId || "");
        if (endpointFromConfig) {
            clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
        }
    }
    const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
};
const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
            case "staticContextParams":
                endpointParams[name] = instruction.value;
                break;
            case "contextParams":
                endpointParams[name] = commandInput[instruction.name];
                break;
            case "clientContextParams":
            case "builtInParams":
                endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
                break;
            default:
                throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
    }
    if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await resolveParamsForS3(endpointParams);
    }
    return endpointParams;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js

const getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-middleware/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js


const endpointMiddleware = ({ config, instructions, }) => {
    return (next, context) => async (args) => {
        const endpoint = await getEndpointFromInstructions(args.input, {
            getEndpointParameterInstructions() {
                return instructions;
            },
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
            context["signing_region"] = authScheme.signingRegion;
            context["signing_service"] = authScheme.signingName;
            const smithyContext = getSmithyContext(context);
            const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
            if (httpAuthOption) {
                httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
                    signing_region: authScheme.signingRegion,
                    signingRegion: authScheme.signingRegion,
                    signing_service: authScheme.signingName,
                    signingName: authScheme.signingName,
                    signingRegionSet: authScheme.signingRegionSet,
                }, authScheme.properties);
            }
        }
        return next({
            ...args,
        });
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
const deserializerMiddleware = (options, deserializer) => (next) => async (args) => {
    const { response } = await next(args);
    try {
        const parsed = await deserializer(response, options);
        return {
            response,
            output: parsed,
        };
    }
    catch (error) {
        Object.defineProperty(error, "$response", {
            value: response,
        });
        if (!("$metadata" in error)) {
            const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
            error.message += "\n  " + hint;
            if (typeof error.$responseBodyText !== "undefined") {
                if (error.$response) {
                    error.$response.body = error.$responseBodyText;
                }
            }
        }
        throw error;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    const endpoint = context.endpointV2?.url && options.urlParser
        ? async () => options.urlParser(context.endpointV2.url)
        : options.endpoint;
    if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
        ...args,
        request,
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js


const deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true,
};
const serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true,
};
function getSerdePlugin(config, serializer, deserializer) {
    return {
        applyToStack: (commandStack) => {
            commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
            commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
        },
    };
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-serde/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js


const endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: serializerMiddlewareOption.name,
};
const getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(endpointMiddleware({
            config,
            instructions,
        }), endpointMiddlewareOptions);
    },
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js


const resolveEndpointConfig = (input) => {
    const tls = input.tls ?? true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    return {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
        useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-endpoint/dist-es/index.js






;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
class NoOpLogger {
    trace() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
const getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo(constructStack()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo(constructStack());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                const step = mw.step ??
                    mw.relation +
                        " " +
                        mw.toMiddleware;
                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/middleware-stack/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/client.js

class Client {
    constructor(config) {
        this.middlewareStack = constructStack();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/is-array-buffer/dist-es/index.js
const dist_es_isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// EXTERNAL MODULE: external "buffer"
var external_buffer_ = __webpack_require__(181);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-buffer-from/dist-es/index.js


const dist_es_fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!dist_es_isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return external_buffer_.Buffer.from(input, offset, length);
};
const dist_es_fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? external_buffer_.Buffer.from(input, encoding) : external_buffer_.Buffer.from(input);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-base64/dist-es/fromBase64.js

const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64_fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = dist_es_fromString(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js

const fromUtf8_fromUtf8 = (input) => {
    const buf = dist_es_fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js

const toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-utf8/dist-es/toUtf8.js

const toUtf8_toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return dist_es_fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-utf8/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-base64/dist-es/toBase64.js


const toBase64_toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
        input = fromUtf8_fromUtf8(_input);
    }
    else {
        input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return dist_es_fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-base64/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-stream/dist-es/blob/transforms.js



function transforms_transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return toBase64(payload);
    }
    return toUtf8(payload);
}
function transforms_transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js

class Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter extends (/* unused pure expression or super */ null && (Uint8Array)) {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return transformFromString(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
    }
}

// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(2203);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.js

const getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
const getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
    let httpHandler = runtimeConfig.httpHandler;
    return {
        setHttpHandler(handler) {
            httpHandler = handler;
        },
        httpHandler() {
            return httpHandler;
        },
        updateHttpClientConfig(key, value) {
            httpHandler.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
            return httpHandler.httpHandlerConfigs();
        },
    };
};
const resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
    return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/protocol-http/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class httpRequest_HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new httpRequest_HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/protocol-http/dist-es/httpResponse.js
class httpResponse_HttpResponse {
    constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/protocol-http/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/querystring-builder/dist-es/index.js

function dist_es_buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = escapeUri(key);
        if (Array.isArray(value)) {
            for (let i = 0, iLen = value.length; i < iLen; i++) {
                parts.push(`${key}=${escapeUri(value[i])}`);
            }
        }
        else {
            let qsEntry = key;
            if (value || typeof value === "string") {
                qsEntry += `=${escapeUri(value)}`;
            }
            parts.push(qsEntry);
        }
    }
    return parts.join("&");
}

// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(8611);
// EXTERNAL MODULE: external "https"
var external_https_ = __webpack_require__(5692);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/constants.js
const constants_NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/get-transformed-headers.js
const get_transformed_headers_getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
};


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/set-connection-timeout.js
const set_connection_timeout_setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
        return;
    }
    const timeoutId = setTimeout(() => {
        request.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
            name: "TimeoutError",
        }));
    }, timeoutInMs);
    request.on("socket", (socket) => {
        if (socket.connecting) {
            socket.on("connect", () => {
                clearTimeout(timeoutId);
            });
        }
        else {
            clearTimeout(timeoutId);
        }
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/set-socket-keep-alive.js
const set_socket_keep_alive_setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }) => {
    if (keepAlive !== true) {
        return;
    }
    request.on("socket", (socket) => {
        socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/set-socket-timeout.js
const set_socket_timeout_setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    request.setTimeout(timeoutInMs, () => {
        request.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/write-request-body.js

const MIN_WAIT_TIME = 1000;
async function write_request_body_writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", () => {
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            }),
        ]);
    }
    if (!hasError) {
        writeBody(httpRequest, request.body);
    }
}
function writeBody(httpRequest, body) {
    if (body instanceof external_stream_.Readable) {
        body.pipe(httpRequest);
        return;
    }
    if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
            httpRequest.end(body);
            return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" &&
            uint8.buffer &&
            typeof uint8.byteOffset === "number" &&
            typeof uint8.byteLength === "number") {
            httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
            return;
        }
        httpRequest.end(Buffer.from(body));
        return;
    }
    httpRequest.end();
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js










const DEFAULT_REQUEST_TIMEOUT = 0;
class NodeHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
            return socketWarningTimestamp;
        }
        const interval = 15000;
        if (Date.now() - interval < socketWarningTimestamp) {
            return socketWarningTimestamp;
        }
        if (sockets && requests) {
            for (const origin in sockets) {
                const socketsInUse = sockets[origin]?.length ?? 0;
                const requestsEnqueued = requests[origin]?.length ?? 0;
                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
                    console.warn("@smithy/node-http-handler:WARN", `socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.`, "See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html", "or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.");
                    return Date.now();
                }
            }
        }
        return socketWarningTimestamp;
    }
    constructor(options) {
        this.socketWarningTimestamp = 0;
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout ?? socketTimeout,
            httpAgent: (() => {
                if (httpAgent instanceof external_http_.Agent || typeof httpAgent?.destroy === "function") {
                    return httpAgent;
                }
                return new external_http_.Agent({ keepAlive, maxSockets, ...httpAgent });
            })(),
            httpsAgent: (() => {
                if (httpsAgent instanceof external_https_.Agent || typeof httpsAgent?.destroy === "function") {
                    return httpsAgent;
                }
                return new external_https_.Agent({ keepAlive, maxSockets, ...httpsAgent });
            })(),
        };
    }
    destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        let socketCheckTimeoutId;
        return new Promise((_resolve, _reject) => {
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                clearTimeout(socketCheckTimeoutId);
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
            socketCheckTimeoutId = setTimeout(() => {
                this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp);
            }, this.config.socketAcquisitionWarningTimeout ??
                (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000));
            const queryString = dist_es_buildQueryString(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent,
                auth,
            };
            const requestFunc = isSSL ? external_https_.request : external_http_.request;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new httpResponse_HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: get_transformed_headers_getTransformedHeaders(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (constants_NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            set_connection_timeout_setConnectionTimeout(req, reject, this.config.connectionTimeout);
            set_socket_timeout_setSocketTimeout(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                set_socket_keep_alive_setSocketKeepAlive(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                });
            }
            writeRequestBodyPromise = write_request_body_writeRequestBody(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

// EXTERNAL MODULE: external "http2"
var external_http2_ = __webpack_require__(5675);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
class node_http2_connection_pool_NodeHttp2ConnectionPool {
    constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions ?? [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-manager.js


class node_http2_connection_manager_NodeHttp2ConnectionManager {
    constructor(config) {
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/node-http2-handler.js






class NodeHttp2Handler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal?.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: this.config?.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = buildQueryString(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [constants.HTTP2_HEADER_PATH]: path,
                [constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: getTransformedHeaders(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js

class collector_Collector extends external_stream_.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js

const stream_collector_streamCollector = (stream) => {
    if (isReadableStreamInstance(stream)) {
        return collectReadableStream(stream);
    }
    return new Promise((resolve, reject) => {
        const collector = new collector_Collector();
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
            resolve(bytes);
        });
    });
};
const isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
async function collectReadableStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/node-http-handler/dist-es/index.js




// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(9023);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js



const keepAliveSupport = {
    supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
};
class FetchHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
        if (typeof options === "function") {
            this.configProvider = options().then((opts) => opts || {});
        }
        else {
            this.config = options ?? {};
            this.configProvider = Promise.resolve(this.config);
        }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        const requestTimeoutInMs = this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = buildQueryString(request.query || {});
        if (queryString) {
            path += `?${queryString}`;
        }
        if (request.fragment) {
            path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? undefined : request.body;
        const requestOptions = {
            body,
            headers: new Headers(request.headers),
            method: method,
        };
        if (body) {
            requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
            requestOptions.signal = abortSignal;
        }
        if (keepAliveSupport.supported) {
            requestOptions.keepalive = keepAlive;
        }
        const fetchRequest = new Request(url, requestOptions);
        const raceOfPromises = [
            fetch(fetchRequest).then((response) => {
                const fetchHeaders = response.headers;
                const transformedHeaders = {};
                for (const pair of fetchHeaders.entries()) {
                    transformedHeaders[pair[0]] = pair[1];
                }
                const hasReadableStream = response.body != undefined;
                if (!hasReadableStream) {
                    return response.blob().then((body) => ({
                        response: new HttpResponse({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body,
                        }),
                    }));
                }
                return {
                    response: new HttpResponse({
                        headers: transformedHeaders,
                        reason: response.statusText,
                        statusCode: response.status,
                        body: response.body,
                    }),
                };
            }),
            requestTimeout(requestTimeoutInMs),
        ];
        if (abortSignal) {
            raceOfPromises.push(new Promise((resolve, reject) => {
                abortSignal.onabort = () => {
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }));
        }
        return Promise.race(raceOfPromises);
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            config[key] = value;
            return config;
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js

const dist_es_stream_collector_streamCollector = (stream) => {
    if (typeof Blob === "function" && stream instanceof Blob) {
        return collectBlob(stream);
    }
    return collectStream(stream);
};
async function collectBlob(blob) {
    const base64 = await readToBase64(blob);
    const arrayBuffer = fromBase64(base64);
    return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}
function readToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (reader.readyState !== 2) {
                return reject(new Error("Reader aborted too early"));
            }
            const result = (reader.result ?? "");
            const commaIndex = result.indexOf(",");
            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
            resolve(result.substring(dataOffset));
        };
        reader.onabort = () => reject(new Error("Read aborted"));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
    });
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/fetch-http-handler/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-hex-encoding/dist-es/index.js
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function dist_es_toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js




const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    if (!isBlobInstance(stream) && !sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
            throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" +
                "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
    };
    return Object.assign(stream, {
        transformToByteArray: transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === "base64") {
                return toBase64(buf);
            }
            else if (encoding === "hex") {
                return toHex(buf);
            }
            else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
                return toUtf8(buf);
            }
            else if (typeof TextDecoder === "function") {
                return new TextDecoder(encoding).decode(buf);
            }
            else {
                throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            transformed = true;
            if (isBlobInstance(stream)) {
                return blobToWebStream(stream);
            }
            else if (sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
                return stream;
            }
            else {
                throw new Error(`Cannot transform payload to web stream, got ${stream}`);
            }
        },
    });
};
const isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
const sdk_stream_mixin_browser_isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js





const sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdk_stream_mixin_sdkStreamMixin = (stream) => {
    if (!(stream instanceof Readable)) {
        try {
            return sdkStreamMixinReadableStream(stream);
        }
        catch (e) {
            const name = stream?.__proto__?.constructor?.name || stream;
            throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return Readable.toWeb(stream);
        },
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/util-stream/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js

const collect_stream_body_collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/command.js


class Command {
    constructor() {
        this.middlewareStack = constructStack();
    }
    static classBuilder() {
        return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [SMITHY_CONTEXT_KEY]: {
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
class ClassBuilder {
    constructor() {
        this._init = () => { };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
    }
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends Command {
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(...[input]) {
                super();
                this.serialize = closure._serializer;
                this.deserialize = closure._deserializer;
                this.input = input ?? {};
                closure._init(this);
            }
            resolveMiddleware(stack, configuration, options) {
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/parse-utils.js
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
const expectInt = (/* unused pure expression or super */ null && (expectLong));
const expectInt32 = (value) => expectSizedInt(value, 32);
const expectShort = (value) => expectSizedInt(value, 16);
const expectByte = (value) => expectSizedInt(value, 8);
const expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = expectObject(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
const parse_utils_strictParseDouble = (value) => {
    if (typeof value == "string") {
        return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
};
const strictParseFloat = (/* unused pure expression or super */ null && (parse_utils_strictParseDouble));
const parse_utils_strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
};
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectNumber(value);
};
const handleFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat = (/* unused pure expression or super */ null && (limitedParseDouble));
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectFloat32(value);
};
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value) => {
    if (typeof value === "string") {
        return expectLong(parseNumber(value));
    }
    return expectLong(value);
};
const strictParseInt = (/* unused pure expression or super */ null && (strictParseLong));
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
};
const parse_utils_strictParseShort = (value) => {
    if (typeof value === "string") {
        return expectShort(parseNumber(value));
    }
    return expectShort(value);
};
const parse_utils_strictParseByte = (value) => {
    if (typeof value === "string") {
        return expectByte(parseNumber(value));
    }
    return expectByte(value);
};
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
const logger = {
    warn: console.warn,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/date-utils.js

const DAYS = (/* unused pure expression or super */ null && (["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]));
const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
const RFC3339 = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/)));
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
const RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
const parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = parse_utils_strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
const IMF_FIXDATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const RFC_850_DATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const ASC_TIME = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/)));
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = (/* unused pure expression or super */ null && (50 * 365 * 24 * 60 * 60 * 1000));
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = parse_utils_strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return parse_utils_strictParseFloat32("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/exceptions.js
class ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
const exceptions_decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/default-error-handler.js

const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw exceptions_decorateServiceException(response, parsedBody);
};
const withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
const loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
        case "standard":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "in-region":
            return {
                retryMode: "standard",
                connectionTimeout: 1100,
            };
        case "cross-region":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "mobile":
            return {
                retryMode: "standard",
                connectionTimeout: 30000,
            };
        default:
            return {};
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
let warningEmitted = false;
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
        warningEmitted = true;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js


const extensions_checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in checksum_AlgorithmId) {
        const algorithmId = checksum_AlgorithmId[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const extensions_checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
const retry_getRetryConfiguration = (runtimeConfig) => {
    let _retryStrategy = runtimeConfig.retryStrategy;
    return {
        setRetryStrategy(retryStrategy) {
            _retryStrategy = retryStrategy;
        },
        retryStrategy() {
            return _retryStrategy;
        },
    };
};
const retry_resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js


const getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
        ...extensions_checksum_getChecksumConfiguration(runtimeConfig),
        ...retry_getRetryConfiguration(runtimeConfig),
    };
};
const defaultExtensionConfiguration_getDefaultClientConfiguration = (/* unused pure expression or super */ null && (getDefaultExtensionConfiguration));
const defaultExtensionConfiguration_resolveDefaultRuntimeConfig = (config) => {
    return {
        ...extensions_checksum_resolveChecksumRuntimeConfig(config),
        ...retry_resolveRetryRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js
const getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/lazy-json.js
const StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(StringWrapper, String);
class LazyJsonString extends (/* unused pure expression or super */ null && (StringWrapper)) {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
        }
        return new LazyJsonString(JSON.stringify(object));
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/node_modules/@smithy/smithy-client/dist-es/index.js























;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/endpoint/EndpointParameters.js
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "iam",
    };
};
const commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/core/dist-cjs/index.js
var dist_cjs = __webpack_require__(5685);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/models/IAMServiceException.js


class IAMServiceException extends ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, IAMServiceException.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/models/models_0.js


const AccessAdvisorUsageGranularityType = {
    ACTION_LEVEL: "ACTION_LEVEL",
    SERVICE_LEVEL: "SERVICE_LEVEL",
};
const StatusType = {
    Active: "Active",
    Inactive: "Inactive",
};
class InvalidInputException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "InvalidInputException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidInputException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidInputException.prototype);
    }
}
class LimitExceededException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "LimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "LimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, LimitExceededException.prototype);
    }
}
class NoSuchEntityException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "NoSuchEntityException",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchEntityException";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchEntityException.prototype);
    }
}
class ServiceFailureException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "ServiceFailureException",
            $fault: "server",
            ...opts,
        });
        this.name = "ServiceFailureException";
        this.$fault = "server";
        Object.setPrototypeOf(this, ServiceFailureException.prototype);
    }
}
class EntityAlreadyExistsException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "EntityAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        this.name = "EntityAlreadyExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, EntityAlreadyExistsException.prototype);
    }
}
class UnmodifiableEntityException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "UnmodifiableEntityException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnmodifiableEntityException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnmodifiableEntityException.prototype);
    }
}
const AssignmentStatusType = {
    Any: "Any",
    Assigned: "Assigned",
    Unassigned: "Unassigned",
};
const PermissionsBoundaryAttachmentType = {
    Policy: "PermissionsBoundaryPolicy",
};
class PolicyNotAttachableException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "PolicyNotAttachableException",
            $fault: "client",
            ...opts,
        });
        this.name = "PolicyNotAttachableException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PolicyNotAttachableException.prototype);
    }
}
class EntityTemporarilyUnmodifiableException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "EntityTemporarilyUnmodifiableException",
            $fault: "client",
            ...opts,
        });
        this.name = "EntityTemporarilyUnmodifiableException";
        this.$fault = "client";
        Object.setPrototypeOf(this, EntityTemporarilyUnmodifiableException.prototype);
    }
}
class InvalidUserTypeException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "InvalidUserTypeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidUserTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidUserTypeException.prototype);
    }
}
class PasswordPolicyViolationException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "PasswordPolicyViolationException",
            $fault: "client",
            ...opts,
        });
        this.name = "PasswordPolicyViolationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PasswordPolicyViolationException.prototype);
    }
}
class ConcurrentModificationException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "ConcurrentModificationException",
            $fault: "client",
            ...opts,
        });
        this.name = "ConcurrentModificationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ConcurrentModificationException.prototype);
    }
}
class OpenIdIdpCommunicationErrorException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "OpenIdIdpCommunicationErrorException",
            $fault: "client",
            ...opts,
        });
        this.name = "OpenIdIdpCommunicationErrorException";
        this.$fault = "client";
        Object.setPrototypeOf(this, OpenIdIdpCommunicationErrorException.prototype);
    }
}
class MalformedPolicyDocumentException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "MalformedPolicyDocumentException",
            $fault: "client",
            ...opts,
        });
        this.name = "MalformedPolicyDocumentException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
    }
}
class ServiceNotSupportedException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "ServiceNotSupportedException",
            $fault: "client",
            ...opts,
        });
        this.name = "ServiceNotSupportedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ServiceNotSupportedException.prototype);
    }
}
class DeleteConflictException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "DeleteConflictException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeleteConflictException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeleteConflictException.prototype);
    }
}
class InvalidAuthenticationCodeException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "InvalidAuthenticationCodeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidAuthenticationCodeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidAuthenticationCodeException.prototype);
    }
}
const ReportStateType = {
    COMPLETE: "COMPLETE",
    INPROGRESS: "INPROGRESS",
    STARTED: "STARTED",
};
class ReportGenerationLimitExceededException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "ReportGenerationLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "ReportGenerationLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ReportGenerationLimitExceededException.prototype);
    }
}
const EntityType = {
    AWSManagedPolicy: "AWSManagedPolicy",
    Group: "Group",
    LocalManagedPolicy: "LocalManagedPolicy",
    Role: "Role",
    User: "User",
};
const models_0_SummaryKeyType = {
    AccessKeysPerUserQuota: "AccessKeysPerUserQuota",
    AccountAccessKeysPresent: "AccountAccessKeysPresent",
    AccountMFAEnabled: "AccountMFAEnabled",
    AccountSigningCertificatesPresent: "AccountSigningCertificatesPresent",
    AttachedPoliciesPerGroupQuota: "AttachedPoliciesPerGroupQuota",
    AttachedPoliciesPerRoleQuota: "AttachedPoliciesPerRoleQuota",
    AttachedPoliciesPerUserQuota: "AttachedPoliciesPerUserQuota",
    GlobalEndpointTokenVersion: "GlobalEndpointTokenVersion",
    GroupPolicySizeQuota: "GroupPolicySizeQuota",
    Groups: "Groups",
    GroupsPerUserQuota: "GroupsPerUserQuota",
    GroupsQuota: "GroupsQuota",
    MFADevices: "MFADevices",
    MFADevicesInUse: "MFADevicesInUse",
    Policies: "Policies",
    PoliciesQuota: "PoliciesQuota",
    PolicySizeQuota: "PolicySizeQuota",
    PolicyVersionsInUse: "PolicyVersionsInUse",
    PolicyVersionsInUseQuota: "PolicyVersionsInUseQuota",
    ServerCertificates: "ServerCertificates",
    ServerCertificatesQuota: "ServerCertificatesQuota",
    SigningCertificatesPerUserQuota: "SigningCertificatesPerUserQuota",
    UserPolicySizeQuota: "UserPolicySizeQuota",
    Users: "Users",
    UsersQuota: "UsersQuota",
    VersionsPerPolicyQuota: "VersionsPerPolicyQuota",
};
class CredentialReportExpiredException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "CredentialReportExpiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "CredentialReportExpiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, CredentialReportExpiredException.prototype);
    }
}
class CredentialReportNotPresentException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "CredentialReportNotPresentException",
            $fault: "client",
            ...opts,
        });
        this.name = "CredentialReportNotPresentException";
        this.$fault = "client";
        Object.setPrototypeOf(this, CredentialReportNotPresentException.prototype);
    }
}
class CredentialReportNotReadyException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "CredentialReportNotReadyException",
            $fault: "client",
            ...opts,
        });
        this.name = "CredentialReportNotReadyException";
        this.$fault = "client";
        Object.setPrototypeOf(this, CredentialReportNotReadyException.prototype);
    }
}
const ReportFormatType = {
    text_csv: "text/csv",
};
const SortKeyType = {
    LAST_AUTHENTICATED_TIME_ASCENDING: "LAST_AUTHENTICATED_TIME_ASCENDING",
    LAST_AUTHENTICATED_TIME_DESCENDING: "LAST_AUTHENTICATED_TIME_DESCENDING",
    SERVICE_NAMESPACE_ASCENDING: "SERVICE_NAMESPACE_ASCENDING",
    SERVICE_NAMESPACE_DESCENDING: "SERVICE_NAMESPACE_DESCENDING",
};
const JobStatusType = {
    COMPLETED: "COMPLETED",
    FAILED: "FAILED",
    IN_PROGRESS: "IN_PROGRESS",
};
const PolicyOwnerEntityType = {
    GROUP: "GROUP",
    ROLE: "ROLE",
    USER: "USER",
};
const DeletionTaskStatusType = {
    FAILED: "FAILED",
    IN_PROGRESS: "IN_PROGRESS",
    NOT_STARTED: "NOT_STARTED",
    SUCCEEDED: "SUCCEEDED",
};
const EncodingType = {
    PEM: "PEM",
    SSH: "SSH",
};
class UnrecognizedPublicKeyEncodingException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "UnrecognizedPublicKeyEncodingException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnrecognizedPublicKeyEncodingException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnrecognizedPublicKeyEncodingException.prototype);
    }
}
const PolicyUsageType = {
    PermissionsBoundary: "PermissionsBoundary",
    PermissionsPolicy: "PermissionsPolicy",
};
const PolicyScopeType = {
    AWS: "AWS",
    All: "All",
    Local: "Local",
};
const PolicyType = {
    INLINE: "INLINE",
    MANAGED: "MANAGED",
};
const GlobalEndpointTokenVersion = {
    v1Token: "v1Token",
    v2Token: "v2Token",
};
class PolicyEvaluationException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "PolicyEvaluationException",
            $fault: "server",
            ...opts,
        });
        this.name = "PolicyEvaluationException";
        this.$fault = "server";
        Object.setPrototypeOf(this, PolicyEvaluationException.prototype);
    }
}
const ContextKeyTypeEnum = {
    BINARY: "binary",
    BINARY_LIST: "binaryList",
    BOOLEAN: "boolean",
    BOOLEAN_LIST: "booleanList",
    DATE: "date",
    DATE_LIST: "dateList",
    IP: "ip",
    IP_LIST: "ipList",
    NUMERIC: "numeric",
    NUMERIC_LIST: "numericList",
    STRING: "string",
    STRING_LIST: "stringList",
};
const PolicyEvaluationDecisionType = {
    ALLOWED: "allowed",
    EXPLICIT_DENY: "explicitDeny",
    IMPLICIT_DENY: "implicitDeny",
};
const PolicySourceType = {
    AWS_MANAGED: "aws-managed",
    GROUP: "group",
    NONE: "none",
    RESOURCE: "resource",
    ROLE: "role",
    USER: "user",
    USER_MANAGED: "user-managed",
};
const AccessKeyFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING }),
});
const ChangePasswordRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.OldPassword && { OldPassword: SENSITIVE_STRING }),
    ...(obj.NewPassword && { NewPassword: SENSITIVE_STRING }),
});
const CreateAccessKeyResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.AccessKey && { AccessKey: AccessKeyFilterSensitiveLog(obj.AccessKey) }),
});
const CreateLoginProfileRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Password && { Password: SENSITIVE_STRING }),
});
const ServiceSpecificCredentialFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.ServicePassword && { ServicePassword: SENSITIVE_STRING }),
});
const CreateServiceSpecificCredentialResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.ServiceSpecificCredential && {
        ServiceSpecificCredential: ServiceSpecificCredentialFilterSensitiveLog(obj.ServiceSpecificCredential),
    }),
});
const VirtualMFADeviceFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Base32StringSeed && { Base32StringSeed: SENSITIVE_STRING }),
    ...(obj.QRCodePNG && { QRCodePNG: SENSITIVE_STRING }),
});
const CreateVirtualMFADeviceResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.VirtualMFADevice && { VirtualMFADevice: VirtualMFADeviceFilterSensitiveLog(obj.VirtualMFADevice) }),
});
const ListVirtualMFADevicesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.VirtualMFADevices && {
        VirtualMFADevices: obj.VirtualMFADevices.map((item) => VirtualMFADeviceFilterSensitiveLog(item)),
    }),
});
const ResetServiceSpecificCredentialResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.ServiceSpecificCredential && {
        ServiceSpecificCredential: ServiceSpecificCredentialFilterSensitiveLog(obj.ServiceSpecificCredential),
    }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/models/models_1.js


class KeyPairMismatchException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "KeyPairMismatchException",
            $fault: "client",
            ...opts,
        });
        this.name = "KeyPairMismatchException";
        this.$fault = "client";
        Object.setPrototypeOf(this, KeyPairMismatchException.prototype);
    }
}
class MalformedCertificateException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "MalformedCertificateException",
            $fault: "client",
            ...opts,
        });
        this.name = "MalformedCertificateException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MalformedCertificateException.prototype);
    }
}
class DuplicateCertificateException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "DuplicateCertificateException",
            $fault: "client",
            ...opts,
        });
        this.name = "DuplicateCertificateException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DuplicateCertificateException.prototype);
    }
}
class InvalidCertificateException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "InvalidCertificateException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidCertificateException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidCertificateException.prototype);
    }
}
class DuplicateSSHPublicKeyException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "DuplicateSSHPublicKeyException",
            $fault: "client",
            ...opts,
        });
        this.name = "DuplicateSSHPublicKeyException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DuplicateSSHPublicKeyException.prototype);
    }
}
class InvalidPublicKeyException extends IAMServiceException {
    constructor(opts) {
        super({
            name: "InvalidPublicKeyException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidPublicKeyException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidPublicKeyException.prototype);
    }
}
const UpdateLoginProfileRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Password && { Password: SENSITIVE_STRING }),
});
const UploadServerCertificateRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.PrivateKey && { PrivateKey: SENSITIVE_STRING }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/protocols/Aws_query.js






const se_AddClientIDToOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddClientIDToOpenIDConnectProviderRequest(input, context),
        [_A]: _ACIDTOIDCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_AddRoleToInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddRoleToInstanceProfileRequest(input, context),
        [_A]: _ARTIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_AddUserToGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddUserToGroupRequest(input, context),
        [_A]: _AUTG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_AttachGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachGroupPolicyRequest(input, context),
        [_A]: _AGP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_AttachRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachRolePolicyRequest(input, context),
        [_A]: _ARP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_AttachUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachUserPolicyRequest(input, context),
        [_A]: _AUP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ChangePasswordCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ChangePasswordRequest(input, context),
        [_A]: _CP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateAccessKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateAccessKeyRequest(input, context),
        [_A]: _CAK,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateAccountAliasCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateAccountAliasRequest(input, context),
        [_A]: _CAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateGroupRequest(input, context),
        [_A]: _CG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateInstanceProfileRequest(input, context),
        [_A]: _CIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateLoginProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLoginProfileRequest(input, context),
        [_A]: _CLP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateOpenIDConnectProviderRequest(input, context),
        [_A]: _COIDCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreatePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreatePolicyRequest(input, context),
        [_A]: _CPr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreatePolicyVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreatePolicyVersionRequest(input, context),
        [_A]: _CPV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateRoleRequest(input, context),
        [_A]: _CR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateSAMLProviderRequest(input, context),
        [_A]: _CSAMLP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateServiceLinkedRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateServiceLinkedRoleRequest(input, context),
        [_A]: _CSLR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateServiceSpecificCredentialCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateServiceSpecificCredentialRequest(input, context),
        [_A]: _CSSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateUserRequest(input, context),
        [_A]: _CU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateVirtualMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVirtualMFADeviceRequest(input, context),
        [_A]: _CVMFAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeactivateMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeactivateMFADeviceRequest(input, context),
        [_A]: _DMFAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteAccessKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAccessKeyRequest(input, context),
        [_A]: _DAK,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteAccountAliasCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAccountAliasRequest(input, context),
        [_A]: _DAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteAccountPasswordPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _DAPP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteGroupRequest(input, context),
        [_A]: _DG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteGroupPolicyRequest(input, context),
        [_A]: _DGP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteInstanceProfileRequest(input, context),
        [_A]: _DIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteLoginProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLoginProfileRequest(input, context),
        [_A]: _DLP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteOpenIDConnectProviderRequest(input, context),
        [_A]: _DOIDCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeletePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeletePolicyRequest(input, context),
        [_A]: _DP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeletePolicyVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeletePolicyVersionRequest(input, context),
        [_A]: _DPV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRoleRequest(input, context),
        [_A]: _DR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteRolePermissionsBoundaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRolePermissionsBoundaryRequest(input, context),
        [_A]: _DRPB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRolePolicyRequest(input, context),
        [_A]: _DRP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSAMLProviderRequest(input, context),
        [_A]: _DSAMLP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteServerCertificateRequest(input, context),
        [_A]: _DSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteServiceLinkedRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteServiceLinkedRoleRequest(input, context),
        [_A]: _DSLR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteServiceSpecificCredentialCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteServiceSpecificCredentialRequest(input, context),
        [_A]: _DSSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteSigningCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSigningCertificateRequest(input, context),
        [_A]: _DSCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteSSHPublicKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSSHPublicKeyRequest(input, context),
        [_A]: _DSSHPK,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteUserRequest(input, context),
        [_A]: _DU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteUserPermissionsBoundaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteUserPermissionsBoundaryRequest(input, context),
        [_A]: _DUPB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteUserPolicyRequest(input, context),
        [_A]: _DUP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteVirtualMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVirtualMFADeviceRequest(input, context),
        [_A]: _DVMFAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DetachGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachGroupPolicyRequest(input, context),
        [_A]: _DGPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DetachRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachRolePolicyRequest(input, context),
        [_A]: _DRPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DetachUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachUserPolicyRequest(input, context),
        [_A]: _DUPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_EnableMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableMFADeviceRequest(input, context),
        [_A]: _EMFAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GenerateCredentialReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _GCR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GenerateOrganizationsAccessReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GenerateOrganizationsAccessReportRequest(input, context),
        [_A]: _GOAR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GenerateServiceLastAccessedDetailsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GenerateServiceLastAccessedDetailsRequest(input, context),
        [_A]: _GSLAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetAccessKeyLastUsedCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAccessKeyLastUsedRequest(input, context),
        [_A]: _GAKLU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetAccountAuthorizationDetailsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAccountAuthorizationDetailsRequest(input, context),
        [_A]: _GAAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetAccountPasswordPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _GAPP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetAccountSummaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _GAS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetContextKeysForCustomPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetContextKeysForCustomPolicyRequest(input, context),
        [_A]: _GCKFCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetContextKeysForPrincipalPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetContextKeysForPrincipalPolicyRequest(input, context),
        [_A]: _GCKFPP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetCredentialReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _GCRe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetGroupRequest(input, context),
        [_A]: _GG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetGroupPolicyRequest(input, context),
        [_A]: _GGP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetInstanceProfileRequest(input, context),
        [_A]: _GIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetLoginProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetLoginProfileRequest(input, context),
        [_A]: _GLP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMFADeviceRequest(input, context),
        [_A]: _GMFAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetOpenIDConnectProviderRequest(input, context),
        [_A]: _GOIDCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetOrganizationsAccessReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetOrganizationsAccessReportRequest(input, context),
        [_A]: _GOARe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetPolicyRequest(input, context),
        [_A]: _GP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetPolicyVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetPolicyVersionRequest(input, context),
        [_A]: _GPV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetRoleRequest(input, context),
        [_A]: _GR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetRolePolicyRequest(input, context),
        [_A]: _GRP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSAMLProviderRequest(input, context),
        [_A]: _GSAMLP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetServerCertificateRequest(input, context),
        [_A]: _GSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetServiceLastAccessedDetailsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetServiceLastAccessedDetailsRequest(input, context),
        [_A]: _GSLADe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetServiceLastAccessedDetailsWithEntitiesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetServiceLastAccessedDetailsWithEntitiesRequest(input, context),
        [_A]: _GSLADWE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetServiceLinkedRoleDeletionStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetServiceLinkedRoleDeletionStatusRequest(input, context),
        [_A]: _GSLRDS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetSSHPublicKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSSHPublicKeyRequest(input, context),
        [_A]: _GSSHPK,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetUserRequest(input, context),
        [_A]: _GU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetUserPolicyRequest(input, context),
        [_A]: _GUP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListAccessKeysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAccessKeysRequest(input, context),
        [_A]: _LAK,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListAccountAliasesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAccountAliasesRequest(input, context),
        [_A]: _LAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListAttachedGroupPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAttachedGroupPoliciesRequest(input, context),
        [_A]: _LAGP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListAttachedRolePoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAttachedRolePoliciesRequest(input, context),
        [_A]: _LARP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListAttachedUserPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAttachedUserPoliciesRequest(input, context),
        [_A]: _LAUP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListEntitiesForPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListEntitiesForPolicyRequest(input, context),
        [_A]: _LEFP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListGroupPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListGroupPoliciesRequest(input, context),
        [_A]: _LGP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListGroupsRequest(input, context),
        [_A]: _LG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListGroupsForUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListGroupsForUserRequest(input, context),
        [_A]: _LGFU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListInstanceProfilesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListInstanceProfilesRequest(input, context),
        [_A]: _LIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListInstanceProfilesForRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListInstanceProfilesForRoleRequest(input, context),
        [_A]: _LIPFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListInstanceProfileTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListInstanceProfileTagsRequest(input, context),
        [_A]: _LIPT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListMFADevicesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListMFADevicesRequest(input, context),
        [_A]: _LMFAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListMFADeviceTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListMFADeviceTagsRequest(input, context),
        [_A]: _LMFADT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListOpenIDConnectProvidersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListOpenIDConnectProvidersRequest(input, context),
        [_A]: _LOIDCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListOpenIDConnectProviderTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListOpenIDConnectProviderTagsRequest(input, context),
        [_A]: _LOIDCPT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListPoliciesRequest(input, context),
        [_A]: _LP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListPoliciesGrantingServiceAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListPoliciesGrantingServiceAccessRequest(input, context),
        [_A]: _LPGSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListPolicyTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListPolicyTagsRequest(input, context),
        [_A]: _LPT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListPolicyVersionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListPolicyVersionsRequest(input, context),
        [_A]: _LPV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListRolePoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListRolePoliciesRequest(input, context),
        [_A]: _LRP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListRolesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListRolesRequest(input, context),
        [_A]: _LR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListRoleTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListRoleTagsRequest(input, context),
        [_A]: _LRT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListSAMLProvidersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSAMLProvidersRequest(input, context),
        [_A]: _LSAMLP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListSAMLProviderTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSAMLProviderTagsRequest(input, context),
        [_A]: _LSAMLPT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListServerCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListServerCertificatesRequest(input, context),
        [_A]: _LSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListServerCertificateTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListServerCertificateTagsRequest(input, context),
        [_A]: _LSCT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListServiceSpecificCredentialsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListServiceSpecificCredentialsRequest(input, context),
        [_A]: _LSSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListSigningCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSigningCertificatesRequest(input, context),
        [_A]: _LSCi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListSSHPublicKeysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSSHPublicKeysRequest(input, context),
        [_A]: _LSSHPK,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListUserPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListUserPoliciesRequest(input, context),
        [_A]: _LUP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListUsersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListUsersRequest(input, context),
        [_A]: _LU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListUserTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListUserTagsRequest(input, context),
        [_A]: _LUT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListVirtualMFADevicesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListVirtualMFADevicesRequest(input, context),
        [_A]: _LVMFAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutGroupPolicyRequest(input, context),
        [_A]: _PGP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutRolePermissionsBoundaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutRolePermissionsBoundaryRequest(input, context),
        [_A]: _PRPB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutRolePolicyRequest(input, context),
        [_A]: _PRP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutUserPermissionsBoundaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutUserPermissionsBoundaryRequest(input, context),
        [_A]: _PUPB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutUserPolicyRequest(input, context),
        [_A]: _PUP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_RemoveClientIDFromOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveClientIDFromOpenIDConnectProviderRequest(input, context),
        [_A]: _RCIDFOIDCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_RemoveRoleFromInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveRoleFromInstanceProfileRequest(input, context),
        [_A]: _RRFIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_RemoveUserFromGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveUserFromGroupRequest(input, context),
        [_A]: _RUFG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ResetServiceSpecificCredentialCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetServiceSpecificCredentialRequest(input, context),
        [_A]: _RSSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ResyncMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResyncMFADeviceRequest(input, context),
        [_A]: _RMFAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_SetDefaultPolicyVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetDefaultPolicyVersionRequest(input, context),
        [_A]: _SDPV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_SetSecurityTokenServicePreferencesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetSecurityTokenServicePreferencesRequest(input, context),
        [_A]: _SSTSP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_SimulateCustomPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SimulateCustomPolicyRequest(input, context),
        [_A]: _SCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_SimulatePrincipalPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SimulatePrincipalPolicyRequest(input, context),
        [_A]: _SPP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_TagInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagInstanceProfileRequest(input, context),
        [_A]: _TIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_TagMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagMFADeviceRequest(input, context),
        [_A]: _TMFAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_TagOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagOpenIDConnectProviderRequest(input, context),
        [_A]: _TOIDCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_TagPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagPolicyRequest(input, context),
        [_A]: _TP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_TagRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagRoleRequest(input, context),
        [_A]: _TR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_TagSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagSAMLProviderRequest(input, context),
        [_A]: _TSAMLP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_TagServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagServerCertificateRequest(input, context),
        [_A]: _TSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_TagUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagUserRequest(input, context),
        [_A]: _TU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UntagInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagInstanceProfileRequest(input, context),
        [_A]: _UIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UntagMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagMFADeviceRequest(input, context),
        [_A]: _UMFAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UntagOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagOpenIDConnectProviderRequest(input, context),
        [_A]: _UOIDCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UntagPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagPolicyRequest(input, context),
        [_A]: _UP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UntagRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagRoleRequest(input, context),
        [_A]: _UR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UntagSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagSAMLProviderRequest(input, context),
        [_A]: _USAMLP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UntagServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagServerCertificateRequest(input, context),
        [_A]: _USC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UntagUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagUserRequest(input, context),
        [_A]: _UU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateAccessKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateAccessKeyRequest(input, context),
        [_A]: _UAK,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateAccountPasswordPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateAccountPasswordPolicyRequest(input, context),
        [_A]: _UAPP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateAssumeRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateAssumeRolePolicyRequest(input, context),
        [_A]: _UARP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateGroupRequest(input, context),
        [_A]: _UG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateLoginProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateLoginProfileRequest(input, context),
        [_A]: _ULP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateOpenIDConnectProviderThumbprintCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateOpenIDConnectProviderThumbprintRequest(input, context),
        [_A]: _UOIDCPT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateRoleRequest(input, context),
        [_A]: _URp,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateRoleDescriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateRoleDescriptionRequest(input, context),
        [_A]: _URD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateSAMLProviderRequest(input, context),
        [_A]: _USAMLPp,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateServerCertificateRequest(input, context),
        [_A]: _USCp,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateServiceSpecificCredentialCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateServiceSpecificCredentialRequest(input, context),
        [_A]: _USSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateSigningCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateSigningCertificateRequest(input, context),
        [_A]: _USCpd,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateSSHPublicKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateSSHPublicKeyRequest(input, context),
        [_A]: _USSHPK,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateUserRequest(input, context),
        [_A]: _UUp,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UploadServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UploadServerCertificateRequest(input, context),
        [_A]: _USCpl,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UploadSigningCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UploadSigningCertificateRequest(input, context),
        [_A]: _USCplo,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UploadSSHPublicKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UploadSSHPublicKeyRequest(input, context),
        [_A]: _USSHPKp,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const de_AddClientIDToOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_AddRoleToInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_AddUserToGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_AttachGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_AttachRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_AttachUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_ChangePasswordCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_CreateAccessKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateAccessKeyResponse(data.CreateAccessKeyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateAccountAliasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_CreateGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateGroupResponse(data.CreateGroupResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateInstanceProfileResponse(data.CreateInstanceProfileResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateLoginProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLoginProfileResponse(data.CreateLoginProfileResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateOpenIDConnectProviderResponse(data.CreateOpenIDConnectProviderResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreatePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreatePolicyResponse(data.CreatePolicyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreatePolicyVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreatePolicyVersionResponse(data.CreatePolicyVersionResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRoleResponse(data.CreateRoleResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateSAMLProviderResponse(data.CreateSAMLProviderResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateServiceLinkedRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateServiceLinkedRoleResponse(data.CreateServiceLinkedRoleResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateServiceSpecificCredentialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateServiceSpecificCredentialResponse(data.CreateServiceSpecificCredentialResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateUserResponse(data.CreateUserResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateVirtualMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVirtualMFADeviceResponse(data.CreateVirtualMFADeviceResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeactivateMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteAccessKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteAccountAliasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteAccountPasswordPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteLoginProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeletePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeletePolicyVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteRolePermissionsBoundaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteServiceLinkedRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteServiceLinkedRoleResponse(data.DeleteServiceLinkedRoleResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteServiceSpecificCredentialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteSigningCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteSSHPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteUserPermissionsBoundaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DeleteVirtualMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DetachGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DetachRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_DetachUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_EnableMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_GenerateCredentialReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateCredentialReportResponse(data.GenerateCredentialReportResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GenerateOrganizationsAccessReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateOrganizationsAccessReportResponse(data.GenerateOrganizationsAccessReportResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GenerateServiceLastAccessedDetailsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateServiceLastAccessedDetailsResponse(data.GenerateServiceLastAccessedDetailsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetAccessKeyLastUsedCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccessKeyLastUsedResponse(data.GetAccessKeyLastUsedResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetAccountAuthorizationDetailsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccountAuthorizationDetailsResponse(data.GetAccountAuthorizationDetailsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetAccountPasswordPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccountPasswordPolicyResponse(data.GetAccountPasswordPolicyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetAccountSummaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccountSummaryResponse(data.GetAccountSummaryResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetContextKeysForCustomPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetContextKeysForPolicyResponse(data.GetContextKeysForCustomPolicyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetContextKeysForPrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetContextKeysForPolicyResponse(data.GetContextKeysForPrincipalPolicyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetCredentialReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCredentialReportResponse(data.GetCredentialReportResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetGroupResponse(data.GetGroupResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetGroupPolicyResponse(data.GetGroupPolicyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetInstanceProfileResponse(data.GetInstanceProfileResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetLoginProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetLoginProfileResponse(data.GetLoginProfileResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMFADeviceResponse(data.GetMFADeviceResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetOpenIDConnectProviderResponse(data.GetOpenIDConnectProviderResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetOrganizationsAccessReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetOrganizationsAccessReportResponse(data.GetOrganizationsAccessReportResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPolicyResponse(data.GetPolicyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetPolicyVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPolicyVersionResponse(data.GetPolicyVersionResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetRoleResponse(data.GetRoleResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetRolePolicyResponse(data.GetRolePolicyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSAMLProviderResponse(data.GetSAMLProviderResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServerCertificateResponse(data.GetServerCertificateResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetServiceLastAccessedDetailsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServiceLastAccessedDetailsResponse(data.GetServiceLastAccessedDetailsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetServiceLastAccessedDetailsWithEntitiesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServiceLastAccessedDetailsWithEntitiesResponse(data.GetServiceLastAccessedDetailsWithEntitiesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetServiceLinkedRoleDeletionStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServiceLinkedRoleDeletionStatusResponse(data.GetServiceLinkedRoleDeletionStatusResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetSSHPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSSHPublicKeyResponse(data.GetSSHPublicKeyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseXmlBody)(output.body, context);
    let contents = {};
    contents = de_GetUserResponse(data.GetUserResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetUserPolicyResponse(data.GetUserPolicyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListAccessKeysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAccessKeysResponse(data.ListAccessKeysResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListAccountAliasesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAccountAliasesResponse(data.ListAccountAliasesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListAttachedGroupPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAttachedGroupPoliciesResponse(data.ListAttachedGroupPoliciesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListAttachedRolePoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAttachedRolePoliciesResponse(data.ListAttachedRolePoliciesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListAttachedUserPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAttachedUserPoliciesResponse(data.ListAttachedUserPoliciesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListEntitiesForPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListEntitiesForPolicyResponse(data.ListEntitiesForPolicyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListGroupPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGroupPoliciesResponse(data.ListGroupPoliciesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGroupsResponse(data.ListGroupsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListGroupsForUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGroupsForUserResponse(data.ListGroupsForUserResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListInstanceProfilesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListInstanceProfilesResponse(data.ListInstanceProfilesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListInstanceProfilesForRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListInstanceProfilesForRoleResponse(data.ListInstanceProfilesForRoleResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListInstanceProfileTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListInstanceProfileTagsResponse(data.ListInstanceProfileTagsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListMFADevicesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListMFADevicesResponse(data.ListMFADevicesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListMFADeviceTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListMFADeviceTagsResponse(data.ListMFADeviceTagsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListOpenIDConnectProvidersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListOpenIDConnectProvidersResponse(data.ListOpenIDConnectProvidersResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListOpenIDConnectProviderTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListOpenIDConnectProviderTagsResponse(data.ListOpenIDConnectProviderTagsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListPoliciesResponse(data.ListPoliciesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListPoliciesGrantingServiceAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListPoliciesGrantingServiceAccessResponse(data.ListPoliciesGrantingServiceAccessResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListPolicyTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListPolicyTagsResponse(data.ListPolicyTagsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListPolicyVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListPolicyVersionsResponse(data.ListPolicyVersionsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListRolePoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListRolePoliciesResponse(data.ListRolePoliciesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListRolesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListRolesResponse(data.ListRolesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListRoleTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListRoleTagsResponse(data.ListRoleTagsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListSAMLProvidersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSAMLProvidersResponse(data.ListSAMLProvidersResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListSAMLProviderTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSAMLProviderTagsResponse(data.ListSAMLProviderTagsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListServerCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListServerCertificatesResponse(data.ListServerCertificatesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListServerCertificateTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListServerCertificateTagsResponse(data.ListServerCertificateTagsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListServiceSpecificCredentialsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListServiceSpecificCredentialsResponse(data.ListServiceSpecificCredentialsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListSigningCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSigningCertificatesResponse(data.ListSigningCertificatesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListSSHPublicKeysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSSHPublicKeysResponse(data.ListSSHPublicKeysResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListUserPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUserPoliciesResponse(data.ListUserPoliciesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListUsersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUsersResponse(data.ListUsersResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListUserTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUserTagsResponse(data.ListUserTagsResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListVirtualMFADevicesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListVirtualMFADevicesResponse(data.ListVirtualMFADevicesResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_PutRolePermissionsBoundaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_PutRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_PutUserPermissionsBoundaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_PutUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_RemoveClientIDFromOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_RemoveRoleFromInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_RemoveUserFromGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_ResetServiceSpecificCredentialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ResetServiceSpecificCredentialResponse(data.ResetServiceSpecificCredentialResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ResyncMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_SetDefaultPolicyVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_SetSecurityTokenServicePreferencesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_SimulateCustomPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SimulatePolicyResponse(data.SimulateCustomPolicyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_SimulatePrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SimulatePolicyResponse(data.SimulatePrincipalPolicyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_TagInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_TagMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_TagOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_TagPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_TagRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_TagSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_TagServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_TagUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UntagInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UntagMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UntagOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UntagPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UntagRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UntagSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UntagServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UntagUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UpdateAccessKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UpdateAccountPasswordPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UpdateAssumeRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UpdateGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UpdateLoginProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UpdateOpenIDConnectProviderThumbprintCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UpdateRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateRoleResponse(data.UpdateRoleResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateRoleDescriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateRoleDescriptionResponse(data.UpdateRoleDescriptionResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateSAMLProviderResponse(data.UpdateSAMLProviderResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UpdateServiceSpecificCredentialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UpdateSigningCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UpdateSSHPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UpdateUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
    };
    return response;
};
const de_UploadServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UploadServerCertificateResponse(data.UploadServerCertificateResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UploadSigningCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UploadSigningCertificateResponse(data.UploadSigningCertificateResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UploadSSHPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UploadSSHPublicKeyResponse(data.UploadSSHPublicKeyResult, context);
    const response = {
        $metadata: Aws_query_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await (0,dist_cjs.parseXmlErrorBody)(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        case "PolicyNotAttachable":
        case "com.amazonaws.iam#PolicyNotAttachableException":
            throw await de_PolicyNotAttachableExceptionRes(parsedOutput, context);
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "InvalidUserType":
        case "com.amazonaws.iam#InvalidUserTypeException":
            throw await de_InvalidUserTypeExceptionRes(parsedOutput, context);
        case "PasswordPolicyViolation":
        case "com.amazonaws.iam#PasswordPolicyViolationException":
            throw await de_PasswordPolicyViolationExceptionRes(parsedOutput, context);
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "OpenIdIdpCommunicationError":
        case "com.amazonaws.iam#OpenIdIdpCommunicationErrorException":
            throw await de_OpenIdIdpCommunicationErrorExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NotSupportedService":
        case "com.amazonaws.iam#ServiceNotSupportedException":
            throw await de_ServiceNotSupportedExceptionRes(parsedOutput, context);
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InvalidAuthenticationCode":
        case "com.amazonaws.iam#InvalidAuthenticationCodeException":
            throw await de_InvalidAuthenticationCodeExceptionRes(parsedOutput, context);
        case "ReportGenerationLimitExceeded":
        case "com.amazonaws.iam#ReportGenerationLimitExceededException":
            throw await de_ReportGenerationLimitExceededExceptionRes(parsedOutput, context);
        case "ReportExpired":
        case "com.amazonaws.iam#CredentialReportExpiredException":
            throw await de_CredentialReportExpiredExceptionRes(parsedOutput, context);
        case "ReportInProgress":
        case "com.amazonaws.iam#CredentialReportNotReadyException":
            throw await de_CredentialReportNotReadyExceptionRes(parsedOutput, context);
        case "ReportNotPresent":
        case "com.amazonaws.iam#CredentialReportNotPresentException":
            throw await de_CredentialReportNotPresentExceptionRes(parsedOutput, context);
        case "UnrecognizedPublicKeyEncoding":
        case "com.amazonaws.iam#UnrecognizedPublicKeyEncodingException":
            throw await de_UnrecognizedPublicKeyEncodingExceptionRes(parsedOutput, context);
        case "PolicyEvaluation":
        case "com.amazonaws.iam#PolicyEvaluationException":
            throw await de_PolicyEvaluationExceptionRes(parsedOutput, context);
        case "KeyPairMismatch":
        case "com.amazonaws.iam#KeyPairMismatchException":
            throw await de_KeyPairMismatchExceptionRes(parsedOutput, context);
        case "MalformedCertificate":
        case "com.amazonaws.iam#MalformedCertificateException":
            throw await de_MalformedCertificateExceptionRes(parsedOutput, context);
        case "DuplicateCertificate":
        case "com.amazonaws.iam#DuplicateCertificateException":
            throw await de_DuplicateCertificateExceptionRes(parsedOutput, context);
        case "InvalidCertificate":
        case "com.amazonaws.iam#InvalidCertificateException":
            throw await de_InvalidCertificateExceptionRes(parsedOutput, context);
        case "DuplicateSSHPublicKey":
        case "com.amazonaws.iam#DuplicateSSHPublicKeyException":
            throw await de_DuplicateSSHPublicKeyExceptionRes(parsedOutput, context);
        case "InvalidPublicKey":
        case "com.amazonaws.iam#InvalidPublicKeyException":
            throw await de_InvalidPublicKeyExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return Aws_query_throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ConcurrentModificationException(body.Error, context);
    const exception = new ConcurrentModificationException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_CredentialReportExpiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CredentialReportExpiredException(body.Error, context);
    const exception = new CredentialReportExpiredException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_CredentialReportNotPresentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CredentialReportNotPresentException(body.Error, context);
    const exception = new CredentialReportNotPresentException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_CredentialReportNotReadyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CredentialReportNotReadyException(body.Error, context);
    const exception = new CredentialReportNotReadyException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_DeleteConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DeleteConflictException(body.Error, context);
    const exception = new DeleteConflictException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_DuplicateCertificateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateCertificateException(body.Error, context);
    const exception = new DuplicateCertificateException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_DuplicateSSHPublicKeyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateSSHPublicKeyException(body.Error, context);
    const exception = new DuplicateSSHPublicKeyException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_EntityAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EntityAlreadyExistsException(body.Error, context);
    const exception = new EntityAlreadyExistsException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_EntityTemporarilyUnmodifiableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EntityTemporarilyUnmodifiableException(body.Error, context);
    const exception = new EntityTemporarilyUnmodifiableException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_InvalidAuthenticationCodeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAuthenticationCodeException(body.Error, context);
    const exception = new InvalidAuthenticationCodeException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_InvalidCertificateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidCertificateException(body.Error, context);
    const exception = new InvalidCertificateException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_InvalidInputExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidInputException(body.Error, context);
    const exception = new InvalidInputException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_InvalidPublicKeyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidPublicKeyException(body.Error, context);
    const exception = new InvalidPublicKeyException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_InvalidUserTypeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidUserTypeException(body.Error, context);
    const exception = new InvalidUserTypeException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_KeyPairMismatchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_KeyPairMismatchException(body.Error, context);
    const exception = new KeyPairMismatchException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededException(body.Error, context);
    const exception = new LimitExceededException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_MalformedCertificateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MalformedCertificateException(body.Error, context);
    const exception = new MalformedCertificateException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MalformedPolicyDocumentException(body.Error, context);
    const exception = new MalformedPolicyDocumentException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_NoSuchEntityExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_NoSuchEntityException(body.Error, context);
    const exception = new NoSuchEntityException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_OpenIdIdpCommunicationErrorExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpenIdIdpCommunicationErrorException(body.Error, context);
    const exception = new OpenIdIdpCommunicationErrorException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_PasswordPolicyViolationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PasswordPolicyViolationException(body.Error, context);
    const exception = new PasswordPolicyViolationException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_PolicyEvaluationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PolicyEvaluationException(body.Error, context);
    const exception = new PolicyEvaluationException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_PolicyNotAttachableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PolicyNotAttachableException(body.Error, context);
    const exception = new PolicyNotAttachableException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_ReportGenerationLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReportGenerationLimitExceededException(body.Error, context);
    const exception = new ReportGenerationLimitExceededException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_ServiceFailureExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServiceFailureException(body.Error, context);
    const exception = new ServiceFailureException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_ServiceNotSupportedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServiceNotSupportedException(body.Error, context);
    const exception = new ServiceNotSupportedException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_UnmodifiableEntityExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnmodifiableEntityException(body.Error, context);
    const exception = new UnmodifiableEntityException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const de_UnrecognizedPublicKeyEncodingExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnrecognizedPublicKeyEncodingException(body.Error, context);
    const exception = new UnrecognizedPublicKeyEncodingException({
        $metadata: Aws_query_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return exceptions_decorateServiceException(exception, body);
};
const se_ActionNameListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AddClientIDToOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input[_OIDCPA] != null) {
        entries[_OIDCPA] = input[_OIDCPA];
    }
    if (input[_CID] != null) {
        entries[_CID] = input[_CID];
    }
    return entries;
};
const se_AddRoleToInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input[_IPN] != null) {
        entries[_IPN] = input[_IPN];
    }
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    return entries;
};
const se_AddUserToGroupRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    return entries;
};
const se_AttachGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    return entries;
};
const se_AttachRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    return entries;
};
const se_AttachUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    return entries;
};
const se_ChangePasswordRequest = (input, context) => {
    const entries = {};
    if (input[_OP] != null) {
        entries[_OP] = input[_OP];
    }
    if (input[_NP] != null) {
        entries[_NP] = input[_NP];
    }
    return entries;
};
const se_clientIDListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ContextEntry = (input, context) => {
    const entries = {};
    if (input[_CKN] != null) {
        entries[_CKN] = input[_CKN];
    }
    if (input[_CKV] != null) {
        const memberEntries = se_ContextKeyValueListType(input[_CKV], context);
        if (input[_CKV]?.length === 0) {
            entries.ContextKeyValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ContextKeyValues.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CKT] != null) {
        entries[_CKT] = input[_CKT];
    }
    return entries;
};
const se_ContextEntryListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ContextEntry(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ContextKeyValueListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CreateAccessKeyRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    return entries;
};
const se_CreateAccountAliasRequest = (input, context) => {
    const entries = {};
    if (input[_AA] != null) {
        entries[_AA] = input[_AA];
    }
    return entries;
};
const se_CreateGroupRequest = (input, context) => {
    const entries = {};
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    return entries;
};
const se_CreateInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input[_IPN] != null) {
        entries[_IPN] = input[_IPN];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateLoginProfileRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_Pa] != null) {
        entries[_Pa] = input[_Pa];
    }
    if (input[_PRR] != null) {
        entries[_PRR] = input[_PRR];
    }
    return entries;
};
const se_CreateOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    if (input[_CIDL] != null) {
        const memberEntries = se_clientIDListType(input[_CIDL], context);
        if (input[_CIDL]?.length === 0) {
            entries.ClientIDList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClientIDList.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TL] != null) {
        const memberEntries = se_thumbprintListType(input[_TL], context);
        if (input[_TL]?.length === 0) {
            entries.ThumbprintList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ThumbprintList.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreatePolicyRequest = (input, context) => {
    const entries = {};
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreatePolicyVersionRequest = (input, context) => {
    const entries = {};
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    if (input[_SAD] != null) {
        entries[_SAD] = input[_SAD];
    }
    return entries;
};
const se_CreateRoleRequest = (input, context) => {
    const entries = {};
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_ARPD] != null) {
        entries[_ARPD] = input[_ARPD];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_MSD] != null) {
        entries[_MSD] = input[_MSD];
    }
    if (input[_PB] != null) {
        entries[_PB] = input[_PB];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input[_SAMLMD] != null) {
        entries[_SAMLMD] = input[_SAMLMD];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateServiceLinkedRoleRequest = (input, context) => {
    const entries = {};
    if (input[_AWSSN] != null) {
        entries[_AWSSN] = input[_AWSSN];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_CS] != null) {
        entries[_CS] = input[_CS];
    }
    return entries;
};
const se_CreateServiceSpecificCredentialRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    return entries;
};
const se_CreateUserRequest = (input, context) => {
    const entries = {};
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_PB] != null) {
        entries[_PB] = input[_PB];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVirtualMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_VMFADN] != null) {
        entries[_VMFADN] = input[_VMFADN];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeactivateMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_SNe] != null) {
        entries[_SNe] = input[_SNe];
    }
    return entries;
};
const se_DeleteAccessKeyRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_AKI] != null) {
        entries[_AKI] = input[_AKI];
    }
    return entries;
};
const se_DeleteAccountAliasRequest = (input, context) => {
    const entries = {};
    if (input[_AA] != null) {
        entries[_AA] = input[_AA];
    }
    return entries;
};
const se_DeleteGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    return entries;
};
const se_DeleteGroupRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    return entries;
};
const se_DeleteInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input[_IPN] != null) {
        entries[_IPN] = input[_IPN];
    }
    return entries;
};
const se_DeleteLoginProfileRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    return entries;
};
const se_DeleteOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input[_OIDCPA] != null) {
        entries[_OIDCPA] = input[_OIDCPA];
    }
    return entries;
};
const se_DeletePolicyRequest = (input, context) => {
    const entries = {};
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    return entries;
};
const se_DeletePolicyVersionRequest = (input, context) => {
    const entries = {};
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_DeleteRolePermissionsBoundaryRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    return entries;
};
const se_DeleteRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    return entries;
};
const se_DeleteRoleRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    return entries;
};
const se_DeleteSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input[_SAMLPA] != null) {
        entries[_SAMLPA] = input[_SAMLPA];
    }
    return entries;
};
const se_DeleteServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    return entries;
};
const se_DeleteServiceLinkedRoleRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    return entries;
};
const se_DeleteServiceSpecificCredentialRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_SSCI] != null) {
        entries[_SSCI] = input[_SSCI];
    }
    return entries;
};
const se_DeleteSigningCertificateRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_CI] != null) {
        entries[_CI] = input[_CI];
    }
    return entries;
};
const se_DeleteSSHPublicKeyRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_SSHPKI] != null) {
        entries[_SSHPKI] = input[_SSHPKI];
    }
    return entries;
};
const se_DeleteUserPermissionsBoundaryRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    return entries;
};
const se_DeleteUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    return entries;
};
const se_DeleteUserRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    return entries;
};
const se_DeleteVirtualMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input[_SNe] != null) {
        entries[_SNe] = input[_SNe];
    }
    return entries;
};
const se_DetachGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    return entries;
};
const se_DetachRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    return entries;
};
const se_DetachUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    return entries;
};
const se_EnableMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_SNe] != null) {
        entries[_SNe] = input[_SNe];
    }
    if (input[_AC] != null) {
        entries[_AC] = input[_AC];
    }
    if (input[_ACu] != null) {
        entries[_ACu] = input[_ACu];
    }
    return entries;
};
const se_entityListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_GenerateOrganizationsAccessReportRequest = (input, context) => {
    const entries = {};
    if (input[_EP] != null) {
        entries[_EP] = input[_EP];
    }
    if (input[_OPI] != null) {
        entries[_OPI] = input[_OPI];
    }
    return entries;
};
const se_GenerateServiceLastAccessedDetailsRequest = (input, context) => {
    const entries = {};
    if (input[_Ar] != null) {
        entries[_Ar] = input[_Ar];
    }
    if (input[_G] != null) {
        entries[_G] = input[_G];
    }
    return entries;
};
const se_GetAccessKeyLastUsedRequest = (input, context) => {
    const entries = {};
    if (input[_AKI] != null) {
        entries[_AKI] = input[_AKI];
    }
    return entries;
};
const se_GetAccountAuthorizationDetailsRequest = (input, context) => {
    const entries = {};
    if (input[_F] != null) {
        const memberEntries = se_entityListType(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filter = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_GetContextKeysForCustomPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_PIL] != null) {
        const memberEntries = se_SimulationPolicyListType(input[_PIL], context);
        if (input[_PIL]?.length === 0) {
            entries.PolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetContextKeysForPrincipalPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_PSA] != null) {
        entries[_PSA] = input[_PSA];
    }
    if (input[_PIL] != null) {
        const memberEntries = se_SimulationPolicyListType(input[_PIL], context);
        if (input[_PIL]?.length === 0) {
            entries.PolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    return entries;
};
const se_GetGroupRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_GetInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input[_IPN] != null) {
        entries[_IPN] = input[_IPN];
    }
    return entries;
};
const se_GetLoginProfileRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    return entries;
};
const se_GetMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input[_SNe] != null) {
        entries[_SNe] = input[_SNe];
    }
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    return entries;
};
const se_GetOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input[_OIDCPA] != null) {
        entries[_OIDCPA] = input[_OIDCPA];
    }
    return entries;
};
const se_GetOrganizationsAccessReportRequest = (input, context) => {
    const entries = {};
    if (input[_JI] != null) {
        entries[_JI] = input[_JI];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_SK] != null) {
        entries[_SK] = input[_SK];
    }
    return entries;
};
const se_GetPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    return entries;
};
const se_GetPolicyVersionRequest = (input, context) => {
    const entries = {};
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_GetRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    return entries;
};
const se_GetRoleRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    return entries;
};
const se_GetSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input[_SAMLPA] != null) {
        entries[_SAMLPA] = input[_SAMLPA];
    }
    return entries;
};
const se_GetServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    return entries;
};
const se_GetServiceLastAccessedDetailsRequest = (input, context) => {
    const entries = {};
    if (input[_JI] != null) {
        entries[_JI] = input[_JI];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_GetServiceLastAccessedDetailsWithEntitiesRequest = (input, context) => {
    const entries = {};
    if (input[_JI] != null) {
        entries[_JI] = input[_JI];
    }
    if (input[_SNer] != null) {
        entries[_SNer] = input[_SNer];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_GetServiceLinkedRoleDeletionStatusRequest = (input, context) => {
    const entries = {};
    if (input[_DTI] != null) {
        entries[_DTI] = input[_DTI];
    }
    return entries;
};
const se_GetSSHPublicKeyRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_SSHPKI] != null) {
        entries[_SSHPKI] = input[_SSHPKI];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    return entries;
};
const se_GetUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    return entries;
};
const se_GetUserRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    return entries;
};
const se_ListAccessKeysRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListAccountAliasesRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListAttachedGroupPoliciesRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_PP] != null) {
        entries[_PP] = input[_PP];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListAttachedRolePoliciesRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_PP] != null) {
        entries[_PP] = input[_PP];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListAttachedUserPoliciesRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_PP] != null) {
        entries[_PP] = input[_PP];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListEntitiesForPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_EF] != null) {
        entries[_EF] = input[_EF];
    }
    if (input[_PP] != null) {
        entries[_PP] = input[_PP];
    }
    if (input[_PUF] != null) {
        entries[_PUF] = input[_PUF];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListGroupPoliciesRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListGroupsForUserRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListGroupsRequest = (input, context) => {
    const entries = {};
    if (input[_PP] != null) {
        entries[_PP] = input[_PP];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListInstanceProfilesForRoleRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListInstanceProfilesRequest = (input, context) => {
    const entries = {};
    if (input[_PP] != null) {
        entries[_PP] = input[_PP];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListInstanceProfileTagsRequest = (input, context) => {
    const entries = {};
    if (input[_IPN] != null) {
        entries[_IPN] = input[_IPN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListMFADevicesRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListMFADeviceTagsRequest = (input, context) => {
    const entries = {};
    if (input[_SNe] != null) {
        entries[_SNe] = input[_SNe];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListOpenIDConnectProvidersRequest = (input, context) => {
    const entries = {};
    return entries;
};
const se_ListOpenIDConnectProviderTagsRequest = (input, context) => {
    const entries = {};
    if (input[_OIDCPA] != null) {
        entries[_OIDCPA] = input[_OIDCPA];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListPoliciesGrantingServiceAccessRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ar] != null) {
        entries[_Ar] = input[_Ar];
    }
    if (input[_SNerv] != null) {
        const memberEntries = se_serviceNamespaceListType(input[_SNerv], context);
        if (input[_SNerv]?.length === 0) {
            entries.ServiceNamespaces = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ServiceNamespaces.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ListPoliciesRequest = (input, context) => {
    const entries = {};
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    if (input[_PP] != null) {
        entries[_PP] = input[_PP];
    }
    if (input[_PUF] != null) {
        entries[_PUF] = input[_PUF];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListPolicyTagsRequest = (input, context) => {
    const entries = {};
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListPolicyVersionsRequest = (input, context) => {
    const entries = {};
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListRolePoliciesRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListRolesRequest = (input, context) => {
    const entries = {};
    if (input[_PP] != null) {
        entries[_PP] = input[_PP];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListRoleTagsRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListSAMLProvidersRequest = (input, context) => {
    const entries = {};
    return entries;
};
const se_ListSAMLProviderTagsRequest = (input, context) => {
    const entries = {};
    if (input[_SAMLPA] != null) {
        entries[_SAMLPA] = input[_SAMLPA];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListServerCertificatesRequest = (input, context) => {
    const entries = {};
    if (input[_PP] != null) {
        entries[_PP] = input[_PP];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListServerCertificateTagsRequest = (input, context) => {
    const entries = {};
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListServiceSpecificCredentialsRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    return entries;
};
const se_ListSigningCertificatesRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListSSHPublicKeysRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListUserPoliciesRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListUsersRequest = (input, context) => {
    const entries = {};
    if (input[_PP] != null) {
        entries[_PP] = input[_PP];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListUserTagsRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_ListVirtualMFADevicesRequest = (input, context) => {
    const entries = {};
    if (input[_AS] != null) {
        entries[_AS] = input[_AS];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    return entries;
};
const se_PutGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    return entries;
};
const se_PutRolePermissionsBoundaryRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_PB] != null) {
        entries[_PB] = input[_PB];
    }
    return entries;
};
const se_PutRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    return entries;
};
const se_PutUserPermissionsBoundaryRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_PB] != null) {
        entries[_PB] = input[_PB];
    }
    return entries;
};
const se_PutUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    return entries;
};
const se_RemoveClientIDFromOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input[_OIDCPA] != null) {
        entries[_OIDCPA] = input[_OIDCPA];
    }
    if (input[_CID] != null) {
        entries[_CID] = input[_CID];
    }
    return entries;
};
const se_RemoveRoleFromInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input[_IPN] != null) {
        entries[_IPN] = input[_IPN];
    }
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    return entries;
};
const se_RemoveUserFromGroupRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    return entries;
};
const se_ResetServiceSpecificCredentialRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_SSCI] != null) {
        entries[_SSCI] = input[_SSCI];
    }
    return entries;
};
const se_ResourceNameListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ResyncMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_SNe] != null) {
        entries[_SNe] = input[_SNe];
    }
    if (input[_AC] != null) {
        entries[_AC] = input[_AC];
    }
    if (input[_ACu] != null) {
        entries[_ACu] = input[_ACu];
    }
    return entries;
};
const se_serviceNamespaceListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SetDefaultPolicyVersionRequest = (input, context) => {
    const entries = {};
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_SetSecurityTokenServicePreferencesRequest = (input, context) => {
    const entries = {};
    if (input[_GETV] != null) {
        entries[_GETV] = input[_GETV];
    }
    return entries;
};
const se_SimulateCustomPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_PIL] != null) {
        const memberEntries = se_SimulationPolicyListType(input[_PIL], context);
        if (input[_PIL]?.length === 0) {
            entries.PolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PBPIL] != null) {
        const memberEntries = se_SimulationPolicyListType(input[_PBPIL], context);
        if (input[_PBPIL]?.length === 0) {
            entries.PermissionsBoundaryPolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PermissionsBoundaryPolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AN] != null) {
        const memberEntries = se_ActionNameListType(input[_AN], context);
        if (input[_AN]?.length === 0) {
            entries.ActionNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ActionNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RA] != null) {
        const memberEntries = se_ResourceNameListType(input[_RA], context);
        if (input[_RA]?.length === 0) {
            entries.ResourceArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RP] != null) {
        entries[_RP] = input[_RP];
    }
    if (input[_RO] != null) {
        entries[_RO] = input[_RO];
    }
    if (input[_CA] != null) {
        entries[_CA] = input[_CA];
    }
    if (input[_CE] != null) {
        const memberEntries = se_ContextEntryListType(input[_CE], context);
        if (input[_CE]?.length === 0) {
            entries.ContextEntries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ContextEntries.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RHO] != null) {
        entries[_RHO] = input[_RHO];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_SimulatePrincipalPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_PSA] != null) {
        entries[_PSA] = input[_PSA];
    }
    if (input[_PIL] != null) {
        const memberEntries = se_SimulationPolicyListType(input[_PIL], context);
        if (input[_PIL]?.length === 0) {
            entries.PolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PBPIL] != null) {
        const memberEntries = se_SimulationPolicyListType(input[_PBPIL], context);
        if (input[_PBPIL]?.length === 0) {
            entries.PermissionsBoundaryPolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PermissionsBoundaryPolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AN] != null) {
        const memberEntries = se_ActionNameListType(input[_AN], context);
        if (input[_AN]?.length === 0) {
            entries.ActionNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ActionNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RA] != null) {
        const memberEntries = se_ResourceNameListType(input[_RA], context);
        if (input[_RA]?.length === 0) {
            entries.ResourceArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RP] != null) {
        entries[_RP] = input[_RP];
    }
    if (input[_RO] != null) {
        entries[_RO] = input[_RO];
    }
    if (input[_CA] != null) {
        entries[_CA] = input[_CA];
    }
    if (input[_CE] != null) {
        const memberEntries = se_ContextEntryListType(input[_CE], context);
        if (input[_CE]?.length === 0) {
            entries.ContextEntries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ContextEntries.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RHO] != null) {
        entries[_RHO] = input[_RHO];
    }
    if (input[_MI] != null) {
        entries[_MI] = input[_MI];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_SimulationPolicyListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_TagInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input[_IPN] != null) {
        entries[_IPN] = input[_IPN];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_tagKeyListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_tagListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TagMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input[_SNe] != null) {
        entries[_SNe] = input[_SNe];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input[_OIDCPA] != null) {
        entries[_OIDCPA] = input[_OIDCPA];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagRoleRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input[_SAMLPA] != null) {
        entries[_SAMLPA] = input[_SAMLPA];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagUserRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_thumbprintListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_UntagInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input[_IPN] != null) {
        entries[_IPN] = input[_IPN];
    }
    if (input[_TK] != null) {
        const memberEntries = se_tagKeyListType(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input[_SNe] != null) {
        entries[_SNe] = input[_SNe];
    }
    if (input[_TK] != null) {
        const memberEntries = se_tagKeyListType(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input[_OIDCPA] != null) {
        entries[_OIDCPA] = input[_OIDCPA];
    }
    if (input[_TK] != null) {
        const memberEntries = se_tagKeyListType(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_TK] != null) {
        const memberEntries = se_tagKeyListType(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagRoleRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_TK] != null) {
        const memberEntries = se_tagKeyListType(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input[_SAMLPA] != null) {
        entries[_SAMLPA] = input[_SAMLPA];
    }
    if (input[_TK] != null) {
        const memberEntries = se_tagKeyListType(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_TK] != null) {
        const memberEntries = se_tagKeyListType(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagUserRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_TK] != null) {
        const memberEntries = se_tagKeyListType(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UpdateAccessKeyRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_AKI] != null) {
        entries[_AKI] = input[_AKI];
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    return entries;
};
const se_UpdateAccountPasswordPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_MPL] != null) {
        entries[_MPL] = input[_MPL];
    }
    if (input[_RS] != null) {
        entries[_RS] = input[_RS];
    }
    if (input[_RNe] != null) {
        entries[_RNe] = input[_RNe];
    }
    if (input[_RUC] != null) {
        entries[_RUC] = input[_RUC];
    }
    if (input[_RLC] != null) {
        entries[_RLC] = input[_RLC];
    }
    if (input[_AUTCP] != null) {
        entries[_AUTCP] = input[_AUTCP];
    }
    if (input[_MPA] != null) {
        entries[_MPA] = input[_MPA];
    }
    if (input[_PRPa] != null) {
        entries[_PRPa] = input[_PRPa];
    }
    if (input[_HE] != null) {
        entries[_HE] = input[_HE];
    }
    return entries;
};
const se_UpdateAssumeRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    return entries;
};
const se_UpdateGroupRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_NPe] != null) {
        entries[_NPe] = input[_NPe];
    }
    if (input[_NGN] != null) {
        entries[_NGN] = input[_NGN];
    }
    return entries;
};
const se_UpdateLoginProfileRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_Pa] != null) {
        entries[_Pa] = input[_Pa];
    }
    if (input[_PRR] != null) {
        entries[_PRR] = input[_PRR];
    }
    return entries;
};
const se_UpdateOpenIDConnectProviderThumbprintRequest = (input, context) => {
    const entries = {};
    if (input[_OIDCPA] != null) {
        entries[_OIDCPA] = input[_OIDCPA];
    }
    if (input[_TL] != null) {
        const memberEntries = se_thumbprintListType(input[_TL], context);
        if (input[_TL]?.length === 0) {
            entries.ThumbprintList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ThumbprintList.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UpdateRoleDescriptionRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    return entries;
};
const se_UpdateRoleRequest = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_MSD] != null) {
        entries[_MSD] = input[_MSD];
    }
    return entries;
};
const se_UpdateSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input[_SAMLMD] != null) {
        entries[_SAMLMD] = input[_SAMLMD];
    }
    if (input[_SAMLPA] != null) {
        entries[_SAMLPA] = input[_SAMLPA];
    }
    return entries;
};
const se_UpdateServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_NPe] != null) {
        entries[_NPe] = input[_NPe];
    }
    if (input[_NSCN] != null) {
        entries[_NSCN] = input[_NSCN];
    }
    return entries;
};
const se_UpdateServiceSpecificCredentialRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_SSCI] != null) {
        entries[_SSCI] = input[_SSCI];
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    return entries;
};
const se_UpdateSigningCertificateRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_CI] != null) {
        entries[_CI] = input[_CI];
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    return entries;
};
const se_UpdateSSHPublicKeyRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_SSHPKI] != null) {
        entries[_SSHPKI] = input[_SSHPKI];
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    return entries;
};
const se_UpdateUserRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_NPe] != null) {
        entries[_NPe] = input[_NPe];
    }
    if (input[_NUN] != null) {
        entries[_NUN] = input[_NUN];
    }
    return entries;
};
const se_UploadServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_CB] != null) {
        entries[_CB] = input[_CB];
    }
    if (input[_PK] != null) {
        entries[_PK] = input[_PK];
    }
    if (input[_CC] != null) {
        entries[_CC] = input[_CC];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UploadSigningCertificateRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_CB] != null) {
        entries[_CB] = input[_CB];
    }
    return entries;
};
const se_UploadSSHPublicKeyRequest = (input, context) => {
    const entries = {};
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_SSHPKB] != null) {
        entries[_SSHPKB] = input[_SSHPKB];
    }
    return entries;
};
const de_AccessDetail = (output, context) => {
    const contents = {};
    if (output[_SN] != null) {
        contents[_SN] = __expectString(output[_SN]);
    }
    if (output[_SNer] != null) {
        contents[_SNer] = __expectString(output[_SNer]);
    }
    if (output[_R] != null) {
        contents[_R] = __expectString(output[_R]);
    }
    if (output[_EP] != null) {
        contents[_EP] = __expectString(output[_EP]);
    }
    if (output[_LAT] != null) {
        contents[_LAT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LAT]));
    }
    if (output[_TAE] != null) {
        contents[_TAE] = __strictParseInt32(output[_TAE]);
    }
    return contents;
};
const de_AccessDetails = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccessDetail(entry, context);
    });
};
const de_AccessKey = (output, context) => {
    const contents = {};
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_AKI] != null) {
        contents[_AKI] = __expectString(output[_AKI]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_SAK] != null) {
        contents[_SAK] = __expectString(output[_SAK]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    return contents;
};
const de_AccessKeyLastUsed = (output, context) => {
    const contents = {};
    if (output[_LUD] != null) {
        contents[_LUD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LUD]));
    }
    if (output[_SN] != null) {
        contents[_SN] = __expectString(output[_SN]);
    }
    if (output[_R] != null) {
        contents[_R] = __expectString(output[_R]);
    }
    return contents;
};
const de_AccessKeyMetadata = (output, context) => {
    const contents = {};
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_AKI] != null) {
        contents[_AKI] = __expectString(output[_AKI]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    return contents;
};
const de_accessKeyMetadataListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccessKeyMetadata(entry, context);
    });
};
const de_accountAliasListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ArnListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AttachedPermissionsBoundary = (output, context) => {
    const contents = {};
    if (output[_PBT] != null) {
        contents[_PBT] = expectString(output[_PBT]);
    }
    if (output[_PBA] != null) {
        contents[_PBA] = expectString(output[_PBA]);
    }
    return contents;
};
const de_attachedPoliciesListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AttachedPolicy(entry, context);
    });
};
const de_AttachedPolicy = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_PA] != null) {
        contents[_PA] = __expectString(output[_PA]);
    }
    return contents;
};
const de_certificateListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SigningCertificate(entry, context);
    });
};
const de_CertificationMapType = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __expectString(pair["value"]);
        return acc;
    }, {});
};
const de_clientIDListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ConcurrentModificationException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_ContextKeyNamesResultListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CreateAccessKeyResponse = (output, context) => {
    const contents = {};
    if (output[_AK] != null) {
        contents[_AK] = de_AccessKey(output[_AK], context);
    }
    return contents;
};
const de_CreateGroupResponse = (output, context) => {
    const contents = {};
    if (output[_Gr] != null) {
        contents[_Gr] = de_Group(output[_Gr], context);
    }
    return contents;
};
const de_CreateInstanceProfileResponse = (output, context) => {
    const contents = {};
    if (output[_IP] != null) {
        contents[_IP] = de_InstanceProfile(output[_IP], context);
    }
    return contents;
};
const de_CreateLoginProfileResponse = (output, context) => {
    const contents = {};
    if (output[_LPo] != null) {
        contents[_LPo] = de_LoginProfile(output[_LPo], context);
    }
    return contents;
};
const de_CreateOpenIDConnectProviderResponse = (output, context) => {
    const contents = {};
    if (output[_OIDCPA] != null) {
        contents[_OIDCPA] = __expectString(output[_OIDCPA]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    return contents;
};
const de_CreatePolicyResponse = (output, context) => {
    const contents = {};
    if (output[_Po] != null) {
        contents[_Po] = de_Policy(output[_Po], context);
    }
    return contents;
};
const de_CreatePolicyVersionResponse = (output, context) => {
    const contents = {};
    if (output[_PV] != null) {
        contents[_PV] = de_PolicyVersion(output[_PV], context);
    }
    return contents;
};
const de_CreateRoleResponse = (output, context) => {
    const contents = {};
    if (output[_Ro] != null) {
        contents[_Ro] = de_Role(output[_Ro], context);
    }
    return contents;
};
const de_CreateSAMLProviderResponse = (output, context) => {
    const contents = {};
    if (output[_SAMLPA] != null) {
        contents[_SAMLPA] = __expectString(output[_SAMLPA]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    return contents;
};
const de_CreateServiceLinkedRoleResponse = (output, context) => {
    const contents = {};
    if (output[_Ro] != null) {
        contents[_Ro] = de_Role(output[_Ro], context);
    }
    return contents;
};
const de_CreateServiceSpecificCredentialResponse = (output, context) => {
    const contents = {};
    if (output[_SSC] != null) {
        contents[_SSC] = de_ServiceSpecificCredential(output[_SSC], context);
    }
    return contents;
};
const de_CreateUserResponse = (output, context) => {
    const contents = {};
    if (output[_Us] != null) {
        contents[_Us] = de_User(output[_Us], context);
    }
    return contents;
};
const de_CreateVirtualMFADeviceResponse = (output, context) => {
    const contents = {};
    if (output[_VMFAD] != null) {
        contents[_VMFAD] = de_VirtualMFADevice(output[_VMFAD], context);
    }
    return contents;
};
const de_CredentialReportExpiredException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_CredentialReportNotPresentException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_CredentialReportNotReadyException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_DeleteConflictException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_DeleteServiceLinkedRoleResponse = (output, context) => {
    const contents = {};
    if (output[_DTI] != null) {
        contents[_DTI] = __expectString(output[_DTI]);
    }
    return contents;
};
const de_DeletionTaskFailureReasonType = (output, context) => {
    const contents = {};
    if (output[_Re] != null) {
        contents[_Re] = __expectString(output[_Re]);
    }
    if (output.RoleUsageList === "") {
        contents[_RUL] = [];
    }
    else if (output[_RUL] != null && output[_RUL][_me] != null) {
        contents[_RUL] = de_RoleUsageListType(__getArrayIfSingleItem(output[_RUL][_me]), context);
    }
    return contents;
};
const de_DuplicateCertificateException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_DuplicateSSHPublicKeyException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_EntityAlreadyExistsException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_EntityDetails = (output, context) => {
    const contents = {};
    if (output[_EI] != null) {
        contents[_EI] = de_EntityInfo(output[_EI], context);
    }
    if (output[_LA] != null) {
        contents[_LA] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LA]));
    }
    return contents;
};
const de_entityDetailsListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EntityDetails(entry, context);
    });
};
const de_EntityInfo = (output, context) => {
    const contents = {};
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output[_Ty] != null) {
        contents[_Ty] = __expectString(output[_Ty]);
    }
    if (output[_I] != null) {
        contents[_I] = __expectString(output[_I]);
    }
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    return contents;
};
const de_EntityTemporarilyUnmodifiableException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_ErrorDetails = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    if (output[_C] != null) {
        contents[_C] = __expectString(output[_C]);
    }
    return contents;
};
const de_EvalDecisionDetailsType = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __expectString(pair["value"]);
        return acc;
    }, {});
};
const de_EvaluationResult = (output, context) => {
    const contents = {};
    if (output[_EAN] != null) {
        contents[_EAN] = __expectString(output[_EAN]);
    }
    if (output[_ERN] != null) {
        contents[_ERN] = __expectString(output[_ERN]);
    }
    if (output[_ED] != null) {
        contents[_ED] = __expectString(output[_ED]);
    }
    if (output.MatchedStatements === "") {
        contents[_MS] = [];
    }
    else if (output[_MS] != null && output[_MS][_me] != null) {
        contents[_MS] = de_StatementListType(__getArrayIfSingleItem(output[_MS][_me]), context);
    }
    if (output.MissingContextValues === "") {
        contents[_MCV] = [];
    }
    else if (output[_MCV] != null && output[_MCV][_me] != null) {
        contents[_MCV] = de_ContextKeyNamesResultListType(__getArrayIfSingleItem(output[_MCV][_me]), context);
    }
    if (output[_ODD] != null) {
        contents[_ODD] = de_OrganizationsDecisionDetail(output[_ODD], context);
    }
    if (output[_PBDD] != null) {
        contents[_PBDD] = de_PermissionsBoundaryDecisionDetail(output[_PBDD], context);
    }
    if (output.EvalDecisionDetails === "") {
        contents[_EDD] = {};
    }
    else if (output[_EDD] != null && output[_EDD][_e] != null) {
        contents[_EDD] = de_EvalDecisionDetailsType(__getArrayIfSingleItem(output[_EDD][_e]), context);
    }
    if (output.ResourceSpecificResults === "") {
        contents[_RSR] = [];
    }
    else if (output[_RSR] != null && output[_RSR][_me] != null) {
        contents[_RSR] = de_ResourceSpecificResultListType(__getArrayIfSingleItem(output[_RSR][_me]), context);
    }
    return contents;
};
const de_EvaluationResultsListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EvaluationResult(entry, context);
    });
};
const de_GenerateCredentialReportResponse = (output, context) => {
    const contents = {};
    if (output[_Sta] != null) {
        contents[_Sta] = __expectString(output[_Sta]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    return contents;
};
const de_GenerateOrganizationsAccessReportResponse = (output, context) => {
    const contents = {};
    if (output[_JI] != null) {
        contents[_JI] = __expectString(output[_JI]);
    }
    return contents;
};
const de_GenerateServiceLastAccessedDetailsResponse = (output, context) => {
    const contents = {};
    if (output[_JI] != null) {
        contents[_JI] = __expectString(output[_JI]);
    }
    return contents;
};
const de_GetAccessKeyLastUsedResponse = (output, context) => {
    const contents = {};
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_AKLU] != null) {
        contents[_AKLU] = de_AccessKeyLastUsed(output[_AKLU], context);
    }
    return contents;
};
const de_GetAccountAuthorizationDetailsResponse = (output, context) => {
    const contents = {};
    if (output.UserDetailList === "") {
        contents[_UDL] = [];
    }
    else if (output[_UDL] != null && output[_UDL][_me] != null) {
        contents[_UDL] = de_userDetailListType(__getArrayIfSingleItem(output[_UDL][_me]), context);
    }
    if (output.GroupDetailList === "") {
        contents[_GDL] = [];
    }
    else if (output[_GDL] != null && output[_GDL][_me] != null) {
        contents[_GDL] = de_groupDetailListType(__getArrayIfSingleItem(output[_GDL][_me]), context);
    }
    if (output.RoleDetailList === "") {
        contents[_RDL] = [];
    }
    else if (output[_RDL] != null && output[_RDL][_me] != null) {
        contents[_RDL] = de_roleDetailListType(__getArrayIfSingleItem(output[_RDL][_me]), context);
    }
    if (output.Policies === "") {
        contents[_Pol] = [];
    }
    else if (output[_Pol] != null && output[_Pol][_me] != null) {
        contents[_Pol] = de_ManagedPolicyDetailListType(__getArrayIfSingleItem(output[_Pol][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_GetAccountPasswordPolicyResponse = (output, context) => {
    const contents = {};
    if (output[_PPa] != null) {
        contents[_PPa] = de_PasswordPolicy(output[_PPa], context);
    }
    return contents;
};
const de_GetAccountSummaryResponse = (output, context) => {
    const contents = {};
    if (output.SummaryMap === "") {
        contents[_SM] = {};
    }
    else if (output[_SM] != null && output[_SM][_e] != null) {
        contents[_SM] = de_summaryMapType(__getArrayIfSingleItem(output[_SM][_e]), context);
    }
    return contents;
};
const de_GetContextKeysForPolicyResponse = (output, context) => {
    const contents = {};
    if (output.ContextKeyNames === "") {
        contents[_CKNo] = [];
    }
    else if (output[_CKNo] != null && output[_CKNo][_me] != null) {
        contents[_CKNo] = de_ContextKeyNamesResultListType(__getArrayIfSingleItem(output[_CKNo][_me]), context);
    }
    return contents;
};
const de_GetCredentialReportResponse = (output, context) => {
    const contents = {};
    if (output[_Co] != null) {
        contents[_Co] = context.base64Decoder(output[_Co]);
    }
    if (output[_RF] != null) {
        contents[_RF] = __expectString(output[_RF]);
    }
    if (output[_GT] != null) {
        contents[_GT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_GT]));
    }
    return contents;
};
const de_GetGroupPolicyResponse = (output, context) => {
    const contents = {};
    if (output[_GN] != null) {
        contents[_GN] = __expectString(output[_GN]);
    }
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_PD] != null) {
        contents[_PD] = __expectString(output[_PD]);
    }
    return contents;
};
const de_GetGroupResponse = (output, context) => {
    const contents = {};
    if (output[_Gr] != null) {
        contents[_Gr] = de_Group(output[_Gr], context);
    }
    if (output.Users === "") {
        contents[_Use] = [];
    }
    else if (output[_Use] != null && output[_Use][_me] != null) {
        contents[_Use] = de_userListType(__getArrayIfSingleItem(output[_Use][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_GetInstanceProfileResponse = (output, context) => {
    const contents = {};
    if (output[_IP] != null) {
        contents[_IP] = de_InstanceProfile(output[_IP], context);
    }
    return contents;
};
const de_GetLoginProfileResponse = (output, context) => {
    const contents = {};
    if (output[_LPo] != null) {
        contents[_LPo] = de_LoginProfile(output[_LPo], context);
    }
    return contents;
};
const de_GetMFADeviceResponse = (output, context) => {
    const contents = {};
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_SNe] != null) {
        contents[_SNe] = __expectString(output[_SNe]);
    }
    if (output[_EDn] != null) {
        contents[_EDn] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_EDn]));
    }
    if (output.Certifications === "") {
        contents[_Ce] = {};
    }
    else if (output[_Ce] != null && output[_Ce][_e] != null) {
        contents[_Ce] = de_CertificationMapType(__getArrayIfSingleItem(output[_Ce][_e]), context);
    }
    return contents;
};
const de_GetOpenIDConnectProviderResponse = (output, context) => {
    const contents = {};
    if (output[_U] != null) {
        contents[_U] = __expectString(output[_U]);
    }
    if (output.ClientIDList === "") {
        contents[_CIDL] = [];
    }
    else if (output[_CIDL] != null && output[_CIDL][_me] != null) {
        contents[_CIDL] = de_clientIDListType(__getArrayIfSingleItem(output[_CIDL][_me]), context);
    }
    if (output.ThumbprintList === "") {
        contents[_TL] = [];
    }
    else if (output[_TL] != null && output[_TL][_me] != null) {
        contents[_TL] = de_thumbprintListType(__getArrayIfSingleItem(output[_TL][_me]), context);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    return contents;
};
const de_GetOrganizationsAccessReportResponse = (output, context) => {
    const contents = {};
    if (output[_JS] != null) {
        contents[_JS] = __expectString(output[_JS]);
    }
    if (output[_JCD] != null) {
        contents[_JCD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_JCD]));
    }
    if (output[_JCDo] != null) {
        contents[_JCDo] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_JCDo]));
    }
    if (output[_NOSA] != null) {
        contents[_NOSA] = __strictParseInt32(output[_NOSA]);
    }
    if (output[_NOSNA] != null) {
        contents[_NOSNA] = __strictParseInt32(output[_NOSNA]);
    }
    if (output.AccessDetails === "") {
        contents[_AD] = [];
    }
    else if (output[_AD] != null && output[_AD][_me] != null) {
        contents[_AD] = de_AccessDetails(__getArrayIfSingleItem(output[_AD][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output[_EDr] != null) {
        contents[_EDr] = de_ErrorDetails(output[_EDr], context);
    }
    return contents;
};
const de_GetPolicyResponse = (output, context) => {
    const contents = {};
    if (output[_Po] != null) {
        contents[_Po] = de_Policy(output[_Po], context);
    }
    return contents;
};
const de_GetPolicyVersionResponse = (output, context) => {
    const contents = {};
    if (output[_PV] != null) {
        contents[_PV] = de_PolicyVersion(output[_PV], context);
    }
    return contents;
};
const de_GetRolePolicyResponse = (output, context) => {
    const contents = {};
    if (output[_RN] != null) {
        contents[_RN] = __expectString(output[_RN]);
    }
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_PD] != null) {
        contents[_PD] = __expectString(output[_PD]);
    }
    return contents;
};
const de_GetRoleResponse = (output, context) => {
    const contents = {};
    if (output[_Ro] != null) {
        contents[_Ro] = de_Role(output[_Ro], context);
    }
    return contents;
};
const de_GetSAMLProviderResponse = (output, context) => {
    const contents = {};
    if (output[_SAMLMD] != null) {
        contents[_SAMLMD] = __expectString(output[_SAMLMD]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output[_VU] != null) {
        contents[_VU] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_VU]));
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    return contents;
};
const de_GetServerCertificateResponse = (output, context) => {
    const contents = {};
    if (output[_SC] != null) {
        contents[_SC] = de_ServerCertificate(output[_SC], context);
    }
    return contents;
};
const de_GetServiceLastAccessedDetailsResponse = (output, context) => {
    const contents = {};
    if (output[_JS] != null) {
        contents[_JS] = __expectString(output[_JS]);
    }
    if (output[_JT] != null) {
        contents[_JT] = __expectString(output[_JT]);
    }
    if (output[_JCD] != null) {
        contents[_JCD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_JCD]));
    }
    if (output.ServicesLastAccessed === "") {
        contents[_SLA] = [];
    }
    else if (output[_SLA] != null && output[_SLA][_me] != null) {
        contents[_SLA] = de_ServicesLastAccessed(__getArrayIfSingleItem(output[_SLA][_me]), context);
    }
    if (output[_JCDo] != null) {
        contents[_JCDo] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_JCDo]));
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output[_Er] != null) {
        contents[_Er] = de_ErrorDetails(output[_Er], context);
    }
    return contents;
};
const de_GetServiceLastAccessedDetailsWithEntitiesResponse = (output, context) => {
    const contents = {};
    if (output[_JS] != null) {
        contents[_JS] = __expectString(output[_JS]);
    }
    if (output[_JCD] != null) {
        contents[_JCD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_JCD]));
    }
    if (output[_JCDo] != null) {
        contents[_JCDo] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_JCDo]));
    }
    if (output.EntityDetailsList === "") {
        contents[_EDL] = [];
    }
    else if (output[_EDL] != null && output[_EDL][_me] != null) {
        contents[_EDL] = de_entityDetailsListType(__getArrayIfSingleItem(output[_EDL][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output[_Er] != null) {
        contents[_Er] = de_ErrorDetails(output[_Er], context);
    }
    return contents;
};
const de_GetServiceLinkedRoleDeletionStatusResponse = (output, context) => {
    const contents = {};
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_Re] != null) {
        contents[_Re] = de_DeletionTaskFailureReasonType(output[_Re], context);
    }
    return contents;
};
const de_GetSSHPublicKeyResponse = (output, context) => {
    const contents = {};
    if (output[_SSHPK] != null) {
        contents[_SSHPK] = de_SSHPublicKey(output[_SSHPK], context);
    }
    return contents;
};
const de_GetUserPolicyResponse = (output, context) => {
    const contents = {};
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_PD] != null) {
        contents[_PD] = __expectString(output[_PD]);
    }
    return contents;
};
const de_GetUserResponse = (output, context) => {
    const contents = {};
    if (output[_Us] != null) {
        contents[_Us] = de_User(output[_Us], context);
    }
    return contents;
};
const de_Group = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output[_GN] != null) {
        contents[_GN] = __expectString(output[_GN]);
    }
    if (output[_GI] != null) {
        contents[_GI] = __expectString(output[_GI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    return contents;
};
const de_GroupDetail = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output[_GN] != null) {
        contents[_GN] = __expectString(output[_GN]);
    }
    if (output[_GI] != null) {
        contents[_GI] = __expectString(output[_GI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output.GroupPolicyList === "") {
        contents[_GPL] = [];
    }
    else if (output[_GPL] != null && output[_GPL][_me] != null) {
        contents[_GPL] = de_policyDetailListType(__getArrayIfSingleItem(output[_GPL][_me]), context);
    }
    if (output.AttachedManagedPolicies === "") {
        contents[_AMP] = [];
    }
    else if (output[_AMP] != null && output[_AMP][_me] != null) {
        contents[_AMP] = de_attachedPoliciesListType(__getArrayIfSingleItem(output[_AMP][_me]), context);
    }
    return contents;
};
const de_groupDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GroupDetail(entry, context);
    });
};
const de_groupListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Group(entry, context);
    });
};
const de_groupNameListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InstanceProfile = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output[_IPN] != null) {
        contents[_IPN] = __expectString(output[_IPN]);
    }
    if (output[_IPI] != null) {
        contents[_IPI] = __expectString(output[_IPI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output.Roles === "") {
        contents[_Rol] = [];
    }
    else if (output[_Rol] != null && output[_Rol][_me] != null) {
        contents[_Rol] = de_roleListType(__getArrayIfSingleItem(output[_Rol][_me]), context);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    return contents;
};
const de_instanceProfileListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceProfile(entry, context);
    });
};
const de_InvalidAuthenticationCodeException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_InvalidCertificateException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_InvalidInputException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_InvalidPublicKeyException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_InvalidUserTypeException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_KeyPairMismatchException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_LimitExceededException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_ListAccessKeysResponse = (output, context) => {
    const contents = {};
    if (output.AccessKeyMetadata === "") {
        contents[_AKM] = [];
    }
    else if (output[_AKM] != null && output[_AKM][_me] != null) {
        contents[_AKM] = de_accessKeyMetadataListType(__getArrayIfSingleItem(output[_AKM][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListAccountAliasesResponse = (output, context) => {
    const contents = {};
    if (output.AccountAliases === "") {
        contents[_AAc] = [];
    }
    else if (output[_AAc] != null && output[_AAc][_me] != null) {
        contents[_AAc] = de_accountAliasListType(__getArrayIfSingleItem(output[_AAc][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListAttachedGroupPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.AttachedPolicies === "") {
        contents[_AP] = [];
    }
    else if (output[_AP] != null && output[_AP][_me] != null) {
        contents[_AP] = de_attachedPoliciesListType(__getArrayIfSingleItem(output[_AP][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListAttachedRolePoliciesResponse = (output, context) => {
    const contents = {};
    if (output.AttachedPolicies === "") {
        contents[_AP] = [];
    }
    else if (output[_AP] != null && output[_AP][_me] != null) {
        contents[_AP] = de_attachedPoliciesListType(__getArrayIfSingleItem(output[_AP][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListAttachedUserPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.AttachedPolicies === "") {
        contents[_AP] = [];
    }
    else if (output[_AP] != null && output[_AP][_me] != null) {
        contents[_AP] = de_attachedPoliciesListType(__getArrayIfSingleItem(output[_AP][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListEntitiesForPolicyResponse = (output, context) => {
    const contents = {};
    if (output.PolicyGroups === "") {
        contents[_PG] = [];
    }
    else if (output[_PG] != null && output[_PG][_me] != null) {
        contents[_PG] = de_PolicyGroupListType(__getArrayIfSingleItem(output[_PG][_me]), context);
    }
    if (output.PolicyUsers === "") {
        contents[_PU] = [];
    }
    else if (output[_PU] != null && output[_PU][_me] != null) {
        contents[_PU] = de_PolicyUserListType(__getArrayIfSingleItem(output[_PU][_me]), context);
    }
    if (output.PolicyRoles === "") {
        contents[_PR] = [];
    }
    else if (output[_PR] != null && output[_PR][_me] != null) {
        contents[_PR] = de_PolicyRoleListType(__getArrayIfSingleItem(output[_PR][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListGroupPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.PolicyNames === "") {
        contents[_PNo] = [];
    }
    else if (output[_PNo] != null && output[_PNo][_me] != null) {
        contents[_PNo] = de_policyNameListType(__getArrayIfSingleItem(output[_PNo][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListGroupsForUserResponse = (output, context) => {
    const contents = {};
    if (output.Groups === "") {
        contents[_Gro] = [];
    }
    else if (output[_Gro] != null && output[_Gro][_me] != null) {
        contents[_Gro] = de_groupListType(__getArrayIfSingleItem(output[_Gro][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListGroupsResponse = (output, context) => {
    const contents = {};
    if (output.Groups === "") {
        contents[_Gro] = [];
    }
    else if (output[_Gro] != null && output[_Gro][_me] != null) {
        contents[_Gro] = de_groupListType(__getArrayIfSingleItem(output[_Gro][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListInstanceProfilesForRoleResponse = (output, context) => {
    const contents = {};
    if (output.InstanceProfiles === "") {
        contents[_IPn] = [];
    }
    else if (output[_IPn] != null && output[_IPn][_me] != null) {
        contents[_IPn] = de_instanceProfileListType(__getArrayIfSingleItem(output[_IPn][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListInstanceProfilesResponse = (output, context) => {
    const contents = {};
    if (output.InstanceProfiles === "") {
        contents[_IPn] = [];
    }
    else if (output[_IPn] != null && output[_IPn][_me] != null) {
        contents[_IPn] = de_instanceProfileListType(__getArrayIfSingleItem(output[_IPn][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListInstanceProfileTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListMFADevicesResponse = (output, context) => {
    const contents = {};
    if (output.MFADevices === "") {
        contents[_MFAD] = [];
    }
    else if (output[_MFAD] != null && output[_MFAD][_me] != null) {
        contents[_MFAD] = de_mfaDeviceListType(__getArrayIfSingleItem(output[_MFAD][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListMFADeviceTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListOpenIDConnectProvidersResponse = (output, context) => {
    const contents = {};
    if (output.OpenIDConnectProviderList === "") {
        contents[_OIDCPL] = [];
    }
    else if (output[_OIDCPL] != null && output[_OIDCPL][_me] != null) {
        contents[_OIDCPL] = de_OpenIDConnectProviderListType(__getArrayIfSingleItem(output[_OIDCPL][_me]), context);
    }
    return contents;
};
const de_ListOpenIDConnectProviderTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListPoliciesGrantingServiceAccessEntry = (output, context) => {
    const contents = {};
    if (output[_SNer] != null) {
        contents[_SNer] = __expectString(output[_SNer]);
    }
    if (output.Policies === "") {
        contents[_Pol] = [];
    }
    else if (output[_Pol] != null && output[_Pol][_me] != null) {
        contents[_Pol] = de_policyGrantingServiceAccessListType(__getArrayIfSingleItem(output[_Pol][_me]), context);
    }
    return contents;
};
const de_ListPoliciesGrantingServiceAccessResponse = (output, context) => {
    const contents = {};
    if (output.PoliciesGrantingServiceAccess === "") {
        contents[_PGSA] = [];
    }
    else if (output[_PGSA] != null && output[_PGSA][_me] != null) {
        contents[_PGSA] = de_listPolicyGrantingServiceAccessResponseListType(__getArrayIfSingleItem(output[_PGSA][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.Policies === "") {
        contents[_Pol] = [];
    }
    else if (output[_Pol] != null && output[_Pol][_me] != null) {
        contents[_Pol] = de_policyListType(__getArrayIfSingleItem(output[_Pol][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_listPolicyGrantingServiceAccessResponseListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListPoliciesGrantingServiceAccessEntry(entry, context);
    });
};
const de_ListPolicyTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListPolicyVersionsResponse = (output, context) => {
    const contents = {};
    if (output.Versions === "") {
        contents[_Ve] = [];
    }
    else if (output[_Ve] != null && output[_Ve][_me] != null) {
        contents[_Ve] = de_policyDocumentVersionListType(__getArrayIfSingleItem(output[_Ve][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListRolePoliciesResponse = (output, context) => {
    const contents = {};
    if (output.PolicyNames === "") {
        contents[_PNo] = [];
    }
    else if (output[_PNo] != null && output[_PNo][_me] != null) {
        contents[_PNo] = de_policyNameListType(__getArrayIfSingleItem(output[_PNo][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListRolesResponse = (output, context) => {
    const contents = {};
    if (output.Roles === "") {
        contents[_Rol] = [];
    }
    else if (output[_Rol] != null && output[_Rol][_me] != null) {
        contents[_Rol] = de_roleListType(__getArrayIfSingleItem(output[_Rol][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListRoleTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListSAMLProvidersResponse = (output, context) => {
    const contents = {};
    if (output.SAMLProviderList === "") {
        contents[_SAMLPL] = [];
    }
    else if (output[_SAMLPL] != null && output[_SAMLPL][_me] != null) {
        contents[_SAMLPL] = de_SAMLProviderListType(__getArrayIfSingleItem(output[_SAMLPL][_me]), context);
    }
    return contents;
};
const de_ListSAMLProviderTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListServerCertificatesResponse = (output, context) => {
    const contents = {};
    if (output.ServerCertificateMetadataList === "") {
        contents[_SCML] = [];
    }
    else if (output[_SCML] != null && output[_SCML][_me] != null) {
        contents[_SCML] = de_serverCertificateMetadataListType(__getArrayIfSingleItem(output[_SCML][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListServerCertificateTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListServiceSpecificCredentialsResponse = (output, context) => {
    const contents = {};
    if (output.ServiceSpecificCredentials === "") {
        contents[_SSCe] = [];
    }
    else if (output[_SSCe] != null && output[_SSCe][_me] != null) {
        contents[_SSCe] = de_ServiceSpecificCredentialsListType(__getArrayIfSingleItem(output[_SSCe][_me]), context);
    }
    return contents;
};
const de_ListSigningCertificatesResponse = (output, context) => {
    const contents = {};
    if (output.Certificates === "") {
        contents[_Cer] = [];
    }
    else if (output[_Cer] != null && output[_Cer][_me] != null) {
        contents[_Cer] = de_certificateListType(__getArrayIfSingleItem(output[_Cer][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListSSHPublicKeysResponse = (output, context) => {
    const contents = {};
    if (output.SSHPublicKeys === "") {
        contents[_SSHPKu] = [];
    }
    else if (output[_SSHPKu] != null && output[_SSHPKu][_me] != null) {
        contents[_SSHPKu] = de_SSHPublicKeyListType(__getArrayIfSingleItem(output[_SSHPKu][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListUserPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.PolicyNames === "") {
        contents[_PNo] = [];
    }
    else if (output[_PNo] != null && output[_PNo][_me] != null) {
        contents[_PNo] = de_policyNameListType(__getArrayIfSingleItem(output[_PNo][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListUsersResponse = (output, context) => {
    const contents = {};
    if (output.Users === "") {
        contents[_Use] = [];
    }
    else if (output[_Use] != null && output[_Use][_me] != null) {
        contents[_Use] = de_userListType(__getArrayIfSingleItem(output[_Use][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListUserTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ListVirtualMFADevicesResponse = (output, context) => {
    const contents = {};
    if (output.VirtualMFADevices === "") {
        contents[_VMFADi] = [];
    }
    else if (output[_VMFADi] != null && output[_VMFADi][_me] != null) {
        contents[_VMFADi] = de_virtualMFADeviceListType(__getArrayIfSingleItem(output[_VMFADi][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_LoginProfile = (output, context) => {
    const contents = {};
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output[_PRR] != null) {
        contents[_PRR] = __parseBoolean(output[_PRR]);
    }
    return contents;
};
const de_MalformedCertificateException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_MalformedPolicyDocumentException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_ManagedPolicyDetail = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_PI] != null) {
        contents[_PI] = __expectString(output[_PI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output[_DVI] != null) {
        contents[_DVI] = __expectString(output[_DVI]);
    }
    if (output[_ACt] != null) {
        contents[_ACt] = __strictParseInt32(output[_ACt]);
    }
    if (output[_PBUC] != null) {
        contents[_PBUC] = __strictParseInt32(output[_PBUC]);
    }
    if (output[_IA] != null) {
        contents[_IA] = __parseBoolean(output[_IA]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output[_UD] != null) {
        contents[_UD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_UD]));
    }
    if (output.PolicyVersionList === "") {
        contents[_PVL] = [];
    }
    else if (output[_PVL] != null && output[_PVL][_me] != null) {
        contents[_PVL] = de_policyDocumentVersionListType(__getArrayIfSingleItem(output[_PVL][_me]), context);
    }
    return contents;
};
const de_ManagedPolicyDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ManagedPolicyDetail(entry, context);
    });
};
const de_MFADevice = (output, context) => {
    const contents = {};
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_SNe] != null) {
        contents[_SNe] = __expectString(output[_SNe]);
    }
    if (output[_EDn] != null) {
        contents[_EDn] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_EDn]));
    }
    return contents;
};
const de_mfaDeviceListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MFADevice(entry, context);
    });
};
const de_NoSuchEntityException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_OpenIDConnectProviderListEntry = (output, context) => {
    const contents = {};
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    return contents;
};
const de_OpenIDConnectProviderListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OpenIDConnectProviderListEntry(entry, context);
    });
};
const de_OpenIdIdpCommunicationErrorException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_OrganizationsDecisionDetail = (output, context) => {
    const contents = {};
    if (output[_ABO] != null) {
        contents[_ABO] = __parseBoolean(output[_ABO]);
    }
    return contents;
};
const de_PasswordPolicy = (output, context) => {
    const contents = {};
    if (output[_MPL] != null) {
        contents[_MPL] = __strictParseInt32(output[_MPL]);
    }
    if (output[_RS] != null) {
        contents[_RS] = __parseBoolean(output[_RS]);
    }
    if (output[_RNe] != null) {
        contents[_RNe] = __parseBoolean(output[_RNe]);
    }
    if (output[_RUC] != null) {
        contents[_RUC] = __parseBoolean(output[_RUC]);
    }
    if (output[_RLC] != null) {
        contents[_RLC] = __parseBoolean(output[_RLC]);
    }
    if (output[_AUTCP] != null) {
        contents[_AUTCP] = __parseBoolean(output[_AUTCP]);
    }
    if (output[_EPx] != null) {
        contents[_EPx] = __parseBoolean(output[_EPx]);
    }
    if (output[_MPA] != null) {
        contents[_MPA] = __strictParseInt32(output[_MPA]);
    }
    if (output[_PRPa] != null) {
        contents[_PRPa] = __strictParseInt32(output[_PRPa]);
    }
    if (output[_HE] != null) {
        contents[_HE] = __parseBoolean(output[_HE]);
    }
    return contents;
};
const de_PasswordPolicyViolationException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_PermissionsBoundaryDecisionDetail = (output, context) => {
    const contents = {};
    if (output[_ABPB] != null) {
        contents[_ABPB] = __parseBoolean(output[_ABPB]);
    }
    return contents;
};
const de_Policy = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_PI] != null) {
        contents[_PI] = __expectString(output[_PI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output[_DVI] != null) {
        contents[_DVI] = __expectString(output[_DVI]);
    }
    if (output[_ACt] != null) {
        contents[_ACt] = __strictParseInt32(output[_ACt]);
    }
    if (output[_PBUC] != null) {
        contents[_PBUC] = __strictParseInt32(output[_PBUC]);
    }
    if (output[_IA] != null) {
        contents[_IA] = __parseBoolean(output[_IA]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output[_UD] != null) {
        contents[_UD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_UD]));
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    return contents;
};
const de_PolicyDetail = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_PD] != null) {
        contents[_PD] = __expectString(output[_PD]);
    }
    return contents;
};
const de_policyDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyDetail(entry, context);
    });
};
const de_policyDocumentVersionListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyVersion(entry, context);
    });
};
const de_PolicyEvaluationException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_PolicyGrantingServiceAccess = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_PT] != null) {
        contents[_PT] = __expectString(output[_PT]);
    }
    if (output[_PA] != null) {
        contents[_PA] = __expectString(output[_PA]);
    }
    if (output[_ET] != null) {
        contents[_ET] = __expectString(output[_ET]);
    }
    if (output[_EN] != null) {
        contents[_EN] = __expectString(output[_EN]);
    }
    return contents;
};
const de_policyGrantingServiceAccessListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyGrantingServiceAccess(entry, context);
    });
};
const de_PolicyGroup = (output, context) => {
    const contents = {};
    if (output[_GN] != null) {
        contents[_GN] = __expectString(output[_GN]);
    }
    if (output[_GI] != null) {
        contents[_GI] = __expectString(output[_GI]);
    }
    return contents;
};
const de_PolicyGroupListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyGroup(entry, context);
    });
};
const de_policyListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Policy(entry, context);
    });
};
const de_policyNameListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_PolicyNotAttachableException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_PolicyRole = (output, context) => {
    const contents = {};
    if (output[_RN] != null) {
        contents[_RN] = __expectString(output[_RN]);
    }
    if (output[_RI] != null) {
        contents[_RI] = __expectString(output[_RI]);
    }
    return contents;
};
const de_PolicyRoleListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyRole(entry, context);
    });
};
const de_PolicyUser = (output, context) => {
    const contents = {};
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_UI] != null) {
        contents[_UI] = __expectString(output[_UI]);
    }
    return contents;
};
const de_PolicyUserListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyUser(entry, context);
    });
};
const de_PolicyVersion = (output, context) => {
    const contents = {};
    if (output[_Do] != null) {
        contents[_Do] = __expectString(output[_Do]);
    }
    if (output[_VI] != null) {
        contents[_VI] = __expectString(output[_VI]);
    }
    if (output[_IDV] != null) {
        contents[_IDV] = __parseBoolean(output[_IDV]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    return contents;
};
const de_Position = (output, context) => {
    const contents = {};
    if (output[_L] != null) {
        contents[_L] = __strictParseInt32(output[_L]);
    }
    if (output[_Col] != null) {
        contents[_Col] = __strictParseInt32(output[_Col]);
    }
    return contents;
};
const de_ReportGenerationLimitExceededException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_ResetServiceSpecificCredentialResponse = (output, context) => {
    const contents = {};
    if (output[_SSC] != null) {
        contents[_SSC] = de_ServiceSpecificCredential(output[_SSC], context);
    }
    return contents;
};
const de_ResourceSpecificResult = (output, context) => {
    const contents = {};
    if (output[_ERN] != null) {
        contents[_ERN] = __expectString(output[_ERN]);
    }
    if (output[_ERD] != null) {
        contents[_ERD] = __expectString(output[_ERD]);
    }
    if (output.MatchedStatements === "") {
        contents[_MS] = [];
    }
    else if (output[_MS] != null && output[_MS][_me] != null) {
        contents[_MS] = de_StatementListType(__getArrayIfSingleItem(output[_MS][_me]), context);
    }
    if (output.MissingContextValues === "") {
        contents[_MCV] = [];
    }
    else if (output[_MCV] != null && output[_MCV][_me] != null) {
        contents[_MCV] = de_ContextKeyNamesResultListType(__getArrayIfSingleItem(output[_MCV][_me]), context);
    }
    if (output.EvalDecisionDetails === "") {
        contents[_EDD] = {};
    }
    else if (output[_EDD] != null && output[_EDD][_e] != null) {
        contents[_EDD] = de_EvalDecisionDetailsType(__getArrayIfSingleItem(output[_EDD][_e]), context);
    }
    if (output[_PBDD] != null) {
        contents[_PBDD] = de_PermissionsBoundaryDecisionDetail(output[_PBDD], context);
    }
    return contents;
};
const de_ResourceSpecificResultListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResourceSpecificResult(entry, context);
    });
};
const de_Role = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output[_RN] != null) {
        contents[_RN] = __expectString(output[_RN]);
    }
    if (output[_RI] != null) {
        contents[_RI] = __expectString(output[_RI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output[_ARPD] != null) {
        contents[_ARPD] = __expectString(output[_ARPD]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_MSD] != null) {
        contents[_MSD] = __strictParseInt32(output[_MSD]);
    }
    if (output[_PB] != null) {
        contents[_PB] = de_AttachedPermissionsBoundary(output[_PB], context);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    if (output[_RLU] != null) {
        contents[_RLU] = de_RoleLastUsed(output[_RLU], context);
    }
    return contents;
};
const de_RoleDetail = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output[_RN] != null) {
        contents[_RN] = __expectString(output[_RN]);
    }
    if (output[_RI] != null) {
        contents[_RI] = __expectString(output[_RI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output[_ARPD] != null) {
        contents[_ARPD] = __expectString(output[_ARPD]);
    }
    if (output.InstanceProfileList === "") {
        contents[_IPL] = [];
    }
    else if (output[_IPL] != null && output[_IPL][_me] != null) {
        contents[_IPL] = de_instanceProfileListType(__getArrayIfSingleItem(output[_IPL][_me]), context);
    }
    if (output.RolePolicyList === "") {
        contents[_RPL] = [];
    }
    else if (output[_RPL] != null && output[_RPL][_me] != null) {
        contents[_RPL] = de_policyDetailListType(__getArrayIfSingleItem(output[_RPL][_me]), context);
    }
    if (output.AttachedManagedPolicies === "") {
        contents[_AMP] = [];
    }
    else if (output[_AMP] != null && output[_AMP][_me] != null) {
        contents[_AMP] = de_attachedPoliciesListType(__getArrayIfSingleItem(output[_AMP][_me]), context);
    }
    if (output[_PB] != null) {
        contents[_PB] = de_AttachedPermissionsBoundary(output[_PB], context);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    if (output[_RLU] != null) {
        contents[_RLU] = de_RoleLastUsed(output[_RLU], context);
    }
    return contents;
};
const de_roleDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoleDetail(entry, context);
    });
};
const de_RoleLastUsed = (output, context) => {
    const contents = {};
    if (output[_LUD] != null) {
        contents[_LUD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LUD]));
    }
    if (output[_R] != null) {
        contents[_R] = __expectString(output[_R]);
    }
    return contents;
};
const de_roleListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Role(entry, context);
    });
};
const de_RoleUsageListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoleUsageType(entry, context);
    });
};
const de_RoleUsageType = (output, context) => {
    const contents = {};
    if (output[_R] != null) {
        contents[_R] = __expectString(output[_R]);
    }
    if (output.Resources === "") {
        contents[_Res] = [];
    }
    else if (output[_Res] != null && output[_Res][_me] != null) {
        contents[_Res] = de_ArnListType(__getArrayIfSingleItem(output[_Res][_me]), context);
    }
    return contents;
};
const de_SAMLProviderListEntry = (output, context) => {
    const contents = {};
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_VU] != null) {
        contents[_VU] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_VU]));
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    return contents;
};
const de_SAMLProviderListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SAMLProviderListEntry(entry, context);
    });
};
const de_ServerCertificate = (output, context) => {
    const contents = {};
    if (output[_SCM] != null) {
        contents[_SCM] = de_ServerCertificateMetadata(output[_SCM], context);
    }
    if (output[_CB] != null) {
        contents[_CB] = __expectString(output[_CB]);
    }
    if (output[_CC] != null) {
        contents[_CC] = __expectString(output[_CC]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    return contents;
};
const de_ServerCertificateMetadata = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output[_SCN] != null) {
        contents[_SCN] = __expectString(output[_SCN]);
    }
    if (output[_SCI] != null) {
        contents[_SCI] = __expectString(output[_SCI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_UDp] != null) {
        contents[_UDp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_UDp]));
    }
    if (output[_Ex] != null) {
        contents[_Ex] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Ex]));
    }
    return contents;
};
const de_serverCertificateMetadataListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServerCertificateMetadata(entry, context);
    });
};
const de_ServiceFailureException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_ServiceLastAccessed = (output, context) => {
    const contents = {};
    if (output[_SN] != null) {
        contents[_SN] = __expectString(output[_SN]);
    }
    if (output[_LA] != null) {
        contents[_LA] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LA]));
    }
    if (output[_SNer] != null) {
        contents[_SNer] = __expectString(output[_SNer]);
    }
    if (output[_LAE] != null) {
        contents[_LAE] = __expectString(output[_LAE]);
    }
    if (output[_LAR] != null) {
        contents[_LAR] = __expectString(output[_LAR]);
    }
    if (output[_TAE] != null) {
        contents[_TAE] = __strictParseInt32(output[_TAE]);
    }
    if (output.TrackedActionsLastAccessed === "") {
        contents[_TALA] = [];
    }
    else if (output[_TALA] != null && output[_TALA][_me] != null) {
        contents[_TALA] = de_TrackedActionsLastAccessed(__getArrayIfSingleItem(output[_TALA][_me]), context);
    }
    return contents;
};
const de_ServiceNotSupportedException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_ServicesLastAccessed = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServiceLastAccessed(entry, context);
    });
};
const de_ServiceSpecificCredential = (output, context) => {
    const contents = {};
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output[_SN] != null) {
        contents[_SN] = __expectString(output[_SN]);
    }
    if (output[_SUN] != null) {
        contents[_SUN] = __expectString(output[_SUN]);
    }
    if (output[_SP] != null) {
        contents[_SP] = __expectString(output[_SP]);
    }
    if (output[_SSCI] != null) {
        contents[_SSCI] = __expectString(output[_SSCI]);
    }
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    return contents;
};
const de_ServiceSpecificCredentialMetadata = (output, context) => {
    const contents = {};
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_SUN] != null) {
        contents[_SUN] = __expectString(output[_SUN]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output[_SSCI] != null) {
        contents[_SSCI] = __expectString(output[_SSCI]);
    }
    if (output[_SN] != null) {
        contents[_SN] = __expectString(output[_SN]);
    }
    return contents;
};
const de_ServiceSpecificCredentialsListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServiceSpecificCredentialMetadata(entry, context);
    });
};
const de_SigningCertificate = (output, context) => {
    const contents = {};
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_CI] != null) {
        contents[_CI] = __expectString(output[_CI]);
    }
    if (output[_CB] != null) {
        contents[_CB] = __expectString(output[_CB]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_UDp] != null) {
        contents[_UDp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_UDp]));
    }
    return contents;
};
const de_SimulatePolicyResponse = (output, context) => {
    const contents = {};
    if (output.EvaluationResults === "") {
        contents[_ER] = [];
    }
    else if (output[_ER] != null && output[_ER][_me] != null) {
        contents[_ER] = de_EvaluationResultsListType(__getArrayIfSingleItem(output[_ER][_me]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = __parseBoolean(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_SSHPublicKey = (output, context) => {
    const contents = {};
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_SSHPKI] != null) {
        contents[_SSHPKI] = __expectString(output[_SSHPKI]);
    }
    if (output[_Fi] != null) {
        contents[_Fi] = __expectString(output[_Fi]);
    }
    if (output[_SSHPKB] != null) {
        contents[_SSHPKB] = __expectString(output[_SSHPKB]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_UDp] != null) {
        contents[_UDp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_UDp]));
    }
    return contents;
};
const de_SSHPublicKeyListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SSHPublicKeyMetadata(entry, context);
    });
};
const de_SSHPublicKeyMetadata = (output, context) => {
    const contents = {};
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_SSHPKI] != null) {
        contents[_SSHPKI] = __expectString(output[_SSHPKI]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_UDp] != null) {
        contents[_UDp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_UDp]));
    }
    return contents;
};
const de_Statement = (output, context) => {
    const contents = {};
    if (output[_SPI] != null) {
        contents[_SPI] = __expectString(output[_SPI]);
    }
    if (output[_SPT] != null) {
        contents[_SPT] = __expectString(output[_SPT]);
    }
    if (output[_SPt] != null) {
        contents[_SPt] = de_Position(output[_SPt], context);
    }
    if (output[_EPn] != null) {
        contents[_EPn] = de_Position(output[_EPn], context);
    }
    return contents;
};
const de_StatementListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Statement(entry, context);
    });
};
const de_summaryMapType = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __strictParseInt32(pair["value"]);
        return acc;
    }, {});
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
    }
    if (output[_Va] != null) {
        contents[_Va] = expectString(output[_Va]);
    }
    return contents;
};
const de_tagListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_thumbprintListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_TrackedActionLastAccessed = (output, context) => {
    const contents = {};
    if (output[_ANc] != null) {
        contents[_ANc] = __expectString(output[_ANc]);
    }
    if (output[_LAEa] != null) {
        contents[_LAEa] = __expectString(output[_LAEa]);
    }
    if (output[_LATa] != null) {
        contents[_LATa] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LATa]));
    }
    if (output[_LARa] != null) {
        contents[_LARa] = __expectString(output[_LARa]);
    }
    return contents;
};
const de_TrackedActionsLastAccessed = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrackedActionLastAccessed(entry, context);
    });
};
const de_UnmodifiableEntityException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_UnrecognizedPublicKeyEncodingException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = expectString(output[_m]);
    }
    return contents;
};
const de_UpdateRoleDescriptionResponse = (output, context) => {
    const contents = {};
    if (output[_Ro] != null) {
        contents[_Ro] = de_Role(output[_Ro], context);
    }
    return contents;
};
const de_UpdateRoleResponse = (output, context) => {
    const contents = {};
    return contents;
};
const de_UpdateSAMLProviderResponse = (output, context) => {
    const contents = {};
    if (output[_SAMLPA] != null) {
        contents[_SAMLPA] = __expectString(output[_SAMLPA]);
    }
    return contents;
};
const de_UploadServerCertificateResponse = (output, context) => {
    const contents = {};
    if (output[_SCM] != null) {
        contents[_SCM] = de_ServerCertificateMetadata(output[_SCM], context);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    return contents;
};
const de_UploadSigningCertificateResponse = (output, context) => {
    const contents = {};
    if (output[_Cert] != null) {
        contents[_Cert] = de_SigningCertificate(output[_Cert], context);
    }
    return contents;
};
const de_UploadSSHPublicKeyResponse = (output, context) => {
    const contents = {};
    if (output[_SSHPK] != null) {
        contents[_SSHPK] = de_SSHPublicKey(output[_SSHPK], context);
    }
    return contents;
};
const de_User = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
    }
    if (output[_UN] != null) {
        contents[_UN] = expectString(output[_UN]);
    }
    if (output[_UI] != null) {
        contents[_UI] = expectString(output[_UI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = expectString(output[_Ar]);
    }
    if (output[_CD] != null) {
        contents[_CD] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output[_PLU] != null) {
        contents[_PLU] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_PLU]));
    }
    if (output[_PB] != null) {
        contents[_PB] = de_AttachedPermissionsBoundary(output[_PB], context);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(getArrayIfSingleItem(output[_T][_me]), context);
    }
    return contents;
};
const de_UserDetail = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_UI] != null) {
        contents[_UI] = __expectString(output[_UI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output.UserPolicyList === "") {
        contents[_UPL] = [];
    }
    else if (output[_UPL] != null && output[_UPL][_me] != null) {
        contents[_UPL] = de_policyDetailListType(__getArrayIfSingleItem(output[_UPL][_me]), context);
    }
    if (output.GroupList === "") {
        contents[_GL] = [];
    }
    else if (output[_GL] != null && output[_GL][_me] != null) {
        contents[_GL] = de_groupNameListType(__getArrayIfSingleItem(output[_GL][_me]), context);
    }
    if (output.AttachedManagedPolicies === "") {
        contents[_AMP] = [];
    }
    else if (output[_AMP] != null && output[_AMP][_me] != null) {
        contents[_AMP] = de_attachedPoliciesListType(__getArrayIfSingleItem(output[_AMP][_me]), context);
    }
    if (output[_PB] != null) {
        contents[_PB] = de_AttachedPermissionsBoundary(output[_PB], context);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    return contents;
};
const de_userDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UserDetail(entry, context);
    });
};
const de_userListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_User(entry, context);
    });
};
const de_VirtualMFADevice = (output, context) => {
    const contents = {};
    if (output[_SNe] != null) {
        contents[_SNe] = __expectString(output[_SNe]);
    }
    if (output[_BSS] != null) {
        contents[_BSS] = context.base64Decoder(output[_BSS]);
    }
    if (output[_QRCPNG] != null) {
        contents[_QRCPNG] = context.base64Decoder(output[_QRCPNG]);
    }
    if (output[_Us] != null) {
        contents[_Us] = de_User(output[_Us], context);
    }
    if (output[_EDn] != null) {
        contents[_EDn] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_EDn]));
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_tagListType(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    return contents;
};
const de_virtualMFADeviceListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VirtualMFADevice(entry, context);
    });
};
const Aws_query_deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const Aws_query_throwDefaultError = withBaseException(IAMServiceException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new httpRequest_HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const _ = "2010-05-08";
const _A = "Action";
const _AA = "AccountAlias";
const _AAc = "AccountAliases";
const _ABO = "AllowedByOrganizations";
const _ABPB = "AllowedByPermissionsBoundary";
const _AC = "AuthenticationCode1";
const _ACIDTOIDCP = "AddClientIDToOpenIDConnectProvider";
const _ACt = "AttachmentCount";
const _ACu = "AuthenticationCode2";
const _AD = "AccessDetails";
const _AGP = "AttachGroupPolicy";
const _AK = "AccessKey";
const _AKI = "AccessKeyId";
const _AKLU = "AccessKeyLastUsed";
const _AKM = "AccessKeyMetadata";
const _AMP = "AttachedManagedPolicies";
const _AN = "ActionNames";
const _ANc = "ActionName";
const _AP = "AttachedPolicies";
const _ARP = "AttachRolePolicy";
const _ARPD = "AssumeRolePolicyDocument";
const _ARTIP = "AddRoleToInstanceProfile";
const _AS = "AssignmentStatus";
const _AUP = "AttachUserPolicy";
const _AUTCP = "AllowUsersToChangePassword";
const _AUTG = "AddUserToGroup";
const _AWSSN = "AWSServiceName";
const _Ar = "Arn";
const _BSS = "Base32StringSeed";
const _C = "Code";
const _CA = "CallerArn";
const _CAA = "CreateAccountAlias";
const _CAK = "CreateAccessKey";
const _CB = "CertificateBody";
const _CC = "CertificateChain";
const _CD = "CreateDate";
const _CE = "ContextEntries";
const _CG = "CreateGroup";
const _CI = "CertificateId";
const _CID = "ClientID";
const _CIDL = "ClientIDList";
const _CIP = "CreateInstanceProfile";
const _CKN = "ContextKeyName";
const _CKNo = "ContextKeyNames";
const _CKT = "ContextKeyType";
const _CKV = "ContextKeyValues";
const _CLP = "CreateLoginProfile";
const _COIDCP = "CreateOpenIDConnectProvider";
const _CP = "ChangePassword";
const _CPV = "CreatePolicyVersion";
const _CPr = "CreatePolicy";
const _CR = "CreateRole";
const _CS = "CustomSuffix";
const _CSAMLP = "CreateSAMLProvider";
const _CSLR = "CreateServiceLinkedRole";
const _CSSC = "CreateServiceSpecificCredential";
const _CU = "CreateUser";
const _CVMFAD = "CreateVirtualMFADevice";
const _Ce = "Certifications";
const _Cer = "Certificates";
const _Cert = "Certificate";
const _Co = "Content";
const _Col = "Column";
const _D = "Description";
const _DAA = "DeleteAccountAlias";
const _DAK = "DeleteAccessKey";
const _DAPP = "DeleteAccountPasswordPolicy";
const _DG = "DeleteGroup";
const _DGP = "DeleteGroupPolicy";
const _DGPe = "DetachGroupPolicy";
const _DIP = "DeleteInstanceProfile";
const _DLP = "DeleteLoginProfile";
const _DMFAD = "DeactivateMFADevice";
const _DOIDCP = "DeleteOpenIDConnectProvider";
const _DP = "DeletePolicy";
const _DPV = "DeletePolicyVersion";
const _DR = "DeleteRole";
const _DRP = "DeleteRolePolicy";
const _DRPB = "DeleteRolePermissionsBoundary";
const _DRPe = "DetachRolePolicy";
const _DSAMLP = "DeleteSAMLProvider";
const _DSC = "DeleteServerCertificate";
const _DSCe = "DeleteSigningCertificate";
const _DSLR = "DeleteServiceLinkedRole";
const _DSSC = "DeleteServiceSpecificCredential";
const _DSSHPK = "DeleteSSHPublicKey";
const _DTI = "DeletionTaskId";
const _DU = "DeleteUser";
const _DUP = "DeleteUserPolicy";
const _DUPB = "DeleteUserPermissionsBoundary";
const _DUPe = "DetachUserPolicy";
const _DVI = "DefaultVersionId";
const _DVMFAD = "DeleteVirtualMFADevice";
const _Do = "Document";
const _E = "Encoding";
const _EAN = "EvalActionName";
const _ED = "EvalDecision";
const _EDD = "EvalDecisionDetails";
const _EDL = "EntityDetailsList";
const _EDn = "EnableDate";
const _EDr = "ErrorDetails";
const _EF = "EntityFilter";
const _EI = "EntityInfo";
const _EMFAD = "EnableMFADevice";
const _EN = "EntityName";
const _EP = "EntityPath";
const _EPn = "EndPosition";
const _EPx = "ExpirePasswords";
const _ER = "EvaluationResults";
const _ERD = "EvalResourceDecision";
const _ERN = "EvalResourceName";
const _ET = "EntityType";
const _Er = "Error";
const _Ex = "Expiration";
const _F = "Filter";
const _Fi = "Fingerprint";
const _G = "Granularity";
const _GAAD = "GetAccountAuthorizationDetails";
const _GAKLU = "GetAccessKeyLastUsed";
const _GAPP = "GetAccountPasswordPolicy";
const _GAS = "GetAccountSummary";
const _GCKFCP = "GetContextKeysForCustomPolicy";
const _GCKFPP = "GetContextKeysForPrincipalPolicy";
const _GCR = "GenerateCredentialReport";
const _GCRe = "GetCredentialReport";
const _GDL = "GroupDetailList";
const _GETV = "GlobalEndpointTokenVersion";
const _GG = "GetGroup";
const _GGP = "GetGroupPolicy";
const _GI = "GroupId";
const _GIP = "GetInstanceProfile";
const _GL = "GroupList";
const _GLP = "GetLoginProfile";
const _GMFAD = "GetMFADevice";
const _GN = "GroupName";
const _GOAR = "GenerateOrganizationsAccessReport";
const _GOARe = "GetOrganizationsAccessReport";
const _GOIDCP = "GetOpenIDConnectProvider";
const _GP = "GetPolicy";
const _GPL = "GroupPolicyList";
const _GPV = "GetPolicyVersion";
const _GR = "GetRole";
const _GRP = "GetRolePolicy";
const _GSAMLP = "GetSAMLProvider";
const _GSC = "GetServerCertificate";
const _GSLAD = "GenerateServiceLastAccessedDetails";
const _GSLADWE = "GetServiceLastAccessedDetailsWithEntities";
const _GSLADe = "GetServiceLastAccessedDetails";
const _GSLRDS = "GetServiceLinkedRoleDeletionStatus";
const _GSSHPK = "GetSSHPublicKey";
const _GT = "GeneratedTime";
const _GU = "GetUser";
const _GUP = "GetUserPolicy";
const _Gr = "Group";
const _Gro = "Groups";
const _HE = "HardExpiry";
const _I = "Id";
const _IA = "IsAttachable";
const _IDV = "IsDefaultVersion";
const _IP = "InstanceProfile";
const _IPI = "InstanceProfileId";
const _IPL = "InstanceProfileList";
const _IPN = "InstanceProfileName";
const _IPn = "InstanceProfiles";
const _IT = "IsTruncated";
const _JCD = "JobCreationDate";
const _JCDo = "JobCompletionDate";
const _JI = "JobId";
const _JS = "JobStatus";
const _JT = "JobType";
const _K = "Key";
const _L = "Line";
const _LA = "LastAuthenticated";
const _LAA = "ListAccountAliases";
const _LAE = "LastAuthenticatedEntity";
const _LAEa = "LastAccessedEntity";
const _LAGP = "ListAttachedGroupPolicies";
const _LAK = "ListAccessKeys";
const _LAR = "LastAuthenticatedRegion";
const _LARP = "ListAttachedRolePolicies";
const _LARa = "LastAccessedRegion";
const _LAT = "LastAuthenticatedTime";
const _LATa = "LastAccessedTime";
const _LAUP = "ListAttachedUserPolicies";
const _LEFP = "ListEntitiesForPolicy";
const _LG = "ListGroups";
const _LGFU = "ListGroupsForUser";
const _LGP = "ListGroupPolicies";
const _LIP = "ListInstanceProfiles";
const _LIPFR = "ListInstanceProfilesForRole";
const _LIPT = "ListInstanceProfileTags";
const _LMFAD = "ListMFADevices";
const _LMFADT = "ListMFADeviceTags";
const _LOIDCP = "ListOpenIDConnectProviders";
const _LOIDCPT = "ListOpenIDConnectProviderTags";
const _LP = "ListPolicies";
const _LPGSA = "ListPoliciesGrantingServiceAccess";
const _LPT = "ListPolicyTags";
const _LPV = "ListPolicyVersions";
const _LPo = "LoginProfile";
const _LR = "ListRoles";
const _LRP = "ListRolePolicies";
const _LRT = "ListRoleTags";
const _LSAMLP = "ListSAMLProviders";
const _LSAMLPT = "ListSAMLProviderTags";
const _LSC = "ListServerCertificates";
const _LSCT = "ListServerCertificateTags";
const _LSCi = "ListSigningCertificates";
const _LSSC = "ListServiceSpecificCredentials";
const _LSSHPK = "ListSSHPublicKeys";
const _LU = "ListUsers";
const _LUD = "LastUsedDate";
const _LUP = "ListUserPolicies";
const _LUT = "ListUserTags";
const _LVMFAD = "ListVirtualMFADevices";
const _M = "Marker";
const _MCV = "MissingContextValues";
const _MFAD = "MFADevices";
const _MI = "MaxItems";
const _MPA = "MaxPasswordAge";
const _MPL = "MinimumPasswordLength";
const _MS = "MatchedStatements";
const _MSD = "MaxSessionDuration";
const _Me = "Message";
const _N = "Name";
const _NGN = "NewGroupName";
const _NOSA = "NumberOfServicesAccessible";
const _NOSNA = "NumberOfServicesNotAccessed";
const _NP = "NewPassword";
const _NPe = "NewPath";
const _NSCN = "NewServerCertificateName";
const _NUN = "NewUserName";
const _OA = "OnlyAttached";
const _ODD = "OrganizationsDecisionDetail";
const _OIDCPA = "OpenIDConnectProviderArn";
const _OIDCPL = "OpenIDConnectProviderList";
const _OP = "OldPassword";
const _OPI = "OrganizationsPolicyId";
const _P = "Path";
const _PA = "PolicyArn";
const _PB = "PermissionsBoundary";
const _PBA = "PermissionsBoundaryArn";
const _PBDD = "PermissionsBoundaryDecisionDetail";
const _PBPIL = "PermissionsBoundaryPolicyInputList";
const _PBT = "PermissionsBoundaryType";
const _PBUC = "PermissionsBoundaryUsageCount";
const _PD = "PolicyDocument";
const _PG = "PolicyGroups";
const _PGP = "PutGroupPolicy";
const _PGSA = "PoliciesGrantingServiceAccess";
const _PI = "PolicyId";
const _PIL = "PolicyInputList";
const _PK = "PrivateKey";
const _PLU = "PasswordLastUsed";
const _PN = "PolicyName";
const _PNo = "PolicyNames";
const _PP = "PathPrefix";
const _PPa = "PasswordPolicy";
const _PR = "PolicyRoles";
const _PRP = "PutRolePolicy";
const _PRPB = "PutRolePermissionsBoundary";
const _PRPa = "PasswordReusePrevention";
const _PRR = "PasswordResetRequired";
const _PSA = "PolicySourceArn";
const _PT = "PolicyType";
const _PU = "PolicyUsers";
const _PUF = "PolicyUsageFilter";
const _PUP = "PutUserPolicy";
const _PUPB = "PutUserPermissionsBoundary";
const _PV = "PolicyVersion";
const _PVL = "PolicyVersionList";
const _Pa = "Password";
const _Po = "Policy";
const _Pol = "Policies";
const _QRCPNG = "QRCodePNG";
const _R = "Region";
const _RA = "ResourceArns";
const _RCIDFOIDCP = "RemoveClientIDFromOpenIDConnectProvider";
const _RDL = "RoleDetailList";
const _RF = "ReportFormat";
const _RHO = "ResourceHandlingOption";
const _RI = "RoleId";
const _RLC = "RequireLowercaseCharacters";
const _RLU = "RoleLastUsed";
const _RMFAD = "ResyncMFADevice";
const _RN = "RoleName";
const _RNe = "RequireNumbers";
const _RO = "ResourceOwner";
const _RP = "ResourcePolicy";
const _RPL = "RolePolicyList";
const _RRFIP = "RemoveRoleFromInstanceProfile";
const _RS = "RequireSymbols";
const _RSR = "ResourceSpecificResults";
const _RSSC = "ResetServiceSpecificCredential";
const _RUC = "RequireUppercaseCharacters";
const _RUFG = "RemoveUserFromGroup";
const _RUL = "RoleUsageList";
const _Re = "Reason";
const _Res = "Resources";
const _Ro = "Role";
const _Rol = "Roles";
const _S = "Scope";
const _SAD = "SetAsDefault";
const _SAK = "SecretAccessKey";
const _SAMLMD = "SAMLMetadataDocument";
const _SAMLPA = "SAMLProviderArn";
const _SAMLPL = "SAMLProviderList";
const _SC = "ServerCertificate";
const _SCI = "ServerCertificateId";
const _SCM = "ServerCertificateMetadata";
const _SCML = "ServerCertificateMetadataList";
const _SCN = "ServerCertificateName";
const _SCP = "SimulateCustomPolicy";
const _SDPV = "SetDefaultPolicyVersion";
const _SK = "SortKey";
const _SLA = "ServicesLastAccessed";
const _SM = "SummaryMap";
const _SN = "ServiceName";
const _SNe = "SerialNumber";
const _SNer = "ServiceNamespace";
const _SNerv = "ServiceNamespaces";
const _SP = "ServicePassword";
const _SPI = "SourcePolicyId";
const _SPP = "SimulatePrincipalPolicy";
const _SPT = "SourcePolicyType";
const _SPt = "StartPosition";
const _SSC = "ServiceSpecificCredential";
const _SSCI = "ServiceSpecificCredentialId";
const _SSCe = "ServiceSpecificCredentials";
const _SSHPK = "SSHPublicKey";
const _SSHPKB = "SSHPublicKeyBody";
const _SSHPKI = "SSHPublicKeyId";
const _SSHPKu = "SSHPublicKeys";
const _SSTSP = "SetSecurityTokenServicePreferences";
const _SUN = "ServiceUserName";
const _St = "Status";
const _Sta = "State";
const _T = "Tags";
const _TAE = "TotalAuthenticatedEntities";
const _TALA = "TrackedActionsLastAccessed";
const _TIP = "TagInstanceProfile";
const _TK = "TagKeys";
const _TL = "ThumbprintList";
const _TMFAD = "TagMFADevice";
const _TOIDCP = "TagOpenIDConnectProvider";
const _TP = "TagPolicy";
const _TR = "TagRole";
const _TSAMLP = "TagSAMLProvider";
const _TSC = "TagServerCertificate";
const _TU = "TagUser";
const _Ty = "Type";
const _U = "Url";
const _UAK = "UpdateAccessKey";
const _UAPP = "UpdateAccountPasswordPolicy";
const _UARP = "UpdateAssumeRolePolicy";
const _UD = "UpdateDate";
const _UDL = "UserDetailList";
const _UDp = "UploadDate";
const _UG = "UpdateGroup";
const _UI = "UserId";
const _UIP = "UntagInstanceProfile";
const _ULP = "UpdateLoginProfile";
const _UMFAD = "UntagMFADevice";
const _UN = "UserName";
const _UOIDCP = "UntagOpenIDConnectProvider";
const _UOIDCPT = "UpdateOpenIDConnectProviderThumbprint";
const _UP = "UntagPolicy";
const _UPL = "UserPolicyList";
const _UR = "UntagRole";
const _URD = "UpdateRoleDescription";
const _URp = "UpdateRole";
const _USAMLP = "UntagSAMLProvider";
const _USAMLPp = "UpdateSAMLProvider";
const _USC = "UntagServerCertificate";
const _USCp = "UpdateServerCertificate";
const _USCpd = "UpdateSigningCertificate";
const _USCpl = "UploadServerCertificate";
const _USCplo = "UploadSigningCertificate";
const _USSC = "UpdateServiceSpecificCredential";
const _USSHPK = "UpdateSSHPublicKey";
const _USSHPKp = "UploadSSHPublicKey";
const _UU = "UntagUser";
const _UUp = "UpdateUser";
const _Us = "User";
const _Use = "Users";
const _V = "Version";
const _VI = "VersionId";
const _VMFAD = "VirtualMFADevice";
const _VMFADN = "VirtualMFADeviceName";
const _VMFADi = "VirtualMFADevices";
const _VU = "ValidUntil";
const _Va = "Value";
const _Ve = "Versions";
const _e = "entry";
const _m = "message";
const _me = "member";
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => extendedEncodeURIComponent(key) + "=" + extendedEncodeURIComponent(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/commands/GetUserCommand.js






class GetUserCommand extends Command
    .classBuilder()
    .ep({
    ...commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSIdentityManagementV20100508", "GetUser", {})
    .n("IAMClient", "GetUserCommand")
    .f(void 0, void 0)
    .ser(se_GetUserCommand)
    .de(de_GetUserCommand)
    .build() {
}

;// CONCATENATED MODULE: ./src/core/aws/account/get-info.ts




const getUser = (iamClient, request) => Function_pipe(new GetUserCommand({}), tryAwsServiceCall({
    service: iamClient,
    request: request,
    try: (service, command, signal) => service.send(command, { abortSignal: signal }),
    expect: (output) => output.User !== undefined
}));
const getAccount = (stsClient, request) => Function_pipe(new GetCallerIdentityCommand({}), tryAwsServiceCall({
    service: stsClient,
    request: request,
    try: (service, command, signal) => service.send(command, { abortSignal: signal }),
    expect: (output) => output.Account !== undefined && output.UserId !== undefined
}));
const getRegion = (stsClient, request) => Function_pipe(Effect_tryPromise({
    try: () => stsClient.get(request).config.region(),
    catch: () => ({
        _tag: 'AwsServiceError',
        service: stsClient.name,
        message: 'Failed to get region from STS Client'
    })
}), Effect_filterOrFail((output) => output !== undefined, () => ({
    _tag: 'AwsUnExpectedResponseError',
    service: stsClient.name,
    message: 'Region output is null from STS Client',
    response: undefined
})));
const getAwsAccountInfo = (stsClient, iamClient) => (request) => Function_pipe(Effect_all([getAccount(stsClient, request), getUser(iamClient, request), getRegion(stsClient, request)]), Effect_map(([accountOutput, userOutput, region]) => ({
    accountId: accountOutput.Account,
    userId: accountOutput.UserId,
    userName: userOutput.User?.UserName,
    profile: request.profile,
    region: region
})));

// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/STSClient.js + 8 modules
var STSClient = __webpack_require__(8658);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/credential-provider-node/dist-es/index.js + 33 modules
var credential_provider_node_dist_es = __webpack_require__(2528);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-host-header/dist-es/index.js + 14 modules
var middleware_host_header_dist_es = __webpack_require__(9813);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-logger/dist-es/index.js + 1 modules
var middleware_logger_dist_es = __webpack_require__(9359);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js + 14 modules
var middleware_recursion_detection_dist_es = __webpack_require__(2163);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js + 17 modules
var middleware_user_agent_dist_es = __webpack_require__(4725);
// EXTERNAL MODULE: ./node_modules/@smithy/config-resolver/dist-es/index.js + 26 modules
var config_resolver_dist_es = __webpack_require__(7373);
// EXTERNAL MODULE: ./node_modules/@smithy/core/dist-es/index.js + 110 modules
var core_dist_es = __webpack_require__(2073);
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-content-length/dist-es/index.js + 14 modules
var middleware_content_length_dist_es = __webpack_require__(9587);
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-retry/dist-es/index.js + 69 modules
var middleware_retry_dist_es = __webpack_require__(2467);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/auth/httpAuthSchemeProvider.js


const defaultIAMHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
        operation: getSmithyContext(context).operation,
        region: (await normalizeProvider(config.region)()) ||
            (() => {
                throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
            })(),
    };
};
function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
            name: "iam",
            region: authParameters.region,
        },
        propertiesExtractor: (config, context) => ({
            signingProperties: {
                config,
                context,
            },
        }),
    };
}
const defaultIAMHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
        default: {
            options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
        }
    }
    return options;
};
const resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = (0,dist_cjs.resolveAwsSdkSigV4Config)(config);
    return {
        ...config_0,
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/package.json
const package_namespaceObject = {"rE":"3.582.0"};
// EXTERNAL MODULE: ./node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js + 40 modules
var util_user_agent_node_dist_es = __webpack_require__(4733);
// EXTERNAL MODULE: ./node_modules/@smithy/hash-node/dist-es/index.js + 6 modules
var hash_node_dist_es = __webpack_require__(5914);
// EXTERNAL MODULE: ./node_modules/@smithy/util-body-length-node/dist-es/index.js + 1 modules
var util_body_length_node_dist_es = __webpack_require__(7809);
// EXTERNAL MODULE: ./node_modules/@smithy/util-retry/dist-es/index.js + 8 modules
var util_retry_dist_es = __webpack_require__(3323);
// EXTERNAL MODULE: ./node_modules/@aws-sdk/util-endpoints/dist-es/index.js + 9 modules
var util_endpoints_dist_es = __webpack_require__(6652);
// EXTERNAL MODULE: ./node_modules/@smithy/util-endpoints/dist-es/index.js + 45 modules
var _smithy_util_endpoints_dist_es = __webpack_require__(6275);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/endpoint/ruleset.js
const C = "required", D = "fn", ruleset_E = "argv", F = "ref", G = "authSchemes", H = "signingName", I = "signingRegion";
const a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = "stringEquals", i = "sigv4", j = "iam", k = { [C]: false, "type": "String" }, l = { [C]: true, "default": false, "type": "Boolean" }, m = { [F]: "Endpoint" }, n = { [D]: c, [ruleset_E]: [{ [F]: "UseFIPS" }, true] }, o = { [D]: c, [ruleset_E]: [{ [F]: "UseDualStack" }, true] }, p = {}, q = { [D]: h, [ruleset_E]: [{ [D]: "getAttr", [ruleset_E]: [{ [F]: g }, "name"] }, "aws"] }, r = { [D]: "getAttr", [ruleset_E]: [{ [F]: g }, "name"] }, s = { [D]: c, [ruleset_E]: [{ [F]: "UseFIPS" }, false] }, t = { [D]: c, [ruleset_E]: [{ [F]: "UseDualStack" }, false] }, u = { [G]: [{ "name": i, [H]: j, [I]: "us-east-1" }] }, v = { [D]: h, [ruleset_E]: [r, "aws-us-gov"] }, w = { "url": "https://iam.us-gov.amazonaws.com", "properties": { [G]: [{ "name": i, [H]: j, [I]: "us-gov-west-1" }] }, "headers": {} }, x = { [D]: "getAttr", [ruleset_E]: [{ [F]: g }, "supportsFIPS"] }, y = { [D]: c, [ruleset_E]: [true, { [D]: "getAttr", [ruleset_E]: [{ [F]: g }, "supportsDualStack"] }] }, z = [n], A = [o], B = [{ [F]: "Region" }];
const _data = { version: "1.0", parameters: { Region: k, UseDualStack: l, UseFIPS: l, Endpoint: k }, rules: [{ conditions: [{ [D]: b, [ruleset_E]: [m] }], rules: [{ conditions: z, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: A, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: m, properties: p, headers: p }, type: e }], type: f }, { conditions: [{ [D]: b, [ruleset_E]: B }], rules: [{ conditions: [{ [D]: "aws.partition", [ruleset_E]: B, assign: g }], rules: [{ conditions: [q, s, t], endpoint: { url: "https://iam.amazonaws.com", properties: u, headers: p }, type: e }, { conditions: [q, n, t], endpoint: { url: "https://iam-fips.amazonaws.com", properties: u, headers: p }, type: e }, { conditions: [{ [D]: h, [ruleset_E]: [r, "aws-cn"] }, s, t], endpoint: { url: "https://iam.cn-north-1.amazonaws.com.cn", properties: { [G]: [{ name: i, [H]: j, [I]: "cn-north-1" }] }, headers: p }, type: e }, { conditions: [v, s, t], endpoint: w, type: e }, { conditions: [v, n, t], endpoint: w, type: e }, { conditions: [{ [D]: h, [ruleset_E]: [r, "aws-iso"] }, s, t], endpoint: { url: "https://iam.us-iso-east-1.c2s.ic.gov", properties: { [G]: [{ name: i, [H]: j, [I]: "us-iso-east-1" }] }, headers: p }, type: e }, { conditions: [{ [D]: h, [ruleset_E]: [r, "aws-iso-b"] }, s, t], endpoint: { url: "https://iam.us-isob-east-1.sc2s.sgov.gov", properties: { [G]: [{ name: i, [H]: j, [I]: "us-isob-east-1" }] }, headers: p }, type: e }, { conditions: [{ [D]: h, [ruleset_E]: [r, "aws-iso-e"] }, s, t], endpoint: { url: "https://iam.eu-isoe-west-1.cloud.adc-e.uk", properties: { [G]: [{ name: i, [H]: j, [I]: "eu-isoe-west-1" }] }, headers: p }, type: e }, { conditions: [{ [D]: h, [ruleset_E]: [r, "aws-iso-f"] }, s, t], endpoint: { url: "https://iam.us-isof-south-1.csp.hci.ic.gov", properties: { [G]: [{ name: i, [H]: j, [I]: "us-isof-south-1" }] }, headers: p }, type: e }, { conditions: [n, o], rules: [{ conditions: [{ [D]: c, [ruleset_E]: [a, x] }, y], rules: [{ endpoint: { url: "https://iam-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: p, headers: p }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: z, rules: [{ conditions: [{ [D]: c, [ruleset_E]: [x, a] }], rules: [{ endpoint: { url: "https://iam-fips.{Region}.{PartitionResult#dnsSuffix}", properties: p, headers: p }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: A, rules: [{ conditions: [y], rules: [{ endpoint: { url: "https://iam.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: p, headers: p }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://iam.{Region}.{PartitionResult#dnsSuffix}", properties: p, headers: p }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
const ruleSet = _data;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/endpoint/endpointResolver.js



const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0,_smithy_util_endpoints_dist_es/* resolveEndpoint */.sO)(ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
_smithy_util_endpoints_dist_es/* customEndpointFunctions */.mw.aws = util_endpoints_dist_es/* awsEndpointFunctions */.UF;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/runtimeConfig.shared.js







const getRuntimeConfig = (config) => {
    return {
        apiVersion: "2010-05-08",
        base64Decoder: config?.base64Decoder ?? fromBase64_fromBase64,
        base64Encoder: config?.base64Encoder ?? toBase64_toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultIAMHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                signer: new dist_cjs.AwsSdkSigV4Signer(),
            },
        ],
        logger: config?.logger ?? new NoOpLogger(),
        serviceId: config?.serviceId ?? "IAM",
        urlParser: config?.urlParser ?? parseUrl,
        utf8Decoder: config?.utf8Decoder ?? fromUtf8_fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? toUtf8_toUtf8,
    };
};

// EXTERNAL MODULE: ./node_modules/@smithy/util-defaults-mode-node/dist-es/index.js + 40 modules
var util_defaults_mode_node_dist_es = __webpack_require__(2);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/runtimeConfig.js















const runtimeConfig_getRuntimeConfig = (config) => {
    emitWarningIfUnsupportedVersion(process.version);
    const defaultsMode = (0,util_defaults_mode_node_dist_es/* resolveDefaultsModeConfig */.I)(config);
    const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
    const clientSharedValues = getRuntimeConfig(config);
    (0,dist_cjs.emitWarningIfUnsupportedVersion)(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_dist_es/* calculateBodyLength */.n,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? credential_provider_node_dist_es/* defaultProvider */.v6,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0,util_user_agent_node_dist_es/* defaultUserAgent */.mJ)({ serviceId: clientSharedValues.serviceId, clientVersion: package_namespaceObject.rE }),
        maxAttempts: config?.maxAttempts ?? loadConfig(middleware_retry_dist_es/* NODE_MAX_ATTEMPT_CONFIG_OPTIONS */.qs),
        region: config?.region ?? loadConfig(config_resolver_dist_es/* NODE_REGION_CONFIG_OPTIONS */.GG, config_resolver_dist_es/* NODE_REGION_CONFIG_FILE_OPTIONS */.zH),
        requestHandler: NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ??
            loadConfig({
                ...middleware_retry_dist_es/* NODE_RETRY_MODE_CONFIG_OPTIONS */.kN,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_dist_es/* DEFAULT_RETRY_MODE */.L0,
            }),
        sha256: config?.sha256 ?? hash_node_dist_es/* Hash */.V.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? stream_collector_streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(config_resolver_dist_es/* NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS */.e$),
        useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(config_resolver_dist_es/* NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS */.Ko),
    };
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/region-config-resolver/dist-es/index.js + 3 modules
var region_config_resolver_dist_es = __webpack_require__(4547);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/auth/httpAuthExtensionConfiguration.js
const getHttpAuthExtensionConfiguration = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
const resolveHttpAuthRuntimeConfig = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/runtimeExtensions.js




const asPartial = (t) => t;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial((0,region_config_resolver_dist_es/* getAwsRegionExtensionConfiguration */.Rq)(runtimeConfig)),
        ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
        ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig)),
        ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0,region_config_resolver_dist_es/* resolveAwsRegionExtensionConfiguration */.$3)(extensionConfiguration),
        ...defaultExtensionConfiguration_resolveDefaultRuntimeConfig(extensionConfiguration),
        ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
        ...resolveHttpAuthRuntimeConfig(extensionConfiguration),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-iam/dist-es/IAMClient.js















class IAMClient extends Client {
    constructor(...[configuration]) {
        const _config_0 = runtimeConfig_getRuntimeConfig(configuration || {});
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = (0,config_resolver_dist_es/* resolveRegionConfig */.TD)(_config_1);
        const _config_3 = resolveEndpointConfig(_config_2);
        const _config_4 = (0,middleware_retry_dist_es/* resolveRetryConfig */.$z)(_config_3);
        const _config_5 = (0,middleware_host_header_dist_es/* resolveHostHeaderConfig */.OV)(_config_4);
        const _config_6 = (0,middleware_user_agent_dist_es/* resolveUserAgentConfig */.Dc)(_config_5);
        const _config_7 = resolveHttpAuthSchemeConfig(_config_6);
        const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0,middleware_retry_dist_es/* getRetryPlugin */.ey)(this.config));
        this.middlewareStack.use((0,middleware_content_length_dist_es/* getContentLengthPlugin */.vK)(this.config));
        this.middlewareStack.use((0,middleware_host_header_dist_es/* getHostHeaderPlugin */.TC)(this.config));
        this.middlewareStack.use((0,middleware_logger_dist_es/* getLoggerPlugin */.Y7)(this.config));
        this.middlewareStack.use((0,middleware_recursion_detection_dist_es/* getRecursionDetectionPlugin */.n4)(this.config));
        this.middlewareStack.use((0,middleware_user_agent_dist_es/* getUserAgentPlugin */.sM)(this.config));
        this.middlewareStack.use((0,core_dist_es.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
            httpAuthSchemeParametersProvider: this.getDefaultHttpAuthSchemeParametersProvider(),
            identityProviderConfigProvider: this.getIdentityProviderConfigProvider(),
        }));
        this.middlewareStack.use((0,core_dist_es.getHttpSigningPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
    getDefaultHttpAuthSchemeParametersProvider() {
        return defaultIAMHttpAuthSchemeParametersProvider;
    }
    getIdentityProviderConfigProvider() {
        return async (config) => new core_dist_es.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials,
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
const s3_resolveParamsForS3 = async (endpointParams) => {
    const bucket = endpointParams?.Bucket || "";
    if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if (s3_isArnBucketName(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
            throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
    }
    else if (!s3_isDnsCompatibleBucketName(bucket) ||
        (bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:")) ||
        bucket.toLowerCase() !== bucket ||
        bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
    }
    return endpointParams;
};
const s3_DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const s3_IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const s3_DOTS_PATTERN = /\.\./;
const s3_DOT_PATTERN = /\./;
const s3_S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
const s3_isDnsCompatibleBucketName = (bucketName) => s3_DOMAIN_PATTERN.test(bucketName) && !s3_IP_ADDRESS_PATTERN.test(bucketName) && !s3_DOTS_PATTERN.test(bucketName);
const s3_isArnBucketName = (bucketName) => {
    const [arn, partition, service, , , bucket] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = Boolean(isArn && partition && service && bucket);
    if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return isValidArn;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
const createConfigValueProvider_createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
    const configProvider = async () => {
        const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
            return configValue();
        }
        return configValue;
    };
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
        return async () => {
            const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
            const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
            return configValue;
        };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
            const endpoint = await configProvider();
            if (endpoint && typeof endpoint === "object") {
                if ("url" in endpoint) {
                    return endpoint.url.href;
                }
                if ("hostname" in endpoint) {
                    const { protocol, hostname, port, path } = endpoint;
                    return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
                }
            }
            return endpoint;
        };
    }
    return configProvider;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/property-provider/dist-es/ProviderError.js
class ProviderError_ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError_ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js

class CredentialsProviderError_CredentialsProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError_CredentialsProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js

class TokenProviderError_TokenProviderError extends ProviderError_ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError_TokenProviderError.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/property-provider/dist-es/chain.js

const chain_chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError_ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/property-provider/dist-es/fromStatic.js
const dist_es_fromStatic_fromStatic = (staticValue) => () => Promise.resolve(staticValue);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/property-provider/dist-es/memoize.js
const dist_es_memoize_memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/property-provider/dist-es/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-config-provider/dist-es/fromEnv.js

const dist_es_fromEnv_fromEnv = (envVarSelector) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new CredentialsProviderError_CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js


const getHomeDir_homeDirCache = {};
const getHomeDir_getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const dist_es_getHomeDir_getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${external_path_.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDir_getHomeDirCacheKey();
    if (!getHomeDir_homeDirCache[homeDirCacheKey])
        getHomeDir_homeDirCache[homeDirCacheKey] = (0,external_os_.homedir)();
    return getHomeDir_homeDirCache[homeDirCacheKey];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
const getProfileName_ENV_PROFILE = "AWS_PROFILE";
const getProfileName_DEFAULT_PROFILE = "default";
const getProfileName_getProfileName = (init) => init.profile || process.env[getProfileName_ENV_PROFILE] || getProfileName_DEFAULT_PROFILE;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js



const dist_es_getSSOTokenFilepath_getSSOTokenFilepath = (id) => {
    const hasher = createHash("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js


const { readFile: getSSOTokenFromFile_readFile } = external_fs_.promises;
const getSSOTokenFromFile_getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = getSSOTokenFilepath(id);
    const ssoTokenText = await getSSOTokenFromFile_readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/types/dist-es/auth/auth.js
var auth_HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(auth_HttpAuthLocation || (auth_HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuth_HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuth_HttpApiKeyAuthLocation || (HttpApiKeyAuth_HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/types/dist-es/endpoint.js
var endpoint_EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(endpoint_EndpointURLScheme || (endpoint_EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/types/dist-es/extensions/checksum.js
var extensions_checksum_AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(extensions_checksum_AlgorithmId || (extensions_checksum_AlgorithmId = {}));
const dist_es_extensions_checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => extensions_checksum_AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => extensions_checksum_AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const dist_es_extensions_checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const defaultClientConfiguration_getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const defaultClientConfiguration_resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/types/dist-es/http.js
var dist_es_http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(dist_es_http_FieldPosition || (dist_es_http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/types/dist-es/middleware.js
const middleware_SMITHY_CONTEXT_KEY = "__smithy_context";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/types/dist-es/profile.js
var dist_es_profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(dist_es_profile_IniSectionType || (dist_es_profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/types/dist-es/transfer.js
var transfer_RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(transfer_RequestHandlerProtocol || (transfer_RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js


const getConfigData_getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(dist_es_loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(dist_es_profile_IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(dist_es_loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === dist_es_profile_IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js


const getConfigFilepath_ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const dist_es_getConfigFilepath_getConfigFilepath = () => process.env[getConfigFilepath_ENV_CONFIG_PATH] || (0,external_path_.join)(dist_es_getHomeDir_getHomeDir(), ".aws", "config");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js


const getCredentialsFilepath_ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath_getCredentialsFilepath = () => process.env[getCredentialsFilepath_ENV_CREDENTIALS_PATH] || (0,external_path_.join)(dist_es_getHomeDir_getHomeDir(), ".aws", "credentials");

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js


const parseIni_prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const parseIni_profileNameBlockList = ["__proto__", "profile __proto__"];
const dist_es_parseIni_parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = parseIni_prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(dist_es_profile_IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(dist_es_loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (parseIni_profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(dist_es_loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js

const { readFile: dist_es_slurpFile_readFile } = external_fs_.promises;
const slurpFile_filePromisesHash = {};
const dist_es_slurpFile_slurpFile = (path, options) => {
    if (!slurpFile_filePromisesHash[path] || options?.ignoreCache) {
        slurpFile_filePromisesHash[path] = dist_es_slurpFile_readFile(path, "utf8");
    }
    return slurpFile_filePromisesHash[path];
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js





const loadSharedConfigFiles_swallowError = () => ({});
const dist_es_loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR = ".";
const dist_es_loadSharedConfigFiles_loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath_getCredentialsFilepath(), configFilepath = dist_es_getConfigFilepath_getConfigFilepath() } = init;
    const parsedFiles = await Promise.all([
        dist_es_slurpFile_slurpFile(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(dist_es_parseIni_parseIni)
            .then(getConfigData_getConfigData)
            .catch(loadSharedConfigFiles_swallowError),
        dist_es_slurpFile_slurpFile(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(dist_es_parseIni_parseIni)
            .catch(loadSharedConfigFiles_swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js


const dist_es_getSsoSessionData_getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js




const dist_es_loadSsoSessionData_swallowError = () => ({});
const loadSsoSessionData_loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(dist_es_loadSsoSessionData_swallowError);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js


const parseKnownFiles_parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js


const fromSharedConfigFiles_fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = getProfileName_getProfileName(init);
    const { configFile, credentialsFile } = await dist_es_loadSharedConfigFiles_loadSharedConfigFiles(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new CredentialsProviderError_CredentialsProviderError(e.message ||
            `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-config-provider/dist-es/fromStatic.js

const dist_es_fromStatic_isFunction = (func) => typeof func === "function";
const node_config_provider_dist_es_fromStatic_fromStatic = (defaultValue) => dist_es_fromStatic_isFunction(defaultValue) ? async () => await defaultValue() : dist_es_fromStatic_fromStatic(defaultValue);

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-config-provider/dist-es/configLoader.js




const configLoader_loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => dist_es_memoize_memoize(chain_chain(dist_es_fromEnv_fromEnv(environmentVariableSelector), fromSharedConfigFiles_fromSharedConfigFiles(configFileSelector, configuration), node_config_provider_dist_es_fromStatic_fromStatic(defaultValue)));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-config-provider/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointUrlConfig.js

const getEndpointUrlConfig_ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
const getEndpointUrlConfig_CONFIG_ENDPOINT_URL = "endpoint_url";
const getEndpointUrlConfig_getEndpointUrlConfig = (serviceId) => ({
    environmentVariableSelector: (env) => {
        const serviceSuffixParts = serviceId.split(" ").map((w) => w.toUpperCase());
        const serviceEndpointUrl = env[[getEndpointUrlConfig_ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
        if (serviceEndpointUrl)
            return serviceEndpointUrl;
        const endpointUrl = env[getEndpointUrlConfig_ENV_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    configFileSelector: (profile, config) => {
        if (config && profile.services) {
            const servicesSection = config[["services", profile.services].join(dist_es_loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR)];
            if (servicesSection) {
                const servicePrefixParts = serviceId.split(" ").map((w) => w.toLowerCase());
                const endpointUrl = servicesSection[[servicePrefixParts.join("_"), getEndpointUrlConfig_CONFIG_ENDPOINT_URL].join(dist_es_loadSharedConfigFiles_CONFIG_PREFIX_SEPARATOR)];
                if (endpointUrl)
                    return endpointUrl;
            }
        }
        const endpointUrl = profile[getEndpointUrlConfig_CONFIG_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    default: undefined,
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.js


const getEndpointFromConfig_getEndpointFromConfig = async (serviceId) => configLoader_loadConfig(getEndpointUrlConfig_getEndpointUrlConfig(serviceId))();

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/querystring-parser/dist-es/index.js
function dist_es_parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
        for (const pair of querystring.split("&")) {
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
                value = decodeURIComponent(value);
            }
            if (!(key in query)) {
                query[key] = value;
            }
            else if (Array.isArray(query[key])) {
                query[key].push(value);
            }
            else {
                query[key] = [query[key], value];
            }
        }
    }
    return query;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/url-parser/dist-es/index.js

const dist_es_parseUrl = (url) => {
    if (typeof url === "string") {
        return dist_es_parseUrl(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
        query = dist_es_parseQueryString(search);
    }
    return {
        hostname,
        port: port ? parseInt(port) : undefined,
        protocol,
        path: pathname,
        query,
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js

const toEndpointV1_toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
        if ("url" in endpoint) {
            return dist_es_parseUrl(endpoint.url);
        }
        return endpoint;
    }
    return dist_es_parseUrl(endpoint);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js




const getEndpointFromInstructions_getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.endpoint) {
        const endpointFromConfig = await getEndpointFromConfig_getEndpointFromConfig(clientConfig.serviceId || "");
        if (endpointFromConfig) {
            clientConfig.endpoint = () => Promise.resolve(toEndpointV1_toEndpointV1(endpointFromConfig));
        }
    }
    const endpointParams = await getEndpointFromInstructions_resolveParams(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
};
const getEndpointFromInstructions_resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
            case "staticContextParams":
                endpointParams[name] = instruction.value;
                break;
            case "contextParams":
                endpointParams[name] = commandInput[instruction.name];
                break;
            case "clientContextParams":
            case "builtInParams":
                endpointParams[name] = await createConfigValueProvider_createConfigValueProvider(instruction.name, name, clientConfig)();
                break;
            default:
                throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
    }
    if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await s3_resolveParamsForS3(endpointParams);
    }
    return endpointParams;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js

const getSmithyContext_getSmithyContext = (context) => context[middleware_SMITHY_CONTEXT_KEY] || (context[middleware_SMITHY_CONTEXT_KEY] = {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
const normalizeProvider_normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-middleware/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js


const endpointMiddleware_endpointMiddleware = ({ config, instructions, }) => {
    return (next, context) => async (args) => {
        const endpoint = await getEndpointFromInstructions_getEndpointFromInstructions(args.input, {
            getEndpointParameterInstructions() {
                return instructions;
            },
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
            context["signing_region"] = authScheme.signingRegion;
            context["signing_service"] = authScheme.signingName;
            const smithyContext = getSmithyContext_getSmithyContext(context);
            const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
            if (httpAuthOption) {
                httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
                    signing_region: authScheme.signingRegion,
                    signingRegion: authScheme.signingRegion,
                    signing_service: authScheme.signingName,
                    signingName: authScheme.signingName,
                    signingRegionSet: authScheme.signingRegionSet,
                }, authScheme.properties);
            }
        }
        return next({
            ...args,
        });
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
const deserializerMiddleware_deserializerMiddleware = (options, deserializer) => (next) => async (args) => {
    const { response } = await next(args);
    try {
        const parsed = await deserializer(response, options);
        return {
            response,
            output: parsed,
        };
    }
    catch (error) {
        Object.defineProperty(error, "$response", {
            value: response,
        });
        if (!("$metadata" in error)) {
            const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
            error.message += "\n  " + hint;
            if (typeof error.$responseBodyText !== "undefined") {
                if (error.$response) {
                    error.$response.body = error.$responseBodyText;
                }
            }
        }
        throw error;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
const serializerMiddleware_serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    const endpoint = context.endpointV2?.url && options.urlParser
        ? async () => options.urlParser(context.endpointV2.url)
        : options.endpoint;
    if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
        ...args,
        request,
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js


const serdePlugin_deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true,
};
const serdePlugin_serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true,
};
function serdePlugin_getSerdePlugin(config, serializer, deserializer) {
    return {
        applyToStack: (commandStack) => {
            commandStack.add(deserializerMiddleware_deserializerMiddleware(config, deserializer), serdePlugin_deserializerMiddlewareOption);
            commandStack.add(serializerMiddleware_serializerMiddleware(config, serializer), serdePlugin_serializerMiddlewareOption);
        },
    };
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-serde/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js


const getEndpointPlugin_endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: serdePlugin_serializerMiddlewareOption.name,
};
const getEndpointPlugin_getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(endpointMiddleware_endpointMiddleware({
            config,
            instructions,
        }), getEndpointPlugin_endpointMiddlewareOptions);
    },
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js


const resolveEndpointConfig_resolveEndpointConfig = (input) => {
    const tls = input.tls ?? true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => toEndpointV1_toEndpointV1(await normalizeProvider_normalizeProvider(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    return {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: normalizeProvider_normalizeProvider(input.useDualstackEndpoint ?? false),
        useFipsEndpoint: normalizeProvider_normalizeProvider(input.useFipsEndpoint ?? false),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-endpoint/dist-es/index.js






;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
class NoOpLogger_NoOpLogger {
    trace() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
const MiddlewareStack_getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const MiddlewareStack_getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const MiddlewareStack_constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => MiddlewareStack_stepWeights[b.step] - MiddlewareStack_stepWeights[a.step] ||
        MiddlewareStack_priorityWeights[b.priority || "normal"] - MiddlewareStack_priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = MiddlewareStack_getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of MiddlewareStack_getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of MiddlewareStack_getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of MiddlewareStack_getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${MiddlewareStack_getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = MiddlewareStack_getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${MiddlewareStack_getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${MiddlewareStack_getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${MiddlewareStack_getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = MiddlewareStack_getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${MiddlewareStack_getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${MiddlewareStack_getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${MiddlewareStack_getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo(MiddlewareStack_constructStack()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = MiddlewareStack_getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo(MiddlewareStack_constructStack());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                const step = mw.step ??
                    mw.relation +
                        " " +
                        mw.toMiddleware;
                return MiddlewareStack_getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
const MiddlewareStack_stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const MiddlewareStack_priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/middleware-stack/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/client.js

class client_Client {
    constructor(config) {
        this.middlewareStack = MiddlewareStack_constructStack();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/is-array-buffer/dist-es/index.js
const is_array_buffer_dist_es_isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-buffer-from/dist-es/index.js


const util_buffer_from_dist_es_fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!is_array_buffer_dist_es_isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return external_buffer_.Buffer.from(input, offset, length);
};
const util_buffer_from_dist_es_fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? external_buffer_.Buffer.from(input, encoding) : external_buffer_.Buffer.from(input);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-base64/dist-es/fromBase64.js

const fromBase64_BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const dist_es_fromBase64_fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!fromBase64_BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = util_buffer_from_dist_es_fromString(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js

const dist_es_fromUtf8_fromUtf8 = (input) => {
    const buf = util_buffer_from_dist_es_fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js

const toUint8Array_toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-utf8/dist-es/toUtf8.js

const dist_es_toUtf8_toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return util_buffer_from_dist_es_fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-utf8/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-base64/dist-es/toBase64.js


const dist_es_toBase64_toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
        input = dist_es_fromUtf8_fromUtf8(_input);
    }
    else {
        input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return util_buffer_from_dist_es_fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-base64/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-stream/dist-es/blob/transforms.js



function blob_transforms_transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return toBase64(payload);
    }
    return toUtf8(payload);
}
function blob_transforms_transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js

class blob_Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter extends (/* unused pure expression or super */ null && (Uint8Array)) {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return transformFromString(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, blob_Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.js

const getAwsChunkedEncodingStream_getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
const httpExtensionConfiguration_getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
    let httpHandler = runtimeConfig.httpHandler;
    return {
        setHttpHandler(handler) {
            httpHandler = handler;
        },
        httpHandler() {
            return httpHandler;
        },
        updateHttpClientConfig(key, value) {
            httpHandler.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
            return httpHandler.httpHandlerConfigs();
        },
    };
};
const httpExtensionConfiguration_resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
    return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/protocol-http/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/protocol-http/dist-es/Field.js

class Field_Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class dist_es_httpRequest_HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new dist_es_httpRequest_HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = httpRequest_cloneQuery(cloned.query);
        return cloned;
    }
}
function httpRequest_cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/protocol-http/dist-es/httpResponse.js
class dist_es_httpResponse_HttpResponse {
    constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/protocol-http/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
const escape_uri_escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, escape_uri_hexEncode);
const escape_uri_hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/querystring-builder/dist-es/index.js

function querystring_builder_dist_es_buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = escape_uri_escapeUri(key);
        if (Array.isArray(value)) {
            for (let i = 0, iLen = value.length; i < iLen; i++) {
                parts.push(`${key}=${escape_uri_escapeUri(value[i])}`);
            }
        }
        else {
            let qsEntry = key;
            if (value || typeof value === "string") {
                qsEntry += `=${escape_uri_escapeUri(value)}`;
            }
            parts.push(qsEntry);
        }
    }
    return parts.join("&");
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/constants.js
const dist_es_constants_NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/get-transformed-headers.js
const dist_es_get_transformed_headers_getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
};


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/set-connection-timeout.js
const dist_es_set_connection_timeout_setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
        return;
    }
    const timeoutId = setTimeout(() => {
        request.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
            name: "TimeoutError",
        }));
    }, timeoutInMs);
    request.on("socket", (socket) => {
        if (socket.connecting) {
            socket.on("connect", () => {
                clearTimeout(timeoutId);
            });
        }
        else {
            clearTimeout(timeoutId);
        }
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/set-socket-keep-alive.js
const dist_es_set_socket_keep_alive_setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }) => {
    if (keepAlive !== true) {
        return;
    }
    request.on("socket", (socket) => {
        socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/set-socket-timeout.js
const dist_es_set_socket_timeout_setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    request.setTimeout(timeoutInMs, () => {
        request.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/write-request-body.js

const write_request_body_MIN_WAIT_TIME = 1000;
async function dist_es_write_request_body_writeRequestBody(httpRequest, request, maxContinueTimeoutMs = write_request_body_MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(setTimeout(resolve, Math.max(write_request_body_MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", () => {
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            }),
        ]);
    }
    if (!hasError) {
        write_request_body_writeBody(httpRequest, request.body);
    }
}
function write_request_body_writeBody(httpRequest, body) {
    if (body instanceof external_stream_.Readable) {
        body.pipe(httpRequest);
        return;
    }
    if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
            httpRequest.end(body);
            return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" &&
            uint8.buffer &&
            typeof uint8.byteOffset === "number" &&
            typeof uint8.byteLength === "number") {
            httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
            return;
        }
        httpRequest.end(Buffer.from(body));
        return;
    }
    httpRequest.end();
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js










const node_http_handler_DEFAULT_REQUEST_TIMEOUT = 0;
class node_http_handler_NodeHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new node_http_handler_NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
            return socketWarningTimestamp;
        }
        const interval = 15000;
        if (Date.now() - interval < socketWarningTimestamp) {
            return socketWarningTimestamp;
        }
        if (sockets && requests) {
            for (const origin in sockets) {
                const socketsInUse = sockets[origin]?.length ?? 0;
                const requestsEnqueued = requests[origin]?.length ?? 0;
                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
                    console.warn("@smithy/node-http-handler:WARN", `socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.`, "See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html", "or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.");
                    return Date.now();
                }
            }
        }
        return socketWarningTimestamp;
    }
    constructor(options) {
        this.socketWarningTimestamp = 0;
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout ?? socketTimeout,
            httpAgent: (() => {
                if (httpAgent instanceof external_http_.Agent || typeof httpAgent?.destroy === "function") {
                    return httpAgent;
                }
                return new external_http_.Agent({ keepAlive, maxSockets, ...httpAgent });
            })(),
            httpsAgent: (() => {
                if (httpsAgent instanceof external_https_.Agent || typeof httpsAgent?.destroy === "function") {
                    return httpsAgent;
                }
                return new external_https_.Agent({ keepAlive, maxSockets, ...httpsAgent });
            })(),
        };
    }
    destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        let socketCheckTimeoutId;
        return new Promise((_resolve, _reject) => {
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                clearTimeout(socketCheckTimeoutId);
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
            socketCheckTimeoutId = setTimeout(() => {
                this.socketWarningTimestamp = node_http_handler_NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp);
            }, this.config.socketAcquisitionWarningTimeout ??
                (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000));
            const queryString = querystring_builder_dist_es_buildQueryString(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent,
                auth,
            };
            const requestFunc = isSSL ? external_https_.request : external_http_.request;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new dist_es_httpResponse_HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: dist_es_get_transformed_headers_getTransformedHeaders(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (dist_es_constants_NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            dist_es_set_connection_timeout_setConnectionTimeout(req, reject, this.config.connectionTimeout);
            dist_es_set_socket_timeout_setSocketTimeout(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                dist_es_set_socket_keep_alive_setSocketKeepAlive(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                });
            }
            writeRequestBodyPromise = dist_es_write_request_body_writeRequestBody(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
class dist_es_node_http2_connection_pool_NodeHttp2ConnectionPool {
    constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions ?? [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-manager.js


class dist_es_node_http2_connection_manager_NodeHttp2ConnectionManager {
    constructor(config) {
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/node-http2-handler.js






class node_http2_handler_NodeHttp2Handler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new node_http2_handler_NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal?.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: this.config?.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = buildQueryString(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [constants.HTTP2_HEADER_PATH]: path,
                [constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: getTransformedHeaders(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js

class stream_collector_collector_Collector extends external_stream_.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js

const node_http_handler_dist_es_stream_collector_streamCollector = (stream) => {
    if (stream_collector_isReadableStreamInstance(stream)) {
        return stream_collector_collectReadableStream(stream);
    }
    return new Promise((resolve, reject) => {
        const collector = new stream_collector_collector_Collector();
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
            resolve(bytes);
        });
    });
};
const stream_collector_isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
async function stream_collector_collectReadableStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/node-http-handler/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js



const fetch_http_handler_keepAliveSupport = {
    supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
};
class fetch_http_handler_FetchHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new fetch_http_handler_FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
        if (typeof options === "function") {
            this.configProvider = options().then((opts) => opts || {});
        }
        else {
            this.config = options ?? {};
            this.configProvider = Promise.resolve(this.config);
        }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        const requestTimeoutInMs = this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = buildQueryString(request.query || {});
        if (queryString) {
            path += `?${queryString}`;
        }
        if (request.fragment) {
            path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? undefined : request.body;
        const requestOptions = {
            body,
            headers: new Headers(request.headers),
            method: method,
        };
        if (body) {
            requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
            requestOptions.signal = abortSignal;
        }
        if (fetch_http_handler_keepAliveSupport.supported) {
            requestOptions.keepalive = keepAlive;
        }
        const fetchRequest = new Request(url, requestOptions);
        const raceOfPromises = [
            fetch(fetchRequest).then((response) => {
                const fetchHeaders = response.headers;
                const transformedHeaders = {};
                for (const pair of fetchHeaders.entries()) {
                    transformedHeaders[pair[0]] = pair[1];
                }
                const hasReadableStream = response.body != undefined;
                if (!hasReadableStream) {
                    return response.blob().then((body) => ({
                        response: new HttpResponse({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body,
                        }),
                    }));
                }
                return {
                    response: new HttpResponse({
                        headers: transformedHeaders,
                        reason: response.statusText,
                        statusCode: response.status,
                        body: response.body,
                    }),
                };
            }),
            requestTimeout(requestTimeoutInMs),
        ];
        if (abortSignal) {
            raceOfPromises.push(new Promise((resolve, reject) => {
                abortSignal.onabort = () => {
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }));
        }
        return Promise.race(raceOfPromises);
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            config[key] = value;
            return config;
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js

const fetch_http_handler_dist_es_stream_collector_streamCollector = (stream) => {
    if (typeof Blob === "function" && stream instanceof Blob) {
        return stream_collector_collectBlob(stream);
    }
    return stream_collector_collectStream(stream);
};
async function stream_collector_collectBlob(blob) {
    const base64 = await stream_collector_readToBase64(blob);
    const arrayBuffer = fromBase64(base64);
    return new Uint8Array(arrayBuffer);
}
async function stream_collector_collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}
function stream_collector_readToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (reader.readyState !== 2) {
                return reject(new Error("Reader aborted too early"));
            }
            const result = (reader.result ?? "");
            const commaIndex = result.indexOf(",");
            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
            resolve(result.substring(dataOffset));
        };
        reader.onabort = () => reject(new Error("Read aborted"));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
    });
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/fetch-http-handler/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-hex-encoding/dist-es/index.js
const dist_es_SHORT_TO_HEX = {};
const dist_es_HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    dist_es_SHORT_TO_HEX[i] = encodedByte;
    dist_es_HEX_TO_SHORT[encodedByte] = i;
}
function dist_es_fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in dist_es_HEX_TO_SHORT) {
            out[i / 2] = dist_es_HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function util_hex_encoding_dist_es_toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += dist_es_SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js




const sdk_stream_mixin_browser_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdk_stream_mixin_browser_sdkStreamMixin = (stream) => {
    if (!sdk_stream_mixin_browser_isBlobInstance(stream) && !dist_es_sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(sdk_stream_mixin_browser_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
            throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" +
                "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
    };
    return Object.assign(stream, {
        transformToByteArray: transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === "base64") {
                return toBase64(buf);
            }
            else if (encoding === "hex") {
                return toHex(buf);
            }
            else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
                return toUtf8(buf);
            }
            else if (typeof TextDecoder === "function") {
                return new TextDecoder(encoding).decode(buf);
            }
            else {
                throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(sdk_stream_mixin_browser_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            transformed = true;
            if (sdk_stream_mixin_browser_isBlobInstance(stream)) {
                return blobToWebStream(stream);
            }
            else if (dist_es_sdk_stream_mixin_browser_isReadableStreamInstance(stream)) {
                return stream;
            }
            else {
                throw new Error(`Cannot transform payload to web stream, got ${stream}`);
            }
        },
    });
};
const sdk_stream_mixin_browser_isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
const dist_es_sdk_stream_mixin_browser_isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js





const dist_es_sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const dist_es_sdk_stream_mixin_sdkStreamMixin = (stream) => {
    if (!(stream instanceof Readable)) {
        try {
            return sdkStreamMixinReadableStream(stream);
        }
        catch (e) {
            const name = stream?.__proto__?.constructor?.name || stream;
            throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(dist_es_sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(dist_es_sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return Readable.toWeb(stream);
        },
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/util-stream/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js

const dist_es_collect_stream_body_collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/command.js


class command_Command {
    constructor() {
        this.middlewareStack = MiddlewareStack_constructStack();
    }
    static classBuilder() {
        return new command_ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [middleware_SMITHY_CONTEXT_KEY]: {
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
class command_ClassBuilder {
    constructor() {
        this._init = () => { };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
    }
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends command_Command {
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(...[input]) {
                super();
                this.serialize = closure._serializer;
                this.deserialize = closure._deserializer;
                this.input = input ?? {};
                closure._init(this);
            }
            resolveMiddleware(stack, configuration, options) {
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/parse-utils.js
const parse_utils_parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
const parse_utils_expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            parse_utils_logger.warn(parse_utils_stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            parse_utils_logger.warn(parse_utils_stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
const parse_utils_expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                parse_utils_logger.warn(parse_utils_stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
const parse_utils_MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const parse_utils_expectFloat32 = (value) => {
    const expected = parse_utils_expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > parse_utils_MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
const parse_utils_expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
const parse_utils_expectInt = (/* unused pure expression or super */ null && (parse_utils_expectLong));
const parse_utils_expectInt32 = (value) => parse_utils_expectSizedInt(value, 32);
const parse_utils_expectShort = (value) => parse_utils_expectSizedInt(value, 16);
const parse_utils_expectByte = (value) => parse_utils_expectSizedInt(value, 8);
const parse_utils_expectSizedInt = (value, size) => {
    const expected = parse_utils_expectLong(value);
    if (expected !== undefined && parse_utils_castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const parse_utils_castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const parse_utils_expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
const parse_utils_expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
const parse_utils_expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        parse_utils_logger.warn(parse_utils_stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
const parse_utils_expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = parse_utils_expectObject(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
const dist_es_parse_utils_strictParseDouble = (value) => {
    if (typeof value == "string") {
        return parse_utils_expectNumber(parse_utils_parseNumber(value));
    }
    return parse_utils_expectNumber(value);
};
const parse_utils_strictParseFloat = (/* unused pure expression or super */ null && (dist_es_parse_utils_strictParseDouble));
const dist_es_parse_utils_strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parse_utils_expectFloat32(parse_utils_parseNumber(value));
    }
    return parse_utils_expectFloat32(value);
};
const parse_utils_NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parse_utils_parseNumber = (value) => {
    const matches = value.match(parse_utils_NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const parse_utils_limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parse_utils_parseFloatString(value);
    }
    return parse_utils_expectNumber(value);
};
const parse_utils_handleFloat = (/* unused pure expression or super */ null && (parse_utils_limitedParseDouble));
const parse_utils_limitedParseFloat = (/* unused pure expression or super */ null && (parse_utils_limitedParseDouble));
const parse_utils_limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parse_utils_parseFloatString(value);
    }
    return parse_utils_expectFloat32(value);
};
const parse_utils_parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const parse_utils_strictParseLong = (value) => {
    if (typeof value === "string") {
        return parse_utils_expectLong(parse_utils_parseNumber(value));
    }
    return parse_utils_expectLong(value);
};
const parse_utils_strictParseInt = (/* unused pure expression or super */ null && (parse_utils_strictParseLong));
const parse_utils_strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return parse_utils_expectInt32(parse_utils_parseNumber(value));
    }
    return parse_utils_expectInt32(value);
};
const dist_es_parse_utils_strictParseShort = (value) => {
    if (typeof value === "string") {
        return parse_utils_expectShort(parse_utils_parseNumber(value));
    }
    return parse_utils_expectShort(value);
};
const dist_es_parse_utils_strictParseByte = (value) => {
    if (typeof value === "string") {
        return parse_utils_expectByte(parse_utils_parseNumber(value));
    }
    return parse_utils_expectByte(value);
};
const parse_utils_stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
const parse_utils_logger = {
    warn: console.warn,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/date-utils.js

const date_utils_DAYS = (/* unused pure expression or super */ null && (["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]));
const date_utils_MONTHS = (/* unused pure expression or super */ null && (["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]));
function date_utils_dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${date_utils_DAYS[dayOfWeek]}, ${dayOfMonthString} ${date_utils_MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
const date_utils_RFC3339 = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/)));
const date_utils_parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = date_utils_RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(date_utils_stripLeadingZeroes(yearStr));
    const month = date_utils_parseDateValue(monthStr, "month", 1, 12);
    const day = date_utils_parseDateValue(dayStr, "day", 1, 31);
    return date_utils_buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
const date_utils_RFC3339_WITH_OFFSET = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/)));
const date_utils_parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = date_utils_RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(date_utils_stripLeadingZeroes(yearStr));
    const month = date_utils_parseDateValue(monthStr, "month", 1, 12);
    const day = date_utils_parseDateValue(dayStr, "day", 1, 31);
    const date = date_utils_buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - date_utils_parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
const date_utils_IMF_FIXDATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const date_utils_RFC_850_DATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const date_utils_ASC_TIME = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/)));
const date_utils_parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = date_utils_IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return date_utils_buildDate(strictParseShort(date_utils_stripLeadingZeroes(yearStr)), date_utils_parseMonthByShortName(monthStr), date_utils_parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = date_utils_RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return date_utils_adjustRfc850Year(date_utils_buildDate(date_utils_parseTwoDigitYear(yearStr), date_utils_parseMonthByShortName(monthStr), date_utils_parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = date_utils_ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return date_utils_buildDate(strictParseShort(date_utils_stripLeadingZeroes(yearStr)), date_utils_parseMonthByShortName(monthStr), date_utils_parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
const date_utils_parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = dist_es_parse_utils_strictParseDouble(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
const date_utils_buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    date_utils_validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, date_utils_parseDateValue(time.hours, "hour", 0, 23), date_utils_parseDateValue(time.minutes, "minute", 0, 59), date_utils_parseDateValue(time.seconds, "seconds", 0, 60), date_utils_parseMilliseconds(time.fractionalMilliseconds)));
};
const date_utils_parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(date_utils_stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const date_utils_FIFTY_YEARS_IN_MILLIS = (/* unused pure expression or super */ null && (50 * 365 * 24 * 60 * 60 * 1000));
const date_utils_adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > date_utils_FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const date_utils_parseMonthByShortName = (value) => {
    const monthIdx = date_utils_MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const date_utils_DAYS_IN_MONTH = (/* unused pure expression or super */ null && ([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]));
const date_utils_validateDayOfMonth = (year, month, day) => {
    let maxDays = date_utils_DAYS_IN_MONTH[month];
    if (month === 1 && date_utils_isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${date_utils_MONTHS[month]} in ${year}: ${day}`);
    }
};
const date_utils_isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const date_utils_parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(date_utils_stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const date_utils_parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
};
const date_utils_parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const date_utils_stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/exceptions.js
class exceptions_ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, exceptions_ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
const dist_es_exceptions_decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/default-error-handler.js

const default_error_handler_throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = default_error_handler_deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw dist_es_exceptions_decorateServiceException(response, parsedBody);
};
const default_error_handler_withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        default_error_handler_throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
const default_error_handler_deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
const defaults_mode_loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
        case "standard":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "in-region":
            return {
                retryMode: "standard",
                connectionTimeout: 1100,
            };
        case "cross-region":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "mobile":
            return {
                retryMode: "standard",
                connectionTimeout: 30000,
            };
        default:
            return {};
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
let emitWarningIfUnsupportedVersion_warningEmitted = false;
const emitWarningIfUnsupportedVersion_emitWarningIfUnsupportedVersion = (version) => {
    if (version && !emitWarningIfUnsupportedVersion_warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
        emitWarningIfUnsupportedVersion_warningEmitted = true;
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js


const smithy_client_dist_es_extensions_checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in extensions_checksum_AlgorithmId) {
        const algorithmId = extensions_checksum_AlgorithmId[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const smithy_client_dist_es_extensions_checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
const extensions_retry_getRetryConfiguration = (runtimeConfig) => {
    let _retryStrategy = runtimeConfig.retryStrategy;
    return {
        setRetryStrategy(retryStrategy) {
            _retryStrategy = retryStrategy;
        },
        retryStrategy() {
            return _retryStrategy;
        },
    };
};
const extensions_retry_resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js


const defaultExtensionConfiguration_getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
        ...smithy_client_dist_es_extensions_checksum_getChecksumConfiguration(runtimeConfig),
        ...extensions_retry_getRetryConfiguration(runtimeConfig),
    };
};
const extensions_defaultExtensionConfiguration_getDefaultClientConfiguration = (/* unused pure expression or super */ null && (defaultExtensionConfiguration_getDefaultExtensionConfiguration));
const extensions_defaultExtensionConfiguration_resolveDefaultRuntimeConfig = (config) => {
    return {
        ...smithy_client_dist_es_extensions_checksum_resolveChecksumRuntimeConfig(config),
        ...extensions_retry_resolveRetryRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/lazy-json.js
const lazy_json_StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
lazy_json_StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: lazy_json_StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(lazy_json_StringWrapper, String);
class lazy_json_LazyJsonString extends (/* unused pure expression or super */ null && (lazy_json_StringWrapper)) {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof lazy_json_LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new lazy_json_LazyJsonString(object);
        }
        return new lazy_json_LazyJsonString(JSON.stringify(object));
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/object-mapping.js
function object_mapping_map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
        target = {};
        instructions = arg0;
    }
    else {
        target = arg0;
        if (typeof arg1 === "function") {
            filter = arg1;
            instructions = arg2;
            return mapWithFilter(target, filter, instructions);
        }
        else {
            instructions = arg1;
        }
    }
    for (const key of Object.keys(instructions)) {
        if (!Array.isArray(instructions[key])) {
            target[key] = instructions[key];
            continue;
        }
        applyInstruction(target, null, instructions, key);
    }
    return target;
}
const convertMap = (target) => {
    const output = {};
    for (const [k, v] of Object.entries(target || {})) {
        output[k] = [, v];
    }
    return output;
};
const object_mapping_take = (source, instructions) => {
    const out = {};
    for (const key in instructions) {
        applyInstruction(out, source, instructions, key);
    }
    return out;
};
const mapWithFilter = (target, filter, instructions) => {
    return object_mapping_map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
            _instructions[key] = value;
        }
        else {
            if (typeof value === "function") {
                _instructions[key] = [filter, value()];
            }
            else {
                _instructions[key] = [filter, value];
            }
        }
        return _instructions;
    }, {}));
};
const applyInstruction = (target, source, instructions, targetKey) => {
    if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
            instruction = [, instruction];
        }
        const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if ((typeof filter === "function" && filter(source[sourceKey])) || (typeof filter !== "function" && !!filter)) {
            target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter === undefined && (_value = value()) != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed) {
            target[targetKey] = _value;
        }
        else if (customFilterPassed) {
            target[targetKey] = value();
        }
    }
    else {
        const defaultFilterPassed = filter === undefined && value != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed || customFilterPassed) {
            target[targetKey] = value;
        }
    }
};
const nonNullish = (_) => _ != null;
const pass = (_) => _;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/serde-json.js
const serde_json_json = (obj) => {
    if (obj == null) {
        return {};
    }
    if (Array.isArray(obj)) {
        return obj.filter((_) => _ != null).map(serde_json_json);
    }
    if (typeof obj === "object") {
        const target = {};
        for (const key of Object.keys(obj)) {
            if (obj[key] == null) {
                continue;
            }
            target[key] = serde_json_json(obj[key]);
        }
        return target;
    }
    return obj;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/node_modules/@smithy/smithy-client/dist-es/index.js























;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/endpoint/EndpointParameters.js
const EndpointParameters_resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "dynamodb",
    };
};
const EndpointParameters_commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};

// EXTERNAL MODULE: ./node_modules/uuid/dist/esm-node/v4.js + 3 modules
var v4 = __webpack_require__(4349);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/models/DynamoDBServiceException.js


class DynamoDBServiceException extends exceptions_ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, DynamoDBServiceException.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/models/models_0.js

const ApproximateCreationDateTimePrecision = {
    MICROSECOND: "MICROSECOND",
    MILLISECOND: "MILLISECOND",
};
const AttributeAction = {
    ADD: "ADD",
    DELETE: "DELETE",
    PUT: "PUT",
};
const ScalarAttributeType = {
    B: "B",
    N: "N",
    S: "S",
};
const BackupStatus = {
    AVAILABLE: "AVAILABLE",
    CREATING: "CREATING",
    DELETED: "DELETED",
};
const BackupType = {
    AWS_BACKUP: "AWS_BACKUP",
    SYSTEM: "SYSTEM",
    USER: "USER",
};
const BillingMode = {
    PAY_PER_REQUEST: "PAY_PER_REQUEST",
    PROVISIONED: "PROVISIONED",
};
const KeyType = {
    HASH: "HASH",
    RANGE: "RANGE",
};
const ProjectionType = {
    ALL: "ALL",
    INCLUDE: "INCLUDE",
    KEYS_ONLY: "KEYS_ONLY",
};
const SSEType = {
    AES256: "AES256",
    KMS: "KMS",
};
const SSEStatus = {
    DISABLED: "DISABLED",
    DISABLING: "DISABLING",
    ENABLED: "ENABLED",
    ENABLING: "ENABLING",
    UPDATING: "UPDATING",
};
const StreamViewType = {
    KEYS_ONLY: "KEYS_ONLY",
    NEW_AND_OLD_IMAGES: "NEW_AND_OLD_IMAGES",
    NEW_IMAGE: "NEW_IMAGE",
    OLD_IMAGE: "OLD_IMAGE",
};
const TimeToLiveStatus = {
    DISABLED: "DISABLED",
    DISABLING: "DISABLING",
    ENABLED: "ENABLED",
    ENABLING: "ENABLING",
};
class BackupInUseException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "BackupInUseException",
            $fault: "client",
            ...opts,
        });
        this.name = "BackupInUseException";
        this.$fault = "client";
        Object.setPrototypeOf(this, BackupInUseException.prototype);
    }
}
class BackupNotFoundException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "BackupNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "BackupNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, BackupNotFoundException.prototype);
    }
}
const BackupTypeFilter = {
    ALL: "ALL",
    AWS_BACKUP: "AWS_BACKUP",
    SYSTEM: "SYSTEM",
    USER: "USER",
};
const ReturnConsumedCapacity = {
    INDEXES: "INDEXES",
    NONE: "NONE",
    TOTAL: "TOTAL",
};
const ReturnValuesOnConditionCheckFailure = {
    ALL_OLD: "ALL_OLD",
    NONE: "NONE",
};
const BatchStatementErrorCodeEnum = {
    AccessDenied: "AccessDenied",
    ConditionalCheckFailed: "ConditionalCheckFailed",
    DuplicateItem: "DuplicateItem",
    InternalServerError: "InternalServerError",
    ItemCollectionSizeLimitExceeded: "ItemCollectionSizeLimitExceeded",
    ProvisionedThroughputExceeded: "ProvisionedThroughputExceeded",
    RequestLimitExceeded: "RequestLimitExceeded",
    ResourceNotFound: "ResourceNotFound",
    ThrottlingError: "ThrottlingError",
    TransactionConflict: "TransactionConflict",
    ValidationError: "ValidationError",
};
class InternalServerError extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "InternalServerError",
            $fault: "server",
            ...opts,
        });
        this.name = "InternalServerError";
        this.$fault = "server";
        Object.setPrototypeOf(this, InternalServerError.prototype);
    }
}
class RequestLimitExceeded extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "RequestLimitExceeded",
            $fault: "client",
            ...opts,
        });
        this.name = "RequestLimitExceeded";
        this.$fault = "client";
        Object.setPrototypeOf(this, RequestLimitExceeded.prototype);
    }
}
class InvalidEndpointException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "InvalidEndpointException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidEndpointException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidEndpointException.prototype);
        this.Message = opts.Message;
    }
}
class ProvisionedThroughputExceededException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "ProvisionedThroughputExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "ProvisionedThroughputExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ProvisionedThroughputExceededException.prototype);
    }
}
class ResourceNotFoundException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
}
const ReturnItemCollectionMetrics = {
    NONE: "NONE",
    SIZE: "SIZE",
};
class ItemCollectionSizeLimitExceededException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "ItemCollectionSizeLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "ItemCollectionSizeLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ItemCollectionSizeLimitExceededException.prototype);
    }
}
const ComparisonOperator = {
    BEGINS_WITH: "BEGINS_WITH",
    BETWEEN: "BETWEEN",
    CONTAINS: "CONTAINS",
    EQ: "EQ",
    GE: "GE",
    GT: "GT",
    IN: "IN",
    LE: "LE",
    LT: "LT",
    NE: "NE",
    NOT_CONTAINS: "NOT_CONTAINS",
    NOT_NULL: "NOT_NULL",
    NULL: "NULL",
};
const ConditionalOperator = {
    AND: "AND",
    OR: "OR",
};
const ContinuousBackupsStatus = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
const PointInTimeRecoveryStatus = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
class ContinuousBackupsUnavailableException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "ContinuousBackupsUnavailableException",
            $fault: "client",
            ...opts,
        });
        this.name = "ContinuousBackupsUnavailableException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ContinuousBackupsUnavailableException.prototype);
    }
}
const ContributorInsightsAction = {
    DISABLE: "DISABLE",
    ENABLE: "ENABLE",
};
const ContributorInsightsStatus = {
    DISABLED: "DISABLED",
    DISABLING: "DISABLING",
    ENABLED: "ENABLED",
    ENABLING: "ENABLING",
    FAILED: "FAILED",
};
class models_0_LimitExceededException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "LimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "LimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, models_0_LimitExceededException.prototype);
    }
}
class TableInUseException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "TableInUseException",
            $fault: "client",
            ...opts,
        });
        this.name = "TableInUseException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TableInUseException.prototype);
    }
}
class TableNotFoundException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "TableNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "TableNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TableNotFoundException.prototype);
    }
}
const GlobalTableStatus = {
    ACTIVE: "ACTIVE",
    CREATING: "CREATING",
    DELETING: "DELETING",
    UPDATING: "UPDATING",
};
const ReplicaStatus = {
    ACTIVE: "ACTIVE",
    CREATING: "CREATING",
    CREATION_FAILED: "CREATION_FAILED",
    DELETING: "DELETING",
    INACCESSIBLE_ENCRYPTION_CREDENTIALS: "INACCESSIBLE_ENCRYPTION_CREDENTIALS",
    REGION_DISABLED: "REGION_DISABLED",
    UPDATING: "UPDATING",
};
const TableClass = {
    STANDARD: "STANDARD",
    STANDARD_INFREQUENT_ACCESS: "STANDARD_INFREQUENT_ACCESS",
};
class GlobalTableAlreadyExistsException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "GlobalTableAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        this.name = "GlobalTableAlreadyExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, GlobalTableAlreadyExistsException.prototype);
    }
}
const IndexStatus = {
    ACTIVE: "ACTIVE",
    CREATING: "CREATING",
    DELETING: "DELETING",
    UPDATING: "UPDATING",
};
const TableStatus = {
    ACTIVE: "ACTIVE",
    ARCHIVED: "ARCHIVED",
    ARCHIVING: "ARCHIVING",
    CREATING: "CREATING",
    DELETING: "DELETING",
    INACCESSIBLE_ENCRYPTION_CREDENTIALS: "INACCESSIBLE_ENCRYPTION_CREDENTIALS",
    UPDATING: "UPDATING",
};
class ResourceInUseException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "ResourceInUseException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceInUseException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceInUseException.prototype);
    }
}
const ReturnValue = {
    ALL_NEW: "ALL_NEW",
    ALL_OLD: "ALL_OLD",
    NONE: "NONE",
    UPDATED_NEW: "UPDATED_NEW",
    UPDATED_OLD: "UPDATED_OLD",
};
class TransactionConflictException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "TransactionConflictException",
            $fault: "client",
            ...opts,
        });
        this.name = "TransactionConflictException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TransactionConflictException.prototype);
    }
}
class PolicyNotFoundException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "PolicyNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "PolicyNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PolicyNotFoundException.prototype);
    }
}
const ExportFormat = {
    DYNAMODB_JSON: "DYNAMODB_JSON",
    ION: "ION",
};
const ExportStatus = {
    COMPLETED: "COMPLETED",
    FAILED: "FAILED",
    IN_PROGRESS: "IN_PROGRESS",
};
const ExportType = {
    FULL_EXPORT: "FULL_EXPORT",
    INCREMENTAL_EXPORT: "INCREMENTAL_EXPORT",
};
const ExportViewType = {
    NEW_AND_OLD_IMAGES: "NEW_AND_OLD_IMAGES",
    NEW_IMAGE: "NEW_IMAGE",
};
const S3SseAlgorithm = {
    AES256: "AES256",
    KMS: "KMS",
};
class ExportNotFoundException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "ExportNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ExportNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ExportNotFoundException.prototype);
    }
}
class GlobalTableNotFoundException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "GlobalTableNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "GlobalTableNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, GlobalTableNotFoundException.prototype);
    }
}
const ImportStatus = {
    CANCELLED: "CANCELLED",
    CANCELLING: "CANCELLING",
    COMPLETED: "COMPLETED",
    FAILED: "FAILED",
    IN_PROGRESS: "IN_PROGRESS",
};
const InputCompressionType = {
    GZIP: "GZIP",
    NONE: "NONE",
    ZSTD: "ZSTD",
};
const InputFormat = {
    CSV: "CSV",
    DYNAMODB_JSON: "DYNAMODB_JSON",
    ION: "ION",
};
class ImportNotFoundException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "ImportNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ImportNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ImportNotFoundException.prototype);
    }
}
const DestinationStatus = {
    ACTIVE: "ACTIVE",
    DISABLED: "DISABLED",
    DISABLING: "DISABLING",
    ENABLE_FAILED: "ENABLE_FAILED",
    ENABLING: "ENABLING",
    UPDATING: "UPDATING",
};
class DuplicateItemException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "DuplicateItemException",
            $fault: "client",
            ...opts,
        });
        this.name = "DuplicateItemException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DuplicateItemException.prototype);
    }
}
class IdempotentParameterMismatchException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "IdempotentParameterMismatchException",
            $fault: "client",
            ...opts,
        });
        this.name = "IdempotentParameterMismatchException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IdempotentParameterMismatchException.prototype);
        this.Message = opts.Message;
    }
}
class TransactionInProgressException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "TransactionInProgressException",
            $fault: "client",
            ...opts,
        });
        this.name = "TransactionInProgressException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TransactionInProgressException.prototype);
        this.Message = opts.Message;
    }
}
class ExportConflictException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "ExportConflictException",
            $fault: "client",
            ...opts,
        });
        this.name = "ExportConflictException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ExportConflictException.prototype);
    }
}
class InvalidExportTimeException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "InvalidExportTimeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidExportTimeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidExportTimeException.prototype);
    }
}
class PointInTimeRecoveryUnavailableException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "PointInTimeRecoveryUnavailableException",
            $fault: "client",
            ...opts,
        });
        this.name = "PointInTimeRecoveryUnavailableException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PointInTimeRecoveryUnavailableException.prototype);
    }
}
class ImportConflictException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "ImportConflictException",
            $fault: "client",
            ...opts,
        });
        this.name = "ImportConflictException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ImportConflictException.prototype);
    }
}
const Select = {
    ALL_ATTRIBUTES: "ALL_ATTRIBUTES",
    ALL_PROJECTED_ATTRIBUTES: "ALL_PROJECTED_ATTRIBUTES",
    COUNT: "COUNT",
    SPECIFIC_ATTRIBUTES: "SPECIFIC_ATTRIBUTES",
};
class TableAlreadyExistsException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "TableAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        this.name = "TableAlreadyExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TableAlreadyExistsException.prototype);
    }
}
class InvalidRestoreTimeException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "InvalidRestoreTimeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRestoreTimeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRestoreTimeException.prototype);
    }
}
class ReplicaAlreadyExistsException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "ReplicaAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        this.name = "ReplicaAlreadyExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ReplicaAlreadyExistsException.prototype);
    }
}
class ReplicaNotFoundException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "ReplicaNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ReplicaNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ReplicaNotFoundException.prototype);
    }
}
class IndexNotFoundException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "IndexNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "IndexNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IndexNotFoundException.prototype);
    }
}
var AttributeValue;
(function (AttributeValue) {
    AttributeValue.visit = (value, visitor) => {
        if (value.S !== undefined)
            return visitor.S(value.S);
        if (value.N !== undefined)
            return visitor.N(value.N);
        if (value.B !== undefined)
            return visitor.B(value.B);
        if (value.SS !== undefined)
            return visitor.SS(value.SS);
        if (value.NS !== undefined)
            return visitor.NS(value.NS);
        if (value.BS !== undefined)
            return visitor.BS(value.BS);
        if (value.M !== undefined)
            return visitor.M(value.M);
        if (value.L !== undefined)
            return visitor.L(value.L);
        if (value.NULL !== undefined)
            return visitor.NULL(value.NULL);
        if (value.BOOL !== undefined)
            return visitor.BOOL(value.BOOL);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(AttributeValue || (AttributeValue = {}));
class ConditionalCheckFailedException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "ConditionalCheckFailedException",
            $fault: "client",
            ...opts,
        });
        this.name = "ConditionalCheckFailedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ConditionalCheckFailedException.prototype);
        this.Item = opts.Item;
    }
}
class TransactionCanceledException extends DynamoDBServiceException {
    constructor(opts) {
        super({
            name: "TransactionCanceledException",
            $fault: "client",
            ...opts,
        });
        this.name = "TransactionCanceledException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TransactionCanceledException.prototype);
        this.Message = opts.Message;
        this.CancellationReasons = opts.CancellationReasons;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/protocols/Aws_json1_0.js






const se_BatchExecuteStatementCommand = async (input, context) => {
    const headers = sharedHeaders("BatchExecuteStatement");
    let body;
    body = JSON.stringify(se_BatchExecuteStatementInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_BatchGetItemCommand = async (input, context) => {
    const headers = sharedHeaders("BatchGetItem");
    let body;
    body = JSON.stringify(se_BatchGetItemInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_BatchWriteItemCommand = async (input, context) => {
    const headers = sharedHeaders("BatchWriteItem");
    let body;
    body = JSON.stringify(se_BatchWriteItemInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateBackupCommand = async (input, context) => {
    const headers = sharedHeaders("CreateBackup");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateGlobalTableCommand = async (input, context) => {
    const headers = sharedHeaders("CreateGlobalTable");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_CreateTableCommand = async (input, context) => {
    const headers = sharedHeaders("CreateTable");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteBackupCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteBackup");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteItemCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteItem");
    let body;
    body = JSON.stringify(se_DeleteItemInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteResourcePolicyCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteResourcePolicy");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteTableCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteTable");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeBackupCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeBackup");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeContinuousBackupsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeContinuousBackups");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeContributorInsightsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeContributorInsights");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeEndpointsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeEndpoints");
    let body;
    body = JSON.stringify(serde_json_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeExportCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeExport");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeGlobalTableCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeGlobalTable");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeGlobalTableSettingsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeGlobalTableSettings");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeImportCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeImport");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeKinesisStreamingDestinationCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeKinesisStreamingDestination");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeLimitsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeLimits");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeTableCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeTable");
    let body;
    body = JSON.stringify(serde_json_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeTableReplicaAutoScalingCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeTableReplicaAutoScaling");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeTimeToLiveCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeTimeToLive");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DisableKinesisStreamingDestinationCommand = async (input, context) => {
    const headers = sharedHeaders("DisableKinesisStreamingDestination");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_EnableKinesisStreamingDestinationCommand = async (input, context) => {
    const headers = sharedHeaders("EnableKinesisStreamingDestination");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ExecuteStatementCommand = async (input, context) => {
    const headers = sharedHeaders("ExecuteStatement");
    let body;
    body = JSON.stringify(se_ExecuteStatementInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ExecuteTransactionCommand = async (input, context) => {
    const headers = sharedHeaders("ExecuteTransaction");
    let body;
    body = JSON.stringify(se_ExecuteTransactionInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ExportTableToPointInTimeCommand = async (input, context) => {
    const headers = sharedHeaders("ExportTableToPointInTime");
    let body;
    body = JSON.stringify(se_ExportTableToPointInTimeInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetItemCommand = async (input, context) => {
    const headers = sharedHeaders("GetItem");
    let body;
    body = JSON.stringify(se_GetItemInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetResourcePolicyCommand = async (input, context) => {
    const headers = sharedHeaders("GetResourcePolicy");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ImportTableCommand = async (input, context) => {
    const headers = sharedHeaders("ImportTable");
    let body;
    body = JSON.stringify(se_ImportTableInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListBackupsCommand = async (input, context) => {
    const headers = sharedHeaders("ListBackups");
    let body;
    body = JSON.stringify(se_ListBackupsInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListContributorInsightsCommand = async (input, context) => {
    const headers = sharedHeaders("ListContributorInsights");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListExportsCommand = async (input, context) => {
    const headers = sharedHeaders("ListExports");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListGlobalTablesCommand = async (input, context) => {
    const headers = sharedHeaders("ListGlobalTables");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListImportsCommand = async (input, context) => {
    const headers = sharedHeaders("ListImports");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListTablesCommand = async (input, context) => {
    const headers = sharedHeaders("ListTables");
    let body;
    body = JSON.stringify(serde_json_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListTagsOfResourceCommand = async (input, context) => {
    const headers = sharedHeaders("ListTagsOfResource");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutItemCommand = async (input, context) => {
    const headers = sharedHeaders("PutItem");
    let body;
    body = JSON.stringify(se_PutItemInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutResourcePolicyCommand = async (input, context) => {
    const headers = sharedHeaders("PutResourcePolicy");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_QueryCommand = async (input, context) => {
    const headers = sharedHeaders("Query");
    let body;
    body = JSON.stringify(se_QueryInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_RestoreTableFromBackupCommand = async (input, context) => {
    const headers = sharedHeaders("RestoreTableFromBackup");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_RestoreTableToPointInTimeCommand = async (input, context) => {
    const headers = sharedHeaders("RestoreTableToPointInTime");
    let body;
    body = JSON.stringify(se_RestoreTableToPointInTimeInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ScanCommand = async (input, context) => {
    const headers = sharedHeaders("Scan");
    let body;
    body = JSON.stringify(se_ScanInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_TagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("TagResource");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_TransactGetItemsCommand = async (input, context) => {
    const headers = sharedHeaders("TransactGetItems");
    let body;
    body = JSON.stringify(se_TransactGetItemsInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_TransactWriteItemsCommand = async (input, context) => {
    const headers = sharedHeaders("TransactWriteItems");
    let body;
    body = JSON.stringify(se_TransactWriteItemsInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UntagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("UntagResource");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateContinuousBackupsCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateContinuousBackups");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateContributorInsightsCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateContributorInsights");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateGlobalTableCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateGlobalTable");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateGlobalTableSettingsCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateGlobalTableSettings");
    let body;
    body = JSON.stringify(se_UpdateGlobalTableSettingsInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateItemCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateItem");
    let body;
    body = JSON.stringify(se_UpdateItemInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateKinesisStreamingDestinationCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateKinesisStreamingDestination");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateTableCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateTable");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateTableReplicaAutoScalingCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateTableReplicaAutoScaling");
    let body;
    body = JSON.stringify(se_UpdateTableReplicaAutoScalingInput(input, context));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UpdateTimeToLiveCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateTimeToLive");
    let body;
    body = JSON.stringify(_json(input));
    return Aws_json1_0_buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const de_BatchExecuteStatementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_BatchExecuteStatementOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_BatchGetItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_BatchGetItemOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_BatchWriteItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_BatchWriteItemOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateBackupOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateGlobalTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateGlobalTableOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTableOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteBackupOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_DeleteItemOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTableOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeBackupOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeContinuousBackupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeContinuousBackupsOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeContributorInsightsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeContributorInsightsOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = serde_json_json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeExportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeExportOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeGlobalTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeGlobalTableOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeGlobalTableSettingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeGlobalTableSettingsOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeImportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeImportOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeKinesisStreamingDestinationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeLimitsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_DescribeTableOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeTableReplicaAutoScalingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTableReplicaAutoScalingOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeTimeToLiveCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DisableKinesisStreamingDestinationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_EnableKinesisStreamingDestinationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ExecuteStatementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_ExecuteStatementOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ExecuteTransactionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_ExecuteTransactionOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ExportTableToPointInTimeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExportTableToPointInTimeOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_GetItemOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ImportTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ImportTableOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListBackupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListBackupsOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListContributorInsightsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListExportsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListGlobalTablesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListImportsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListImportsOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListTablesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = serde_json_json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListTagsOfResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_PutItemOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_QueryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_QueryOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_RestoreTableFromBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreTableFromBackupOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_RestoreTableToPointInTimeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreTableToPointInTimeOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ScanCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_ScanOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
    };
    return response;
};
const de_TransactGetItemsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_TransactGetItemsOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_TransactWriteItemsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_TransactWriteItemsOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
    };
    return response;
};
const de_UpdateContinuousBackupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateContinuousBackupsOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateContributorInsightsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateGlobalTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateGlobalTableOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateGlobalTableSettingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateGlobalTableSettingsOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await (0,dist_cjs.parseJsonBody)(output.body, context);
    let contents = {};
    contents = de_UpdateItemOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateKinesisStreamingDestinationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateTableOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateTableReplicaAutoScalingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateTableReplicaAutoScalingOutput(data, context);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateTimeToLiveCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return Aws_json1_0_de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: Aws_json1_0_deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const Aws_json1_0_de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await (0,dist_cjs.parseJsonErrorBody)(output.body, context),
    };
    const errorCode = (0,dist_cjs.loadRestJsonErrorCode)(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.dynamodb#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "RequestLimitExceeded":
        case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await de_RequestLimitExceededRes(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ItemCollectionSizeLimitExceededException":
        case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
            throw await de_ItemCollectionSizeLimitExceededExceptionRes(parsedOutput, context);
        case "BackupInUseException":
        case "com.amazonaws.dynamodb#BackupInUseException":
            throw await de_BackupInUseExceptionRes(parsedOutput, context);
        case "ContinuousBackupsUnavailableException":
        case "com.amazonaws.dynamodb#ContinuousBackupsUnavailableException":
            throw await de_ContinuousBackupsUnavailableExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.dynamodb#LimitExceededException":
            throw await Aws_json1_0_de_LimitExceededExceptionRes(parsedOutput, context);
        case "TableInUseException":
        case "com.amazonaws.dynamodb#TableInUseException":
            throw await de_TableInUseExceptionRes(parsedOutput, context);
        case "TableNotFoundException":
        case "com.amazonaws.dynamodb#TableNotFoundException":
            throw await de_TableNotFoundExceptionRes(parsedOutput, context);
        case "GlobalTableAlreadyExistsException":
        case "com.amazonaws.dynamodb#GlobalTableAlreadyExistsException":
            throw await de_GlobalTableAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        case "BackupNotFoundException":
        case "com.amazonaws.dynamodb#BackupNotFoundException":
            throw await de_BackupNotFoundExceptionRes(parsedOutput, context);
        case "ConditionalCheckFailedException":
        case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
            throw await de_ConditionalCheckFailedExceptionRes(parsedOutput, context);
        case "TransactionConflictException":
        case "com.amazonaws.dynamodb#TransactionConflictException":
            throw await de_TransactionConflictExceptionRes(parsedOutput, context);
        case "PolicyNotFoundException":
        case "com.amazonaws.dynamodb#PolicyNotFoundException":
            throw await de_PolicyNotFoundExceptionRes(parsedOutput, context);
        case "ExportNotFoundException":
        case "com.amazonaws.dynamodb#ExportNotFoundException":
            throw await de_ExportNotFoundExceptionRes(parsedOutput, context);
        case "GlobalTableNotFoundException":
        case "com.amazonaws.dynamodb#GlobalTableNotFoundException":
            throw await de_GlobalTableNotFoundExceptionRes(parsedOutput, context);
        case "ImportNotFoundException":
        case "com.amazonaws.dynamodb#ImportNotFoundException":
            throw await de_ImportNotFoundExceptionRes(parsedOutput, context);
        case "DuplicateItemException":
        case "com.amazonaws.dynamodb#DuplicateItemException":
            throw await de_DuplicateItemExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.dynamodb#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "TransactionCanceledException":
        case "com.amazonaws.dynamodb#TransactionCanceledException":
            throw await de_TransactionCanceledExceptionRes(parsedOutput, context);
        case "TransactionInProgressException":
        case "com.amazonaws.dynamodb#TransactionInProgressException":
            throw await de_TransactionInProgressExceptionRes(parsedOutput, context);
        case "ExportConflictException":
        case "com.amazonaws.dynamodb#ExportConflictException":
            throw await de_ExportConflictExceptionRes(parsedOutput, context);
        case "InvalidExportTimeException":
        case "com.amazonaws.dynamodb#InvalidExportTimeException":
            throw await de_InvalidExportTimeExceptionRes(parsedOutput, context);
        case "PointInTimeRecoveryUnavailableException":
        case "com.amazonaws.dynamodb#PointInTimeRecoveryUnavailableException":
            throw await de_PointInTimeRecoveryUnavailableExceptionRes(parsedOutput, context);
        case "ImportConflictException":
        case "com.amazonaws.dynamodb#ImportConflictException":
            throw await de_ImportConflictExceptionRes(parsedOutput, context);
        case "TableAlreadyExistsException":
        case "com.amazonaws.dynamodb#TableAlreadyExistsException":
            throw await de_TableAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidRestoreTimeException":
        case "com.amazonaws.dynamodb#InvalidRestoreTimeException":
            throw await de_InvalidRestoreTimeExceptionRes(parsedOutput, context);
        case "ReplicaAlreadyExistsException":
        case "com.amazonaws.dynamodb#ReplicaAlreadyExistsException":
            throw await de_ReplicaAlreadyExistsExceptionRes(parsedOutput, context);
        case "ReplicaNotFoundException":
        case "com.amazonaws.dynamodb#ReplicaNotFoundException":
            throw await de_ReplicaNotFoundExceptionRes(parsedOutput, context);
        case "IndexNotFoundException":
        case "com.amazonaws.dynamodb#IndexNotFoundException":
            throw await de_IndexNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_0_throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BackupInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new BackupInUseException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_BackupNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new BackupNotFoundException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_ConditionalCheckFailedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ConditionalCheckFailedException(body, context);
    const exception = new ConditionalCheckFailedException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_ContinuousBackupsUnavailableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new ContinuousBackupsUnavailableException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_DuplicateItemExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new DuplicateItemException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_ExportConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new ExportConflictException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_ExportNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new ExportNotFoundException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_GlobalTableAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new GlobalTableAlreadyExistsException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_GlobalTableNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new GlobalTableNotFoundException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_IdempotentParameterMismatchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new IdempotentParameterMismatchException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_ImportConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new ImportConflictException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_ImportNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new ImportNotFoundException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_IndexNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new IndexNotFoundException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_InternalServerErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new InternalServerError({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_InvalidEndpointExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new InvalidEndpointException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_InvalidExportTimeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new InvalidExportTimeException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_InvalidRestoreTimeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new InvalidRestoreTimeException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_ItemCollectionSizeLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new ItemCollectionSizeLimitExceededException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const Aws_json1_0_de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new models_0_LimitExceededException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_PointInTimeRecoveryUnavailableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new PointInTimeRecoveryUnavailableException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_PolicyNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new PolicyNotFoundException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_ProvisionedThroughputExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new ProvisionedThroughputExceededException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_ReplicaAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new ReplicaAlreadyExistsException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_ReplicaNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new ReplicaNotFoundException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_RequestLimitExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new RequestLimitExceeded({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_ResourceInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new ResourceInUseException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new ResourceNotFoundException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_TableAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new TableAlreadyExistsException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_TableInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new TableInUseException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_TableNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new TableNotFoundException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_TransactionCanceledExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TransactionCanceledException(body, context);
    const exception = new TransactionCanceledException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_TransactionConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new TransactionConflictException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const de_TransactionInProgressExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = serde_json_json(body);
    const exception = new TransactionInProgressException({
        $metadata: Aws_json1_0_deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return dist_es_exceptions_decorateServiceException(exception, body);
};
const se_AttributeUpdates = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_AttributeValueUpdate(value, context);
        return acc;
    }, {});
};
const se_AttributeValue = (input, context) => {
    return AttributeValue.visit(input, {
        B: (value) => ({ B: context.base64Encoder(value) }),
        BOOL: (value) => ({ BOOL: value }),
        BS: (value) => ({ BS: se_BinarySetAttributeValue(value, context) }),
        L: (value) => ({ L: se_ListAttributeValue(value, context) }),
        M: (value) => ({ M: se_MapAttributeValue(value, context) }),
        N: (value) => ({ N: value }),
        NS: (value) => ({ NS: serde_json_json(value) }),
        NULL: (value) => ({ NULL: value }),
        S: (value) => ({ S: value }),
        SS: (value) => ({ SS: serde_json_json(value) }),
        _: (name, value) => ({ name: value }),
    });
};
const se_AttributeValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AttributeValue(entry, context);
    });
};
const se_AttributeValueUpdate = (input, context) => {
    return object_mapping_take(input, {
        Action: [],
        Value: (_) => se_AttributeValue(_, context),
    });
};
const se_AutoScalingPolicyUpdate = (input, context) => {
    return take(input, {
        PolicyName: [],
        TargetTrackingScalingPolicyConfiguration: (_) => se_AutoScalingTargetTrackingScalingPolicyConfigurationUpdate(_, context),
    });
};
const se_AutoScalingSettingsUpdate = (input, context) => {
    return take(input, {
        AutoScalingDisabled: [],
        AutoScalingRoleArn: [],
        MaximumUnits: [],
        MinimumUnits: [],
        ScalingPolicyUpdate: (_) => se_AutoScalingPolicyUpdate(_, context),
    });
};
const se_AutoScalingTargetTrackingScalingPolicyConfigurationUpdate = (input, context) => {
    return take(input, {
        DisableScaleIn: [],
        ScaleInCooldown: [],
        ScaleOutCooldown: [],
        TargetValue: __serializeFloat,
    });
};
const se_BatchExecuteStatementInput = (input, context) => {
    return object_mapping_take(input, {
        ReturnConsumedCapacity: [],
        Statements: (_) => se_PartiQLBatchRequest(_, context),
    });
};
const se_BatchGetItemInput = (input, context) => {
    return object_mapping_take(input, {
        RequestItems: (_) => se_BatchGetRequestMap(_, context),
        ReturnConsumedCapacity: [],
    });
};
const se_BatchGetRequestMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_KeysAndAttributes(value, context);
        return acc;
    }, {});
};
const se_BatchStatementRequest = (input, context) => {
    return object_mapping_take(input, {
        ConsistentRead: [],
        Parameters: (_) => se_PreparedStatementParameters(_, context),
        ReturnValuesOnConditionCheckFailure: [],
        Statement: [],
    });
};
const se_BatchWriteItemInput = (input, context) => {
    return object_mapping_take(input, {
        RequestItems: (_) => se_BatchWriteItemRequestMap(_, context),
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
    });
};
const se_BatchWriteItemRequestMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_WriteRequests(value, context);
        return acc;
    }, {});
};
const se_BinarySetAttributeValue = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return context.base64Encoder(entry);
    });
};
const se_Condition = (input, context) => {
    return object_mapping_take(input, {
        AttributeValueList: (_) => se_AttributeValueList(_, context),
        ComparisonOperator: [],
    });
};
const se_ConditionCheck = (input, context) => {
    return object_mapping_take(input, {
        ConditionExpression: [],
        ExpressionAttributeNames: serde_json_json,
        ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
        Key: (_) => se_Key(_, context),
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
    });
};
const se_Delete = (input, context) => {
    return object_mapping_take(input, {
        ConditionExpression: [],
        ExpressionAttributeNames: serde_json_json,
        ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
        Key: (_) => se_Key(_, context),
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
    });
};
const se_DeleteItemInput = (input, context) => {
    return object_mapping_take(input, {
        ConditionExpression: [],
        ConditionalOperator: [],
        Expected: (_) => se_ExpectedAttributeMap(_, context),
        ExpressionAttributeNames: serde_json_json,
        ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
        Key: (_) => se_Key(_, context),
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
        ReturnValues: [],
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
    });
};
const se_DeleteRequest = (input, context) => {
    return object_mapping_take(input, {
        Key: (_) => se_Key(_, context),
    });
};
const se_ExecuteStatementInput = (input, context) => {
    return object_mapping_take(input, {
        ConsistentRead: [],
        Limit: [],
        NextToken: [],
        Parameters: (_) => se_PreparedStatementParameters(_, context),
        ReturnConsumedCapacity: [],
        ReturnValuesOnConditionCheckFailure: [],
        Statement: [],
    });
};
const se_ExecuteTransactionInput = (input, context) => {
    return object_mapping_take(input, {
        ClientRequestToken: [true, (_) => _ ?? (0,v4/* default */.A)()],
        ReturnConsumedCapacity: [],
        TransactStatements: (_) => se_ParameterizedStatements(_, context),
    });
};
const se_ExpectedAttributeMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_ExpectedAttributeValue(value, context);
        return acc;
    }, {});
};
const se_ExpectedAttributeValue = (input, context) => {
    return object_mapping_take(input, {
        AttributeValueList: (_) => se_AttributeValueList(_, context),
        ComparisonOperator: [],
        Exists: [],
        Value: (_) => se_AttributeValue(_, context),
    });
};
const se_ExportTableToPointInTimeInput = (input, context) => {
    return take(input, {
        ClientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        ExportFormat: [],
        ExportTime: (_) => Math.round(_.getTime() / 1000),
        ExportType: [],
        IncrementalExportSpecification: (_) => se_IncrementalExportSpecification(_, context),
        S3Bucket: [],
        S3BucketOwner: [],
        S3Prefix: [],
        S3SseAlgorithm: [],
        S3SseKmsKeyId: [],
        TableArn: [],
    });
};
const se_ExpressionAttributeValueMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_AttributeValue(value, context);
        return acc;
    }, {});
};
const se_FilterConditionMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_Condition(value, context);
        return acc;
    }, {});
};
const se_Get = (input, context) => {
    return object_mapping_take(input, {
        ExpressionAttributeNames: serde_json_json,
        Key: (_) => se_Key(_, context),
        ProjectionExpression: [],
        TableName: [],
    });
};
const se_GetItemInput = (input, context) => {
    return object_mapping_take(input, {
        AttributesToGet: serde_json_json,
        ConsistentRead: [],
        ExpressionAttributeNames: serde_json_json,
        Key: (_) => se_Key(_, context),
        ProjectionExpression: [],
        ReturnConsumedCapacity: [],
        TableName: [],
    });
};
const se_GlobalSecondaryIndexAutoScalingUpdate = (input, context) => {
    return take(input, {
        IndexName: [],
        ProvisionedWriteCapacityAutoScalingUpdate: (_) => se_AutoScalingSettingsUpdate(_, context),
    });
};
const se_GlobalSecondaryIndexAutoScalingUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_GlobalSecondaryIndexAutoScalingUpdate(entry, context);
    });
};
const se_GlobalTableGlobalSecondaryIndexSettingsUpdate = (input, context) => {
    return take(input, {
        IndexName: [],
        ProvisionedWriteCapacityAutoScalingSettingsUpdate: (_) => se_AutoScalingSettingsUpdate(_, context),
        ProvisionedWriteCapacityUnits: [],
    });
};
const se_GlobalTableGlobalSecondaryIndexSettingsUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_GlobalTableGlobalSecondaryIndexSettingsUpdate(entry, context);
    });
};
const se_ImportTableInput = (input, context) => {
    return take(input, {
        ClientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        InputCompressionType: [],
        InputFormat: [],
        InputFormatOptions: _json,
        S3BucketSource: _json,
        TableCreationParameters: _json,
    });
};
const se_IncrementalExportSpecification = (input, context) => {
    return take(input, {
        ExportFromTime: (_) => Math.round(_.getTime() / 1000),
        ExportToTime: (_) => Math.round(_.getTime() / 1000),
        ExportViewType: [],
    });
};
const se_Key = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_AttributeValue(value, context);
        return acc;
    }, {});
};
const se_KeyConditions = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_Condition(value, context);
        return acc;
    }, {});
};
const se_KeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Key(entry, context);
    });
};
const se_KeysAndAttributes = (input, context) => {
    return object_mapping_take(input, {
        AttributesToGet: serde_json_json,
        ConsistentRead: [],
        ExpressionAttributeNames: serde_json_json,
        Keys: (_) => se_KeyList(_, context),
        ProjectionExpression: [],
    });
};
const se_ListAttributeValue = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AttributeValue(entry, context);
    });
};
const se_ListBackupsInput = (input, context) => {
    return take(input, {
        BackupType: [],
        ExclusiveStartBackupArn: [],
        Limit: [],
        TableName: [],
        TimeRangeLowerBound: (_) => Math.round(_.getTime() / 1000),
        TimeRangeUpperBound: (_) => Math.round(_.getTime() / 1000),
    });
};
const se_MapAttributeValue = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_AttributeValue(value, context);
        return acc;
    }, {});
};
const se_ParameterizedStatement = (input, context) => {
    return object_mapping_take(input, {
        Parameters: (_) => se_PreparedStatementParameters(_, context),
        ReturnValuesOnConditionCheckFailure: [],
        Statement: [],
    });
};
const se_ParameterizedStatements = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ParameterizedStatement(entry, context);
    });
};
const se_PartiQLBatchRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_BatchStatementRequest(entry, context);
    });
};
const se_PreparedStatementParameters = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AttributeValue(entry, context);
    });
};
const se_Put = (input, context) => {
    return object_mapping_take(input, {
        ConditionExpression: [],
        ExpressionAttributeNames: serde_json_json,
        ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
        Item: (_) => se_PutItemInputAttributeMap(_, context),
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
    });
};
const se_PutItemInput = (input, context) => {
    return object_mapping_take(input, {
        ConditionExpression: [],
        ConditionalOperator: [],
        Expected: (_) => se_ExpectedAttributeMap(_, context),
        ExpressionAttributeNames: serde_json_json,
        ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
        Item: (_) => se_PutItemInputAttributeMap(_, context),
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
        ReturnValues: [],
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
    });
};
const se_PutItemInputAttributeMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_AttributeValue(value, context);
        return acc;
    }, {});
};
const se_PutRequest = (input, context) => {
    return object_mapping_take(input, {
        Item: (_) => se_PutItemInputAttributeMap(_, context),
    });
};
const se_QueryInput = (input, context) => {
    return object_mapping_take(input, {
        AttributesToGet: serde_json_json,
        ConditionalOperator: [],
        ConsistentRead: [],
        ExclusiveStartKey: (_) => se_Key(_, context),
        ExpressionAttributeNames: serde_json_json,
        ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
        FilterExpression: [],
        IndexName: [],
        KeyConditionExpression: [],
        KeyConditions: (_) => se_KeyConditions(_, context),
        Limit: [],
        ProjectionExpression: [],
        QueryFilter: (_) => se_FilterConditionMap(_, context),
        ReturnConsumedCapacity: [],
        ScanIndexForward: [],
        Select: [],
        TableName: [],
    });
};
const se_ReplicaAutoScalingUpdate = (input, context) => {
    return take(input, {
        RegionName: [],
        ReplicaGlobalSecondaryIndexUpdates: (_) => se_ReplicaGlobalSecondaryIndexAutoScalingUpdateList(_, context),
        ReplicaProvisionedReadCapacityAutoScalingUpdate: (_) => se_AutoScalingSettingsUpdate(_, context),
    });
};
const se_ReplicaAutoScalingUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ReplicaAutoScalingUpdate(entry, context);
    });
};
const se_ReplicaGlobalSecondaryIndexAutoScalingUpdate = (input, context) => {
    return take(input, {
        IndexName: [],
        ProvisionedReadCapacityAutoScalingUpdate: (_) => se_AutoScalingSettingsUpdate(_, context),
    });
};
const se_ReplicaGlobalSecondaryIndexAutoScalingUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ReplicaGlobalSecondaryIndexAutoScalingUpdate(entry, context);
    });
};
const se_ReplicaGlobalSecondaryIndexSettingsUpdate = (input, context) => {
    return take(input, {
        IndexName: [],
        ProvisionedReadCapacityAutoScalingSettingsUpdate: (_) => se_AutoScalingSettingsUpdate(_, context),
        ProvisionedReadCapacityUnits: [],
    });
};
const se_ReplicaGlobalSecondaryIndexSettingsUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ReplicaGlobalSecondaryIndexSettingsUpdate(entry, context);
    });
};
const se_ReplicaSettingsUpdate = (input, context) => {
    return take(input, {
        RegionName: [],
        ReplicaGlobalSecondaryIndexSettingsUpdate: (_) => se_ReplicaGlobalSecondaryIndexSettingsUpdateList(_, context),
        ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate: (_) => se_AutoScalingSettingsUpdate(_, context),
        ReplicaProvisionedReadCapacityUnits: [],
        ReplicaTableClass: [],
    });
};
const se_ReplicaSettingsUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ReplicaSettingsUpdate(entry, context);
    });
};
const se_RestoreTableToPointInTimeInput = (input, context) => {
    return take(input, {
        BillingModeOverride: [],
        GlobalSecondaryIndexOverride: _json,
        LocalSecondaryIndexOverride: _json,
        OnDemandThroughputOverride: _json,
        ProvisionedThroughputOverride: _json,
        RestoreDateTime: (_) => Math.round(_.getTime() / 1000),
        SSESpecificationOverride: _json,
        SourceTableArn: [],
        SourceTableName: [],
        TargetTableName: [],
        UseLatestRestorableTime: [],
    });
};
const se_ScanInput = (input, context) => {
    return object_mapping_take(input, {
        AttributesToGet: serde_json_json,
        ConditionalOperator: [],
        ConsistentRead: [],
        ExclusiveStartKey: (_) => se_Key(_, context),
        ExpressionAttributeNames: serde_json_json,
        ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
        FilterExpression: [],
        IndexName: [],
        Limit: [],
        ProjectionExpression: [],
        ReturnConsumedCapacity: [],
        ScanFilter: (_) => se_FilterConditionMap(_, context),
        Segment: [],
        Select: [],
        TableName: [],
        TotalSegments: [],
    });
};
const se_TransactGetItem = (input, context) => {
    return object_mapping_take(input, {
        Get: (_) => se_Get(_, context),
    });
};
const se_TransactGetItemList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_TransactGetItem(entry, context);
    });
};
const se_TransactGetItemsInput = (input, context) => {
    return object_mapping_take(input, {
        ReturnConsumedCapacity: [],
        TransactItems: (_) => se_TransactGetItemList(_, context),
    });
};
const se_TransactWriteItem = (input, context) => {
    return object_mapping_take(input, {
        ConditionCheck: (_) => se_ConditionCheck(_, context),
        Delete: (_) => se_Delete(_, context),
        Put: (_) => se_Put(_, context),
        Update: (_) => se_Update(_, context),
    });
};
const se_TransactWriteItemList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_TransactWriteItem(entry, context);
    });
};
const se_TransactWriteItemsInput = (input, context) => {
    return object_mapping_take(input, {
        ClientRequestToken: [true, (_) => _ ?? (0,v4/* default */.A)()],
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
        TransactItems: (_) => se_TransactWriteItemList(_, context),
    });
};
const se_Update = (input, context) => {
    return object_mapping_take(input, {
        ConditionExpression: [],
        ExpressionAttributeNames: serde_json_json,
        ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
        Key: (_) => se_Key(_, context),
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
        UpdateExpression: [],
    });
};
const se_UpdateGlobalTableSettingsInput = (input, context) => {
    return take(input, {
        GlobalTableBillingMode: [],
        GlobalTableGlobalSecondaryIndexSettingsUpdate: (_) => se_GlobalTableGlobalSecondaryIndexSettingsUpdateList(_, context),
        GlobalTableName: [],
        GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate: (_) => se_AutoScalingSettingsUpdate(_, context),
        GlobalTableProvisionedWriteCapacityUnits: [],
        ReplicaSettingsUpdate: (_) => se_ReplicaSettingsUpdateList(_, context),
    });
};
const se_UpdateItemInput = (input, context) => {
    return object_mapping_take(input, {
        AttributeUpdates: (_) => se_AttributeUpdates(_, context),
        ConditionExpression: [],
        ConditionalOperator: [],
        Expected: (_) => se_ExpectedAttributeMap(_, context),
        ExpressionAttributeNames: serde_json_json,
        ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
        Key: (_) => se_Key(_, context),
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
        ReturnValues: [],
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
        UpdateExpression: [],
    });
};
const se_UpdateTableReplicaAutoScalingInput = (input, context) => {
    return take(input, {
        GlobalSecondaryIndexUpdates: (_) => se_GlobalSecondaryIndexAutoScalingUpdateList(_, context),
        ProvisionedWriteCapacityAutoScalingUpdate: (_) => se_AutoScalingSettingsUpdate(_, context),
        ReplicaUpdates: (_) => se_ReplicaAutoScalingUpdateList(_, context),
        TableName: [],
    });
};
const se_WriteRequest = (input, context) => {
    return object_mapping_take(input, {
        DeleteRequest: (_) => se_DeleteRequest(_, context),
        PutRequest: (_) => se_PutRequest(_, context),
    });
};
const se_WriteRequests = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_WriteRequest(entry, context);
    });
};
const de_ArchivalSummary = (output, context) => {
    return object_mapping_take(output, {
        ArchivalBackupArn: parse_utils_expectString,
        ArchivalDateTime: (_) => parse_utils_expectNonNull(date_utils_parseEpochTimestamp(parse_utils_expectNumber(_))),
        ArchivalReason: parse_utils_expectString,
    });
};
const de_AttributeMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_AttributeValue((0,dist_cjs.awsExpectUnion)(value), context);
        return acc;
    }, {});
};
const de_AttributeValue = (output, context) => {
    if (output.B != null) {
        return {
            B: context.base64Decoder(output.B),
        };
    }
    if (parse_utils_expectBoolean(output.BOOL) !== undefined) {
        return { BOOL: parse_utils_expectBoolean(output.BOOL) };
    }
    if (output.BS != null) {
        return {
            BS: de_BinarySetAttributeValue(output.BS, context),
        };
    }
    if (output.L != null) {
        return {
            L: de_ListAttributeValue(output.L, context),
        };
    }
    if (output.M != null) {
        return {
            M: de_MapAttributeValue(output.M, context),
        };
    }
    if (parse_utils_expectString(output.N) !== undefined) {
        return { N: parse_utils_expectString(output.N) };
    }
    if (output.NS != null) {
        return {
            NS: serde_json_json(output.NS),
        };
    }
    if (parse_utils_expectBoolean(output.NULL) !== undefined) {
        return { NULL: parse_utils_expectBoolean(output.NULL) };
    }
    if (parse_utils_expectString(output.S) !== undefined) {
        return { S: parse_utils_expectString(output.S) };
    }
    if (output.SS != null) {
        return {
            SS: serde_json_json(output.SS),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_AutoScalingPolicyDescription = (output, context) => {
    return take(output, {
        PolicyName: __expectString,
        TargetTrackingScalingPolicyConfiguration: (_) => de_AutoScalingTargetTrackingScalingPolicyConfigurationDescription(_, context),
    });
};
const de_AutoScalingPolicyDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AutoScalingPolicyDescription(entry, context);
    });
    return retVal;
};
const de_AutoScalingSettingsDescription = (output, context) => {
    return take(output, {
        AutoScalingDisabled: __expectBoolean,
        AutoScalingRoleArn: __expectString,
        MaximumUnits: __expectLong,
        MinimumUnits: __expectLong,
        ScalingPolicies: (_) => de_AutoScalingPolicyDescriptionList(_, context),
    });
};
const de_AutoScalingTargetTrackingScalingPolicyConfigurationDescription = (output, context) => {
    return take(output, {
        DisableScaleIn: __expectBoolean,
        ScaleInCooldown: __expectInt32,
        ScaleOutCooldown: __expectInt32,
        TargetValue: __limitedParseDouble,
    });
};
const de_BackupDescription = (output, context) => {
    return take(output, {
        BackupDetails: (_) => de_BackupDetails(_, context),
        SourceTableDetails: (_) => de_SourceTableDetails(_, context),
        SourceTableFeatureDetails: (_) => de_SourceTableFeatureDetails(_, context),
    });
};
const de_BackupDetails = (output, context) => {
    return take(output, {
        BackupArn: __expectString,
        BackupCreationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        BackupExpiryDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        BackupName: __expectString,
        BackupSizeBytes: __expectLong,
        BackupStatus: __expectString,
        BackupType: __expectString,
    });
};
const de_BackupSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BackupSummary(entry, context);
    });
    return retVal;
};
const de_BackupSummary = (output, context) => {
    return take(output, {
        BackupArn: __expectString,
        BackupCreationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        BackupExpiryDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        BackupName: __expectString,
        BackupSizeBytes: __expectLong,
        BackupStatus: __expectString,
        BackupType: __expectString,
        TableArn: __expectString,
        TableId: __expectString,
        TableName: __expectString,
    });
};
const de_BatchExecuteStatementOutput = (output, context) => {
    return object_mapping_take(output, {
        ConsumedCapacity: (_) => de_ConsumedCapacityMultiple(_, context),
        Responses: (_) => de_PartiQLBatchResponse(_, context),
    });
};
const de_BatchGetItemOutput = (output, context) => {
    return object_mapping_take(output, {
        ConsumedCapacity: (_) => de_ConsumedCapacityMultiple(_, context),
        Responses: (_) => de_BatchGetResponseMap(_, context),
        UnprocessedKeys: (_) => de_BatchGetRequestMap(_, context),
    });
};
const de_BatchGetRequestMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_KeysAndAttributes(value, context);
        return acc;
    }, {});
};
const de_BatchGetResponseMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_ItemList(value, context);
        return acc;
    }, {});
};
const de_BatchStatementError = (output, context) => {
    return object_mapping_take(output, {
        Code: parse_utils_expectString,
        Item: (_) => de_AttributeMap(_, context),
        Message: parse_utils_expectString,
    });
};
const de_BatchStatementResponse = (output, context) => {
    return object_mapping_take(output, {
        Error: (_) => de_BatchStatementError(_, context),
        Item: (_) => de_AttributeMap(_, context),
        TableName: parse_utils_expectString,
    });
};
const de_BatchWriteItemOutput = (output, context) => {
    return object_mapping_take(output, {
        ConsumedCapacity: (_) => de_ConsumedCapacityMultiple(_, context),
        ItemCollectionMetrics: (_) => de_ItemCollectionMetricsPerTable(_, context),
        UnprocessedItems: (_) => de_BatchWriteItemRequestMap(_, context),
    });
};
const de_BatchWriteItemRequestMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_WriteRequests(value, context);
        return acc;
    }, {});
};
const de_BillingModeSummary = (output, context) => {
    return object_mapping_take(output, {
        BillingMode: parse_utils_expectString,
        LastUpdateToPayPerRequestDateTime: (_) => parse_utils_expectNonNull(date_utils_parseEpochTimestamp(parse_utils_expectNumber(_))),
    });
};
const de_BinarySetAttributeValue = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return context.base64Decoder(entry);
    });
    return retVal;
};
const de_CancellationReason = (output, context) => {
    return object_mapping_take(output, {
        Code: parse_utils_expectString,
        Item: (_) => de_AttributeMap(_, context),
        Message: parse_utils_expectString,
    });
};
const de_CancellationReasonList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CancellationReason(entry, context);
    });
    return retVal;
};
const de_Capacity = (output, context) => {
    return object_mapping_take(output, {
        CapacityUnits: parse_utils_limitedParseDouble,
        ReadCapacityUnits: parse_utils_limitedParseDouble,
        WriteCapacityUnits: parse_utils_limitedParseDouble,
    });
};
const de_ConditionalCheckFailedException = (output, context) => {
    return object_mapping_take(output, {
        Item: (_) => de_AttributeMap(_, context),
        message: parse_utils_expectString,
    });
};
const de_ConsumedCapacity = (output, context) => {
    return object_mapping_take(output, {
        CapacityUnits: parse_utils_limitedParseDouble,
        GlobalSecondaryIndexes: (_) => de_SecondaryIndexesCapacityMap(_, context),
        LocalSecondaryIndexes: (_) => de_SecondaryIndexesCapacityMap(_, context),
        ReadCapacityUnits: parse_utils_limitedParseDouble,
        Table: (_) => de_Capacity(_, context),
        TableName: parse_utils_expectString,
        WriteCapacityUnits: parse_utils_limitedParseDouble,
    });
};
const de_ConsumedCapacityMultiple = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ConsumedCapacity(entry, context);
    });
    return retVal;
};
const de_ContinuousBackupsDescription = (output, context) => {
    return take(output, {
        ContinuousBackupsStatus: __expectString,
        PointInTimeRecoveryDescription: (_) => de_PointInTimeRecoveryDescription(_, context),
    });
};
const de_CreateBackupOutput = (output, context) => {
    return take(output, {
        BackupDetails: (_) => de_BackupDetails(_, context),
    });
};
const de_CreateGlobalTableOutput = (output, context) => {
    return take(output, {
        GlobalTableDescription: (_) => de_GlobalTableDescription(_, context),
    });
};
const de_CreateTableOutput = (output, context) => {
    return take(output, {
        TableDescription: (_) => de_TableDescription(_, context),
    });
};
const de_DeleteBackupOutput = (output, context) => {
    return take(output, {
        BackupDescription: (_) => de_BackupDescription(_, context),
    });
};
const de_DeleteItemOutput = (output, context) => {
    return object_mapping_take(output, {
        Attributes: (_) => de_AttributeMap(_, context),
        ConsumedCapacity: (_) => de_ConsumedCapacity(_, context),
        ItemCollectionMetrics: (_) => de_ItemCollectionMetrics(_, context),
    });
};
const de_DeleteRequest = (output, context) => {
    return object_mapping_take(output, {
        Key: (_) => de_Key(_, context),
    });
};
const de_DeleteTableOutput = (output, context) => {
    return take(output, {
        TableDescription: (_) => de_TableDescription(_, context),
    });
};
const de_DescribeBackupOutput = (output, context) => {
    return take(output, {
        BackupDescription: (_) => de_BackupDescription(_, context),
    });
};
const de_DescribeContinuousBackupsOutput = (output, context) => {
    return take(output, {
        ContinuousBackupsDescription: (_) => de_ContinuousBackupsDescription(_, context),
    });
};
const de_DescribeContributorInsightsOutput = (output, context) => {
    return take(output, {
        ContributorInsightsRuleList: _json,
        ContributorInsightsStatus: __expectString,
        FailureException: _json,
        IndexName: __expectString,
        LastUpdateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        TableName: __expectString,
    });
};
const de_DescribeExportOutput = (output, context) => {
    return take(output, {
        ExportDescription: (_) => de_ExportDescription(_, context),
    });
};
const de_DescribeGlobalTableOutput = (output, context) => {
    return take(output, {
        GlobalTableDescription: (_) => de_GlobalTableDescription(_, context),
    });
};
const de_DescribeGlobalTableSettingsOutput = (output, context) => {
    return take(output, {
        GlobalTableName: __expectString,
        ReplicaSettings: (_) => de_ReplicaSettingsDescriptionList(_, context),
    });
};
const de_DescribeImportOutput = (output, context) => {
    return take(output, {
        ImportTableDescription: (_) => de_ImportTableDescription(_, context),
    });
};
const de_DescribeTableOutput = (output, context) => {
    return object_mapping_take(output, {
        Table: (_) => de_TableDescription(_, context),
    });
};
const de_DescribeTableReplicaAutoScalingOutput = (output, context) => {
    return take(output, {
        TableAutoScalingDescription: (_) => de_TableAutoScalingDescription(_, context),
    });
};
const de_ExecuteStatementOutput = (output, context) => {
    return object_mapping_take(output, {
        ConsumedCapacity: (_) => de_ConsumedCapacity(_, context),
        Items: (_) => de_ItemList(_, context),
        LastEvaluatedKey: (_) => de_Key(_, context),
        NextToken: parse_utils_expectString,
    });
};
const de_ExecuteTransactionOutput = (output, context) => {
    return object_mapping_take(output, {
        ConsumedCapacity: (_) => de_ConsumedCapacityMultiple(_, context),
        Responses: (_) => de_ItemResponseList(_, context),
    });
};
const de_ExportDescription = (output, context) => {
    return take(output, {
        BilledSizeBytes: __expectLong,
        ClientToken: __expectString,
        EndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ExportArn: __expectString,
        ExportFormat: __expectString,
        ExportManifest: __expectString,
        ExportStatus: __expectString,
        ExportTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ExportType: __expectString,
        FailureCode: __expectString,
        FailureMessage: __expectString,
        IncrementalExportSpecification: (_) => de_IncrementalExportSpecification(_, context),
        ItemCount: __expectLong,
        S3Bucket: __expectString,
        S3BucketOwner: __expectString,
        S3Prefix: __expectString,
        S3SseAlgorithm: __expectString,
        S3SseKmsKeyId: __expectString,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        TableArn: __expectString,
        TableId: __expectString,
    });
};
const de_ExportTableToPointInTimeOutput = (output, context) => {
    return take(output, {
        ExportDescription: (_) => de_ExportDescription(_, context),
    });
};
const de_GetItemOutput = (output, context) => {
    return object_mapping_take(output, {
        ConsumedCapacity: (_) => de_ConsumedCapacity(_, context),
        Item: (_) => de_AttributeMap(_, context),
    });
};
const de_GlobalSecondaryIndexDescription = (output, context) => {
    return object_mapping_take(output, {
        Backfilling: parse_utils_expectBoolean,
        IndexArn: parse_utils_expectString,
        IndexName: parse_utils_expectString,
        IndexSizeBytes: parse_utils_expectLong,
        IndexStatus: parse_utils_expectString,
        ItemCount: parse_utils_expectLong,
        KeySchema: serde_json_json,
        OnDemandThroughput: serde_json_json,
        Projection: serde_json_json,
        ProvisionedThroughput: (_) => de_ProvisionedThroughputDescription(_, context),
    });
};
const de_GlobalSecondaryIndexDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GlobalSecondaryIndexDescription(entry, context);
    });
    return retVal;
};
const de_GlobalTableDescription = (output, context) => {
    return take(output, {
        CreationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        GlobalTableArn: __expectString,
        GlobalTableName: __expectString,
        GlobalTableStatus: __expectString,
        ReplicationGroup: (_) => de_ReplicaDescriptionList(_, context),
    });
};
const de_ImportSummary = (output, context) => {
    return take(output, {
        CloudWatchLogGroupArn: __expectString,
        EndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ImportArn: __expectString,
        ImportStatus: __expectString,
        InputFormat: __expectString,
        S3BucketSource: _json,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        TableArn: __expectString,
    });
};
const de_ImportSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ImportSummary(entry, context);
    });
    return retVal;
};
const de_ImportTableDescription = (output, context) => {
    return take(output, {
        ClientToken: __expectString,
        CloudWatchLogGroupArn: __expectString,
        EndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ErrorCount: __expectLong,
        FailureCode: __expectString,
        FailureMessage: __expectString,
        ImportArn: __expectString,
        ImportStatus: __expectString,
        ImportedItemCount: __expectLong,
        InputCompressionType: __expectString,
        InputFormat: __expectString,
        InputFormatOptions: _json,
        ProcessedItemCount: __expectLong,
        ProcessedSizeBytes: __expectLong,
        S3BucketSource: _json,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        TableArn: __expectString,
        TableCreationParameters: _json,
        TableId: __expectString,
    });
};
const de_ImportTableOutput = (output, context) => {
    return take(output, {
        ImportTableDescription: (_) => de_ImportTableDescription(_, context),
    });
};
const de_IncrementalExportSpecification = (output, context) => {
    return take(output, {
        ExportFromTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ExportToTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ExportViewType: __expectString,
    });
};
const de_ItemCollectionKeyAttributeMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_AttributeValue((0,dist_cjs.awsExpectUnion)(value), context);
        return acc;
    }, {});
};
const de_ItemCollectionMetrics = (output, context) => {
    return object_mapping_take(output, {
        ItemCollectionKey: (_) => de_ItemCollectionKeyAttributeMap(_, context),
        SizeEstimateRangeGB: (_) => de_ItemCollectionSizeEstimateRange(_, context),
    });
};
const de_ItemCollectionMetricsMultiple = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ItemCollectionMetrics(entry, context);
    });
    return retVal;
};
const de_ItemCollectionMetricsPerTable = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_ItemCollectionMetricsMultiple(value, context);
        return acc;
    }, {});
};
const de_ItemCollectionSizeEstimateRange = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return parse_utils_limitedParseDouble(entry);
    });
    return retVal;
};
const de_ItemList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AttributeMap(entry, context);
    });
    return retVal;
};
const de_ItemResponse = (output, context) => {
    return object_mapping_take(output, {
        Item: (_) => de_AttributeMap(_, context),
    });
};
const de_ItemResponseList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ItemResponse(entry, context);
    });
    return retVal;
};
const de_Key = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_AttributeValue((0,dist_cjs.awsExpectUnion)(value), context);
        return acc;
    }, {});
};
const de_KeyList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Key(entry, context);
    });
    return retVal;
};
const de_KeysAndAttributes = (output, context) => {
    return object_mapping_take(output, {
        AttributesToGet: serde_json_json,
        ConsistentRead: parse_utils_expectBoolean,
        ExpressionAttributeNames: serde_json_json,
        Keys: (_) => de_KeyList(_, context),
        ProjectionExpression: parse_utils_expectString,
    });
};
const de_ListAttributeValue = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AttributeValue((0,dist_cjs.awsExpectUnion)(entry), context);
    });
    return retVal;
};
const de_ListBackupsOutput = (output, context) => {
    return take(output, {
        BackupSummaries: (_) => de_BackupSummaries(_, context),
        LastEvaluatedBackupArn: __expectString,
    });
};
const de_ListImportsOutput = (output, context) => {
    return take(output, {
        ImportSummaryList: (_) => de_ImportSummaryList(_, context),
        NextToken: __expectString,
    });
};
const de_MapAttributeValue = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_AttributeValue((0,dist_cjs.awsExpectUnion)(value), context);
        return acc;
    }, {});
};
const de_PartiQLBatchResponse = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BatchStatementResponse(entry, context);
    });
    return retVal;
};
const de_PointInTimeRecoveryDescription = (output, context) => {
    return take(output, {
        EarliestRestorableDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        LatestRestorableDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        PointInTimeRecoveryStatus: __expectString,
    });
};
const de_ProvisionedThroughputDescription = (output, context) => {
    return object_mapping_take(output, {
        LastDecreaseDateTime: (_) => parse_utils_expectNonNull(date_utils_parseEpochTimestamp(parse_utils_expectNumber(_))),
        LastIncreaseDateTime: (_) => parse_utils_expectNonNull(date_utils_parseEpochTimestamp(parse_utils_expectNumber(_))),
        NumberOfDecreasesToday: parse_utils_expectLong,
        ReadCapacityUnits: parse_utils_expectLong,
        WriteCapacityUnits: parse_utils_expectLong,
    });
};
const de_PutItemInputAttributeMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_AttributeValue((0,dist_cjs.awsExpectUnion)(value), context);
        return acc;
    }, {});
};
const de_PutItemOutput = (output, context) => {
    return object_mapping_take(output, {
        Attributes: (_) => de_AttributeMap(_, context),
        ConsumedCapacity: (_) => de_ConsumedCapacity(_, context),
        ItemCollectionMetrics: (_) => de_ItemCollectionMetrics(_, context),
    });
};
const de_PutRequest = (output, context) => {
    return object_mapping_take(output, {
        Item: (_) => de_PutItemInputAttributeMap(_, context),
    });
};
const de_QueryOutput = (output, context) => {
    return object_mapping_take(output, {
        ConsumedCapacity: (_) => de_ConsumedCapacity(_, context),
        Count: parse_utils_expectInt32,
        Items: (_) => de_ItemList(_, context),
        LastEvaluatedKey: (_) => de_Key(_, context),
        ScannedCount: parse_utils_expectInt32,
    });
};
const de_ReplicaAutoScalingDescription = (output, context) => {
    return take(output, {
        GlobalSecondaryIndexes: (_) => de_ReplicaGlobalSecondaryIndexAutoScalingDescriptionList(_, context),
        RegionName: __expectString,
        ReplicaProvisionedReadCapacityAutoScalingSettings: (_) => de_AutoScalingSettingsDescription(_, context),
        ReplicaProvisionedWriteCapacityAutoScalingSettings: (_) => de_AutoScalingSettingsDescription(_, context),
        ReplicaStatus: __expectString,
    });
};
const de_ReplicaAutoScalingDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReplicaAutoScalingDescription(entry, context);
    });
    return retVal;
};
const de_ReplicaDescription = (output, context) => {
    return object_mapping_take(output, {
        GlobalSecondaryIndexes: serde_json_json,
        KMSMasterKeyId: parse_utils_expectString,
        OnDemandThroughputOverride: serde_json_json,
        ProvisionedThroughputOverride: serde_json_json,
        RegionName: parse_utils_expectString,
        ReplicaInaccessibleDateTime: (_) => parse_utils_expectNonNull(date_utils_parseEpochTimestamp(parse_utils_expectNumber(_))),
        ReplicaStatus: parse_utils_expectString,
        ReplicaStatusDescription: parse_utils_expectString,
        ReplicaStatusPercentProgress: parse_utils_expectString,
        ReplicaTableClassSummary: (_) => de_TableClassSummary(_, context),
    });
};
const de_ReplicaDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReplicaDescription(entry, context);
    });
    return retVal;
};
const de_ReplicaGlobalSecondaryIndexAutoScalingDescription = (output, context) => {
    return take(output, {
        IndexName: __expectString,
        IndexStatus: __expectString,
        ProvisionedReadCapacityAutoScalingSettings: (_) => de_AutoScalingSettingsDescription(_, context),
        ProvisionedWriteCapacityAutoScalingSettings: (_) => de_AutoScalingSettingsDescription(_, context),
    });
};
const de_ReplicaGlobalSecondaryIndexAutoScalingDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReplicaGlobalSecondaryIndexAutoScalingDescription(entry, context);
    });
    return retVal;
};
const de_ReplicaGlobalSecondaryIndexSettingsDescription = (output, context) => {
    return take(output, {
        IndexName: __expectString,
        IndexStatus: __expectString,
        ProvisionedReadCapacityAutoScalingSettings: (_) => de_AutoScalingSettingsDescription(_, context),
        ProvisionedReadCapacityUnits: __expectLong,
        ProvisionedWriteCapacityAutoScalingSettings: (_) => de_AutoScalingSettingsDescription(_, context),
        ProvisionedWriteCapacityUnits: __expectLong,
    });
};
const de_ReplicaGlobalSecondaryIndexSettingsDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReplicaGlobalSecondaryIndexSettingsDescription(entry, context);
    });
    return retVal;
};
const de_ReplicaSettingsDescription = (output, context) => {
    return take(output, {
        RegionName: __expectString,
        ReplicaBillingModeSummary: (_) => de_BillingModeSummary(_, context),
        ReplicaGlobalSecondaryIndexSettings: (_) => de_ReplicaGlobalSecondaryIndexSettingsDescriptionList(_, context),
        ReplicaProvisionedReadCapacityAutoScalingSettings: (_) => de_AutoScalingSettingsDescription(_, context),
        ReplicaProvisionedReadCapacityUnits: __expectLong,
        ReplicaProvisionedWriteCapacityAutoScalingSettings: (_) => de_AutoScalingSettingsDescription(_, context),
        ReplicaProvisionedWriteCapacityUnits: __expectLong,
        ReplicaStatus: __expectString,
        ReplicaTableClassSummary: (_) => de_TableClassSummary(_, context),
    });
};
const de_ReplicaSettingsDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReplicaSettingsDescription(entry, context);
    });
    return retVal;
};
const de_RestoreSummary = (output, context) => {
    return object_mapping_take(output, {
        RestoreDateTime: (_) => parse_utils_expectNonNull(date_utils_parseEpochTimestamp(parse_utils_expectNumber(_))),
        RestoreInProgress: parse_utils_expectBoolean,
        SourceBackupArn: parse_utils_expectString,
        SourceTableArn: parse_utils_expectString,
    });
};
const de_RestoreTableFromBackupOutput = (output, context) => {
    return take(output, {
        TableDescription: (_) => de_TableDescription(_, context),
    });
};
const de_RestoreTableToPointInTimeOutput = (output, context) => {
    return take(output, {
        TableDescription: (_) => de_TableDescription(_, context),
    });
};
const de_ScanOutput = (output, context) => {
    return object_mapping_take(output, {
        ConsumedCapacity: (_) => de_ConsumedCapacity(_, context),
        Count: parse_utils_expectInt32,
        Items: (_) => de_ItemList(_, context),
        LastEvaluatedKey: (_) => de_Key(_, context),
        ScannedCount: parse_utils_expectInt32,
    });
};
const de_SecondaryIndexesCapacityMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_Capacity(value, context);
        return acc;
    }, {});
};
const de_SourceTableDetails = (output, context) => {
    return take(output, {
        BillingMode: __expectString,
        ItemCount: __expectLong,
        KeySchema: _json,
        OnDemandThroughput: _json,
        ProvisionedThroughput: _json,
        TableArn: __expectString,
        TableCreationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        TableId: __expectString,
        TableName: __expectString,
        TableSizeBytes: __expectLong,
    });
};
const de_SourceTableFeatureDetails = (output, context) => {
    return take(output, {
        GlobalSecondaryIndexes: _json,
        LocalSecondaryIndexes: _json,
        SSEDescription: (_) => de_SSEDescription(_, context),
        StreamDescription: _json,
        TimeToLiveDescription: _json,
    });
};
const de_SSEDescription = (output, context) => {
    return object_mapping_take(output, {
        InaccessibleEncryptionDateTime: (_) => parse_utils_expectNonNull(date_utils_parseEpochTimestamp(parse_utils_expectNumber(_))),
        KMSMasterKeyArn: parse_utils_expectString,
        SSEType: parse_utils_expectString,
        Status: parse_utils_expectString,
    });
};
const de_TableAutoScalingDescription = (output, context) => {
    return take(output, {
        Replicas: (_) => de_ReplicaAutoScalingDescriptionList(_, context),
        TableName: __expectString,
        TableStatus: __expectString,
    });
};
const de_TableClassSummary = (output, context) => {
    return object_mapping_take(output, {
        LastUpdateDateTime: (_) => parse_utils_expectNonNull(date_utils_parseEpochTimestamp(parse_utils_expectNumber(_))),
        TableClass: parse_utils_expectString,
    });
};
const de_TableDescription = (output, context) => {
    return object_mapping_take(output, {
        ArchivalSummary: (_) => de_ArchivalSummary(_, context),
        AttributeDefinitions: serde_json_json,
        BillingModeSummary: (_) => de_BillingModeSummary(_, context),
        CreationDateTime: (_) => parse_utils_expectNonNull(date_utils_parseEpochTimestamp(parse_utils_expectNumber(_))),
        DeletionProtectionEnabled: parse_utils_expectBoolean,
        GlobalSecondaryIndexes: (_) => de_GlobalSecondaryIndexDescriptionList(_, context),
        GlobalTableVersion: parse_utils_expectString,
        ItemCount: parse_utils_expectLong,
        KeySchema: serde_json_json,
        LatestStreamArn: parse_utils_expectString,
        LatestStreamLabel: parse_utils_expectString,
        LocalSecondaryIndexes: serde_json_json,
        OnDemandThroughput: serde_json_json,
        ProvisionedThroughput: (_) => de_ProvisionedThroughputDescription(_, context),
        Replicas: (_) => de_ReplicaDescriptionList(_, context),
        RestoreSummary: (_) => de_RestoreSummary(_, context),
        SSEDescription: (_) => de_SSEDescription(_, context),
        StreamSpecification: serde_json_json,
        TableArn: parse_utils_expectString,
        TableClassSummary: (_) => de_TableClassSummary(_, context),
        TableId: parse_utils_expectString,
        TableName: parse_utils_expectString,
        TableSizeBytes: parse_utils_expectLong,
        TableStatus: parse_utils_expectString,
    });
};
const de_TransactGetItemsOutput = (output, context) => {
    return object_mapping_take(output, {
        ConsumedCapacity: (_) => de_ConsumedCapacityMultiple(_, context),
        Responses: (_) => de_ItemResponseList(_, context),
    });
};
const de_TransactionCanceledException = (output, context) => {
    return object_mapping_take(output, {
        CancellationReasons: (_) => de_CancellationReasonList(_, context),
        Message: parse_utils_expectString,
    });
};
const de_TransactWriteItemsOutput = (output, context) => {
    return object_mapping_take(output, {
        ConsumedCapacity: (_) => de_ConsumedCapacityMultiple(_, context),
        ItemCollectionMetrics: (_) => de_ItemCollectionMetricsPerTable(_, context),
    });
};
const de_UpdateContinuousBackupsOutput = (output, context) => {
    return take(output, {
        ContinuousBackupsDescription: (_) => de_ContinuousBackupsDescription(_, context),
    });
};
const de_UpdateGlobalTableOutput = (output, context) => {
    return take(output, {
        GlobalTableDescription: (_) => de_GlobalTableDescription(_, context),
    });
};
const de_UpdateGlobalTableSettingsOutput = (output, context) => {
    return take(output, {
        GlobalTableName: __expectString,
        ReplicaSettings: (_) => de_ReplicaSettingsDescriptionList(_, context),
    });
};
const de_UpdateItemOutput = (output, context) => {
    return object_mapping_take(output, {
        Attributes: (_) => de_AttributeMap(_, context),
        ConsumedCapacity: (_) => de_ConsumedCapacity(_, context),
        ItemCollectionMetrics: (_) => de_ItemCollectionMetrics(_, context),
    });
};
const de_UpdateTableOutput = (output, context) => {
    return take(output, {
        TableDescription: (_) => de_TableDescription(_, context),
    });
};
const de_UpdateTableReplicaAutoScalingOutput = (output, context) => {
    return take(output, {
        TableAutoScalingDescription: (_) => de_TableAutoScalingDescription(_, context),
    });
};
const de_WriteRequest = (output, context) => {
    return object_mapping_take(output, {
        DeleteRequest: (_) => de_DeleteRequest(_, context),
        PutRequest: (_) => de_PutRequest(_, context),
    });
};
const de_WriteRequests = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_WriteRequest(entry, context);
    });
    return retVal;
};
const Aws_json1_0_deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const Aws_json1_0_collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const Aws_json1_0_throwDefaultError = default_error_handler_withBaseException(DynamoDBServiceException);
const Aws_json1_0_buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new dist_es_httpRequest_HttpRequest(contents);
};
function sharedHeaders(operation) {
    return {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": `DynamoDB_20120810.${operation}`,
    };
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/BatchExecuteStatementCommand.js






class BatchExecuteStatementCommand_BatchExecuteStatementCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "BatchExecuteStatement", {})
    .n("DynamoDBClient", "BatchExecuteStatementCommand")
    .f(void 0, void 0)
    .ser(se_BatchExecuteStatementCommand)
    .de(de_BatchExecuteStatementCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
const dist_es_MiddlewareStack_getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const dist_es_MiddlewareStack_getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const dist_es_MiddlewareStack_constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => dist_es_MiddlewareStack_stepWeights[b.step] - dist_es_MiddlewareStack_stepWeights[a.step] ||
        dist_es_MiddlewareStack_priorityWeights[b.priority || "normal"] - dist_es_MiddlewareStack_priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = dist_es_MiddlewareStack_getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of dist_es_MiddlewareStack_getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of dist_es_MiddlewareStack_getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of dist_es_MiddlewareStack_getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${dist_es_MiddlewareStack_getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = dist_es_MiddlewareStack_getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${dist_es_MiddlewareStack_getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${dist_es_MiddlewareStack_getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${dist_es_MiddlewareStack_getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = dist_es_MiddlewareStack_getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${dist_es_MiddlewareStack_getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${dist_es_MiddlewareStack_getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${dist_es_MiddlewareStack_getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo(dist_es_MiddlewareStack_constructStack()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = dist_es_MiddlewareStack_getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo(dist_es_MiddlewareStack_constructStack());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                const step = mw.step ??
                    mw.relation +
                        " " +
                        mw.toMiddleware;
                return dist_es_MiddlewareStack_getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
const dist_es_MiddlewareStack_stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const dist_es_MiddlewareStack_priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};

;// CONCATENATED MODULE: ./node_modules/@smithy/middleware-stack/dist-es/index.js


;// CONCATENATED MODULE: ./node_modules/@smithy/smithy-client/dist-es/client.js

class dist_es_client_Client {
    constructor(config) {
        this.middlewareStack = dist_es_MiddlewareStack_constructStack();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/util-buffer-from/dist-es/index.js


const _smithy_util_buffer_from_dist_es_fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return Buffer.from(input, offset, length);
};
const _smithy_util_buffer_from_dist_es_fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? Buffer.from(input, encoding) : Buffer.from(input);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-base64/dist-es/fromBase64.js

const dist_es_fromBase64_BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const util_base64_dist_es_fromBase64_fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!dist_es_fromBase64_BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = fromString(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-utf8/dist-es/fromUtf8.js

const util_utf8_dist_es_fromUtf8_fromUtf8 = (input) => {
    const buf = fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-utf8/dist-es/toUint8Array.js

const dist_es_toUint8Array_toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-utf8/dist-es/toUtf8.js

const util_utf8_dist_es_toUtf8_toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-utf8/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/util-base64/dist-es/toBase64.js


const util_base64_dist_es_toBase64_toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
        input = fromUtf8(_input);
    }
    else {
        input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-base64/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@smithy/util-stream/dist-es/blob/transforms.js



function dist_es_blob_transforms_transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return toBase64(payload);
    }
    return toUtf8(payload);
}
function dist_es_blob_transforms_transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
}

;// CONCATENATED MODULE: ./node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js

class dist_es_blob_Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter extends (/* unused pure expression or super */ null && (Uint8Array)) {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return transformFromString(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, dist_es_blob_Uint8ArrayBlobAdapter_Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.js

const dist_es_getAwsChunkedEncodingStream_getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/types/dist-es/auth/auth.js
var auth_auth_HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(auth_auth_HttpAuthLocation || (auth_auth_HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var auth_HttpApiKeyAuth_HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(auth_HttpApiKeyAuth_HttpApiKeyAuthLocation || (auth_HttpApiKeyAuth_HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@smithy/types/dist-es/endpoint.js
var dist_es_endpoint_EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(dist_es_endpoint_EndpointURLScheme || (dist_es_endpoint_EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/types/dist-es/extensions/checksum.js
var dist_es_extensions_checksum_AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(dist_es_extensions_checksum_AlgorithmId || (dist_es_extensions_checksum_AlgorithmId = {}));
const types_dist_es_extensions_checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => dist_es_extensions_checksum_AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => dist_es_extensions_checksum_AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const types_dist_es_extensions_checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const extensions_defaultClientConfiguration_getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const extensions_defaultClientConfiguration_resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/types/dist-es/http.js
var types_dist_es_http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(types_dist_es_http_FieldPosition || (types_dist_es_http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/types/dist-es/middleware.js
const dist_es_middleware_SMITHY_CONTEXT_KEY = "__smithy_context";

;// CONCATENATED MODULE: ./node_modules/@smithy/types/dist-es/profile.js
var types_dist_es_profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(types_dist_es_profile_IniSectionType || (types_dist_es_profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/types/dist-es/transfer.js
var dist_es_transfer_RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(dist_es_transfer_RequestHandlerProtocol || (dist_es_transfer_RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@smithy/protocol-http/dist-es/Field.js

class dist_es_Field_Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/protocol-http/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@smithy/node-http-handler/dist-es/write-request-body.js

const dist_es_write_request_body_MIN_WAIT_TIME = 1000;
async function node_http_handler_dist_es_write_request_body_writeRequestBody(httpRequest, request, maxContinueTimeoutMs = dist_es_write_request_body_MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(setTimeout(resolve, Math.max(dist_es_write_request_body_MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", () => {
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            }),
        ]);
    }
    if (!hasError) {
        dist_es_write_request_body_writeBody(httpRequest, request.body);
    }
}
function dist_es_write_request_body_writeBody(httpRequest, body) {
    if (body instanceof Readable) {
        body.pipe(httpRequest);
        return;
    }
    if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
            httpRequest.end(body);
            return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" &&
            uint8.buffer &&
            typeof uint8.byteOffset === "number" &&
            typeof uint8.byteLength === "number") {
            httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
            return;
        }
        httpRequest.end(Buffer.from(body));
        return;
    }
    httpRequest.end();
}

;// CONCATENATED MODULE: ./node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js










const dist_es_node_http_handler_DEFAULT_REQUEST_TIMEOUT = 0;
class dist_es_node_http_handler_NodeHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new dist_es_node_http_handler_NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
            return socketWarningTimestamp;
        }
        const interval = 15000;
        if (Date.now() - interval < socketWarningTimestamp) {
            return socketWarningTimestamp;
        }
        if (sockets && requests) {
            for (const origin in sockets) {
                const socketsInUse = sockets[origin]?.length ?? 0;
                const requestsEnqueued = requests[origin]?.length ?? 0;
                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
                    console.warn("@smithy/node-http-handler:WARN", `socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.`, "See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html", "or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.");
                    return Date.now();
                }
            }
        }
        return socketWarningTimestamp;
    }
    constructor(options) {
        this.socketWarningTimestamp = 0;
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout ?? socketTimeout,
            httpAgent: (() => {
                if (httpAgent instanceof hAgent || typeof httpAgent?.destroy === "function") {
                    return httpAgent;
                }
                return new hAgent({ keepAlive, maxSockets, ...httpAgent });
            })(),
            httpsAgent: (() => {
                if (httpsAgent instanceof hsAgent || typeof httpsAgent?.destroy === "function") {
                    return httpsAgent;
                }
                return new hsAgent({ keepAlive, maxSockets, ...httpsAgent });
            })(),
        };
    }
    destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        let socketCheckTimeoutId;
        return new Promise((_resolve, _reject) => {
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                clearTimeout(socketCheckTimeoutId);
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
            socketCheckTimeoutId = setTimeout(() => {
                this.socketWarningTimestamp = dist_es_node_http_handler_NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp);
            }, this.config.socketAcquisitionWarningTimeout ?? (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000));
            const queryString = buildQueryString(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent,
                auth,
            };
            const requestFunc = isSSL ? hsRequest : hRequest;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: getTransformedHeaders(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            setConnectionTimeout(req, reject, this.config.connectionTimeout);
            setSocketTimeout(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                setSocketKeepAlive(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                });
            }
            writeRequestBodyPromise = writeRequestBody(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
class node_http_handler_dist_es_node_http2_connection_pool_NodeHttp2ConnectionPool {
    constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions ?? [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-manager.js


class node_http_handler_dist_es_node_http2_connection_manager_NodeHttp2ConnectionManager {
    constructor(config) {
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/node-http-handler/dist-es/node-http2-handler.js






class dist_es_node_http2_handler_NodeHttp2Handler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new dist_es_node_http2_handler_NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal?.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: this.config?.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = buildQueryString(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [constants.HTTP2_HEADER_PATH]: path,
                [constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: getTransformedHeaders(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js

class dist_es_stream_collector_collector_Collector extends external_stream_.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js

const _smithy_node_http_handler_dist_es_stream_collector_streamCollector = (stream) => new Promise((resolve, reject) => {
    const collector = new Collector();
    stream.pipe(collector);
    stream.on("error", (err) => {
        collector.end();
        reject(err);
    });
    collector.on("error", reject);
    collector.on("finish", function () {
        const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
        resolve(bytes);
    });
});

;// CONCATENATED MODULE: ./node_modules/@smithy/node-http-handler/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js




const util_stream_dist_es_sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const util_stream_dist_es_sdk_stream_mixin_sdkStreamMixin = (stream) => {
    if (!(stream instanceof Readable)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(util_stream_dist_es_sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(util_stream_dist_es_sdk_stream_mixin_ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return Readable.toWeb(stream);
        },
    });
};

;// CONCATENATED MODULE: ./node_modules/@smithy/util-stream/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js

const smithy_client_dist_es_collect_stream_body_collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/smithy-client/dist-es/command.js


class dist_es_command_Command {
    constructor() {
        this.middlewareStack = dist_es_MiddlewareStack_constructStack();
    }
    static classBuilder() {
        return new dist_es_command_ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [dist_es_middleware_SMITHY_CONTEXT_KEY]: {
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
class dist_es_command_ClassBuilder {
    constructor() {
        this._init = () => { };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
    }
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends dist_es_command_Command {
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(...[input]) {
                super();
                this.serialize = closure._serializer;
                this.deserialize = closure._deserializer;
                this.input = input ?? {};
                closure._init(this);
            }
            resolveMiddleware(stack, configuration, options) {
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/smithy-client/dist-es/parse-utils.js
const dist_es_parse_utils_parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
const dist_es_parse_utils_expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            dist_es_parse_utils_logger.warn(dist_es_parse_utils_stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            dist_es_parse_utils_logger.warn(dist_es_parse_utils_stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
const dist_es_parse_utils_expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                dist_es_parse_utils_logger.warn(dist_es_parse_utils_stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
const dist_es_parse_utils_MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const dist_es_parse_utils_expectFloat32 = (value) => {
    const expected = dist_es_parse_utils_expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > dist_es_parse_utils_MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
const dist_es_parse_utils_expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
const dist_es_parse_utils_expectInt = (/* unused pure expression or super */ null && (dist_es_parse_utils_expectLong));
const dist_es_parse_utils_expectInt32 = (value) => dist_es_parse_utils_expectSizedInt(value, 32);
const dist_es_parse_utils_expectShort = (value) => dist_es_parse_utils_expectSizedInt(value, 16);
const dist_es_parse_utils_expectByte = (value) => dist_es_parse_utils_expectSizedInt(value, 8);
const dist_es_parse_utils_expectSizedInt = (value, size) => {
    const expected = dist_es_parse_utils_expectLong(value);
    if (expected !== undefined && dist_es_parse_utils_castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const dist_es_parse_utils_castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const dist_es_parse_utils_expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
const dist_es_parse_utils_expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
const dist_es_parse_utils_expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        dist_es_parse_utils_logger.warn(dist_es_parse_utils_stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
const dist_es_parse_utils_expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = dist_es_parse_utils_expectObject(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
const smithy_client_dist_es_parse_utils_strictParseDouble = (value) => {
    if (typeof value == "string") {
        return dist_es_parse_utils_expectNumber(dist_es_parse_utils_parseNumber(value));
    }
    return dist_es_parse_utils_expectNumber(value);
};
const dist_es_parse_utils_strictParseFloat = (/* unused pure expression or super */ null && (smithy_client_dist_es_parse_utils_strictParseDouble));
const smithy_client_dist_es_parse_utils_strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return dist_es_parse_utils_expectFloat32(dist_es_parse_utils_parseNumber(value));
    }
    return dist_es_parse_utils_expectFloat32(value);
};
const dist_es_parse_utils_NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const dist_es_parse_utils_parseNumber = (value) => {
    const matches = value.match(dist_es_parse_utils_NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const dist_es_parse_utils_limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return dist_es_parse_utils_parseFloatString(value);
    }
    return dist_es_parse_utils_expectNumber(value);
};
const dist_es_parse_utils_handleFloat = (/* unused pure expression or super */ null && (dist_es_parse_utils_limitedParseDouble));
const dist_es_parse_utils_limitedParseFloat = (/* unused pure expression or super */ null && (dist_es_parse_utils_limitedParseDouble));
const dist_es_parse_utils_limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return dist_es_parse_utils_parseFloatString(value);
    }
    return dist_es_parse_utils_expectFloat32(value);
};
const dist_es_parse_utils_parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const dist_es_parse_utils_strictParseLong = (value) => {
    if (typeof value === "string") {
        return dist_es_parse_utils_expectLong(dist_es_parse_utils_parseNumber(value));
    }
    return dist_es_parse_utils_expectLong(value);
};
const dist_es_parse_utils_strictParseInt = (/* unused pure expression or super */ null && (dist_es_parse_utils_strictParseLong));
const dist_es_parse_utils_strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return dist_es_parse_utils_expectInt32(dist_es_parse_utils_parseNumber(value));
    }
    return dist_es_parse_utils_expectInt32(value);
};
const smithy_client_dist_es_parse_utils_strictParseShort = (value) => {
    if (typeof value === "string") {
        return dist_es_parse_utils_expectShort(dist_es_parse_utils_parseNumber(value));
    }
    return dist_es_parse_utils_expectShort(value);
};
const smithy_client_dist_es_parse_utils_strictParseByte = (value) => {
    if (typeof value === "string") {
        return dist_es_parse_utils_expectByte(dist_es_parse_utils_parseNumber(value));
    }
    return dist_es_parse_utils_expectByte(value);
};
const dist_es_parse_utils_stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
const dist_es_parse_utils_logger = {
    warn: console.warn,
};

;// CONCATENATED MODULE: ./node_modules/@smithy/smithy-client/dist-es/date-utils.js

const dist_es_date_utils_DAYS = (/* unused pure expression or super */ null && (["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]));
const dist_es_date_utils_MONTHS = (/* unused pure expression or super */ null && (["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]));
function dist_es_date_utils_dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${dist_es_date_utils_DAYS[dayOfWeek]}, ${dayOfMonthString} ${dist_es_date_utils_MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
const dist_es_date_utils_RFC3339 = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/)));
const dist_es_date_utils_parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = dist_es_date_utils_RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(dist_es_date_utils_stripLeadingZeroes(yearStr));
    const month = dist_es_date_utils_parseDateValue(monthStr, "month", 1, 12);
    const day = dist_es_date_utils_parseDateValue(dayStr, "day", 1, 31);
    return dist_es_date_utils_buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
const dist_es_date_utils_RFC3339_WITH_OFFSET = (/* unused pure expression or super */ null && (new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/)));
const dist_es_date_utils_parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = dist_es_date_utils_RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(dist_es_date_utils_stripLeadingZeroes(yearStr));
    const month = dist_es_date_utils_parseDateValue(monthStr, "month", 1, 12);
    const day = dist_es_date_utils_parseDateValue(dayStr, "day", 1, 31);
    const date = dist_es_date_utils_buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - dist_es_date_utils_parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
const dist_es_date_utils_IMF_FIXDATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const dist_es_date_utils_RFC_850_DATE = (/* unused pure expression or super */ null && (new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)));
const dist_es_date_utils_ASC_TIME = (/* unused pure expression or super */ null && (new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/)));
const dist_es_date_utils_parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = dist_es_date_utils_IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return dist_es_date_utils_buildDate(strictParseShort(dist_es_date_utils_stripLeadingZeroes(yearStr)), dist_es_date_utils_parseMonthByShortName(monthStr), dist_es_date_utils_parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = dist_es_date_utils_RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return dist_es_date_utils_adjustRfc850Year(dist_es_date_utils_buildDate(dist_es_date_utils_parseTwoDigitYear(yearStr), dist_es_date_utils_parseMonthByShortName(monthStr), dist_es_date_utils_parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = dist_es_date_utils_ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return dist_es_date_utils_buildDate(strictParseShort(dist_es_date_utils_stripLeadingZeroes(yearStr)), dist_es_date_utils_parseMonthByShortName(monthStr), dist_es_date_utils_parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
const dist_es_date_utils_parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
const dist_es_date_utils_buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    dist_es_date_utils_validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, dist_es_date_utils_parseDateValue(time.hours, "hour", 0, 23), dist_es_date_utils_parseDateValue(time.minutes, "minute", 0, 59), dist_es_date_utils_parseDateValue(time.seconds, "seconds", 0, 60), dist_es_date_utils_parseMilliseconds(time.fractionalMilliseconds)));
};
const dist_es_date_utils_parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(dist_es_date_utils_stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const dist_es_date_utils_FIFTY_YEARS_IN_MILLIS = (/* unused pure expression or super */ null && (50 * 365 * 24 * 60 * 60 * 1000));
const dist_es_date_utils_adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > dist_es_date_utils_FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const dist_es_date_utils_parseMonthByShortName = (value) => {
    const monthIdx = dist_es_date_utils_MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const dist_es_date_utils_DAYS_IN_MONTH = (/* unused pure expression or super */ null && ([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]));
const dist_es_date_utils_validateDayOfMonth = (year, month, day) => {
    let maxDays = dist_es_date_utils_DAYS_IN_MONTH[month];
    if (month === 1 && dist_es_date_utils_isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${dist_es_date_utils_MONTHS[month]} in ${year}: ${day}`);
    }
};
const dist_es_date_utils_isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const dist_es_date_utils_parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(dist_es_date_utils_stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const dist_es_date_utils_parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
};
const dist_es_date_utils_parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const dist_es_date_utils_stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};

;// CONCATENATED MODULE: ./node_modules/@smithy/smithy-client/dist-es/exceptions.js
class dist_es_exceptions_ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, dist_es_exceptions_ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
const smithy_client_dist_es_exceptions_decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/smithy-client/dist-es/default-error-handler.js

const dist_es_default_error_handler_throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = dist_es_default_error_handler_deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw decorateServiceException(response, parsedBody);
};
const dist_es_default_error_handler_withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        dist_es_default_error_handler_throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
const dist_es_default_error_handler_deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});

;// CONCATENATED MODULE: ./node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js


const _smithy_smithy_client_dist_es_extensions_checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in AlgorithmId) {
        const algorithmId = AlgorithmId[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const _smithy_smithy_client_dist_es_extensions_checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js


const extensions_defaultExtensionConfiguration_getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
        ...getRetryConfiguration(runtimeConfig),
    };
};
const dist_es_extensions_defaultExtensionConfiguration_getDefaultClientConfiguration = (/* unused pure expression or super */ null && (extensions_defaultExtensionConfiguration_getDefaultExtensionConfiguration));
const dist_es_extensions_defaultExtensionConfiguration_resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
        ...resolveRetryRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@smithy/smithy-client/dist-es/extensions/index.js


;// CONCATENATED MODULE: ./node_modules/@smithy/smithy-client/dist-es/lazy-json.js
const dist_es_lazy_json_StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
dist_es_lazy_json_StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: dist_es_lazy_json_StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(dist_es_lazy_json_StringWrapper, String);
class dist_es_lazy_json_LazyJsonString extends (/* unused pure expression or super */ null && (dist_es_lazy_json_StringWrapper)) {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof dist_es_lazy_json_LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new dist_es_lazy_json_LazyJsonString(object);
        }
        return new dist_es_lazy_json_LazyJsonString(JSON.stringify(object));
    }
}

;// CONCATENATED MODULE: ./node_modules/@smithy/smithy-client/dist-es/index.js























;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-dynamodb/dist-es/NumberValue.js
class NumberValue {
    constructor(value) {
        if (typeof value === "object" && "N" in value) {
            this.value = String(value.N);
        }
        else {
            this.value = String(value);
        }
        const valueOf = typeof value.valueOf() === "number" ? value.valueOf() : 0;
        const imprecise = valueOf > Number.MAX_SAFE_INTEGER ||
            valueOf < Number.MIN_SAFE_INTEGER ||
            Math.abs(valueOf) === Infinity ||
            Number.isNaN(valueOf);
        if (imprecise) {
            throw new Error(`NumberValue should not be initialized with an imprecise number=${valueOf}. Use a string instead.`);
        }
    }
    static from(value) {
        return new NumberValue(value);
    }
    toAttributeValue() {
        return {
            N: this.toString(),
        };
    }
    toBigInt() {
        const stringValue = this.toString();
        return BigInt(stringValue);
    }
    toString() {
        return String(this.value);
    }
    valueOf() {
        return this.toString();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-dynamodb/dist-es/convertToAttr.js

const convertToAttr = (data, options) => {
    if (data === undefined) {
        throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);
    }
    else if (data === null && typeof data === "object") {
        return convertToNullAttr();
    }
    else if (Array.isArray(data)) {
        return convertToListAttr(data, options);
    }
    else if (data?.constructor?.name === "Set") {
        return convertToSetAttr(data, options);
    }
    else if (data?.constructor?.name === "Map") {
        return convertToMapAttrFromIterable(data, options);
    }
    else if (data?.constructor?.name === "Object" ||
        (!data.constructor && typeof data === "object")) {
        return convertToMapAttrFromEnumerableProps(data, options);
    }
    else if (isBinary(data)) {
        if (data.length === 0 && options?.convertEmptyValues) {
            return convertToNullAttr();
        }
        return convertToBinaryAttr(data);
    }
    else if (typeof data === "boolean" || data?.constructor?.name === "Boolean") {
        return { BOOL: data.valueOf() };
    }
    else if (typeof data === "number" || data?.constructor?.name === "Number") {
        return convertToNumberAttr(data);
    }
    else if (data instanceof NumberValue) {
        return data.toAttributeValue();
    }
    else if (typeof data === "bigint") {
        return convertToBigIntAttr(data);
    }
    else if (typeof data === "string" || data?.constructor?.name === "String") {
        if (data.length === 0 && options?.convertEmptyValues) {
            return convertToNullAttr();
        }
        return convertToStringAttr(data);
    }
    else if (options?.convertClassInstanceToMap && typeof data === "object") {
        return convertToMapAttrFromEnumerableProps(data, options);
    }
    throw new Error(`Unsupported type passed: ${data}. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`);
};
const convertToListAttr = (data, options) => ({
    L: data
        .filter((item) => typeof item !== "function" &&
        (!options?.removeUndefinedValues || (options?.removeUndefinedValues && item !== undefined)))
        .map((item) => convertToAttr(item, options)),
});
const convertToSetAttr = (set, options) => {
    const setToOperate = options?.removeUndefinedValues ? new Set([...set].filter((value) => value !== undefined)) : set;
    if (!options?.removeUndefinedValues && setToOperate.has(undefined)) {
        throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);
    }
    if (setToOperate.size === 0) {
        if (options?.convertEmptyValues) {
            return convertToNullAttr();
        }
        throw new Error(`Pass a non-empty set, or options.convertEmptyValues=true.`);
    }
    const item = setToOperate.values().next().value;
    if (item instanceof NumberValue) {
        return {
            NS: Array.from(setToOperate).map((_) => _.toString()),
        };
    }
    else if (typeof item === "number") {
        return {
            NS: Array.from(setToOperate)
                .map(convertToNumberAttr)
                .map((item) => item.N),
        };
    }
    else if (typeof item === "bigint") {
        return {
            NS: Array.from(setToOperate)
                .map(convertToBigIntAttr)
                .map((item) => item.N),
        };
    }
    else if (typeof item === "string") {
        return {
            SS: Array.from(setToOperate)
                .map(convertToStringAttr)
                .map((item) => item.S),
        };
    }
    else if (isBinary(item)) {
        return {
            BS: Array.from(setToOperate)
                .map(convertToBinaryAttr)
                .map((item) => item.B),
        };
    }
    else {
        throw new Error(`Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.`);
    }
};
const convertToMapAttrFromIterable = (data, options) => ({
    M: ((data) => {
        const map = {};
        for (const [key, value] of data) {
            if (typeof value !== "function" && (value !== undefined || !options?.removeUndefinedValues)) {
                map[key] = convertToAttr(value, options);
            }
        }
        return map;
    })(data),
});
const convertToMapAttrFromEnumerableProps = (data, options) => ({
    M: ((data) => {
        const map = {};
        for (const key in data) {
            const value = data[key];
            if (typeof value !== "function" && (value !== undefined || !options?.removeUndefinedValues)) {
                map[key] = convertToAttr(value, options);
            }
        }
        return map;
    })(data),
});
const convertToNullAttr = () => ({ NULL: true });
const convertToBinaryAttr = (data) => ({ B: data });
const convertToStringAttr = (data) => ({ S: data.toString() });
const convertToBigIntAttr = (data) => ({ N: data.toString() });
const validateBigIntAndThrow = (errorPrefix) => {
    throw new Error(`${errorPrefix} ${typeof BigInt === "function" ? "Use BigInt." : "Pass string value instead."} `);
};
const convertToNumberAttr = (num) => {
    if ([Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY]
        .map((val) => val.toString())
        .includes(num.toString())) {
        throw new Error(`Special numeric value ${num.toString()} is not allowed`);
    }
    else if (num > Number.MAX_SAFE_INTEGER) {
        validateBigIntAndThrow(`Number ${num.toString()} is greater than Number.MAX_SAFE_INTEGER.`);
    }
    else if (num < Number.MIN_SAFE_INTEGER) {
        validateBigIntAndThrow(`Number ${num.toString()} is lesser than Number.MIN_SAFE_INTEGER.`);
    }
    return { N: num.toString() };
};
const isBinary = (data) => {
    const binaryTypes = [
        "ArrayBuffer",
        "Blob",
        "Buffer",
        "DataView",
        "File",
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Uint16Array",
        "Int32Array",
        "Uint32Array",
        "Float32Array",
        "Float64Array",
        "BigInt64Array",
        "BigUint64Array",
    ];
    if (data?.constructor) {
        return binaryTypes.includes(data.constructor.name);
    }
    return false;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-dynamodb/dist-es/marshall.js

function marshall(data, options) {
    const attributeValue = convertToAttr(data, options);
    const [key, value] = Object.entries(attributeValue)[0];
    switch (key) {
        case "M":
        case "L":
            return options?.convertTopLevelContainer ? attributeValue : value;
        case "SS":
        case "NS":
        case "BS":
        case "S":
        case "N":
        case "B":
        case "NULL":
        case "BOOL":
        case "$unknown":
        default:
            return attributeValue;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-dynamodb/dist-es/convertToNative.js

const convertToNative = (data, options) => {
    for (const [key, value] of Object.entries(data)) {
        if (value !== undefined) {
            switch (key) {
                case "NULL":
                    return null;
                case "BOOL":
                    return Boolean(value);
                case "N":
                    return convertNumber(value, options);
                case "B":
                    return convertBinary(value);
                case "S":
                    return convertString(value);
                case "L":
                    return convertList(value, options);
                case "M":
                    return convertToNative_convertMap(value, options);
                case "NS":
                    return new Set(value.map((item) => convertNumber(item, options)));
                case "BS":
                    return new Set(value.map(convertBinary));
                case "SS":
                    return new Set(value.map(convertString));
                default:
                    throw new Error(`Unsupported type passed: ${key}`);
            }
        }
    }
    throw new Error(`No value defined: ${JSON.stringify(data)}`);
};
const convertNumber = (numString, options) => {
    if (options?.wrapNumbers) {
        return NumberValue.from(numString);
    }
    const num = Number(numString);
    const infinityValues = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
    const isLargeFiniteNumber = (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) && !infinityValues.includes(num);
    if (isLargeFiniteNumber) {
        if (typeof BigInt === "function") {
            try {
                return BigInt(numString);
            }
            catch (error) {
                throw new Error(`${numString} can't be converted to BigInt. Set options.wrapNumbers to get string value.`);
            }
        }
        else {
            throw new Error(`${numString} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);
        }
    }
    return num;
};
const convertString = (stringValue) => stringValue;
const convertBinary = (binaryValue) => binaryValue;
const convertList = (list, options) => list.map((item) => convertToNative(item, options));
const convertToNative_convertMap = (map, options) => Object.entries(map).reduce((acc, [key, value]) => ((acc[key] = convertToNative(value, options)), acc), {});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/util-dynamodb/dist-es/unmarshall.js

const unmarshall = (data, options) => {
    if (options?.convertWithoutMapWrapper) {
        return convertToNative(data, options);
    }
    return convertToNative({ M: data }, options);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/utils.js

const SELF = null;
const ALL_VALUES = {};
const ALL_MEMBERS = [];
const NEXT_LEVEL = "*";
const processObj = (obj, processFunc, keyNodes) => {
    if (obj !== undefined) {
        if (keyNodes == null) {
            return processFunc(obj);
        }
        else {
            const keys = Object.keys(keyNodes);
            const goToNextLevel = keys.length === 1 && keys[0] === NEXT_LEVEL;
            const someChildren = keys.length >= 1 && !goToNextLevel;
            const allChildren = keys.length === 0;
            if (someChildren) {
                return processKeysInObj(obj, processFunc, keyNodes);
            }
            else if (allChildren) {
                return processAllKeysInObj(obj, processFunc, SELF);
            }
            else if (goToNextLevel) {
                return Object.entries(obj ?? {}).reduce((acc, [k, v]) => {
                    if (typeof v !== "function") {
                        acc[k] = processObj(v, processFunc, keyNodes[NEXT_LEVEL]);
                    }
                    return acc;
                }, (Array.isArray(obj) ? [] : {}));
            }
        }
    }
    return undefined;
};
const processKeysInObj = (obj, processFunc, keyNodes) => {
    let accumulator;
    if (Array.isArray(obj)) {
        accumulator = [...obj].filter((item) => typeof item !== "function");
    }
    else {
        accumulator = {};
        for (const [k, v] of Object.entries(obj)) {
            if (typeof v !== "function") {
                accumulator[k] = v;
            }
        }
    }
    for (const [nodeKey, nodes] of Object.entries(keyNodes)) {
        if (typeof obj[nodeKey] === "function") {
            continue;
        }
        const processedValue = processObj(obj[nodeKey], processFunc, nodes);
        if (processedValue !== undefined && typeof processedValue !== "function") {
            accumulator[nodeKey] = processedValue;
        }
    }
    return accumulator;
};
const processAllKeysInObj = (obj, processFunc, keyNodes) => {
    if (Array.isArray(obj)) {
        return obj.filter((item) => typeof item !== "function").map((item) => processObj(item, processFunc, keyNodes));
    }
    return Object.entries(obj).reduce((acc, [key, value]) => {
        if (typeof value === "function") {
            return acc;
        }
        const processedValue = processObj(value, processFunc, keyNodes);
        if (processedValue !== undefined && typeof processedValue !== "function") {
            acc[key] = processedValue;
        }
        return acc;
    }, {});
};
const marshallInput = (obj, keyNodes, options) => {
    const marshallFunc = (toMarshall) => marshall(toMarshall, options);
    return processKeysInObj(obj, marshallFunc, keyNodes);
};
const unmarshallOutput = (obj, keyNodes, options) => {
    const unmarshallFunc = (toMarshall) => unmarshall(toMarshall, options);
    return processKeysInObj(obj, unmarshallFunc, keyNodes);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/baseCommand/DynamoDBDocumentClientCommand.js


class DynamoDBDocumentClientCommand extends dist_es_command_Command {
    addMarshallingMiddleware(configuration) {
        const { marshallOptions = {}, unmarshallOptions = {} } = configuration.translateConfig || {};
        marshallOptions.convertTopLevelContainer = marshallOptions.convertTopLevelContainer ?? true;
        unmarshallOptions.convertWithoutMapWrapper = unmarshallOptions.convertWithoutMapWrapper ?? true;
        this.clientCommand.middlewareStack.addRelativeTo((next, context) => async (args) => {
            args.input = marshallInput(this.input, this.inputKeyNodes, marshallOptions);
            context.dynamoDbDocumentClientOptions =
                context.dynamoDbDocumentClientOptions || DynamoDBDocumentClientCommand.defaultLogFilterOverrides;
            const input = args.input;
            context.dynamoDbDocumentClientOptions.overrideInputFilterSensitiveLog = () => {
                return context.inputFilterSensitiveLog?.(input);
            };
            return next(args);
        }, {
            name: "DocumentMarshall",
            relation: "before",
            toMiddleware: "serializerMiddleware",
            override: true,
        });
        this.clientCommand.middlewareStack.addRelativeTo((next, context) => async (args) => {
            const deserialized = await next(args);
            const output = deserialized.output;
            context.dynamoDbDocumentClientOptions =
                context.dynamoDbDocumentClientOptions || DynamoDBDocumentClientCommand.defaultLogFilterOverrides;
            context.dynamoDbDocumentClientOptions.overrideOutputFilterSensitiveLog = () => {
                return context.outputFilterSensitiveLog?.(output);
            };
            deserialized.output = unmarshallOutput(deserialized.output, this.outputKeyNodes, unmarshallOptions);
            return deserialized;
        }, {
            name: "DocumentUnmarshall",
            relation: "before",
            toMiddleware: "deserializerMiddleware",
            override: true,
        });
    }
}
DynamoDBDocumentClientCommand.defaultLogFilterOverrides = {
    overrideInputFilterSensitiveLog(...args) { },
    overrideOutputFilterSensitiveLog(...args) { },
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/BatchExecuteStatementCommand.js





class commands_BatchExecuteStatementCommand_BatchExecuteStatementCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            Statements: {
                "*": {
                    Parameters: ALL_MEMBERS,
                },
            },
        };
        this.outputKeyNodes = {
            Responses: {
                "*": {
                    Error: {
                        Item: ALL_VALUES,
                    },
                    Item: ALL_VALUES,
                },
            },
        };
        this.clientCommand = new BatchExecuteStatementCommand_BatchExecuteStatementCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/BatchGetItemCommand.js






class BatchGetItemCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "BatchGetItem", {})
    .n("DynamoDBClient", "BatchGetItemCommand")
    .f(void 0, void 0)
    .ser(se_BatchGetItemCommand)
    .de(de_BatchGetItemCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/BatchGetCommand.js





class BatchGetCommand_BatchGetCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            RequestItems: {
                "*": {
                    Keys: {
                        "*": ALL_VALUES,
                    },
                },
            },
        };
        this.outputKeyNodes = {
            Responses: {
                "*": {
                    "*": ALL_VALUES,
                },
            },
            UnprocessedKeys: {
                "*": {
                    Keys: {
                        "*": ALL_VALUES,
                    },
                },
            },
        };
        this.clientCommand = new BatchGetItemCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/BatchWriteItemCommand.js






class BatchWriteItemCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "BatchWriteItem", {})
    .n("DynamoDBClient", "BatchWriteItemCommand")
    .f(void 0, void 0)
    .ser(se_BatchWriteItemCommand)
    .de(de_BatchWriteItemCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/BatchWriteCommand.js





class BatchWriteCommand_BatchWriteCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            RequestItems: {
                "*": {
                    "*": {
                        PutRequest: {
                            Item: ALL_VALUES,
                        },
                        DeleteRequest: {
                            Key: ALL_VALUES,
                        },
                    },
                },
            },
        };
        this.outputKeyNodes = {
            UnprocessedItems: {
                "*": {
                    "*": {
                        PutRequest: {
                            Item: ALL_VALUES,
                        },
                        DeleteRequest: {
                            Key: ALL_VALUES,
                        },
                    },
                },
            },
            ItemCollectionMetrics: {
                "*": {
                    "*": {
                        ItemCollectionKey: ALL_VALUES,
                    },
                },
            },
        };
        this.clientCommand = new BatchWriteItemCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DeleteItemCommand.js






class DeleteItemCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "DeleteItem", {})
    .n("DynamoDBClient", "DeleteItemCommand")
    .f(void 0, void 0)
    .ser(se_DeleteItemCommand)
    .de(de_DeleteItemCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/DeleteCommand.js





class DeleteCommand_DeleteCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            Key: ALL_VALUES,
            Expected: {
                "*": {
                    Value: SELF,
                    AttributeValueList: ALL_MEMBERS,
                },
            },
            ExpressionAttributeValues: ALL_VALUES,
        };
        this.outputKeyNodes = {
            Attributes: ALL_VALUES,
            ItemCollectionMetrics: {
                ItemCollectionKey: ALL_VALUES,
            },
        };
        this.clientCommand = new DeleteItemCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ExecuteStatementCommand.js






class ExecuteStatementCommand_ExecuteStatementCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "ExecuteStatement", {})
    .n("DynamoDBClient", "ExecuteStatementCommand")
    .f(void 0, void 0)
    .ser(se_ExecuteStatementCommand)
    .de(de_ExecuteStatementCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/ExecuteStatementCommand.js





class commands_ExecuteStatementCommand_ExecuteStatementCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            Parameters: ALL_MEMBERS,
        };
        this.outputKeyNodes = {
            Items: {
                "*": ALL_VALUES,
            },
            LastEvaluatedKey: ALL_VALUES,
        };
        this.clientCommand = new ExecuteStatementCommand_ExecuteStatementCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ExecuteTransactionCommand.js






class ExecuteTransactionCommand_ExecuteTransactionCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "ExecuteTransaction", {})
    .n("DynamoDBClient", "ExecuteTransactionCommand")
    .f(void 0, void 0)
    .ser(se_ExecuteTransactionCommand)
    .de(de_ExecuteTransactionCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/ExecuteTransactionCommand.js





class commands_ExecuteTransactionCommand_ExecuteTransactionCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            TransactStatements: {
                "*": {
                    Parameters: ALL_MEMBERS,
                },
            },
        };
        this.outputKeyNodes = {
            Responses: {
                "*": {
                    Item: ALL_VALUES,
                },
            },
        };
        this.clientCommand = new ExecuteTransactionCommand_ExecuteTransactionCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/GetItemCommand.js






class GetItemCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "GetItem", {})
    .n("DynamoDBClient", "GetItemCommand")
    .f(void 0, void 0)
    .ser(se_GetItemCommand)
    .de(de_GetItemCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/GetCommand.js





class GetCommand_GetCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            Key: ALL_VALUES,
        };
        this.outputKeyNodes = {
            Item: ALL_VALUES,
        };
        this.clientCommand = new GetItemCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/PutItemCommand.js






class PutItemCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "PutItem", {})
    .n("DynamoDBClient", "PutItemCommand")
    .f(void 0, void 0)
    .ser(se_PutItemCommand)
    .de(de_PutItemCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/PutCommand.js





class PutCommand_PutCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            Item: ALL_VALUES,
            Expected: {
                "*": {
                    Value: SELF,
                    AttributeValueList: ALL_MEMBERS,
                },
            },
            ExpressionAttributeValues: ALL_VALUES,
        };
        this.outputKeyNodes = {
            Attributes: ALL_VALUES,
            ItemCollectionMetrics: {
                ItemCollectionKey: ALL_VALUES,
            },
        };
        this.clientCommand = new PutItemCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/QueryCommand.js






class QueryCommand_QueryCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "Query", {})
    .n("DynamoDBClient", "QueryCommand")
    .f(void 0, void 0)
    .ser(se_QueryCommand)
    .de(de_QueryCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/QueryCommand.js





class commands_QueryCommand_QueryCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            KeyConditions: {
                "*": {
                    AttributeValueList: ALL_MEMBERS,
                },
            },
            QueryFilter: {
                "*": {
                    AttributeValueList: ALL_MEMBERS,
                },
            },
            ExclusiveStartKey: ALL_VALUES,
            ExpressionAttributeValues: ALL_VALUES,
        };
        this.outputKeyNodes = {
            Items: {
                "*": ALL_VALUES,
            },
            LastEvaluatedKey: ALL_VALUES,
        };
        this.clientCommand = new QueryCommand_QueryCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ScanCommand.js






class ScanCommand_ScanCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "Scan", {})
    .n("DynamoDBClient", "ScanCommand")
    .f(void 0, void 0)
    .ser(se_ScanCommand)
    .de(de_ScanCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/ScanCommand.js





class commands_ScanCommand_ScanCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            ScanFilter: {
                "*": {
                    AttributeValueList: ALL_MEMBERS,
                },
            },
            ExclusiveStartKey: ALL_VALUES,
            ExpressionAttributeValues: ALL_VALUES,
        };
        this.outputKeyNodes = {
            Items: {
                "*": ALL_VALUES,
            },
            LastEvaluatedKey: ALL_VALUES,
        };
        this.clientCommand = new ScanCommand_ScanCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/TransactGetItemsCommand.js






class TransactGetItemsCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "TransactGetItems", {})
    .n("DynamoDBClient", "TransactGetItemsCommand")
    .f(void 0, void 0)
    .ser(se_TransactGetItemsCommand)
    .de(de_TransactGetItemsCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/TransactGetCommand.js





class TransactGetCommand_TransactGetCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            TransactItems: {
                "*": {
                    Get: {
                        Key: ALL_VALUES,
                    },
                },
            },
        };
        this.outputKeyNodes = {
            Responses: {
                "*": {
                    Item: ALL_VALUES,
                },
            },
        };
        this.clientCommand = new TransactGetItemsCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/TransactWriteItemsCommand.js






class TransactWriteItemsCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "TransactWriteItems", {})
    .n("DynamoDBClient", "TransactWriteItemsCommand")
    .f(void 0, void 0)
    .ser(se_TransactWriteItemsCommand)
    .de(de_TransactWriteItemsCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/TransactWriteCommand.js





class TransactWriteCommand_TransactWriteCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            TransactItems: {
                "*": {
                    ConditionCheck: {
                        Key: ALL_VALUES,
                        ExpressionAttributeValues: ALL_VALUES,
                    },
                    Put: {
                        Item: ALL_VALUES,
                        ExpressionAttributeValues: ALL_VALUES,
                    },
                    Delete: {
                        Key: ALL_VALUES,
                        ExpressionAttributeValues: ALL_VALUES,
                    },
                    Update: {
                        Key: ALL_VALUES,
                        ExpressionAttributeValues: ALL_VALUES,
                    },
                },
            },
        };
        this.outputKeyNodes = {
            ItemCollectionMetrics: {
                "*": {
                    "*": {
                        ItemCollectionKey: ALL_VALUES,
                    },
                },
            },
        };
        this.clientCommand = new TransactWriteItemsCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UpdateItemCommand.js






class UpdateItemCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "UpdateItem", {})
    .n("DynamoDBClient", "UpdateItemCommand")
    .f(void 0, void 0)
    .ser(se_UpdateItemCommand)
    .de(de_UpdateItemCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/UpdateCommand.js





class UpdateCommand_UpdateCommand extends DynamoDBDocumentClientCommand {
    constructor(input) {
        super();
        this.input = input;
        this.inputKeyNodes = {
            Key: ALL_VALUES,
            AttributeUpdates: {
                "*": {
                    Value: SELF,
                },
            },
            Expected: {
                "*": {
                    Value: SELF,
                    AttributeValueList: ALL_MEMBERS,
                },
            },
            ExpressionAttributeValues: ALL_VALUES,
        };
        this.outputKeyNodes = {
            Attributes: ALL_VALUES,
            ItemCollectionMetrics: {
                ItemCollectionKey: ALL_VALUES,
            },
        };
        this.clientCommand = new UpdateItemCommand(this.input);
        this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.addMarshallingMiddleware(configuration);
        const stack = clientStack.concat(this.middlewareStack);
        const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
        return async () => handler(this.clientCommand);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/DynamoDBDocumentClient.js


class DynamoDBDocumentClient_DynamoDBDocumentClient extends dist_es_client_Client {
    constructor(client, translateConfig) {
        super(client.config);
        this.config = client.config;
        this.config.translateConfig = translateConfig;
        this.middlewareStack = client.middlewareStack;
    }
    static from(client, translateConfig) {
        return new DynamoDBDocumentClient_DynamoDBDocumentClient(client, translateConfig);
    }
    destroy() {
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/DynamoDBDocument.js














class DynamoDBDocument extends (/* unused pure expression or super */ null && (DynamoDBDocumentClient)) {
    static from(client, translateConfig) {
        return new DynamoDBDocument(client, translateConfig);
    }
    batchExecuteStatement(args, optionsOrCb, cb) {
        const command = new BatchExecuteStatementCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    batchGet(args, optionsOrCb, cb) {
        const command = new BatchGetCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    batchWrite(args, optionsOrCb, cb) {
        const command = new BatchWriteCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    delete(args, optionsOrCb, cb) {
        const command = new DeleteCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    executeStatement(args, optionsOrCb, cb) {
        const command = new ExecuteStatementCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    executeTransaction(args, optionsOrCb, cb) {
        const command = new ExecuteTransactionCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    get(args, optionsOrCb, cb) {
        const command = new GetCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    put(args, optionsOrCb, cb) {
        const command = new PutCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    query(args, optionsOrCb, cb) {
        const command = new QueryCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    scan(args, optionsOrCb, cb) {
        const command = new ScanCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    transactGet(args, optionsOrCb, cb) {
        const command = new TransactGetCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    transactWrite(args, optionsOrCb, cb) {
        const command = new TransactWriteCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    update(args, optionsOrCb, cb) {
        const command = new UpdateCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object") {
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            }
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/index.js














;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/pagination/QueryPaginator.js


const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new QueryCommand(input), ...args);
};
async function* paginateQuery(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.ExclusiveStartKey = token;
        input["Limit"] = config.pageSize;
        if (config.client instanceof DynamoDBDocumentClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected DynamoDBDocument | DynamoDBDocumentClient");
        }
        yield page;
        token = page.LastEvaluatedKey;
        hasNext = !!token;
    }
    return undefined;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/pagination/ScanPaginator.js


const ScanPaginator_makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ScanCommand(input), ...args);
};
async function* paginateScan(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.ExclusiveStartKey = token;
        input["Limit"] = config.pageSize;
        if (config.client instanceof DynamoDBDocumentClient) {
            page = await ScanPaginator_makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected DynamoDBDocument | DynamoDBDocumentClient");
        }
        yield page;
        token = page.LastEvaluatedKey;
        hasNext = !!token;
    }
    return undefined;
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/pagination/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/lib-dynamodb/dist-es/index.js






;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/configurations.js
const ENV_ENDPOINT_DISCOVERY = ["AWS_ENABLE_ENDPOINT_DISCOVERY", "AWS_ENDPOINT_DISCOVERY_ENABLED"];
const CONFIG_ENDPOINT_DISCOVERY = "endpoint_discovery_enabled";
const isFalsy = (value) => ["false", "0"].indexOf(value) >= 0;
const NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        for (let i = 0; i < ENV_ENDPOINT_DISCOVERY.length; i++) {
            const envKey = ENV_ENDPOINT_DISCOVERY[i];
            if (envKey in env) {
                const value = env[envKey];
                if (value === "") {
                    throw Error(`Environment variable ${envKey} can't be empty of undefined, got "${value}"`);
                }
                return !isFalsy(value);
            }
        }
    },
    configFileSelector: (profile) => {
        if (CONFIG_ENDPOINT_DISCOVERY in profile) {
            const value = profile[CONFIG_ENDPOINT_DISCOVERY];
            if (value === undefined) {
                throw Error(`Shared config entry ${CONFIG_ENDPOINT_DISCOVERY} can't be undefined, got "${value}"`);
            }
            return !isFalsy(value);
        }
    },
    default: undefined,
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/types/dist-es/auth/auth.js
var dist_es_auth_auth_HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(dist_es_auth_auth_HttpAuthLocation || (dist_es_auth_auth_HttpAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var dist_es_auth_HttpApiKeyAuth_HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(dist_es_auth_HttpApiKeyAuth_HttpApiKeyAuthLocation || (dist_es_auth_HttpApiKeyAuth_HttpApiKeyAuthLocation = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/types/dist-es/auth/index.js







;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/types/dist-es/endpoint.js
var types_dist_es_endpoint_EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(types_dist_es_endpoint_EndpointURLScheme || (types_dist_es_endpoint_EndpointURLScheme = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/types/dist-es/extensions/checksum.js
var types_dist_es_extensions_checksum_AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(types_dist_es_extensions_checksum_AlgorithmId || (types_dist_es_extensions_checksum_AlgorithmId = {}));
const _smithy_types_dist_es_extensions_checksum_getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => types_dist_es_extensions_checksum_AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => types_dist_es_extensions_checksum_AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const _smithy_types_dist_es_extensions_checksum_resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js

const dist_es_extensions_defaultClientConfiguration_getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
    };
};
const dist_es_extensions_defaultClientConfiguration_resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/types/dist-es/extensions/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/types/dist-es/http.js
var _smithy_types_dist_es_http_FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(_smithy_types_dist_es_http_FieldPosition || (_smithy_types_dist_es_http_FieldPosition = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/types/dist-es/profile.js
var _smithy_types_dist_es_profile_IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(_smithy_types_dist_es_profile_IniSectionType || (_smithy_types_dist_es_profile_IniSectionType = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/types/dist-es/transfer.js
var types_dist_es_transfer_RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(types_dist_es_transfer_RequestHandlerProtocol || (types_dist_es_transfer_RequestHandlerProtocol = {}));

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/types/dist-es/index.js





































;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/protocol-http/dist-es/Field.js

class protocol_http_dist_es_Field_Field {
    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@smithy/protocol-http/dist-es/index.js









;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/updateDiscoveredEndpointInCache.js
const requestQueue = {};
const updateDiscoveredEndpointInCache_updateDiscoveredEndpointInCache = async (config, options) => new Promise((resolve, reject) => {
    const { endpointCache } = config;
    const { cacheKey, commandName, identifiers } = options;
    const endpoints = endpointCache.get(cacheKey);
    if (endpoints && endpoints.length === 1 && endpoints[0].Address === "") {
        if (options.isDiscoveredEndpointRequired) {
            if (!requestQueue[cacheKey])
                requestQueue[cacheKey] = [];
            requestQueue[cacheKey].push({ resolve, reject });
        }
        else {
            resolve();
        }
    }
    else if (endpoints && endpoints.length > 0) {
        resolve();
    }
    else {
        const placeholderEndpoints = [{ Address: "", CachePeriodInMinutes: 1 }];
        endpointCache.set(cacheKey, placeholderEndpoints);
        const command = new options.endpointDiscoveryCommandCtor({
            Operation: commandName.slice(0, -7),
            Identifiers: identifiers,
        });
        const handler = command.resolveMiddleware(options.clientStack, config, options.options);
        handler(command)
            .then((result) => {
            endpointCache.set(cacheKey, result.output.Endpoints);
            if (requestQueue[cacheKey]) {
                requestQueue[cacheKey].forEach(({ resolve }) => {
                    resolve();
                });
                delete requestQueue[cacheKey];
            }
            resolve();
        })
            .catch((error) => {
            endpointCache.delete(cacheKey);
            const errorToThrow = Object.assign(new Error(`The operation to discover endpoint failed.` +
                ` Please retry, or provide a custom endpoint and disable endpoint discovery to proceed.`), { reason: error });
            if (requestQueue[cacheKey]) {
                requestQueue[cacheKey].forEach(({ reject }) => {
                    reject(errorToThrow);
                });
                delete requestQueue[cacheKey];
            }
            if (options.isDiscoveredEndpointRequired) {
                reject(errorToThrow);
            }
            else {
                endpointCache.set(cacheKey, placeholderEndpoints);
                resolve();
            }
        });
    }
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/endpointDiscoveryMiddleware.js



const endpointDiscoveryMiddleware_endpointDiscoveryMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
    if (config.isCustomEndpoint) {
        if (config.isClientEndpointDiscoveryEnabled) {
            throw new Error(`Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.`);
        }
        return next(args);
    }
    const { endpointDiscoveryCommandCtor } = config;
    const { isDiscoveredEndpointRequired, identifiers } = middlewareConfig;
    const clientName = context.clientName;
    const commandName = context.commandName;
    const isEndpointDiscoveryEnabled = await config.endpointDiscoveryEnabled();
    const cacheKey = await getCacheKey(commandName, config, { identifiers });
    if (isDiscoveredEndpointRequired) {
        if (isEndpointDiscoveryEnabled === false) {
            throw new Error(`Endpoint Discovery is disabled but ${commandName} on ${clientName} requires it.` +
                ` Please check your configurations.`);
        }
        await updateDiscoveredEndpointInCache(config, {
            ...middlewareConfig,
            commandName,
            cacheKey,
            endpointDiscoveryCommandCtor,
        });
    }
    else if (isEndpointDiscoveryEnabled) {
        updateDiscoveredEndpointInCache(config, {
            ...middlewareConfig,
            commandName,
            cacheKey,
            endpointDiscoveryCommandCtor,
        });
    }
    const { request } = args;
    if (cacheKey && HttpRequest.isInstance(request)) {
        const endpoint = config.endpointCache.getEndpoint(cacheKey);
        if (endpoint) {
            request.hostname = endpoint;
        }
    }
    return next(args);
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/getEndpointDiscoveryPlugin.js

const endpointDiscoveryMiddlewareOptions = {
    name: "endpointDiscoveryMiddleware",
    step: "build",
    tags: ["ENDPOINT_DISCOVERY"],
    override: true,
};
const getEndpointDiscoveryPlugin = (pluginConfig, middlewareConfig) => ({
    applyToStack: (commandStack) => {
        commandStack.add(endpointDiscoveryMiddleware(pluginConfig, middlewareConfig), endpointDiscoveryMiddlewareOptions);
    },
});
const getEndpointDiscoveryRequiredPlugin = (pluginConfig, middlewareConfig) => ({
    applyToStack: (commandStack) => {
        commandStack.add(endpointDiscoveryMiddleware(pluginConfig, { ...middlewareConfig, isDiscoveredEndpointRequired: true }), endpointDiscoveryMiddlewareOptions);
    },
});
const getEndpointDiscoveryOptionalPlugin = (pluginConfig, middlewareConfig) => ({
    applyToStack: (commandStack) => {
        commandStack.add(endpointDiscoveryMiddleware(pluginConfig, { ...middlewareConfig, isDiscoveredEndpointRequired: false }), endpointDiscoveryMiddlewareOptions);
    },
});

// EXTERNAL MODULE: ./node_modules/mnemonist/lru-cache.js
var lru_cache = __webpack_require__(1429);
var lru_cache_default = /*#__PURE__*/__webpack_require__.n(lru_cache);
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/endpoint-cache/dist-es/EndpointCache.js

class EndpointCache {
    constructor(capacity) {
        this.cache = new (lru_cache_default())(capacity);
    }
    getEndpoint(key) {
        const endpointsWithExpiry = this.get(key);
        if (!endpointsWithExpiry || endpointsWithExpiry.length === 0) {
            return undefined;
        }
        const endpoints = endpointsWithExpiry.map((endpoint) => endpoint.Address);
        return endpoints[Math.floor(Math.random() * endpoints.length)];
    }
    get(key) {
        if (!this.has(key)) {
            return;
        }
        const value = this.cache.get(key);
        if (!value) {
            return;
        }
        const now = Date.now();
        const endpointsWithExpiry = value.filter((endpoint) => now < endpoint.Expires);
        if (endpointsWithExpiry.length === 0) {
            this.delete(key);
            return undefined;
        }
        return endpointsWithExpiry;
    }
    set(key, endpoints) {
        const now = Date.now();
        this.cache.set(key, endpoints.map(({ Address, CachePeriodInMinutes }) => ({
            Address,
            Expires: now + CachePeriodInMinutes * 60 * 1000,
        })));
    }
    delete(key) {
        this.cache.set(key, []);
    }
    has(key) {
        if (!this.cache.has(key)) {
            return false;
        }
        const endpoints = this.cache.peek(key);
        if (!endpoints) {
            return false;
        }
        return endpoints.length > 0;
    }
    clear() {
        this.cache.clear();
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/endpoint-cache/dist-es/index.js



;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/resolveEndpointDiscoveryConfig.js

const resolveEndpointDiscoveryConfig = (input, { endpointDiscoveryCommandCtor }) => ({
    ...input,
    endpointDiscoveryCommandCtor,
    endpointCache: new EndpointCache(input.endpointCacheSize ?? 1000),
    endpointDiscoveryEnabled: input.endpointDiscoveryEnabled !== undefined
        ? () => Promise.resolve(input.endpointDiscoveryEnabled)
        : input.endpointDiscoveryEnabledProvider,
    isClientEndpointDiscoveryEnabled: input.endpointDiscoveryEnabled !== undefined,
});

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/index.js




;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/auth/httpAuthSchemeProvider.js


const defaultDynamoDBHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
        operation: getSmithyContext_getSmithyContext(context).operation,
        region: (await normalizeProvider_normalizeProvider(config.region)()) ||
            (() => {
                throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
            })(),
    };
};
function httpAuthSchemeProvider_createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
            name: "dynamodb",
            region: authParameters.region,
        },
        propertiesExtractor: (config, context) => ({
            signingProperties: {
                config,
                context,
            },
        }),
    };
}
const defaultDynamoDBHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
        default: {
            options.push(httpAuthSchemeProvider_createAwsAuthSigv4HttpAuthOption(authParameters));
        }
    }
    return options;
};
const httpAuthSchemeProvider_resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = (0,dist_cjs.resolveAwsSdkSigV4Config)(config);
    return {
        ...config_0,
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeEndpointsCommand.js






class DescribeEndpointsCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "DescribeEndpoints", {})
    .n("DynamoDBClient", "DescribeEndpointsCommand")
    .f(void 0, void 0)
    .ser(se_DescribeEndpointsCommand)
    .de(de_DescribeEndpointsCommand)
    .build() {
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/package.json
const client_dynamodb_package_namespaceObject = {"rE":"3.582.0"};
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/endpoint/ruleset.js
const ruleset_w = "required", ruleset_x = "fn", ruleset_y = "argv", ruleset_z = "ref";
const ruleset_a = true, ruleset_b = "isSet", ruleset_c = "booleanEquals", ruleset_d = "error", ruleset_e = "endpoint", ruleset_f = "tree", ruleset_g = "PartitionResult", ruleset_h = "getAttr", ruleset_i = "stringEquals", ruleset_j = { [ruleset_w]: false, "type": "String" }, ruleset_k = { [ruleset_w]: true, "default": false, "type": "Boolean" }, ruleset_l = { [ruleset_z]: "Endpoint" }, ruleset_m = { [ruleset_x]: ruleset_c, [ruleset_y]: [{ [ruleset_z]: "UseFIPS" }, true] }, ruleset_n = { [ruleset_x]: ruleset_c, [ruleset_y]: [{ [ruleset_z]: "UseDualStack" }, true] }, ruleset_o = {}, ruleset_p = { [ruleset_z]: "Region" }, ruleset_q = { [ruleset_x]: ruleset_h, [ruleset_y]: [{ [ruleset_z]: ruleset_g }, "supportsFIPS"] }, ruleset_r = { [ruleset_z]: ruleset_g }, ruleset_s = { [ruleset_x]: ruleset_c, [ruleset_y]: [true, { [ruleset_x]: ruleset_h, [ruleset_y]: [ruleset_r, "supportsDualStack"] }] }, ruleset_t = [ruleset_m], ruleset_u = [ruleset_n], ruleset_v = [ruleset_p];
const ruleset_data = { version: "1.0", parameters: { Region: ruleset_j, UseDualStack: ruleset_k, UseFIPS: ruleset_k, Endpoint: ruleset_j }, rules: [{ conditions: [{ [ruleset_x]: ruleset_b, [ruleset_y]: [ruleset_l] }], rules: [{ conditions: ruleset_t, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: ruleset_d }, { conditions: ruleset_u, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: ruleset_d }, { endpoint: { url: ruleset_l, properties: ruleset_o, headers: ruleset_o }, type: ruleset_e }], type: ruleset_f }, { conditions: [{ [ruleset_x]: ruleset_b, [ruleset_y]: ruleset_v }], rules: [{ conditions: [{ [ruleset_x]: "aws.partition", [ruleset_y]: ruleset_v, assign: ruleset_g }], rules: [{ conditions: [ruleset_m, ruleset_n], rules: [{ conditions: [{ [ruleset_x]: ruleset_c, [ruleset_y]: [ruleset_a, ruleset_q] }, ruleset_s], rules: [{ endpoint: { url: "https://dynamodb-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: ruleset_o, headers: ruleset_o }, type: ruleset_e }], type: ruleset_f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: ruleset_d }], type: ruleset_f }, { conditions: ruleset_t, rules: [{ conditions: [{ [ruleset_x]: ruleset_c, [ruleset_y]: [ruleset_q, ruleset_a] }], rules: [{ conditions: [{ [ruleset_x]: ruleset_i, [ruleset_y]: [{ [ruleset_x]: ruleset_h, [ruleset_y]: [ruleset_r, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://dynamodb.{Region}.amazonaws.com", properties: ruleset_o, headers: ruleset_o }, type: ruleset_e }, { endpoint: { url: "https://dynamodb-fips.{Region}.{PartitionResult#dnsSuffix}", properties: ruleset_o, headers: ruleset_o }, type: ruleset_e }], type: ruleset_f }, { error: "FIPS is enabled but this partition does not support FIPS", type: ruleset_d }], type: ruleset_f }, { conditions: ruleset_u, rules: [{ conditions: [ruleset_s], rules: [{ endpoint: { url: "https://dynamodb.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: ruleset_o, headers: ruleset_o }, type: ruleset_e }], type: ruleset_f }, { error: "DualStack is enabled but this partition does not support DualStack", type: ruleset_d }], type: ruleset_f }, { conditions: [{ [ruleset_x]: ruleset_i, [ruleset_y]: [ruleset_p, "local"] }], endpoint: { url: "http://localhost:8000", properties: { authSchemes: [{ name: "sigv4", signingName: "dynamodb", signingRegion: "us-east-1" }] }, headers: ruleset_o }, type: ruleset_e }, { endpoint: { url: "https://dynamodb.{Region}.{PartitionResult#dnsSuffix}", properties: ruleset_o, headers: ruleset_o }, type: ruleset_e }], type: ruleset_f }], type: ruleset_f }, { error: "Invalid Configuration: Missing Region", type: ruleset_d }] };
const ruleset_ruleSet = ruleset_data;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/endpoint/endpointResolver.js



const endpointResolver_defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0,_smithy_util_endpoints_dist_es/* resolveEndpoint */.sO)(ruleset_ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
_smithy_util_endpoints_dist_es/* customEndpointFunctions */.mw.aws = util_endpoints_dist_es/* awsEndpointFunctions */.UF;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/runtimeConfig.shared.js







const runtimeConfig_shared_getRuntimeConfig = (config) => {
    return {
        apiVersion: "2012-08-10",
        base64Decoder: config?.base64Decoder ?? dist_es_fromBase64_fromBase64,
        base64Encoder: config?.base64Encoder ?? dist_es_toBase64_toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultDynamoDBHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                signer: new dist_cjs.AwsSdkSigV4Signer(),
            },
        ],
        logger: config?.logger ?? new NoOpLogger_NoOpLogger(),
        serviceId: config?.serviceId ?? "DynamoDB",
        urlParser: config?.urlParser ?? dist_es_parseUrl,
        utf8Decoder: config?.utf8Decoder ?? dist_es_fromUtf8_fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? dist_es_toUtf8_toUtf8,
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/runtimeConfig.js
















const dist_es_runtimeConfig_getRuntimeConfig = (config) => {
    emitWarningIfUnsupportedVersion_emitWarningIfUnsupportedVersion(process.version);
    const defaultsMode = (0,util_defaults_mode_node_dist_es/* resolveDefaultsModeConfig */.I)(config);
    const defaultConfigProvider = () => defaultsMode().then(defaults_mode_loadConfigsForDefaultMode);
    const clientSharedValues = runtimeConfig_shared_getRuntimeConfig(config);
    (0,dist_cjs.emitWarningIfUnsupportedVersion)(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_dist_es/* calculateBodyLength */.n,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? credential_provider_node_dist_es/* defaultProvider */.v6,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0,util_user_agent_node_dist_es/* defaultUserAgent */.mJ)({ serviceId: clientSharedValues.serviceId, clientVersion: client_dynamodb_package_namespaceObject.rE }),
        endpointDiscoveryEnabledProvider: config?.endpointDiscoveryEnabledProvider ?? configLoader_loadConfig(NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS),
        maxAttempts: config?.maxAttempts ?? configLoader_loadConfig(middleware_retry_dist_es/* NODE_MAX_ATTEMPT_CONFIG_OPTIONS */.qs),
        region: config?.region ?? configLoader_loadConfig(config_resolver_dist_es/* NODE_REGION_CONFIG_OPTIONS */.GG, config_resolver_dist_es/* NODE_REGION_CONFIG_FILE_OPTIONS */.zH),
        requestHandler: node_http_handler_NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ??
            configLoader_loadConfig({
                ...middleware_retry_dist_es/* NODE_RETRY_MODE_CONFIG_OPTIONS */.kN,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_dist_es/* DEFAULT_RETRY_MODE */.L0,
            }),
        sha256: config?.sha256 ?? hash_node_dist_es/* Hash */.V.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_dist_es_stream_collector_streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? configLoader_loadConfig(config_resolver_dist_es/* NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS */.e$),
        useFipsEndpoint: config?.useFipsEndpoint ?? configLoader_loadConfig(config_resolver_dist_es/* NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS */.Ko),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/auth/httpAuthExtensionConfiguration.js
const httpAuthExtensionConfiguration_getHttpAuthExtensionConfiguration = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
const httpAuthExtensionConfiguration_resolveHttpAuthRuntimeConfig = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/runtimeExtensions.js




const runtimeExtensions_asPartial = (t) => t;
const runtimeExtensions_resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...runtimeExtensions_asPartial((0,region_config_resolver_dist_es/* getAwsRegionExtensionConfiguration */.Rq)(runtimeConfig)),
        ...runtimeExtensions_asPartial(defaultExtensionConfiguration_getDefaultExtensionConfiguration(runtimeConfig)),
        ...runtimeExtensions_asPartial(httpExtensionConfiguration_getHttpHandlerExtensionConfiguration(runtimeConfig)),
        ...runtimeExtensions_asPartial(httpAuthExtensionConfiguration_getHttpAuthExtensionConfiguration(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0,region_config_resolver_dist_es/* resolveAwsRegionExtensionConfiguration */.$3)(extensionConfiguration),
        ...extensions_defaultExtensionConfiguration_resolveDefaultRuntimeConfig(extensionConfiguration),
        ...httpExtensionConfiguration_resolveHttpHandlerRuntimeConfig(extensionConfiguration),
        ...httpAuthExtensionConfiguration_resolveHttpAuthRuntimeConfig(extensionConfiguration),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/DynamoDBClient.js

















class DynamoDBClient extends client_Client {
    constructor(...[configuration]) {
        const _config_0 = dist_es_runtimeConfig_getRuntimeConfig(configuration || {});
        const _config_1 = EndpointParameters_resolveClientEndpointParameters(_config_0);
        const _config_2 = (0,config_resolver_dist_es/* resolveRegionConfig */.TD)(_config_1);
        const _config_3 = resolveEndpointConfig_resolveEndpointConfig(_config_2);
        const _config_4 = (0,middleware_retry_dist_es/* resolveRetryConfig */.$z)(_config_3);
        const _config_5 = (0,middleware_host_header_dist_es/* resolveHostHeaderConfig */.OV)(_config_4);
        const _config_6 = (0,middleware_user_agent_dist_es/* resolveUserAgentConfig */.Dc)(_config_5);
        const _config_7 = httpAuthSchemeProvider_resolveHttpAuthSchemeConfig(_config_6);
        const _config_8 = resolveEndpointDiscoveryConfig(_config_7, {
            endpointDiscoveryCommandCtor: DescribeEndpointsCommand,
        });
        const _config_9 = runtimeExtensions_resolveRuntimeExtensions(_config_8, configuration?.extensions || []);
        super(_config_9);
        this.config = _config_9;
        this.middlewareStack.use((0,middleware_retry_dist_es/* getRetryPlugin */.ey)(this.config));
        this.middlewareStack.use((0,middleware_content_length_dist_es/* getContentLengthPlugin */.vK)(this.config));
        this.middlewareStack.use((0,middleware_host_header_dist_es/* getHostHeaderPlugin */.TC)(this.config));
        this.middlewareStack.use((0,middleware_logger_dist_es/* getLoggerPlugin */.Y7)(this.config));
        this.middlewareStack.use((0,middleware_recursion_detection_dist_es/* getRecursionDetectionPlugin */.n4)(this.config));
        this.middlewareStack.use((0,middleware_user_agent_dist_es/* getUserAgentPlugin */.sM)(this.config));
        this.middlewareStack.use((0,core_dist_es.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
            httpAuthSchemeParametersProvider: this.getDefaultHttpAuthSchemeParametersProvider(),
            identityProviderConfigProvider: this.getIdentityProviderConfigProvider(),
        }));
        this.middlewareStack.use((0,core_dist_es.getHttpSigningPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
    getDefaultHttpAuthSchemeParametersProvider() {
        return defaultDynamoDBHttpAuthSchemeParametersProvider;
    }
    getIdentityProviderConfigProvider() {
        return async (config) => new core_dist_es.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials,
        });
    }
}

;// CONCATENATED MODULE: ./src/core/aws/common/aws-services.ts





const stsClient = {
    get: (request) => new STSClient/* STSClient */.i({ region: request.region, credentials: (0,credential_provider_node_dist_es/* defaultProvider */.v6)({ profile: request.profile }) }),
    name: 'AWS:STS'
};
const iamClient = {
    get: (request) => new IAMClient({ region: request.region, credentials: (0,credential_provider_node_dist_es/* defaultProvider */.v6)({ profile: request.profile }) }),
    name: 'AWS:IAM'
};
const dynamoDBClient = {
    get: (request) => new DynamoDBClient({ region: request.region, credentials: (0,credential_provider_node_dist_es/* defaultProvider */.v6)({ profile: request.profile }) }),
    name: 'AWS:DynamoDB'
};
const dynamoDBDocumentClient = {
    get: (request) => DynamoDBDocumentClient_DynamoDBDocumentClient.from(dynamoDBClient.get(request)),
    name: 'AWS:DynamoDB'
};

;// CONCATENATED MODULE: ./src/app/aws/account/get-info-command.ts



const exec = (request) => Function_pipe(request, getAwsAccountInfo(stsClient, iamClient), runPromise);
const registerGetAwsAccountInfoCommand = (plugin) => {
    plugin.registerFunction('Aws_GetSessionInfo', exec, { sync: true });
    return plugin;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ListTablesCommand.js






class ListTablesCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "ListTables", {})
    .n("DynamoDBClient", "ListTablesCommand")
    .f(void 0, void 0)
    .ser(se_ListTablesCommand)
    .de(de_ListTablesCommand)
    .build() {
}

;// CONCATENATED MODULE: ./src/core/aws/dynamodb/list-tables.ts



const listDynamoDBTables = (client) => (request) => Function_pipe(new ListTablesCommand({}), tryAwsServiceCall({
    service: client,
    request: request,
    try: (service, command, signal) => service.send(command, { abortSignal: signal }),
    expect: (output) => output.TableNames !== undefined
}), Effect_map((output) => output.TableNames.map((name) => ({ tableName: name }))));

;// CONCATENATED MODULE: ./src/app/aws/dynamodb/list-tables.ts



const list_tables_exec = (request) => Function_pipe(request, listDynamoDBTables(dynamoDBClient), runPromise);
const registerListDynamoDBTables = (plugin) => {
    plugin.registerFunction('ListDynamoDBTables', list_tables_exec, { sync: true });
    return plugin;
};

;// CONCATENATED MODULE: ./src/app/aws/tree/get-tree-elements.ts
const treeRootNodes = [
    {
        _tag: 'AWS::DynamoDB',
        id: 'AWS::DynamoDB',
        name: 'DynamoDB',
        commands: {
            expand: true
        }
    },
    {
        _tag: 'AWS::S3',
        id: 'AWS::S3',
        name: 'S3',
        commands: {
            expand: true
        }
    },
    {
        _tag: 'AWS::SQS',
        id: 'AWS::SQS',
        name: 'SQS',
        commands: {
            expand: true
        }
    }
];
const get_tree_elements_exec = () => treeRootNodes;
const registerGetTreeRootNodes = (plugin) => {
    plugin.registerFunction('Aws_GetTreeRootNodes', get_tree_elements_exec, { sync: true });
    return plugin;
};

;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/internal/matcher.js




/** @internal */
const matcher_TypeId = /*#__PURE__*/Symbol.for("@effect/matcher/Matcher");
const TypeMatcherProto = {
  [matcher_TypeId]: {
    _input: Function_identity,
    _filters: Function_identity,
    _remaining: Function_identity,
    _result: Function_identity,
    _return: Function_identity
  },
  _tag: "TypeMatcher",
  add(_case) {
    return makeTypeMatcher([...this.cases, _case]);
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
const ValueMatcherProto = {
  [matcher_TypeId]: {
    _input: Function_identity,
    _filters: Function_identity,
    _result: Function_identity,
    _return: Function_identity
  },
  _tag: "ValueMatcher",
  add(_case) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, Either_right(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, Either_right(_case.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return Pipeable_pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value;
  return matcher;
}
const makeWhen = (guard, evaluate) => ({
  _tag: "When",
  guard,
  evaluate
});
const makeNot = (guard, evaluate) => ({
  _tag: "Not",
  guard,
  evaluate
});
const makePredicate = pattern => {
  if (typeof pattern === "function") {
    return pattern;
  } else if (Array.isArray(pattern)) {
    const predicates = pattern.map(makePredicate);
    const len = predicates.length;
    return u => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern !== null && typeof pattern === "object") {
    const keysAndPredicates = Object.entries(pattern).map(([k, p]) => [k, makePredicate(p)]);
    const len = keysAndPredicates.length;
    return u => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return u => u === pattern;
};
const makeOrPredicate = patterns => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return u => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === true) {
        return true;
      }
    }
    return false;
  };
};
const makeAndPredicate = patterns => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return u => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === false) {
        return false;
      }
    }
    return true;
  };
};
/** @internal */
const type = () => makeTypeMatcher([]);
/** @internal */
const matcher_value = i => makeValueMatcher(i, Either_left(i));
/** @internal */
const valueTags = fields => {
  const match = tagsExhaustive(fields)(makeTypeMatcher([]));
  return input => match(input);
};
/** @internal */
const typeTags = () => fields => {
  const match = tagsExhaustive(fields)(makeTypeMatcher([]));
  return input => match(input);
};
/** @internal */
const withReturnType = () => self => self;
/** @internal */
const matcher_when = (pattern, f) => self => self.add(makeWhen(makePredicate(pattern), f));
/** @internal */
const whenOr = (...args) => self => {
  const onMatch = args[args.length - 1];
  const patterns = args.slice(0, -1);
  return self.add(makeWhen(makeOrPredicate(patterns), onMatch));
};
/** @internal */
const whenAnd = (...args) => self => {
  const onMatch = args[args.length - 1];
  const patterns = args.slice(0, -1);
  return self.add(makeWhen(makeAndPredicate(patterns), onMatch));
};
/** @internal */
const discriminator = field => (...pattern) => {
  const f = pattern[pattern.length - 1];
  const values = pattern.slice(0, -1);
  const pred = values.length === 1 ? _ => _[field] === values[0] : _ => values.includes(_[field]);
  return self => self.add(makeWhen(pred, f));
};
/** @internal */
const discriminatorStartsWith = field => (pattern, f) => {
  const pred = _ => typeof _[field] === "string" && _[field].startsWith(pattern);
  return self => self.add(makeWhen(pred, f));
};
/** @internal */
const discriminators = field => fields => {
  const predicate = makeWhen(_ => _[field] in fields, data => fields[data[field]](data));
  return self => self.add(predicate);
};
/** @internal */
const discriminatorsExhaustive = field => fields => {
  const addCases = discriminators(field)(fields);
  return matcher => exhaustive(addCases(matcher));
};
/** @internal */
const tag = /*#__PURE__*/discriminator("_tag");
/** @internal */
const tagStartsWith = /*#__PURE__*/discriminatorStartsWith("_tag");
/** @internal */
const tags = /*#__PURE__*/discriminators("_tag");
/** @internal */
const tagsExhaustive = /*#__PURE__*/discriminatorsExhaustive("_tag");
/** @internal */
const matcher_not = (pattern, f) => self => self.add(makeNot(makePredicate(pattern), f));
/** @internal */
const nonEmptyString = u => typeof u === "string" && u.length > 0;
/** @internal */
const is = (...literals) => {
  const len = literals.length;
  return u => {
    for (let i = 0; i < len; i++) {
      if (u === literals[i]) {
        return true;
      }
    }
    return false;
  };
};
/** @internal */
const any = () => true;
/** @internal */
const defined = u => u !== undefined && u !== null;
/** @internal */
const instanceOf = constructor => u => u instanceof constructor;
/** @internal */
const instanceOfUnsafe = (/* unused pure expression or super */ null && (instanceOf));
/** @internal */
const matcher_orElse = f => self => {
  const result = matcher_either(self);
  if (Either_isEither(result)) {
    // @ts-expect-error
    return result._tag === "Right" ? result.right : f(result.left);
  }
  // @ts-expect-error
  return input => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f(a.left);
  };
};
/** @internal */
const orElseAbsurd = self => matcher_orElse(() => {
  throw new Error("effect/Match/orElseAbsurd: absurd");
})(self);
/** @internal */
const matcher_either = self => {
  if (self._tag === "ValueMatcher") {
    return self.value;
  }
  const len = self.cases.length;
  if (len === 1) {
    const _case = self.cases[0];
    return input => {
      if (_case._tag === "When" && _case.guard(input) === true) {
        return Either_right(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return Either_right(_case.evaluate(input));
      }
      return Either_left(input);
    };
  }
  return input => {
    for (let i = 0; i < len; i++) {
      const _case = self.cases[i];
      if (_case._tag === "When" && _case.guard(input) === true) {
        return Either_right(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return Either_right(_case.evaluate(input));
      }
    }
    return Either_left(input);
  };
};
/** @internal */
const matcher_option = self => {
  const toEither = matcher_either(self);
  if (Either_isEither(toEither)) {
    return Either_match(toEither, {
      onLeft: () => Option_none(),
      onRight: Option_some
    });
  }
  return input => Either_match(toEither(input), {
    onLeft: () => Option_none(),
    onRight: Option_some
  });
};
const getExhaustiveAbsurdErrorMessage = "effect/Match/exhaustive: absurd";
/** @internal */
const exhaustive = self => {
  const toEither = matcher_either(self);
  if (Either_isEither(toEither)) {
    if (toEither._tag === "Right") {
      return toEither.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  }
  return u => {
    // @ts-expect-error
    const result = toEither(u);
    if (result._tag === "Right") {
      return result.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  };
};
//# sourceMappingURL=matcher.js.map
;// CONCATENATED MODULE: ./node_modules/effect/dist/esm/Match.js


/**
 * @category type ids
 * @since 1.0.0
 */
const MatcherTypeId = matcher_TypeId;
/**
 * @category constructors
 * @since 1.0.0
 */
const Match_type = type;
/**
 * @category constructors
 * @since 1.0.0
 */
const Match_value = matcher_value;
/**
 * @category constructors
 * @since 1.0.0
 */
const Match_valueTags = valueTags;
/**
 * @category constructors
 * @since 1.0.0
 */
const Match_typeTags = typeTags;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_withReturnType = withReturnType;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_when = matcher_when;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_whenOr = whenOr;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_whenAnd = whenAnd;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_discriminator = discriminator;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_discriminatorStartsWith = discriminatorStartsWith;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_discriminators = discriminators;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_discriminatorsExhaustive = discriminatorsExhaustive;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_tag = tag;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_tagStartsWith = tagStartsWith;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_tags = tags;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_tagsExhaustive = tagsExhaustive;
/**
 * @category combinators
 * @since 1.0.0
 */
const Match_not = matcher_not;
/**
 * @category predicates
 * @since 1.0.0
 */
const Match_nonEmptyString = nonEmptyString;
/**
 * @category predicates
 * @since 1.0.0
 */
const Match_is = is;
/**
 * @category predicates
 * @since 1.0.0
 */
const Match_string = isString;
/**
 * @category predicates
 * @since 1.0.0
 */
const Match_number = isNumber;
/**
 * @category predicates
 * @since 1.0.0
 */
const Match_any = any;
/**
 * @category predicates
 * @since 1.0.0
 */
const Match_defined = defined;
/**
 * @category predicates
 * @since 1.0.0
 */
const Match_boolean = Predicate_isBoolean;
const _undefined = isUndefined;

const _null = isNull;

/**
 * @category predicates
 * @since 1.0.0
 */
const Match_bigint = isBigInt;
/**
 * @category predicates
 * @since 1.0.0
 */
const Match_symbol = isSymbol;
/**
 * @category predicates
 * @since 1.0.0
 */
const date = isDate;
/**
 * @category predicates
 * @since 1.0.0
 */
const record = isRecord;
/**
 * @category predicates
 * @since 1.0.0
 */
const Match_instanceOf = instanceOf;
/**
 * @category predicates
 * @since 1.0.0
 */
const Match_instanceOfUnsafe = instanceOf;
/**
 * @category conversions
 * @since 1.0.0
 */
const Match_orElse = matcher_orElse;
/**
 * @category conversions
 * @since 1.0.0
 */
const Match_orElseAbsurd = orElseAbsurd;
/**
 * @category conversions
 * @since 1.0.0
 */
const Match_either = matcher_either;
/**
 * @category conversions
 * @since 1.0.0
 */
const Match_option = matcher_option;
/**
 * @category conversions
 * @since 1.0.0
 */
const Match_exhaustive = exhaustive;
/**
 * @since 1.0.0
 * @category type ids
 */
const SafeRefinementId = /*#__PURE__*/(/* unused pure expression or super */ null && (Symbol.for("effect/SafeRefinement")));
const Fail = /*#__PURE__*/(/* unused pure expression or super */ null && (Symbol.for("effect/Fail")));
//# sourceMappingURL=Match.js.map
;// CONCATENATED MODULE: ./src/app/aws/tree/get-tree-node-children.ts



const expandDynamoDB = (request) => Function_pipe(request, (request) => ({ region: request.region, profile: request.profile }), listDynamoDBTables(dynamoDBClient));
const matcher = Match_type().pipe(Match_when({ type: 'AWS::DynamoDB' }, (request) => expandDynamoDB(request).pipe(Effect_map((tables) => tables.map((table) => ({
    _tag: 'AWS::DynamoDB::Table',
    id: table.tableName,
    name: table.tableName,
    commands: { expand: false }
}))))), Match_orElse(() => Effect_fail('Unknown tree type')));
const get_tree_node_children_exec = (request) => matcher(request[0]).pipe(runPromise);
const registerGetTreeNodeChildren = (plugin) => {
    plugin.registerFunction('Aws_GetTreeNodeChildren', get_tree_node_children_exec, { sync: true });
    return plugin;
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeTableCommand.js






class DescribeTableCommand extends command_Command
    .classBuilder()
    .ep({
    ...EndpointParameters_commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        serdePlugin_getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin_getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("DynamoDB_20120810", "DescribeTable", {})
    .n("DynamoDBClient", "DescribeTableCommand")
    .f(void 0, void 0)
    .ser(se_DescribeTableCommand)
    .de(de_DescribeTableCommand)
    .build() {
}

;// CONCATENATED MODULE: ./src/core/aws/dynamodb/describe-table.ts



const describeDynamoDBTable = (client) => (request) => Function_pipe(new DescribeTableCommand({ TableName: request.tableName }), tryAwsServiceCall({
    service: client,
    request: request,
    try: (service, command, signal) => service.send(command, { abortSignal: signal }),
    expect: (output) => output.Table !== undefined
}), Effect_map((output) => ({
    tableName: output.Table.TableName,
    tableArn: output.Table.TableArn,
    tableId: output.Table.TableId,
    itemCount: output.Table.ItemCount,
    tableSizeBytes: output.Table.TableSizeBytes,
    keySchema: output.Table.KeySchema.map((key) => ({
        attributeName: key.AttributeName,
        keyType: key.KeyType == 'HASH' ? 'HASH' : 'RANGE'
    }))
})));

;// CONCATENATED MODULE: ./src/app/aws/dynamodb/describe-table.ts



const describe_table_exec = (request) => Function_pipe(request, describeDynamoDBTable(dynamoDBClient));
const registerDescribeDynamoDBTable = (plugin) => {
    plugin.registerAwsNvimFunction('DescribeDynamoDBTable', describe_table_exec);
    return plugin;
};

;// CONCATENATED MODULE: ./src/app/index.ts






class WrappedNvimPlugin {
    plugin;
    constructor(plugin) {
        this.plugin = plugin;
    }
    registerAwsNvimFunction(name, fn) {
        const handler = (request) => {
            const program = Function_pipe(Array.isArray(request) ? request[0] : request, fn);
            // const layer = Logger.replace(Logger.defaultLogger, customLogger);
            // return Effect.runPromise(Effect.provide(Logger.withMinimumLogLevel(program, LogLevel.Debug), layer));
            return runPromise(program);
        };
        this.plugin.registerFunction('Aws_' + name, handler, { sync: true });
        return this;
    }
}
// NvimPlugin.prototype.registerAwsNvimFunction = function <Request>(name: string, fn: (request: Request) => unknown) {
//   // const handle = (request: Request) => pipe(request, fn, Effect.runPromise);
//   // const program = pipe(request, (request) => (Array.isArray(request) ? request[0] : request), fn);
//   // return Effect.runPromise(program);
//   // const layer = Logger.replace(Logger.defaultLogger, customLogger);
//   // return Effect.runPromise(Effect.provide(Logger.withMinimumLogLevel(program, LogLevel.Debug), layer));
//   this.registerFunction(name, fn, { sync: true });
//   return this;
// };
/* harmony default export */ function app(plugin) {
    plugin.setOptions({
        dev: true
    });
    const wrapped = new WrappedNvimPlugin(plugin);
    registerDescribeDynamoDBTable(wrapped);
    Function_pipe(plugin, registerGetAwsAccountInfoCommand, registerListDynamoDBTables, registerGetTreeRootNodes, registerGetTreeNodeChildren);
}

})();

var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;